#! /usr/bin/env -S node --enable-source-maps --test-timeout=60000
exports.id = "vendors-node_modules_puppeteer-core_lib_esm_puppeteer_bidi_bidi_js";
exports.ids = ["vendors-node_modules_puppeteer-core_lib_esm_puppeteer_bidi_bidi_js"];
exports.modules = {

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutgoingMessage = exports.EventEmitter = exports.BidiServer = void 0;
/**
 * @fileoverview The entry point to the BiDi Mapper namespace.
 * Other modules should only access exports defined in this file.
 * XXX: Add ESlint rule for this (https://github.com/import-js/eslint-plugin-import/blob/main/docs/rules/no-restricted-paths.md)
 */
var BidiServer_js_1 = __webpack_require__(/*! ./BidiServer.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js");
Object.defineProperty(exports, "BidiServer", ({ enumerable: true, get: function () { return BidiServer_js_1.BidiServer; } }));
var EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
Object.defineProperty(exports, "EventEmitter", ({ enumerable: true, get: function () { return EventEmitter_js_1.EventEmitter; } }));
var OutgoingMessage_js_1 = __webpack_require__(/*! ./OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
Object.defineProperty(exports, "OutgoingMessage", ({ enumerable: true, get: function () { return OutgoingMessage_js_1.OutgoingMessage; } }));
//# sourceMappingURL=BidiMapper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BidiNoOpParser = void 0;
class BidiNoOpParser {
    // Browser domain
    // keep-sorted start block=yes
    parseRemoveUserContextParams(params) {
        return params;
    }
    // keep-sorted end
    // Browsing Context domain
    // keep-sorted start block=yes
    parseActivateParams(params) {
        return params;
    }
    parseCaptureScreenshotParams(params) {
        return params;
    }
    parseCloseParams(params) {
        return params;
    }
    parseCreateParams(params) {
        return params;
    }
    parseGetTreeParams(params) {
        return params;
    }
    parseHandleUserPromptParams(params) {
        return params;
    }
    parseLocateNodesParams(params) {
        return params;
    }
    parseNavigateParams(params) {
        return params;
    }
    parsePrintParams(params) {
        return params;
    }
    parseReloadParams(params) {
        return params;
    }
    parseSetViewportParams(params) {
        return params;
    }
    parseTraverseHistoryParams(params) {
        return params;
    }
    // keep-sorted end
    // CDP domain
    // keep-sorted start block=yes
    parseGetSessionParams(params) {
        return params;
    }
    parseResolveRealmParams(params) {
        return params;
    }
    parseSendCommandParams(params) {
        return params;
    }
    // keep-sorted end
    // Script domain
    // keep-sorted start block=yes
    parseAddPreloadScriptParams(params) {
        return params;
    }
    parseCallFunctionParams(params) {
        return params;
    }
    parseDisownParams(params) {
        return params;
    }
    parseEvaluateParams(params) {
        return params;
    }
    parseGetRealmsParams(params) {
        return params;
    }
    parseRemovePreloadScriptParams(params) {
        return params;
    }
    // keep-sorted end
    // Input domain
    // keep-sorted start block=yes
    parsePerformActionsParams(params) {
        return params;
    }
    parseReleaseActionsParams(params) {
        return params;
    }
    parseSetFilesParams(params) {
        return params;
    }
    // keep-sorted end
    // Network domain
    // keep-sorted start block=yes
    parseAddInterceptParams(params) {
        return params;
    }
    parseContinueRequestParams(params) {
        return params;
    }
    parseContinueResponseParams(params) {
        return params;
    }
    parseContinueWithAuthParams(params) {
        return params;
    }
    parseFailRequestParams(params) {
        return params;
    }
    parseProvideResponseParams(params) {
        return params;
    }
    parseRemoveInterceptParams(params) {
        return params;
    }
    // keep-sorted end
    // Permissions domain
    // keep-sorted start block=yes
    parseSetPermissionsParams(params) {
        return params;
    }
    // keep-sorted end
    // Session domain
    // keep-sorted start block=yes
    parseSubscribeParams(params) {
        return params;
    }
    // keep-sorted end
    // Storage domain
    // keep-sorted start block=yes
    parseDeleteCookiesParams(params) {
        return params;
    }
    parseGetCookiesParams(params) {
        return params;
    }
    parseSetCookieParams(params) {
        return params;
    }
}
exports.BidiNoOpParser = BidiNoOpParser;
//# sourceMappingURL=BidiNoOpParser.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BidiServer = void 0;
const EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const log_js_1 = __webpack_require__(/*! ../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const ProcessingQueue_js_1 = __webpack_require__(/*! ../utils/ProcessingQueue.js */ "./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js");
const CommandProcessor_js_1 = __webpack_require__(/*! ./CommandProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js");
const CdpTargetManager_js_1 = __webpack_require__(/*! ./modules/cdp/CdpTargetManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js");
const BrowsingContextStorage_js_1 = __webpack_require__(/*! ./modules/context/BrowsingContextStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js");
const NetworkStorage_js_1 = __webpack_require__(/*! ./modules/network/NetworkStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js");
const PreloadScriptStorage_js_1 = __webpack_require__(/*! ./modules/script/PreloadScriptStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js");
const RealmStorage_js_1 = __webpack_require__(/*! ./modules/script/RealmStorage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js");
const EventManager_js_1 = __webpack_require__(/*! ./modules/session/EventManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js");
class BidiServer extends EventEmitter_js_1.EventEmitter {
    #messageQueue;
    #transport;
    #commandProcessor;
    #eventManager;
    #browsingContextStorage = new BrowsingContextStorage_js_1.BrowsingContextStorage();
    #realmStorage = new RealmStorage_js_1.RealmStorage();
    #preloadScriptStorage = new PreloadScriptStorage_js_1.PreloadScriptStorage();
    #logger;
    #handleIncomingMessage = (message) => {
        void this.#commandProcessor.processCommand(message).catch((error) => {
            this.#logger?.(log_js_1.LogType.debugError, error);
        });
    };
    #processOutgoingMessage = async (messageEntry) => {
        const message = messageEntry.message;
        if (messageEntry.channel !== null) {
            message['channel'] = messageEntry.channel;
        }
        await this.#transport.sendMessage(message);
    };
    constructor(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, options, parser, logger) {
        super();
        this.#logger = logger;
        this.#messageQueue = new ProcessingQueue_js_1.ProcessingQueue(this.#processOutgoingMessage, this.#logger);
        this.#transport = bidiTransport;
        this.#transport.setOnMessage(this.#handleIncomingMessage);
        this.#eventManager = new EventManager_js_1.EventManager(this.#browsingContextStorage);
        const networkStorage = new NetworkStorage_js_1.NetworkStorage(this.#eventManager, this.#browsingContextStorage, browserCdpClient, logger);
        new CdpTargetManager_js_1.CdpTargetManager(cdpConnection, browserCdpClient, selfTargetId, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, networkStorage, this.#preloadScriptStorage, options?.acceptInsecureCerts ?? false, defaultUserContextId, options?.unhandledPromptBehavior, logger);
        this.#commandProcessor = new CommandProcessor_js_1.CommandProcessor(cdpConnection, browserCdpClient, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, this.#preloadScriptStorage, networkStorage, parser, this.#logger);
        this.#eventManager.on("event" /* EventManagerEvents.Event */, ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
        });
        this.#commandProcessor.on("response" /* CommandProcessorEvents.Response */, ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
        });
    }
    /**
     * Creates and starts BiDi Mapper instance.
     */
    static async createAndStart(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, options, parser, logger) {
        // The default context is not exposed in Target.getBrowserContexts but can
        // be observed via Target.getTargets. To determine the default browser
        // context, we check which one is mentioned in Target.getTargets and not in
        // Target.getBrowserContexts.
        const [{ browserContextIds }, { targetInfos }] = await Promise.all([
            browserCdpClient.sendCommand('Target.getBrowserContexts'),
            browserCdpClient.sendCommand('Target.getTargets'),
        ]);
        let defaultUserContextId = 'default';
        for (const info of targetInfos) {
            if (info.browserContextId &&
                !browserContextIds.includes(info.browserContextId)) {
                defaultUserContextId = info.browserContextId;
                break;
            }
        }
        const server = new BidiServer(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, defaultUserContextId, options, parser, logger);
        // Needed to get events about new targets.
        await browserCdpClient.sendCommand('Target.setDiscoverTargets', {
            discover: true,
        });
        // Needed to automatically attach to new targets.
        await browserCdpClient.sendCommand('Target.setAutoAttach', {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true,
        });
        await server.#topLevelContextsLoaded();
        return server;
    }
    /**
     * Sends BiDi message.
     */
    emitOutgoingMessage(messageEntry, event) {
        this.#messageQueue.add(messageEntry, event);
    }
    close() {
        this.#transport.close();
    }
    async #topLevelContextsLoaded() {
        await Promise.all(this.#browsingContextStorage
            .getTopLevelContexts()
            .map((c) => c.lifecycleLoaded()));
    }
}
exports.BidiServer = BidiServer;
//# sourceMappingURL=BidiServer.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const EventEmitter_js_1 = __webpack_require__(/*! ../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const log_js_1 = __webpack_require__(/*! ../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BidiNoOpParser_js_1 = __webpack_require__(/*! ./BidiNoOpParser.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js");
const BrowserProcessor_js_1 = __webpack_require__(/*! ./modules/browser/BrowserProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js");
const CdpProcessor_js_1 = __webpack_require__(/*! ./modules/cdp/CdpProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js");
const BrowsingContextProcessor_js_1 = __webpack_require__(/*! ./modules/context/BrowsingContextProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js");
const InputProcessor_js_1 = __webpack_require__(/*! ./modules/input/InputProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js");
const NetworkProcessor_js_1 = __webpack_require__(/*! ./modules/network/NetworkProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js");
const PermissionsProcessor_js_1 = __webpack_require__(/*! ./modules/permissions/PermissionsProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js");
const ScriptProcessor_js_1 = __webpack_require__(/*! ./modules/script/ScriptProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js");
const SessionProcessor_js_1 = __webpack_require__(/*! ./modules/session/SessionProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js");
const StorageProcessor_js_1 = __webpack_require__(/*! ./modules/storage/StorageProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js");
const OutgoingMessage_js_1 = __webpack_require__(/*! ./OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
class CommandProcessor extends EventEmitter_js_1.EventEmitter {
    // keep-sorted start
    #browserProcessor;
    #browsingContextProcessor;
    #cdpProcessor;
    #inputProcessor;
    #networkProcessor;
    #permissionsProcessor;
    #scriptProcessor;
    #sessionProcessor;
    #storageProcessor;
    // keep-sorted end
    #parser;
    #logger;
    constructor(cdpConnection, browserCdpClient, eventManager, browsingContextStorage, realmStorage, preloadScriptStorage, networkStorage, parser = new BidiNoOpParser_js_1.BidiNoOpParser(), logger) {
        super();
        this.#parser = parser;
        this.#logger = logger;
        // keep-sorted start block=yes
        this.#browserProcessor = new BrowserProcessor_js_1.BrowserProcessor(browserCdpClient);
        this.#browsingContextProcessor = new BrowsingContextProcessor_js_1.BrowsingContextProcessor(browserCdpClient, browsingContextStorage, eventManager);
        this.#cdpProcessor = new CdpProcessor_js_1.CdpProcessor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient);
        this.#inputProcessor = new InputProcessor_js_1.InputProcessor(browsingContextStorage, realmStorage);
        this.#networkProcessor = new NetworkProcessor_js_1.NetworkProcessor(browsingContextStorage, networkStorage);
        this.#permissionsProcessor = new PermissionsProcessor_js_1.PermissionsProcessor(browserCdpClient);
        this.#scriptProcessor = new ScriptProcessor_js_1.ScriptProcessor(browsingContextStorage, realmStorage, preloadScriptStorage, logger);
        this.#sessionProcessor = new SessionProcessor_js_1.SessionProcessor(eventManager, browserCdpClient);
        this.#storageProcessor = new StorageProcessor_js_1.StorageProcessor(browserCdpClient, browsingContextStorage, logger);
        // keep-sorted end
    }
    async #processCommand(command) {
        switch (command.method) {
            case 'session.end':
                // TODO: Implement.
                break;
            // Browser domain
            // keep-sorted start block=yes
            case 'browser.close':
                return this.#browserProcessor.close();
            case 'browser.createUserContext':
                return await this.#browserProcessor.createUserContext(command.params);
            case 'browser.getUserContexts':
                return await this.#browserProcessor.getUserContexts();
            case 'browser.removeUserContext':
                return await this.#browserProcessor.removeUserContext(this.#parser.parseRemoveUserContextParams(command.params));
            // keep-sorted end
            // Browsing Context domain
            // keep-sorted start block=yes
            case 'browsingContext.activate':
                return await this.#browsingContextProcessor.activate(this.#parser.parseActivateParams(command.params));
            case 'browsingContext.captureScreenshot':
                return await this.#browsingContextProcessor.captureScreenshot(this.#parser.parseCaptureScreenshotParams(command.params));
            case 'browsingContext.close':
                return await this.#browsingContextProcessor.close(this.#parser.parseCloseParams(command.params));
            case 'browsingContext.create':
                return await this.#browsingContextProcessor.create(this.#parser.parseCreateParams(command.params));
            case 'browsingContext.getTree':
                return this.#browsingContextProcessor.getTree(this.#parser.parseGetTreeParams(command.params));
            case 'browsingContext.handleUserPrompt':
                return await this.#browsingContextProcessor.handleUserPrompt(this.#parser.parseHandleUserPromptParams(command.params));
            case 'browsingContext.locateNodes':
                return await this.#browsingContextProcessor.locateNodes(this.#parser.parseLocateNodesParams(command.params));
            case 'browsingContext.navigate':
                return await this.#browsingContextProcessor.navigate(this.#parser.parseNavigateParams(command.params));
            case 'browsingContext.print':
                return await this.#browsingContextProcessor.print(this.#parser.parsePrintParams(command.params));
            case 'browsingContext.reload':
                return await this.#browsingContextProcessor.reload(this.#parser.parseReloadParams(command.params));
            case 'browsingContext.setViewport':
                return await this.#browsingContextProcessor.setViewport(this.#parser.parseSetViewportParams(command.params));
            case 'browsingContext.traverseHistory':
                return await this.#browsingContextProcessor.traverseHistory(this.#parser.parseTraverseHistoryParams(command.params));
            // keep-sorted end
            // CDP domain
            // keep-sorted start block=yes
            case 'cdp.getSession':
                return this.#cdpProcessor.getSession(this.#parser.parseGetSessionParams(command.params));
            case 'cdp.resolveRealm':
                return this.#cdpProcessor.resolveRealm(this.#parser.parseResolveRealmParams(command.params));
            case 'cdp.sendCommand':
                return await this.#cdpProcessor.sendCommand(this.#parser.parseSendCommandParams(command.params));
            // keep-sorted end
            // Input domain
            // keep-sorted start block=yes
            case 'input.performActions':
                return await this.#inputProcessor.performActions(this.#parser.parsePerformActionsParams(command.params));
            case 'input.releaseActions':
                return await this.#inputProcessor.releaseActions(this.#parser.parseReleaseActionsParams(command.params));
            case 'input.setFiles':
                return await this.#inputProcessor.setFiles(this.#parser.parseSetFilesParams(command.params));
            // keep-sorted end
            // Network domain
            // keep-sorted start block=yes
            case 'network.addIntercept':
                return await this.#networkProcessor.addIntercept(this.#parser.parseAddInterceptParams(command.params));
            case 'network.continueRequest':
                return await this.#networkProcessor.continueRequest(this.#parser.parseContinueRequestParams(command.params));
            case 'network.continueResponse':
                return await this.#networkProcessor.continueResponse(this.#parser.parseContinueResponseParams(command.params));
            case 'network.continueWithAuth':
                return await this.#networkProcessor.continueWithAuth(this.#parser.parseContinueWithAuthParams(command.params));
            case 'network.failRequest':
                return await this.#networkProcessor.failRequest(this.#parser.parseFailRequestParams(command.params));
            case 'network.provideResponse':
                return await this.#networkProcessor.provideResponse(this.#parser.parseProvideResponseParams(command.params));
            case 'network.removeIntercept':
                return await this.#networkProcessor.removeIntercept(this.#parser.parseRemoveInterceptParams(command.params));
            // keep-sorted end
            // Permissions domain
            // keep-sorted start block=yes
            case 'permissions.setPermission':
                return await this.#permissionsProcessor.setPermissions(this.#parser.parseSetPermissionsParams(command.params));
            // keep-sorted end
            // Script domain
            // keep-sorted start block=yes
            case 'script.addPreloadScript':
                return await this.#scriptProcessor.addPreloadScript(this.#parser.parseAddPreloadScriptParams(command.params));
            case 'script.callFunction':
                return await this.#scriptProcessor.callFunction(this.#parser.parseCallFunctionParams(this.#processTargetParams(command.params)));
            case 'script.disown':
                return await this.#scriptProcessor.disown(this.#parser.parseDisownParams(this.#processTargetParams(command.params)));
            case 'script.evaluate':
                return await this.#scriptProcessor.evaluate(this.#parser.parseEvaluateParams(this.#processTargetParams(command.params)));
            case 'script.getRealms':
                return this.#scriptProcessor.getRealms(this.#parser.parseGetRealmsParams(command.params));
            case 'script.removePreloadScript':
                return await this.#scriptProcessor.removePreloadScript(this.#parser.parseRemovePreloadScriptParams(command.params));
            // keep-sorted end
            // Session domain
            // keep-sorted start block=yes
            case 'session.new':
                return await this.#sessionProcessor.create(command.params);
            case 'session.status':
                return this.#sessionProcessor.status();
            case 'session.subscribe':
                return await this.#sessionProcessor.subscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
            case 'session.unsubscribe':
                return await this.#sessionProcessor.unsubscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
            // keep-sorted end
            // Storage domain
            // keep-sorted start block=yes
            case 'storage.deleteCookies':
                return await this.#storageProcessor.deleteCookies(this.#parser.parseDeleteCookiesParams(command.params));
            case 'storage.getCookies':
                return await this.#storageProcessor.getCookies(this.#parser.parseGetCookiesParams(command.params));
            case 'storage.setCookie':
                return await this.#storageProcessor.setCookie(this.#parser.parseSetCookieParams(command.params));
            // keep-sorted end
        }
        // Intentionally kept outside the switch statement to ensure that
        // ESLint @typescript-eslint/switch-exhaustiveness-check triggers if a new
        // command is added.
        throw new protocol_js_1.UnknownCommandException(`Unknown command '${command.method}'.`);
    }
    // Workaround for as zod.union always take the first schema
    // https://github.com/w3c/webdriver-bidi/issues/635
    #processTargetParams(params) {
        if (typeof params === 'object' &&
            params &&
            'target' in params &&
            typeof params.target === 'object' &&
            params.target &&
            'context' in params.target) {
            delete params.target['realm'];
        }
        return params;
    }
    async processCommand(command) {
        try {
            const result = await this.#processCommand(command);
            const response = {
                type: 'success',
                id: command.id,
                result,
            };
            this.emit("response" /* CommandProcessorEvents.Response */, {
                message: OutgoingMessage_js_1.OutgoingMessage.createResolved(response, command.channel),
                event: command.method,
            });
        }
        catch (e) {
            if (e instanceof protocol_js_1.Exception) {
                this.emit("response" /* CommandProcessorEvents.Response */, {
                    message: OutgoingMessage_js_1.OutgoingMessage.createResolved(e.toErrorResponse(command.id), command.channel),
                    event: command.method,
                });
            }
            else {
                const error = e;
                this.#logger?.(log_js_1.LogType.bidi, error);
                this.emit("response" /* CommandProcessorEvents.Response */, {
                    message: OutgoingMessage_js_1.OutgoingMessage.createResolved(new protocol_js_1.UnknownErrorException(error.message, error.stack).toErrorResponse(command.id), command.channel),
                    event: command.method,
                });
            }
        }
    }
}
exports.CommandProcessor = CommandProcessor;
//# sourceMappingURL=CommandProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutgoingMessage = void 0;
class OutgoingMessage {
    #message;
    #channel;
    constructor(message, channel = null) {
        this.#message = message;
        this.#channel = channel;
    }
    static createFromPromise(messagePromise, channel) {
        return messagePromise.then((message) => {
            if (message.kind === 'success') {
                return {
                    kind: 'success',
                    value: new OutgoingMessage(message.value, channel),
                };
            }
            return message;
        });
    }
    static createResolved(message, channel) {
        return Promise.resolve({
            kind: 'success',
            value: new OutgoingMessage(message, channel),
        });
    }
    get message() {
        return this.#message;
    }
    get channel() {
        return this.#channel;
    }
}
exports.OutgoingMessage = OutgoingMessage;
//# sourceMappingURL=OutgoingMessage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/browser/BrowserProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowserProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class BrowserProcessor {
    #browserCdpClient;
    constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
    }
    close() {
        // Ensure that it is put at the end of the event loop.
        // This way we send back the response before closing the tab.
        setTimeout(() => this.#browserCdpClient.sendCommand('Browser.close'), 0);
        return {};
    }
    async createUserContext(params) {
        const request = {
            proxyServer: params['goog:proxyServer'] ?? undefined,
        };
        const proxyBypassList = params['goog:proxyBypassList'] ?? undefined;
        if (proxyBypassList) {
            request.proxyBypassList = proxyBypassList.join(',');
        }
        const context = await this.#browserCdpClient.sendCommand('Target.createBrowserContext', request);
        return {
            userContext: context.browserContextId,
        };
    }
    async removeUserContext(params) {
        const userContext = params.userContext;
        if (userContext === 'default') {
            throw new protocol_js_1.InvalidArgumentException('`default` user context cannot be removed');
        }
        try {
            await this.#browserCdpClient.sendCommand('Target.disposeBrowserContext', {
                browserContextId: userContext,
            });
        }
        catch (err) {
            // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/target_handler.cc;l=1424;drc=c686e8f4fd379312469fe018f5c390e9c8f20d0d
            if (err.message.startsWith('Failed to find context with id')) {
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        return {};
    }
    async getUserContexts() {
        const result = await this.#browserCdpClient.sendCommand('Target.getBrowserContexts');
        return {
            userContexts: [
                {
                    userContext: 'default',
                },
                ...result.browserContextIds.map((id) => {
                    return {
                        userContext: id,
                    };
                }),
            ],
        };
    }
}
exports.BrowserProcessor = BrowserProcessor;
//# sourceMappingURL=BrowserProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpProcessor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class CdpProcessor {
    #browsingContextStorage;
    #realmStorage;
    #cdpConnection;
    #browserCdpClient;
    constructor(browsingContextStorage, realmStorage, cdpConnection, browserCdpClient) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
    }
    getSession(params) {
        const context = params.context;
        const sessionId = this.#browsingContextStorage.getContext(context).cdpTarget.cdpSessionId;
        if (sessionId === undefined) {
            return {};
        }
        return { session: sessionId };
    }
    resolveRealm(params) {
        const context = params.realm;
        const realm = this.#realmStorage.getRealm({ realmId: context });
        if (realm === undefined) {
            throw new protocol_js_1.UnknownErrorException(`Could not find realm ${params.realm}`);
        }
        return { executionContextId: realm.executionContextId };
    }
    async sendCommand(params) {
        const client = params.session
            ? this.#cdpConnection.getCdpClient(params.session)
            : this.#browserCdpClient;
        const result = await client.sendCommand(params.method, params.params);
        return {
            result,
            session: params.session,
        };
    }
}
exports.CdpProcessor = CdpProcessor;
//# sourceMappingURL=CdpProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpTarget = void 0;
const chromium_bidi_js_1 = __webpack_require__(/*! ../../../protocol/chromium-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BrowsingContextImpl_js_1 = __webpack_require__(/*! ../context/BrowsingContextImpl.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js");
const LogManager_js_1 = __webpack_require__(/*! ../log/LogManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js");
class CdpTarget {
    #id;
    #cdpClient;
    #browserCdpClient;
    #realmStorage;
    #eventManager;
    #preloadScriptStorage;
    #browsingContextStorage;
    #networkStorage;
    #unblocked = new Deferred_js_1.Deferred();
    #unhandledPromptBehavior;
    #acceptInsecureCerts;
    #logger;
    #networkDomainEnabled = false;
    #fetchDomainStages = {
        request: false,
        response: false,
        auth: false,
    };
    static create(targetId, cdpClient, browserCdpClient, realmStorage, eventManager, preloadScriptStorage, browsingContextStorage, networkStorage, acceptInsecureCerts, unhandledPromptBehavior, logger) {
        const cdpTarget = new CdpTarget(targetId, cdpClient, browserCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, acceptInsecureCerts, unhandledPromptBehavior, logger);
        LogManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager, logger);
        cdpTarget.#setEventListeners();
        // No need to await.
        // Deferred will be resolved when the target is unblocked.
        void cdpTarget.#unblock();
        return cdpTarget;
    }
    constructor(targetId, cdpClient, browserCdpClient, eventManager, realmStorage, preloadScriptStorage, browsingContextStorage, networkStorage, acceptInsecureCerts, unhandledPromptBehavior, logger) {
        this.#id = targetId;
        this.#cdpClient = cdpClient;
        this.#browserCdpClient = browserCdpClient;
        this.#eventManager = eventManager;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#browsingContextStorage = browsingContextStorage;
        this.#acceptInsecureCerts = acceptInsecureCerts;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
    }
    /** Returns a deferred that resolves when the target is unblocked. */
    get unblocked() {
        return this.#unblocked;
    }
    get id() {
        return this.#id;
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    get browserCdpClient() {
        return this.#browserCdpClient;
    }
    /** Needed for CDP escape path. */
    get cdpSessionId() {
        // SAFETY we got the client by it's id for creating
        return this.#cdpClient.sessionId;
    }
    /**
     * Enables all the required CDP domains and unblocks the target.
     */
    async #unblock() {
        try {
            await Promise.all([
                this.#cdpClient.sendCommand('Page.enable'),
                // There can be some existing frames in the target, if reconnecting to an
                // existing browser instance, e.g. via Puppeteer. Need to restore the browsing
                // contexts for the frames to correctly handle further events, like
                // `Runtime.executionContextCreated`.
                // It's important to schedule this task together with enabling domains commands to
                // prepare the tree before the events (e.g. Runtime.executionContextCreated) start
                // coming.
                // https://github.com/GoogleChromeLabs/chromium-bidi/issues/2282
                this.#cdpClient
                    .sendCommand('Page.getFrameTree')
                    .then((frameTree) => this.#restoreFrameTreeState(frameTree.frameTree)),
                this.#cdpClient.sendCommand('Runtime.enable'),
                this.#cdpClient.sendCommand('Page.setLifecycleEventsEnabled', {
                    enabled: true,
                }),
                // Set ignore certificate errors for each target.
                this.#cdpClient.sendCommand('Security.setIgnoreCertificateErrors', {
                    ignore: this.#acceptInsecureCerts,
                }),
                this.toggleNetworkIfNeeded(),
                this.#cdpClient.sendCommand('Target.setAutoAttach', {
                    autoAttach: true,
                    waitForDebuggerOnStart: true,
                    flatten: true,
                }),
                this.#initAndEvaluatePreloadScripts(),
                this.#cdpClient.sendCommand('Runtime.runIfWaitingForDebugger'),
            ]);
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, 'Failed to unblock target', error);
            // The target might have been closed before the initialization finished.
            if (!this.#cdpClient.isCloseError(error)) {
                this.#unblocked.resolve({
                    kind: 'error',
                    error,
                });
                return;
            }
        }
        this.#unblocked.resolve({
            kind: 'success',
            value: undefined,
        });
    }
    #restoreFrameTreeState(frameTree) {
        const frame = frameTree.frame;
        if (this.#browsingContextStorage.findContext(frame.id) === undefined &&
            frame.parentId !== undefined) {
            // Can restore only not yet known nested frames. The top-level frame is created
            // when the target is attached.
            const parentBrowsingContext = this.#browsingContextStorage.getContext(frame.parentId);
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(frame.id, frame.parentId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, frame.url, undefined, this.#unhandledPromptBehavior, this.#logger);
        }
        frameTree.childFrames?.map((frameTree) => this.#restoreFrameTreeState(frameTree));
    }
    async toggleFetchIfNeeded() {
        const stages = this.#networkStorage.getInterceptionStages(this.topLevelId);
        if (
        // Only toggle interception when Network is enabled
        !this.#networkDomainEnabled ||
            (this.#fetchDomainStages.request === stages.request &&
                this.#fetchDomainStages.response === stages.response &&
                this.#fetchDomainStages.auth === stages.auth)) {
            return;
        }
        const patterns = [];
        this.#fetchDomainStages = stages;
        if (stages.request || stages.auth) {
            // CDP quirk we need request interception when we intercept auth
            patterns.push({
                urlPattern: '*',
                requestStage: 'Request',
            });
        }
        if (stages.response) {
            patterns.push({
                urlPattern: '*',
                requestStage: 'Response',
            });
        }
        if (patterns.length) {
            await this.#cdpClient.sendCommand('Fetch.enable', {
                patterns,
                handleAuthRequests: stages.auth,
            });
        }
        else {
            await this.#cdpClient.sendCommand('Fetch.disable');
        }
    }
    /**
     * Toggles both Network and Fetch domains.
     */
    async toggleNetworkIfNeeded() {
        const enabled = this.isSubscribedTo(chromium_bidi_js_1.BiDiModule.Network);
        if (enabled === this.#networkDomainEnabled) {
            return;
        }
        this.#networkDomainEnabled = enabled;
        try {
            await Promise.all([
                this.#cdpClient.sendCommand(enabled ? 'Network.enable' : 'Network.disable'),
                this.toggleFetchIfNeeded(),
            ]);
        }
        catch (err) {
            this.#networkDomainEnabled = !enabled;
        }
    }
    #setEventListeners() {
        this.#cdpClient.on('*', (event, params) => {
            // We may encounter uses for EventEmitter other than CDP events,
            // which we want to skip.
            if (typeof event !== 'string') {
                return;
            }
            this.#eventManager.registerEvent({
                type: 'event',
                method: `cdp.${event}`,
                params: {
                    event,
                    params,
                    session: this.cdpSessionId,
                },
            }, this.id);
        });
    }
    /**
     * All the ProxyChannels from all the preload scripts of the given
     * BrowsingContext.
     */
    getChannels() {
        return this.#preloadScriptStorage
            .find()
            .flatMap((script) => script.channels);
    }
    /** Loads all top-level preload scripts. */
    async #initAndEvaluatePreloadScripts() {
        await Promise.all(this.#preloadScriptStorage
            .find({
            // Needed for OOPIF
            targetId: this.topLevelId,
            global: true,
        })
            .map((script) => {
            return script.initInTarget(this, true);
        }));
    }
    get topLevelId() {
        return (this.#browsingContextStorage.findTopLevelContextId(this.id) ?? this.id);
    }
    isSubscribedTo(moduleOrEvent) {
        return this.#eventManager.subscriptionManager.isSubscribedTo(moduleOrEvent, this.topLevelId);
    }
}
exports.CdpTarget = CdpTarget;
//# sourceMappingURL=CdpTarget.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTargetManager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CdpTargetManager = void 0;
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const BrowsingContextImpl_js_1 = __webpack_require__(/*! ../context/BrowsingContextImpl.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js");
const WorkerRealm_js_1 = __webpack_require__(/*! ../script/WorkerRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js");
const CdpTarget_js_1 = __webpack_require__(/*! ./CdpTarget.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/cdp/CdpTarget.js");
const cdpToBidiTargetTypes = {
    service_worker: 'service-worker',
    shared_worker: 'shared-worker',
    worker: 'dedicated-worker',
};
class CdpTargetManager {
    #browserCdpClient;
    #cdpConnection;
    #selfTargetId;
    #eventManager;
    #browsingContextStorage;
    #networkStorage;
    #acceptInsecureCerts;
    #preloadScriptStorage;
    #realmStorage;
    #defaultUserContextId;
    #logger;
    #unhandledPromptBehavior;
    constructor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, preloadScriptStorage, acceptInsecureCerts, defaultUserContextId, unhandledPromptBehavior, logger) {
        this.#acceptInsecureCerts = acceptInsecureCerts;
        this.#cdpConnection = cdpConnection;
        this.#browserCdpClient = browserCdpClient;
        this.#selfTargetId = selfTargetId;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkStorage = networkStorage;
        this.#realmStorage = realmStorage;
        this.#defaultUserContextId = defaultUserContextId;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
        this.#setEventListeners(browserCdpClient);
    }
    /**
     * This method is called for each CDP session, since this class is responsible
     * for creating and destroying all targets and browsing contexts.
     */
    #setEventListeners(cdpClient) {
        cdpClient.on('Target.attachedToTarget', (params) => {
            this.#handleAttachedToTargetEvent(params, cdpClient);
        });
        cdpClient.on('Target.detachedFromTarget', this.#handleDetachedFromTargetEvent.bind(this));
        cdpClient.on('Target.targetInfoChanged', this.#handleTargetInfoChangedEvent.bind(this));
        cdpClient.on('Inspector.targetCrashed', () => {
            this.#handleTargetCrashedEvent(cdpClient);
        });
        cdpClient.on('Page.frameAttached', this.#handleFrameAttachedEvent.bind(this));
        cdpClient.on('Page.frameDetached', this.#handleFrameDetachedEvent.bind(this));
    }
    #handleFrameAttachedEvent(params) {
        const parentBrowsingContext = this.#browsingContextStorage.findContext(params.parentFrameId);
        if (parentBrowsingContext !== undefined) {
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(params.frameId, params.parentFrameId, parentBrowsingContext.userContext, parentBrowsingContext.cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, 
            // At this point, we don't know the URL of the frame yet, so it will be updated
            // later.
            'about:blank', undefined, this.#unhandledPromptBehavior, this.#logger);
        }
    }
    #handleFrameDetachedEvent(params) {
        // In case of OOPiF no need in deleting BrowsingContext.
        if (params.reason === 'swap') {
            return;
        }
        this.#browsingContextStorage.findContext(params.frameId)?.dispose();
    }
    #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
        const { sessionId, targetInfo } = params;
        const targetCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        switch (targetInfo.type) {
            case 'page':
            case 'iframe': {
                if (targetInfo.targetId === this.#selfTargetId) {
                    break;
                }
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                const maybeContext = this.#browsingContextStorage.findContext(targetInfo.targetId);
                if (maybeContext) {
                    // OOPiF.
                    maybeContext.updateCdpTarget(cdpTarget);
                }
                else {
                    const userContext = targetInfo.browserContextId &&
                        targetInfo.browserContextId !== this.#defaultUserContextId
                        ? targetInfo.browserContextId
                        : 'default';
                    // New context.
                    BrowsingContextImpl_js_1.BrowsingContextImpl.create(targetInfo.targetId, null, userContext, cdpTarget, this.#eventManager, this.#browsingContextStorage, this.#realmStorage, 
                    // Hack: when a new target created, CDP emits targetInfoChanged with an empty
                    // url, and navigates it to about:blank later. When the event is emitted for
                    // an existing target (reconnect), the url is already known, and navigation
                    // events will not be emitted anymore. Replacing empty url with `about:blank`
                    // allows to handle both cases in the same way.
                    // "7.3.2.1 Creating browsing contexts".
                    // https://html.spec.whatwg.org/multipage/document-sequences.html#creating-browsing-contexts
                    // TODO: check who to deal with non-null creator and its `creatorOrigin`.
                    targetInfo.url === '' ? 'about:blank' : targetInfo.url, targetInfo.openerFrameId ?? targetInfo.openerId, this.#unhandledPromptBehavior, this.#logger);
                }
                return;
            }
            case 'service_worker':
            case 'worker': {
                const realm = this.#realmStorage.findRealm({
                    cdpSessionId: parentSessionCdpClient.sessionId,
                });
                // If there is no browsing context, this worker is already terminated.
                if (!realm) {
                    break;
                }
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget, realm);
                return;
            }
            // In CDP, we only emit shared workers on the browser and not the set of
            // frames that use the shared worker. If we change this in the future to
            // behave like service workers (emits on both browser and frame targets),
            // we can remove this block and merge service workers with the above one.
            case 'shared_worker': {
                const cdpTarget = this.#createCdpTarget(targetCdpClient, targetInfo);
                this.#handleWorkerTarget(cdpToBidiTargetTypes[targetInfo.type], cdpTarget);
                return;
            }
        }
        // DevTools or some other not supported by BiDi target. Just release
        // debugger and ignore them.
        targetCdpClient
            .sendCommand('Runtime.runIfWaitingForDebugger')
            .then(() => parentSessionCdpClient.sendCommand('Target.detachFromTarget', params))
            .catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
    }
    #createCdpTarget(targetCdpClient, targetInfo) {
        this.#setEventListeners(targetCdpClient);
        const target = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, this.#browserCdpClient, this.#realmStorage, this.#eventManager, this.#preloadScriptStorage, this.#browsingContextStorage, this.#networkStorage, this.#acceptInsecureCerts, this.#unhandledPromptBehavior, this.#logger);
        this.#networkStorage.onCdpTargetCreated(target);
        return target;
    }
    #workers = new Map();
    #handleWorkerTarget(realmType, cdpTarget, ownerRealm) {
        cdpTarget.cdpClient.on('Runtime.executionContextCreated', (params) => {
            const { uniqueId, id, origin } = params.context;
            const workerRealm = new WorkerRealm_js_1.WorkerRealm(cdpTarget.cdpClient, this.#eventManager, id, this.#logger, (0, BrowsingContextImpl_js_1.serializeOrigin)(origin), ownerRealm ? [ownerRealm] : [], uniqueId, this.#realmStorage, realmType);
            this.#workers.set(cdpTarget.cdpSessionId, workerRealm);
        });
    }
    #handleDetachedFromTargetEvent({ sessionId, targetId, }) {
        if (targetId) {
            this.#preloadScriptStorage.find({ targetId }).map((preloadScript) => {
                preloadScript.dispose(targetId);
            });
        }
        const context = this.#browsingContextStorage.findContextBySession(sessionId);
        if (context) {
            context.dispose();
            return;
        }
        const worker = this.#workers.get(sessionId);
        if (worker) {
            this.#realmStorage.deleteRealms({
                cdpSessionId: worker.cdpClient.sessionId,
            });
        }
    }
    #handleTargetInfoChangedEvent(params) {
        const context = this.#browsingContextStorage.findContext(params.targetInfo.targetId);
        if (context) {
            context.onTargetInfoChanged(params);
        }
    }
    #handleTargetCrashedEvent(cdpClient) {
        // This is primarily used for service and shared workers. CDP tends to not
        // signal they closed gracefully and instead says they crashed to signal
        // they are closed.
        const realms = this.#realmStorage.findRealms({
            cdpSessionId: cdpClient.sessionId,
        });
        for (const realm of realms) {
            realm.dispose();
        }
    }
}
exports.CdpTargetManager = CdpTargetManager;
//# sourceMappingURL=CdpTargetManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextImpl.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextImpl = void 0;
exports.serializeOrigin = serializeOrigin;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const unitConversions_js_1 = __webpack_require__(/*! ../../../utils/unitConversions.js */ "./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js");
const uuid_1 = __webpack_require__(/*! ../../../utils/uuid */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const WindowRealm_js_1 = __webpack_require__(/*! ../script/WindowRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js");
class BrowsingContextImpl {
    static LOGGER_PREFIX = `${log_js_1.LogType.debug}:browsingContext`;
    /** The ID of this browsing context. */
    #id;
    userContext;
    /**
     * The ID of the parent browsing context.
     * If null, this is a top-level context.
     */
    #parentId;
    /** Direct children browsing contexts. */
    #children = new Set();
    #browsingContextStorage;
    #lifecycle = {
        DOMContentLoaded: new Deferred_js_1.Deferred(),
        load: new Deferred_js_1.Deferred(),
    };
    #navigation = {
        withinDocument: new Deferred_js_1.Deferred(),
    };
    #url;
    #eventManager;
    #realmStorage;
    #loaderId;
    #cdpTarget;
    // The deferred will be resolved when the default realm is created.
    #defaultRealmDeferred = new Deferred_js_1.Deferred();
    #logger;
    // Keeps track of the previously set viewport.
    #previousViewport = { width: 0, height: 0 };
    // The URL of the navigation that is currently in progress. A workaround of the CDP
    // lacking URL for the pending navigation events, e.g. `Page.frameStartedLoading`.
    // Set on `Page.navigate`, `Page.reload` commands and on deprecated CDP event
    // `Page.frameScheduledNavigation`.
    #pendingNavigationUrl;
    #virtualNavigationId = (0, uuid_1.uuidv4)();
    #originalOpener;
    // Set when the user prompt is opened. Required to provide the type in closing event.
    #lastUserPromptType;
    #unhandledPromptBehavior;
    constructor(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        this.#cdpTarget = cdpTarget;
        this.#id = id;
        this.#parentId = parentId;
        this.userContext = userContext;
        this.#eventManager = eventManager;
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#unhandledPromptBehavior = unhandledPromptBehavior;
        this.#logger = logger;
        this.#url = url;
        this.#originalOpener = originalOpener;
    }
    static create(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger) {
        const context = new BrowsingContextImpl(id, parentId, userContext, cdpTarget, eventManager, browsingContextStorage, realmStorage, url, originalOpener, unhandledPromptBehavior, logger);
        context.#initListeners();
        browsingContextStorage.addContext(context);
        if (!context.isTopLevelContext()) {
            context.parent.addChild(context.id);
        }
        eventManager.registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
            params: context.serializeToBidiValue(),
        }, context.id);
        return context;
    }
    static getTimestamp() {
        // `timestamp` from the event is MonotonicTime, not real time, so
        // the best Mapper can do is to set the timestamp to the epoch time
        // of the event arrived.
        // https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-MonotonicTime
        return new Date().getTime();
    }
    /**
     * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
     */
    get navigableId() {
        return this.#loaderId;
    }
    /**
     * Virtual navigation ID. Required, as CDP `loaderId` cannot be mapped 1:1 to all the
     * navigations (e.g. same document navigations). Updated after each navigation,
     * including same-document ones.
     */
    get virtualNavigationId() {
        return this.#virtualNavigationId;
    }
    dispose() {
        this.#deleteAllChildren();
        this.#realmStorage.deleteRealms({
            browsingContextId: this.id,
        });
        // Remove context from the parent.
        if (!this.isTopLevelContext()) {
            this.parent.#children.delete(this.id);
        }
        // Fail all ongoing navigations.
        this.#failLifecycleIfNotFinished();
        this.#eventManager.registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
            params: this.serializeToBidiValue(),
        }, this.id);
        this.#browsingContextStorage.deleteContextById(this.id);
    }
    /** Returns the ID of this context. */
    get id() {
        return this.#id;
    }
    /** Returns the parent context ID. */
    get parentId() {
        return this.#parentId;
    }
    /** Returns the parent context. */
    get parent() {
        if (this.parentId === null) {
            return null;
        }
        return this.#browsingContextStorage.getContext(this.parentId);
    }
    /** Returns all direct children contexts. */
    get directChildren() {
        return [...this.#children].map((id) => this.#browsingContextStorage.getContext(id));
    }
    /** Returns all children contexts, flattened. */
    get allChildren() {
        const children = this.directChildren;
        return children.concat(...children.map((child) => child.allChildren));
    }
    /**
     * Returns true if this is a top-level context.
     * This is the case whenever the parent context ID is null.
     */
    isTopLevelContext() {
        return this.#parentId === null;
    }
    get top() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let topContext = this;
        let parent = topContext.parent;
        while (parent) {
            topContext = parent;
            parent = topContext.parent;
        }
        return topContext;
    }
    addChild(childId) {
        this.#children.add(childId);
    }
    #deleteAllChildren() {
        this.directChildren.map((child) => child.dispose());
    }
    get cdpTarget() {
        return this.#cdpTarget;
    }
    updateCdpTarget(cdpTarget) {
        this.#cdpTarget = cdpTarget;
        this.#initListeners();
    }
    get url() {
        return this.#url;
    }
    async lifecycleLoaded() {
        await this.#lifecycle.load;
    }
    async targetUnblockedOrThrow() {
        const result = await this.#cdpTarget.unblocked;
        if (result.kind === 'error') {
            throw result.error;
        }
    }
    async getOrCreateSandbox(sandbox) {
        if (sandbox === undefined || sandbox === '') {
            // Default realm is not guaranteed to be created at this point, so return a deferred.
            return await this.#defaultRealmDeferred;
        }
        let maybeSandboxes = this.#realmStorage.findRealms({
            browsingContextId: this.id,
            sandbox,
        });
        if (maybeSandboxes.length === 0) {
            await this.#cdpTarget.cdpClient.sendCommand('Page.createIsolatedWorld', {
                frameId: this.id,
                worldName: sandbox,
            });
            // `Runtime.executionContextCreated` should be emitted by the time the
            // previous command is done.
            maybeSandboxes = this.#realmStorage.findRealms({
                browsingContextId: this.id,
                sandbox,
            });
            (0, assert_js_1.assert)(maybeSandboxes.length !== 0);
        }
        // It's possible for more than one sandbox to be created due to provisional
        // frames. In this case, it's always the first one (i.e. the oldest one)
        // that is more relevant since the user may have set that one up already
        // through evaluation.
        return maybeSandboxes[0];
    }
    serializeToBidiValue(maxDepth = 0, addParentField = true) {
        return {
            context: this.#id,
            url: this.url,
            userContext: this.userContext,
            originalOpener: this.#originalOpener ?? null,
            children: maxDepth > 0
                ? this.directChildren.map((c) => c.serializeToBidiValue(maxDepth - 1, false))
                : null,
            ...(addParentField ? { parent: this.#parentId } : {}),
        };
    }
    onTargetInfoChanged(params) {
        this.#url = params.targetInfo.url;
    }
    #initListeners() {
        this.#cdpTarget.cdpClient.on('Page.frameNavigated', (params) => {
            if (this.id !== params.frame.id) {
                return;
            }
            this.#url = params.frame.url + (params.frame.urlFragment ?? '');
            this.#pendingNavigationUrl = undefined;
            // At the point the page is initialized, all the nested iframes from the
            // previous page are detached and realms are destroyed.
            // Remove children from context.
            this.#deleteAllChildren();
        });
        this.#cdpTarget.cdpClient.on('Page.navigatedWithinDocument', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            this.#pendingNavigationUrl = undefined;
            const timestamp = BrowsingContextImpl.getTimestamp();
            this.#url = params.url;
            this.#navigation.withinDocument.resolve();
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.FragmentNavigated,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp,
                    url: this.#url,
                },
            }, this.id);
        });
        this.#cdpTarget.cdpClient.on('Page.frameStartedLoading', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            // Generate a new virtual navigation id.
            this.#virtualNavigationId = (0, uuid_1.uuidv4)();
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp: BrowsingContextImpl.getTimestamp(),
                    // The URL of the navigation that is currently in progress. Although the URL
                    // is not yet known in case of user-initiated navigations, it is possible to
                    // provide the URL in case of BiDi-initiated navigations.
                    // TODO: provide proper URL in case of user-initiated navigations.
                    url: this.#pendingNavigationUrl ?? 'UNKNOWN',
                },
            }, this.id);
        });
        // TODO: don't use deprecated `Page.frameScheduledNavigation` event.
        this.#cdpTarget.cdpClient.on('Page.frameScheduledNavigation', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            this.#pendingNavigationUrl = params.url;
        });
        this.#cdpTarget.cdpClient.on('Page.lifecycleEvent', (params) => {
            if (this.id !== params.frameId) {
                return;
            }
            if (params.name === 'init') {
                this.#documentChanged(params.loaderId);
                return;
            }
            if (params.name === 'commit') {
                this.#loaderId = params.loaderId;
                return;
            }
            // If mapper attached to the page late, it might miss init and
            // commit events. In that case, save the first loaderId for this
            // frameId.
            if (!this.#loaderId) {
                this.#loaderId = params.loaderId;
            }
            // Ignore event from not current navigation.
            if (params.loaderId !== this.#loaderId) {
                return;
            }
            const timestamp = BrowsingContextImpl.getTimestamp();
            switch (params.name) {
                case 'DOMContentLoaded':
                    this.#eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                        params: {
                            context: this.id,
                            navigation: this.#virtualNavigationId,
                            timestamp,
                            url: this.#url,
                        },
                    }, this.id);
                    this.#lifecycle.DOMContentLoaded.resolve();
                    break;
                case 'load':
                    this.#eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.Load,
                        params: {
                            context: this.id,
                            navigation: this.#virtualNavigationId,
                            timestamp,
                            url: this.#url,
                        },
                    }, this.id);
                    this.#lifecycle.load.resolve();
                    break;
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextCreated', (params) => {
            const { auxData, name, uniqueId, id } = params.context;
            if (!auxData || auxData.frameId !== this.id) {
                return;
            }
            let origin;
            let sandbox;
            // Only these execution contexts are supported for now.
            switch (auxData.type) {
                case 'isolated':
                    sandbox = name;
                    // Sandbox should have the same origin as the context itself, but in CDP
                    // it has an empty one.
                    if (!this.#defaultRealmDeferred.isFinished) {
                        this.#logger?.(log_js_1.LogType.debugError, 'Unexpectedly, isolated realm created before the default one');
                    }
                    origin = this.#defaultRealmDeferred.isFinished
                        ? this.#defaultRealmDeferred.result.origin
                        : // This fallback is not expected to be ever reached.
                            '';
                    break;
                case 'default':
                    origin = serializeOrigin(params.context.origin);
                    break;
                default:
                    return;
            }
            const realm = new WindowRealm_js_1.WindowRealm(this.id, this.#browsingContextStorage, this.#cdpTarget.cdpClient, this.#eventManager, id, this.#logger, origin, uniqueId, this.#realmStorage, sandbox);
            if (auxData.isDefault) {
                this.#defaultRealmDeferred.resolve(realm);
                // Initialize ChannelProxy listeners for all the channels of all the
                // preload scripts related to this BrowsingContext.
                // TODO: extend for not default realms by the sandbox name.
                void Promise.all(this.#cdpTarget
                    .getChannels()
                    .map((channel) => channel.startListenerFromWindow(realm, this.#eventManager)));
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextDestroyed', (params) => {
            if (this.#defaultRealmDeferred.isFinished &&
                this.#defaultRealmDeferred.result.executionContextId ===
                    params.executionContextId) {
                this.#defaultRealmDeferred = new Deferred_js_1.Deferred();
            }
            this.#realmStorage.deleteRealms({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.executionContextId,
            });
        });
        this.#cdpTarget.cdpClient.on('Runtime.executionContextsCleared', () => {
            if (!this.#defaultRealmDeferred.isFinished) {
                this.#defaultRealmDeferred.reject(new protocol_js_1.UnknownErrorException('execution contexts cleared'));
            }
            this.#defaultRealmDeferred = new Deferred_js_1.Deferred();
            this.#realmStorage.deleteRealms({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
            });
        });
        this.#cdpTarget.cdpClient.on('Page.javascriptDialogClosed', (params) => {
            const accepted = params.result;
            if (this.#lastUserPromptType === undefined) {
                this.#logger?.(log_js_1.LogType.debugError, 'Unexpectedly no opening prompt event before closing one');
            }
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
                params: {
                    context: this.id,
                    accepted,
                    // `lastUserPromptType` should never be undefined here, so fallback to
                    // `UNKNOWN`. The fallback is required to prevent tests from hanging while
                    // waiting for the closing event. The cast is required, as the `UNKNOWN` value
                    // is not standard.
                    type: this.#lastUserPromptType ??
                        'UNKNOWN',
                    userText: accepted && params.userInput ? params.userInput : undefined,
                },
            }, this.id);
            this.#lastUserPromptType = undefined;
        });
        this.#cdpTarget.cdpClient.on('Page.javascriptDialogOpening', (params) => {
            const promptType = BrowsingContextImpl.#getPromptType(params.type);
            // Set the last prompt type to provide it in closing event.
            this.#lastUserPromptType = promptType;
            const promptHandler = this.#getPromptHandler(promptType);
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
                params: {
                    context: this.id,
                    handler: promptHandler,
                    type: promptType,
                    message: params.message,
                    ...(params.type === 'prompt'
                        ? { defaultValue: params.defaultPrompt }
                        : {}),
                },
            }, this.id);
            switch (promptHandler) {
                // Based on `unhandledPromptBehavior`, check if the prompt should be handled
                // automatically (`accept`, `dismiss`) or wait for the user to do it.
                case 'accept':
                    void this.handleUserPrompt(true);
                    break;
                case 'dismiss':
                    void this.handleUserPrompt(false);
                    break;
                case 'ignore':
                    break;
            }
        });
    }
    static #getPromptType(cdpType) {
        switch (cdpType) {
            case 'alert':
                return "alert" /* BrowsingContext.UserPromptType.Alert */;
            case 'beforeunload':
                return "beforeunload" /* BrowsingContext.UserPromptType.Beforeunload */;
            case 'confirm':
                return "confirm" /* BrowsingContext.UserPromptType.Confirm */;
            case 'prompt':
                return "prompt" /* BrowsingContext.UserPromptType.Prompt */;
        }
    }
    #getPromptHandler(promptType) {
        const defaultPromptHandler = 'dismiss';
        switch (promptType) {
            case "alert" /* BrowsingContext.UserPromptType.Alert */:
                return (this.#unhandledPromptBehavior?.alert ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
            case "beforeunload" /* BrowsingContext.UserPromptType.Beforeunload */:
                return (this.#unhandledPromptBehavior?.beforeUnload ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
            case "confirm" /* BrowsingContext.UserPromptType.Confirm */:
                return (this.#unhandledPromptBehavior?.confirm ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
            case "prompt" /* BrowsingContext.UserPromptType.Prompt */:
                return (this.#unhandledPromptBehavior?.prompt ??
                    this.#unhandledPromptBehavior?.default ??
                    defaultPromptHandler);
        }
    }
    #documentChanged(loaderId) {
        // Same document navigation.
        if (loaderId === undefined || this.#loaderId === loaderId) {
            if (this.#navigation.withinDocument.isFinished) {
                this.#navigation.withinDocument = new Deferred_js_1.Deferred();
            }
            else {
                this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (navigatedWithinDocument)');
            }
            return;
        }
        this.#resetLifecycleIfFinished();
        this.#loaderId = loaderId;
    }
    #resetLifecycleIfFinished() {
        if (this.#lifecycle.DOMContentLoaded.isFinished) {
            this.#lifecycle.DOMContentLoaded = new Deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (DOMContentLoaded)');
        }
        if (this.#lifecycle.load.isFinished) {
            this.#lifecycle.load = new Deferred_js_1.Deferred();
        }
        else {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Document changed (load)');
        }
    }
    #failLifecycleIfNotFinished() {
        if (!this.#lifecycle.DOMContentLoaded.isFinished) {
            this.#lifecycle.DOMContentLoaded.reject(new protocol_js_1.UnknownErrorException('navigation canceled'));
        }
        if (!this.#lifecycle.load.isFinished) {
            this.#lifecycle.load.reject(new protocol_js_1.UnknownErrorException('navigation canceled'));
        }
    }
    async navigate(url, wait) {
        try {
            new URL(url);
        }
        catch {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL: ${url}`);
        }
        await this.targetUnblockedOrThrow();
        // Set the pending navigation URL to provide it in `browsingContext.navigationStarted`
        // event.
        // TODO: detect navigation start not from CDP. Check if
        //  `Page.frameRequestedNavigation` can be used for this purpose.
        this.#pendingNavigationUrl = url;
        // TODO: handle loading errors.
        const cdpNavigateResult = await this.#cdpTarget.cdpClient.sendCommand('Page.navigate', {
            url,
            frameId: this.id,
        });
        if (cdpNavigateResult.errorText) {
            // If navigation failed, no pending navigation is left.
            this.#pendingNavigationUrl = undefined;
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationFailed,
                params: {
                    context: this.id,
                    navigation: this.#virtualNavigationId,
                    timestamp: BrowsingContextImpl.getTimestamp(),
                    url,
                },
            }, this.id);
            throw new protocol_js_1.UnknownErrorException(cdpNavigateResult.errorText);
        }
        this.#documentChanged(cdpNavigateResult.loaderId);
        switch (wait) {
            case "none" /* BrowsingContext.ReadinessState.None */:
                break;
            case "interactive" /* BrowsingContext.ReadinessState.Interactive */:
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#navigation.withinDocument;
                }
                else {
                    await this.#lifecycle.DOMContentLoaded;
                }
                break;
            case "complete" /* BrowsingContext.ReadinessState.Complete */:
                // No `loaderId` means same-document navigation.
                if (cdpNavigateResult.loaderId === undefined) {
                    await this.#navigation.withinDocument;
                }
                else {
                    await this.#lifecycle.load;
                }
                break;
        }
        return {
            navigation: this.#virtualNavigationId,
            // Url can change due to redirect get the latest one.
            url: wait === "none" /* BrowsingContext.ReadinessState.None */ ? url : this.#url,
        };
    }
    async reload(ignoreCache, wait) {
        await this.targetUnblockedOrThrow();
        this.#resetLifecycleIfFinished();
        await this.#cdpTarget.cdpClient.sendCommand('Page.reload', {
            ignoreCache,
        });
        switch (wait) {
            case "none" /* BrowsingContext.ReadinessState.None */:
                break;
            case "interactive" /* BrowsingContext.ReadinessState.Interactive */:
                await this.#lifecycle.DOMContentLoaded;
                break;
            case "complete" /* BrowsingContext.ReadinessState.Complete */:
                await this.#lifecycle.load;
                break;
        }
        return {
            navigation: this.#virtualNavigationId,
            url: this.url,
        };
    }
    async setViewport(viewport, devicePixelRatio) {
        if (viewport === null && devicePixelRatio === null) {
            await this.#cdpTarget.cdpClient.sendCommand('Emulation.clearDeviceMetricsOverride');
        }
        else {
            try {
                let appliedViewport;
                if (viewport === undefined) {
                    appliedViewport = this.#previousViewport;
                }
                else if (viewport === null) {
                    appliedViewport = {
                        width: 0,
                        height: 0,
                    };
                }
                else {
                    appliedViewport = viewport;
                }
                this.#previousViewport = appliedViewport;
                await this.#cdpTarget.cdpClient.sendCommand('Emulation.setDeviceMetricsOverride', {
                    width: this.#previousViewport.width,
                    height: this.#previousViewport.height,
                    deviceScaleFactor: devicePixelRatio ? devicePixelRatio : 0,
                    mobile: false,
                    dontSetVisibleSize: true,
                });
            }
            catch (err) {
                if (err.message.startsWith(
                // https://crsrc.org/c/content/browser/devtools/protocol/emulation_handler.cc;l=257;drc=2f6eee84cf98d4227e7c41718dd71b82f26d90ff
                'Width and height values must be positive')) {
                    throw new protocol_js_1.UnsupportedOperationException('Provided viewport dimensions are not supported');
                }
                throw err;
            }
        }
    }
    async handleUserPrompt(accept, userText) {
        await this.#cdpTarget.cdpClient.sendCommand('Page.handleJavaScriptDialog', {
            accept: accept ?? true,
            promptText: userText,
        });
    }
    async activate() {
        await this.#cdpTarget.cdpClient.sendCommand('Page.bringToFront');
    }
    async captureScreenshot(params) {
        if (!this.isTopLevelContext()) {
            throw new protocol_js_1.UnsupportedOperationException(`Non-top-level 'context' (${params.context}) is currently not supported`);
        }
        const formatParameters = getImageFormatParameters(params);
        // XXX: Focus the original tab after the screenshot is taken.
        // This is needed because the screenshot gets blocked until the active tab gets focus.
        await this.#cdpTarget.cdpClient.sendCommand('Page.bringToFront');
        let captureBeyondViewport = false;
        let script;
        params.origin ??= 'viewport';
        switch (params.origin) {
            case 'document': {
                script = String(() => {
                    const element = document.documentElement;
                    return {
                        x: 0,
                        y: 0,
                        width: element.scrollWidth,
                        height: element.scrollHeight,
                    };
                });
                captureBeyondViewport = true;
                break;
            }
            case 'viewport': {
                script = String(() => {
                    const viewport = window.visualViewport;
                    return {
                        x: viewport.pageLeft,
                        y: viewport.pageTop,
                        width: viewport.width,
                        height: viewport.height,
                    };
                });
                break;
            }
        }
        const realm = await this.getOrCreateSandbox(undefined);
        const originResult = await realm.callFunction(script, false);
        (0, assert_js_1.assert)(originResult.type === 'success');
        const origin = deserializeDOMRect(originResult.result);
        (0, assert_js_1.assert)(origin);
        let rect = origin;
        if (params.clip) {
            const clip = params.clip;
            if (params.origin === 'viewport' && clip.type === 'box') {
                // For viewport origin, the clip is relative to the viewport, while the CDP
                // screenshot is relative to the document. So correction for the viewport position
                // is required.
                clip.x += origin.x;
                clip.y += origin.y;
            }
            rect = getIntersectionRect(await this.#parseRect(clip), origin);
        }
        if (rect.width === 0 || rect.height === 0) {
            throw new protocol_js_1.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${rect.width}, height=${rect.height}`);
        }
        return await this.#cdpTarget.cdpClient.sendCommand('Page.captureScreenshot', {
            clip: { ...rect, scale: 1.0 },
            ...formatParameters,
            captureBeyondViewport,
        });
    }
    async print(params) {
        const cdpParams = {};
        if (params.background !== undefined) {
            cdpParams.printBackground = params.background;
        }
        if (params.margin?.bottom !== undefined) {
            cdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
        }
        if (params.margin?.left !== undefined) {
            cdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
        }
        if (params.margin?.right !== undefined) {
            cdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
        }
        if (params.margin?.top !== undefined) {
            cdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
        }
        if (params.orientation !== undefined) {
            cdpParams.landscape = params.orientation === 'landscape';
        }
        if (params.page?.height !== undefined) {
            cdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
        }
        if (params.page?.width !== undefined) {
            cdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
        }
        if (params.pageRanges !== undefined) {
            for (const range of params.pageRanges) {
                if (typeof range === 'number') {
                    continue;
                }
                const rangeParts = range.split('-');
                if (rangeParts.length < 1 || rangeParts.length > 2) {
                    throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${range} is not a valid integer range.`);
                }
                if (rangeParts.length === 1) {
                    void parseInteger(rangeParts[0] ?? '');
                    continue;
                }
                let lowerBound;
                let upperBound;
                const [rangeLowerPart = '', rangeUpperPart = ''] = rangeParts;
                if (rangeLowerPart === '') {
                    lowerBound = 1;
                }
                else {
                    lowerBound = parseInteger(rangeLowerPart);
                }
                if (rangeUpperPart === '') {
                    upperBound = Number.MAX_SAFE_INTEGER;
                }
                else {
                    upperBound = parseInteger(rangeUpperPart);
                }
                if (lowerBound > upperBound) {
                    throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${rangeLowerPart} > ${rangeUpperPart}`);
                }
            }
            cdpParams.pageRanges = params.pageRanges.join(',');
        }
        if (params.scale !== undefined) {
            cdpParams.scale = params.scale;
        }
        if (params.shrinkToFit !== undefined) {
            cdpParams.preferCSSPageSize = !params.shrinkToFit;
        }
        try {
            const result = await this.#cdpTarget.cdpClient.sendCommand('Page.printToPDF', cdpParams);
            return {
                data: result.data,
            };
        }
        catch (error) {
            // Effectively zero dimensions.
            if (error.message ===
                'invalid print parameters: content area is empty') {
                throw new protocol_js_1.UnsupportedOperationException(error.message);
            }
            throw error;
        }
    }
    /**
     * See
     * https://w3c.github.io/webdriver-bidi/#:~:text=If%20command%20parameters%20contains%20%22clip%22%3A
     */
    async #parseRect(clip) {
        switch (clip.type) {
            case 'box':
                return { x: clip.x, y: clip.y, width: clip.width, height: clip.height };
            case 'element': {
                // TODO: #1213: Use custom sandbox specifically for Chromium BiDi
                const sandbox = await this.getOrCreateSandbox(undefined);
                const result = await sandbox.callFunction(String((element) => {
                    return element instanceof Element;
                }), false, { type: 'undefined' }, [clip.element]);
                if (result.type === 'exception') {
                    throw new protocol_js_1.NoSuchElementException(`Element '${clip.element.sharedId}' was not found`);
                }
                (0, assert_js_1.assert)(result.result.type === 'boolean');
                if (!result.result.value) {
                    throw new protocol_js_1.NoSuchElementException(`Node '${clip.element.sharedId}' is not an Element`);
                }
                {
                    const result = await sandbox.callFunction(String((element) => {
                        const rect = element.getBoundingClientRect();
                        return {
                            x: rect.x,
                            y: rect.y,
                            height: rect.height,
                            width: rect.width,
                        };
                    }), false, { type: 'undefined' }, [clip.element]);
                    (0, assert_js_1.assert)(result.type === 'success');
                    const rect = deserializeDOMRect(result.result);
                    if (!rect) {
                        throw new protocol_js_1.UnableToCaptureScreenException(`Could not get bounding box for Element '${clip.element.sharedId}'`);
                    }
                    return rect;
                }
            }
        }
    }
    async close() {
        await this.#cdpTarget.cdpClient.sendCommand('Page.close');
    }
    async traverseHistory(delta) {
        if (delta === 0) {
            return;
        }
        const history = await this.#cdpTarget.cdpClient.sendCommand('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
            throw new protocol_js_1.NoSuchHistoryEntryException(`No history entry at delta ${delta}`);
        }
        await this.#cdpTarget.cdpClient.sendCommand('Page.navigateToHistoryEntry', {
            entryId: entry.id,
        });
    }
    async toggleModulesIfNeeded() {
        await this.#cdpTarget.toggleNetworkIfNeeded();
    }
    async locateNodes(params) {
        // TODO: create a dedicated sandbox instead of `#defaultRealm`.
        return await this.#locateNodesByLocator(await this.#defaultRealmDeferred, params.locator, params.startNodes ?? [], params.maxNodeCount, params.serializationOptions);
    }
    async #getLocatorDelegate(realm, locator, maxNodeCount, startNodes) {
        switch (locator.type) {
            case 'css':
                return {
                    functionDeclaration: String((cssSelector, maxNodeCount, ...startNodes) => {
                        const locateNodesUsingCss = (element) => {
                            if (!(element instanceof HTMLElement ||
                                element instanceof Document ||
                                element instanceof DocumentFragment)) {
                                throw new Error('startNodes in css selector should be HTMLElement, Document or DocumentFragment');
                            }
                            return [...element.querySelectorAll(cssSelector)];
                        };
                        startNodes = startNodes.length > 0 ? startNodes : [document.body];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingCss(startNode))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `cssSelector`
                        { type: 'string', value: locator.value },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'xpath':
                return {
                    functionDeclaration: String((xPathSelector, maxNodeCount, ...startNodes) => {
                        // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-xpath
                        const evaluator = new XPathEvaluator();
                        const expression = evaluator.createExpression(xPathSelector);
                        const locateNodesUsingXpath = (element) => {
                            const xPathResult = expression.evaluate(element, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE);
                            const returnedNodes = [];
                            for (let i = 0; i < xPathResult.snapshotLength; i++) {
                                returnedNodes.push(xPathResult.snapshotItem(i));
                            }
                            return returnedNodes;
                        };
                        startNodes = startNodes.length > 0 ? startNodes : [document.body];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingXpath(startNode))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `xPathSelector`
                        { type: 'string', value: locator.value },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'innerText':
                // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-inner-text
                if (locator.value === '') {
                    throw new protocol_js_1.InvalidSelectorException('innerText locator cannot be empty');
                }
                return {
                    functionDeclaration: String((innerTextSelector, fullMatch, ignoreCase, maxNodeCount, maxDepth, ...startNodes) => {
                        const searchText = ignoreCase
                            ? innerTextSelector.toUpperCase()
                            : innerTextSelector;
                        const locateNodesUsingInnerText = (node, currentMaxDepth) => {
                            const returnedNodes = [];
                            if (node instanceof DocumentFragment ||
                                node instanceof Document) {
                                const children = [...node.children];
                                children.forEach((child) => 
                                // `currentMaxDepth` is not decremented intentionally according to
                                // https://github.com/w3c/webdriver-bidi/pull/713.
                                returnedNodes.push(...locateNodesUsingInnerText(child, currentMaxDepth)));
                                return returnedNodes;
                            }
                            if (!(node instanceof HTMLElement)) {
                                return [];
                            }
                            const element = node;
                            const nodeInnerText = ignoreCase
                                ? element.innerText?.toUpperCase()
                                : element.innerText;
                            if (!nodeInnerText.includes(searchText)) {
                                return [];
                            }
                            const childNodes = [];
                            for (const child of element.children) {
                                if (child instanceof HTMLElement) {
                                    childNodes.push(child);
                                }
                            }
                            if (childNodes.length === 0) {
                                if (fullMatch && nodeInnerText === searchText) {
                                    returnedNodes.push(element);
                                }
                                else {
                                    if (!fullMatch) {
                                        // Note: `nodeInnerText.includes(searchText)` is already checked
                                        returnedNodes.push(element);
                                    }
                                }
                            }
                            else {
                                const childNodeMatches = 
                                // Don't search deeper if `maxDepth` is reached.
                                currentMaxDepth <= 0
                                    ? []
                                    : childNodes
                                        .map((child) => locateNodesUsingInnerText(child, currentMaxDepth - 1))
                                        .flat(1);
                                if (childNodeMatches.length === 0) {
                                    // Note: `nodeInnerText.includes(searchText)` is already checked
                                    if (!fullMatch || nodeInnerText === searchText) {
                                        returnedNodes.push(element);
                                    }
                                }
                                else {
                                    returnedNodes.push(...childNodeMatches);
                                }
                            }
                            // TODO: stop search early if `maxNodeCount` is reached.
                            return returnedNodes;
                        };
                        // TODO: stop search early if `maxNodeCount` is reached.
                        startNodes = startNodes.length > 0 ? startNodes : [document];
                        const returnedNodes = startNodes
                            .map((startNode) => 
                        // TODO: stop search early if `maxNodeCount` is reached.
                        locateNodesUsingInnerText(startNode, maxDepth))
                            .flat(1);
                        return maxNodeCount === 0
                            ? returnedNodes
                            : returnedNodes.slice(0, maxNodeCount);
                    }),
                    argumentsLocalValues: [
                        // `innerTextSelector`
                        { type: 'string', value: locator.value },
                        // `fullMatch` with default `true`.
                        { type: 'boolean', value: locator.matchType !== 'partial' },
                        // `ignoreCase` with default `false`.
                        { type: 'boolean', value: locator.ignoreCase === true },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `maxDepth` with default `1000` (same as default full serialization depth).
                        { type: 'number', value: locator.maxDepth ?? 1000 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            case 'accessibility': {
                // https://w3c.github.io/webdriver-bidi/#locate-nodes-using-accessibility-attributes
                if (!locator.value.name && !locator.value.role) {
                    throw new protocol_js_1.InvalidSelectorException('Either name or role has to be specified');
                }
                // The next two commands cause a11y caches for the target to be
                // preserved. We probably do not need to disable them if the
                // client is using a11y features, but we could by calling
                // Accessibility.disable.
                await Promise.all([
                    this.#cdpTarget.cdpClient.sendCommand('Accessibility.enable'),
                    this.#cdpTarget.cdpClient.sendCommand('Accessibility.getRootAXNode'),
                ]);
                const bindings = await realm.evaluate(
                /* expression=*/ '({getAccessibleName, getAccessibleRole})', 
                /* awaitPromise=*/ false, "root" /* Script.ResultOwnership.Root */, 
                /* serializationOptions= */ undefined, 
                /* userActivation=*/ false, 
                /* includeCommandLineApi=*/ true);
                if (bindings.type !== 'success') {
                    throw new Error('Could not get bindings');
                }
                if (bindings.result.type !== 'object') {
                    throw new Error('Could not get bindings');
                }
                return {
                    functionDeclaration: String((name, role, bindings, maxNodeCount, ...startNodes) => {
                        const returnedNodes = [];
                        let aborted = false;
                        function collect(contextNodes, selector) {
                            if (aborted) {
                                return;
                            }
                            for (const contextNode of contextNodes) {
                                let match = true;
                                if (selector.role) {
                                    const role = bindings.getAccessibleRole(contextNode);
                                    if (selector.role !== role) {
                                        match = false;
                                    }
                                }
                                if (selector.name) {
                                    const name = bindings.getAccessibleName(contextNode);
                                    if (selector.name !== name) {
                                        match = false;
                                    }
                                }
                                if (match) {
                                    if (maxNodeCount !== 0 &&
                                        returnedNodes.length === maxNodeCount) {
                                        aborted = true;
                                        break;
                                    }
                                    returnedNodes.push(contextNode);
                                }
                                const childNodes = [];
                                for (const child of contextNode.children) {
                                    if (child instanceof HTMLElement) {
                                        childNodes.push(child);
                                    }
                                }
                                collect(childNodes, selector);
                            }
                        }
                        startNodes = startNodes.length > 0 ? startNodes : [document.body];
                        collect(startNodes, {
                            role,
                            name,
                        });
                        return returnedNodes;
                    }),
                    argumentsLocalValues: [
                        // `name`
                        { type: 'string', value: locator.value.name || '' },
                        // `role`
                        { type: 'string', value: locator.value.role || '' },
                        // `bindings`.
                        { handle: bindings.result.handle },
                        // `maxNodeCount` with `0` means no limit.
                        { type: 'number', value: maxNodeCount ?? 0 },
                        // `startNodes`
                        ...startNodes,
                    ],
                };
            }
        }
    }
    async #locateNodesByLocator(realm, locator, startNodes, maxNodeCount, serializationOptions) {
        const locatorDelegate = await this.#getLocatorDelegate(realm, locator, maxNodeCount, startNodes);
        serializationOptions = {
            ...serializationOptions,
            // The returned object is an array of nodes, so no need in deeper JS serialization.
            maxObjectDepth: 1,
        };
        const locatorResult = await realm.callFunction(locatorDelegate.functionDeclaration, false, { type: 'undefined' }, locatorDelegate.argumentsLocalValues, "none" /* Script.ResultOwnership.None */, serializationOptions);
        if (locatorResult.type !== 'success') {
            this.#logger?.(BrowsingContextImpl.LOGGER_PREFIX, 'Failed locateNodesByLocator', locatorResult);
            // Heuristic to detect invalid selector for different types of selectors.
            if (
            // CSS selector.
            locatorResult.exceptionDetails.text?.endsWith('is not a valid selector.') ||
                // XPath selector.
                locatorResult.exceptionDetails.text?.endsWith('is not a valid XPath expression.')) {
                throw new protocol_js_1.InvalidSelectorException(`Not valid selector ${typeof locator.value === 'string' ? locator.value : JSON.stringify(locator.value)}`);
            }
            // Heuristic to detect if the `startNode` is not an `HTMLElement` in css selector.
            if (locatorResult.exceptionDetails.text ===
                'Error: startNodes in css selector should be HTMLElement, Document or DocumentFragment') {
                throw new protocol_js_1.InvalidArgumentException('startNodes in css selector should be HTMLElement, Document or DocumentFragment');
            }
            throw new protocol_js_1.UnknownErrorException(`Unexpected error in selector script: ${locatorResult.exceptionDetails.text}`);
        }
        if (locatorResult.result.type !== 'array') {
            throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result type: ${locatorResult.result.type}`);
        }
        // Check there are no non-node elements in the result.
        const nodes = locatorResult.result.value.map((value) => {
            if (value.type !== 'node') {
                throw new protocol_js_1.UnknownErrorException(`Unexpected selector script result element: ${value.type}`);
            }
            return value;
        });
        return { nodes };
    }
}
exports.BrowsingContextImpl = BrowsingContextImpl;
function serializeOrigin(origin) {
    // https://html.spec.whatwg.org/multipage/origin.html#ascii-serialisation-of-an-origin
    if (['://', ''].includes(origin)) {
        origin = 'null';
    }
    return origin;
}
function getImageFormatParameters(params) {
    const { quality, type } = params.format ?? {
        type: 'image/png',
    };
    switch (type) {
        case 'image/png': {
            return { format: 'png' };
        }
        case 'image/jpeg': {
            return {
                format: 'jpeg',
                ...(quality === undefined ? {} : { quality: Math.round(quality * 100) }),
            };
        }
        case 'image/webp': {
            return {
                format: 'webp',
                ...(quality === undefined ? {} : { quality: Math.round(quality * 100) }),
            };
        }
    }
    throw new protocol_js_1.InvalidArgumentException(`Image format '${type}' is not a supported format`);
}
function deserializeDOMRect(result) {
    if (result.type !== 'object' || result.value === undefined) {
        return;
    }
    const x = result.value.find(([key]) => {
        return key === 'x';
    })?.[1];
    const y = result.value.find(([key]) => {
        return key === 'y';
    })?.[1];
    const height = result.value.find(([key]) => {
        return key === 'height';
    })?.[1];
    const width = result.value.find(([key]) => {
        return key === 'width';
    })?.[1];
    if (x?.type !== 'number' ||
        y?.type !== 'number' ||
        height?.type !== 'number' ||
        width?.type !== 'number') {
        return;
    }
    return {
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value,
    };
}
/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */
function normalizeRect(box) {
    return {
        ...(box.width < 0
            ? {
                x: box.x + box.width,
                width: -box.width,
            }
            : {
                x: box.x,
                width: box.width,
            }),
        ...(box.height < 0
            ? {
                y: box.y + box.height,
                height: -box.height,
            }
            : {
                y: box.y,
                height: box.height,
            }),
    };
}
/** @see https://w3c.github.io/webdriver-bidi/#rectangle-intersection */
function getIntersectionRect(first, second) {
    first = normalizeRect(first);
    second = normalizeRect(second);
    const x = Math.max(first.x, second.x);
    const y = Math.max(first.y, second.y);
    return {
        x,
        y,
        width: Math.max(Math.min(first.x + first.width, second.x + second.width) - x, 0),
        height: Math.max(Math.min(first.y + first.height, second.y + second.height) - y, 0),
    };
}
function parseInteger(value) {
    value = value.trim();
    if (!/^[0-9]+$/.test(value)) {
        throw new protocol_js_1.InvalidArgumentException(`Invalid integer: ${value}`);
    }
    return parseInt(value);
}
//# sourceMappingURL=BrowsingContextImpl.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextProcessor.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class BrowsingContextProcessor {
    #browserCdpClient;
    #browsingContextStorage;
    #eventManager;
    constructor(browserCdpClient, browsingContextStorage, eventManager) {
        this.#browserCdpClient = browserCdpClient;
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        this.#eventManager.addSubscribeHook(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated, this.#onContextCreatedSubscribeHook.bind(this));
    }
    getTree(params) {
        const resultContexts = params.root === undefined
            ? this.#browsingContextStorage.getTopLevelContexts()
            : [this.#browsingContextStorage.getContext(params.root)];
        return {
            contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE)),
        };
    }
    async create(params) {
        let referenceContext;
        let userContext = 'default';
        if (params.referenceContext !== undefined) {
            referenceContext = this.#browsingContextStorage.getContext(params.referenceContext);
            if (!referenceContext.isTopLevelContext()) {
                throw new protocol_js_1.InvalidArgumentException(`referenceContext should be a top-level context`);
            }
            userContext = referenceContext.userContext;
        }
        if (params.userContext !== undefined) {
            userContext = params.userContext;
        }
        const existingContexts = this.#browsingContextStorage
            .getAllContexts()
            .filter((context) => context.userContext === userContext);
        let newWindow = false;
        switch (params.type) {
            case "tab" /* BrowsingContext.CreateType.Tab */:
                newWindow = false;
                break;
            case "window" /* BrowsingContext.CreateType.Window */:
                newWindow = true;
                break;
        }
        if (!existingContexts.length) {
            // If there are no contexts in the given user context, we need to set
            // newWindow to true as newWindow=false will be rejected.
            newWindow = true;
        }
        let result;
        try {
            result = await this.#browserCdpClient.sendCommand('Target.createTarget', {
                url: 'about:blank',
                newWindow,
                browserContextId: userContext === 'default' ? undefined : userContext,
                background: params.background === true,
            });
        }
        catch (err) {
            if (
            // See https://source.chromium.org/chromium/chromium/src/+/main:chrome/browser/devtools/protocol/target_handler.cc;l=90;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
            err.message.startsWith('Failed to find browser context with id') ||
                // See https://source.chromium.org/chromium/chromium/src/+/main:headless/lib/browser/protocol/target_handler.cc;l=49;drc=e80392ac11e48a691f4309964cab83a3a59e01c8
                err.message === 'browserContextId') {
                throw new protocol_js_1.NoSuchUserContextException(`The context ${userContext} was not found`);
            }
            throw err;
        }
        // Wait for the new tab to be loaded to avoid race conditions in the
        // `browsingContext` events, when the `browsingContext.domContentLoaded` and
        // `browsingContext.load` events from the initial `about:blank` navigation
        // are emitted after the next navigation is started.
        // Details: https://github.com/web-platform-tests/wpt/issues/35846
        const contextId = result.targetId;
        const context = this.#browsingContextStorage.getContext(contextId);
        await context.lifecycleLoaded();
        return { context: context.id };
    }
    navigate(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.navigate(params.url, params.wait ?? "none" /* BrowsingContext.ReadinessState.None */);
    }
    reload(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return context.reload(params.ignoreCache ?? false, params.wait ?? "none" /* BrowsingContext.ReadinessState.None */);
    }
    async activate(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException('Activation is only supported on the top-level context');
        }
        await context.activate();
        return {};
    }
    async captureScreenshot(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.captureScreenshot(params);
    }
    async print(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.print(params);
    }
    async setViewport(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException('Emulating viewport is only supported on the top-level context');
        }
        await context.setViewport(params.viewport, params.devicePixelRatio);
        return {};
    }
    async traverseHistory(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context) {
            throw new protocol_js_1.InvalidArgumentException(`No browsing context with id ${params.context}`);
        }
        await context.traverseHistory(params.delta);
        return {};
    }
    async handleUserPrompt(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        try {
            await context.handleUserPrompt(params.accept, params.userText);
        }
        catch (error) {
            // Heuristically determine the error
            // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/page_handler.cc;l=1085?q=%22No%20dialog%20is%20showing%22&ss=chromium
            if (error.message?.includes('No dialog is showing')) {
                throw new protocol_js_1.NoSuchAlertException('No dialog is showing');
            }
            throw error;
        }
        return {};
    }
    async close(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException(`Non top-level browsing context ${context.id} cannot be closed.`);
        }
        try {
            const detachedFromTargetPromise = new Promise((resolve) => {
                const onContextDestroyed = (event) => {
                    if (event.targetId === params.context) {
                        this.#browserCdpClient.off('Target.detachedFromTarget', onContextDestroyed);
                        resolve();
                    }
                };
                this.#browserCdpClient.on('Target.detachedFromTarget', onContextDestroyed);
            });
            if (params.promptUnload) {
                await context.close();
            }
            else {
                await this.#browserCdpClient.sendCommand('Target.closeTarget', {
                    targetId: params.context,
                });
            }
            // Sometimes CDP command finishes before `detachedFromTarget` event,
            // sometimes after. Wait for the CDP command to be finished, and then wait
            // for `detachedFromTarget` if it hasn't emitted.
            await detachedFromTargetPromise;
        }
        catch (error) {
            // Swallow error that arise from the page being destroyed
            // Example is navigating to faulty SSL certificate
            if (!(error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                error.message === 'Not attached to an active page')) {
                throw error;
            }
        }
        return {};
    }
    async locateNodes(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        return await context.locateNodes(params);
    }
    #onContextCreatedSubscribeHook(contextId) {
        const context = this.#browsingContextStorage.getContext(contextId);
        const contextsToReport = [
            context,
            ...this.#browsingContextStorage.getContext(contextId).allChildren,
        ];
        contextsToReport.forEach((context) => {
            this.#eventManager.registerEvent({
                type: 'event',
                method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
                params: context.serializeToBidiValue(),
            }, context.id);
        });
        return Promise.resolve();
    }
}
exports.BrowsingContextProcessor = BrowsingContextProcessor;
//# sourceMappingURL=BrowsingContextProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/context/BrowsingContextStorage.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BrowsingContextStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/** Container class for browsing contexts. */
class BrowsingContextStorage {
    /** Map from context ID to context implementation. */
    #contexts = new Map();
    /** Gets all top-level contexts, i.e. those with no parent. */
    getTopLevelContexts() {
        return this.getAllContexts().filter((context) => context.isTopLevelContext());
    }
    /** Gets all contexts. */
    getAllContexts() {
        return Array.from(this.#contexts.values());
    }
    /** Deletes the context with the given ID. */
    deleteContextById(id) {
        this.#contexts.delete(id);
    }
    /** Deletes the given context. */
    deleteContext(context) {
        this.#contexts.delete(context.id);
    }
    /** Tracks the given context. */
    addContext(context) {
        this.#contexts.set(context.id, context);
    }
    /** Returns true whether there is an existing context with the given ID. */
    hasContext(id) {
        return this.#contexts.has(id);
    }
    /** Gets the context with the given ID, if any. */
    findContext(id) {
        return this.#contexts.get(id);
    }
    /** Returns the top-level context ID of the given context, if any. */
    findTopLevelContextId(id) {
        if (id === null) {
            return null;
        }
        const maybeContext = this.findContext(id);
        const parentId = maybeContext?.parentId ?? null;
        if (parentId === null) {
            return id;
        }
        return this.findTopLevelContextId(parentId);
    }
    findContextBySession(sessionId) {
        for (const context of this.#contexts.values()) {
            if (context.cdpTarget.cdpSessionId === sessionId) {
                return context;
            }
        }
        return;
    }
    /** Gets the context with the given ID, if any, otherwise throws. */
    getContext(id) {
        const result = this.findContext(id);
        if (result === undefined) {
            throw new protocol_js_1.NoSuchFrameException(`Context ${id} not found`);
        }
        return result;
    }
    verifyTopLevelContextsList(contexts) {
        const foundContexts = new Set();
        if (!contexts) {
            return foundContexts;
        }
        for (const contextId of contexts) {
            const context = this.getContext(contextId);
            if (context.isTopLevelContext()) {
                foundContexts.add(context);
            }
            else {
                throw new protocol_js_1.InvalidArgumentException(`Non top-level context '${contextId}' given.`);
            }
        }
        return foundContexts;
    }
}
exports.BrowsingContextStorage = BrowsingContextStorage;
//# sourceMappingURL=BrowsingContextStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionDispatcher = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const GraphemeTools_1 = __webpack_require__(/*! ../../../utils/GraphemeTools */ "./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js");
const InputSource_js_1 = __webpack_require__(/*! ./InputSource.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js");
const keyUtils_js_1 = __webpack_require__(/*! ./keyUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js");
const USKeyboardLayout_js_1 = __webpack_require__(/*! ./USKeyboardLayout.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js");
/** https://w3c.github.io/webdriver/#dfn-center-point */
const CALCULATE_IN_VIEW_CENTER_PT_DECL = ((i) => {
    const t = i.getClientRects()[0], e = Math.max(0, Math.min(t.x, t.x + t.width)), n = Math.min(window.innerWidth, Math.max(t.x, t.x + t.width)), h = Math.max(0, Math.min(t.y, t.y + t.height)), m = Math.min(window.innerHeight, Math.max(t.y, t.y + t.height));
    return [e + ((n - e) >> 1), h + ((m - h) >> 1)];
}).toString();
const IS_MAC_DECL = (() => {
    return navigator.platform.toLowerCase().includes('mac');
}).toString();
async function getElementCenter(context, element) {
    const sandbox = await context.getOrCreateSandbox(undefined);
    const result = await sandbox.callFunction(CALCULATE_IN_VIEW_CENTER_PT_DECL, false, { type: 'undefined' }, [element]);
    if (result.type === 'exception') {
        throw new protocol_js_1.NoSuchElementException(`Origin element ${element.sharedId} was not found`);
    }
    (0, assert_js_1.assert)(result.result.type === 'array');
    (0, assert_js_1.assert)(result.result.value?.[0]?.type === 'number');
    (0, assert_js_1.assert)(result.result.value?.[1]?.type === 'number');
    const { result: { value: [{ value: x }, { value: y }], }, } = result;
    return { x: x, y: y };
}
class ActionDispatcher {
    static isMacOS = async (context) => {
        const result = await (await context.getOrCreateSandbox(undefined)).callFunction(IS_MAC_DECL, false);
        (0, assert_js_1.assert)(result.type !== 'exception');
        (0, assert_js_1.assert)(result.result.type === 'boolean');
        return result.result.value;
    };
    #tickStart = 0;
    #tickDuration = 0;
    #inputState;
    #context;
    #isMacOS;
    constructor(inputState, context, isMacOS) {
        this.#inputState = inputState;
        this.#context = context;
        this.#isMacOS = isMacOS;
    }
    async dispatchActions(optionsByTick) {
        await this.#inputState.queue.run(async () => {
            for (const options of optionsByTick) {
                await this.dispatchTickActions(options);
            }
        });
    }
    async dispatchTickActions(options) {
        this.#tickStart = performance.now();
        this.#tickDuration = 0;
        for (const { action } of options) {
            if ('duration' in action && action.duration !== undefined) {
                this.#tickDuration = Math.max(this.#tickDuration, action.duration);
            }
        }
        const promises = [
            new Promise((resolve) => setTimeout(resolve, this.#tickDuration)),
        ];
        for (const option of options) {
            // In theory we have to wait for each action to happen, but CDP is serial,
            // so as an optimization, we queue all CDP commands at once and await all
            // of them.
            promises.push(this.#dispatchAction(option));
        }
        await Promise.all(promises);
    }
    async #dispatchAction({ id, action }) {
        const source = this.#inputState.get(id);
        const keyState = this.#inputState.getGlobalKeyState();
        switch (action.type) {
            case 'keyDown': {
                // SAFETY: The source is validated before.
                await this.#dispatchKeyDownAction(source, action);
                this.#inputState.cancelList.push({
                    id,
                    action: {
                        ...action,
                        type: 'keyUp',
                    },
                });
                break;
            }
            case 'keyUp': {
                // SAFETY: The source is validated before.
                await this.#dispatchKeyUpAction(source, action);
                break;
            }
            case 'pause': {
                // TODO: Implement waiting on the input source.
                break;
            }
            case 'pointerDown': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerDownAction(source, keyState, action);
                this.#inputState.cancelList.push({
                    id,
                    action: {
                        ...action,
                        type: 'pointerUp',
                    },
                });
                break;
            }
            case 'pointerMove': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerMoveAction(source, keyState, action);
                break;
            }
            case 'pointerUp': {
                // SAFETY: The source is validated before.
                await this.#dispatchPointerUpAction(source, keyState, action);
                break;
            }
            case 'scroll': {
                // SAFETY: The source is validated before.
                await this.#dispatchScrollAction(source, keyState, action);
                break;
            }
        }
    }
    async #dispatchPointerDownAction(source, keyState, action) {
        const { button } = action;
        if (source.pressed.has(button)) {
            return;
        }
        source.pressed.add(button);
        const { x, y, subtype: pointerType } = source;
        const { width, height, pressure, twist, tangentialPressure } = action;
        const { tiltX, tiltY } = getTilt(action);
        // --- Platform-specific code begins here ---
        const { modifiers } = keyState;
        const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
        switch (pointerType) {
            case "mouse" /* Input.PointerType.Mouse */:
            case "pen" /* Input.PointerType.Pen */:
                // TODO: Implement width and height when available.
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mousePressed',
                    x,
                    y,
                    modifiers,
                    button: getCdpButton(button),
                    buttons: source.buttons,
                    clickCount: source.setClickCount(button, new InputSource_js_1.PointerSource.ClickContext(x, y, performance.now())),
                    pointerType,
                    tangentialPressure,
                    tiltX,
                    tiltY,
                    twist,
                    force: pressure,
                });
                break;
            case "touch" /* Input.PointerType.Touch */:
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                    type: 'touchStart',
                    touchPoints: [
                        {
                            x,
                            y,
                            radiusX,
                            radiusY,
                            tangentialPressure,
                            tiltX,
                            tiltY,
                            twist,
                            force: pressure,
                            id: source.pointerId,
                        },
                    ],
                    modifiers,
                });
                break;
        }
        source.radiusX = radiusX;
        source.radiusY = radiusY;
        source.force = pressure;
        // --- Platform-specific code ends here ---
    }
    #dispatchPointerUpAction(source, keyState, action) {
        const { button } = action;
        if (!source.pressed.has(button)) {
            return;
        }
        source.pressed.delete(button);
        const { x, y, force, radiusX, radiusY, subtype: pointerType } = source;
        // --- Platform-specific code begins here ---
        const { modifiers } = keyState;
        switch (pointerType) {
            case "mouse" /* Input.PointerType.Mouse */:
            case "pen" /* Input.PointerType.Pen */:
                // TODO: Implement width and height when available.
                return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mouseReleased',
                    x,
                    y,
                    modifiers,
                    button: getCdpButton(button),
                    buttons: source.buttons,
                    clickCount: source.getClickCount(button),
                    pointerType,
                });
            case "touch" /* Input.PointerType.Touch */:
                return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                    type: 'touchEnd',
                    touchPoints: [
                        {
                            x,
                            y,
                            id: source.pointerId,
                            force,
                            radiusX,
                            radiusY,
                        },
                    ],
                    modifiers,
                });
        }
        // --- Platform-specific code ends here ---
    }
    async #dispatchPointerMoveAction(source, keyState, action) {
        const { x: startX, y: startY, subtype: pointerType } = source;
        const { width, height, pressure, twist, tangentialPressure, x: offsetX, y: offsetY, origin = 'viewport', duration = this.#tickDuration, } = action;
        const { tiltX, tiltY } = getTilt(action);
        const { radiusX, radiusY } = getRadii(width ?? 1, height ?? 1);
        const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY);
        if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
        }
        let last;
        do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let x;
            let y;
            if (last) {
                x = targetX;
                y = targetY;
            }
            else {
                x = Math.round(ratio * (targetX - startX) + startX);
                y = Math.round(ratio * (targetY - startY) + startY);
            }
            if (source.x !== x || source.y !== y) {
                // --- Platform-specific code begins here ---
                const { modifiers } = keyState;
                switch (pointerType) {
                    case "mouse" /* Input.PointerType.Mouse */:
                        // TODO: Implement width and height when available.
                        await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                            type: 'mouseMoved',
                            x,
                            y,
                            modifiers,
                            clickCount: 0,
                            button: getCdpButton(source.pressed.values().next().value ?? 5),
                            buttons: source.buttons,
                            pointerType,
                            tangentialPressure,
                            tiltX,
                            tiltY,
                            twist,
                            force: pressure,
                        });
                        break;
                    case "pen" /* Input.PointerType.Pen */:
                        if (source.pressed.size !== 0) {
                            // TODO: Implement width and height when available.
                            await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                                type: 'mouseMoved',
                                x,
                                y,
                                modifiers,
                                clickCount: 0,
                                button: getCdpButton(source.pressed.values().next().value ?? 5),
                                buttons: source.buttons,
                                pointerType,
                                tangentialPressure,
                                tiltX,
                                tiltY,
                                twist,
                                force: pressure,
                            });
                        }
                        break;
                    case "touch" /* Input.PointerType.Touch */:
                        if (source.pressed.size !== 0) {
                            await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchTouchEvent', {
                                type: 'touchMove',
                                touchPoints: [
                                    {
                                        x,
                                        y,
                                        radiusX,
                                        radiusY,
                                        tangentialPressure,
                                        tiltX,
                                        tiltY,
                                        twist,
                                        force: pressure,
                                        id: source.pointerId,
                                    },
                                ],
                                modifiers,
                            });
                        }
                        break;
                }
                // --- Platform-specific code ends here ---
                source.x = x;
                source.y = y;
                source.radiusX = radiusX;
                source.radiusY = radiusY;
                source.force = pressure;
            }
        } while (!last);
    }
    async #getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY) {
        let targetX;
        let targetY;
        switch (origin) {
            case 'viewport':
                targetX = offsetX;
                targetY = offsetY;
                break;
            case 'pointer':
                targetX = startX + offsetX;
                targetY = startY + offsetY;
                break;
            default: {
                const { x: posX, y: posY } = await getElementCenter(this.#context, origin.element);
                // SAFETY: These can never be special numbers.
                targetX = posX + offsetX;
                targetY = posY + offsetY;
                break;
            }
        }
        return { targetX, targetY };
    }
    async #dispatchScrollAction(_source, keyState, action) {
        const { deltaX: targetDeltaX, deltaY: targetDeltaY, x: offsetX, y: offsetY, origin = 'viewport', duration = this.#tickDuration, } = action;
        if (origin === 'pointer') {
            throw new protocol_js_1.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
        }
        const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, 0, 0);
        if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
        }
        let currentDeltaX = 0;
        let currentDeltaY = 0;
        let last;
        do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let deltaX;
            let deltaY;
            if (last) {
                deltaX = targetDeltaX - currentDeltaX;
                deltaY = targetDeltaY - currentDeltaY;
            }
            else {
                deltaX = Math.round(ratio * targetDeltaX - currentDeltaX);
                deltaY = Math.round(ratio * targetDeltaY - currentDeltaY);
            }
            if (deltaX !== 0 || deltaY !== 0) {
                // --- Platform-specific code begins here ---
                const { modifiers } = keyState;
                await this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchMouseEvent', {
                    type: 'mouseWheel',
                    deltaX,
                    deltaY,
                    x: targetX,
                    y: targetY,
                    modifiers,
                });
                // --- Platform-specific code ends here ---
                currentDeltaX += deltaX;
                currentDeltaY += deltaY;
            }
        } while (!last);
    }
    async #dispatchKeyDownAction(source, action) {
        const rawKey = action.value;
        if (!(0, GraphemeTools_1.isSingleGrapheme)(rawKey)) {
            // https://w3c.github.io/webdriver/#dfn-process-a-key-action
            // WebDriver spec allows a grapheme to be used.
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
        }
        const isGrapheme = (0, GraphemeTools_1.isSingleComplexGrapheme)(rawKey);
        const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
        const repeat = source.pressed.has(key);
        const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
        const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
        switch (key) {
            case 'Alt':
                source.alt = true;
                break;
            case 'Shift':
                source.shift = true;
                break;
            case 'Control':
                source.ctrl = true;
                break;
            case 'Meta':
                source.meta = true;
                break;
        }
        source.pressed.add(key);
        const { modifiers } = source;
        // --- Platform-specific code begins here ---
        // The spread is a little hack so JS gives us an array of unicode characters
        // to measure.
        const unmodifiedText = getKeyEventUnmodifiedText(key, source, isGrapheme);
        const text = getKeyEventText(code ?? '', source) ?? unmodifiedText;
        let command;
        // The following commands need to be declared because Chromium doesn't
        // handle them. See
        // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:third_party/blink/renderer/core/editing/editing_behavior.cc;l=169;drc=b8143cf1dfd24842890fcd831c4f5d909bef4fc4;bpv=0;bpt=1.
        if (this.#isMacOS && source.meta) {
            switch (code) {
                case 'KeyA':
                    command = 'SelectAll';
                    break;
                case 'KeyC':
                    command = 'Copy';
                    break;
                case 'KeyV':
                    command = source.shift ? 'PasteAndMatchStyle' : 'Paste';
                    break;
                case 'KeyX':
                    command = 'Cut';
                    break;
                case 'KeyZ':
                    command = source.shift ? 'Redo' : 'Undo';
                    break;
                default:
                // Intentionally empty.
            }
        }
        const promises = [
            this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchKeyEvent', {
                type: text ? 'keyDown' : 'rawKeyDown',
                windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
                key,
                code,
                text,
                unmodifiedText,
                autoRepeat: repeat,
                isSystemKey: source.alt || undefined,
                location: location < 3 ? location : undefined,
                isKeypad: location === 3,
                modifiers,
                commands: command ? [command] : undefined,
            }),
        ];
        // Drag cancelling happens on escape.
        if (key === 'Escape') {
            if (!source.alt &&
                ((this.#isMacOS && !source.ctrl && !source.meta) || !this.#isMacOS)) {
                promises.push(this.#context.cdpTarget.cdpClient.sendCommand('Input.cancelDragging'));
            }
        }
        await Promise.all(promises);
        // --- Platform-specific code ends here ---
    }
    #dispatchKeyUpAction(source, action) {
        const rawKey = action.value;
        if (!(0, GraphemeTools_1.isSingleGrapheme)(rawKey)) {
            // https://w3c.github.io/webdriver/#dfn-process-a-key-action
            // WebDriver spec allows a grapheme to be used.
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${rawKey}`);
        }
        const isGrapheme = (0, GraphemeTools_1.isSingleComplexGrapheme)(rawKey);
        const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
        if (!source.pressed.has(key)) {
            return;
        }
        const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
        const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
        switch (key) {
            case 'Alt':
                source.alt = false;
                break;
            case 'Shift':
                source.shift = false;
                break;
            case 'Control':
                source.ctrl = false;
                break;
            case 'Meta':
                source.meta = false;
                break;
        }
        source.pressed.delete(key);
        const { modifiers } = source;
        // --- Platform-specific code begins here ---
        // The spread is a little hack so JS gives us an array of unicode characters
        // to measure.
        const unmodifiedText = getKeyEventUnmodifiedText(key, source, isGrapheme);
        const text = getKeyEventText(code ?? '', source) ?? unmodifiedText;
        return this.#context.cdpTarget.cdpClient.sendCommand('Input.dispatchKeyEvent', {
            type: 'keyUp',
            windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
            key,
            code,
            text,
            unmodifiedText,
            location: location < 3 ? location : undefined,
            isSystemKey: source.alt || undefined,
            isKeypad: location === 3,
            modifiers,
        });
        // --- Platform-specific code ends here ---
    }
}
exports.ActionDispatcher = ActionDispatcher;
/**
 * Translates a non-grapheme key to either an `undefined` for a special keys, or a single
 * character modified by shift if needed.
 */
const getKeyEventUnmodifiedText = (key, source, isGrapheme) => {
    if (isGrapheme) {
        // Graphemes should be presented as text in the CDP command.
        return key;
    }
    if (key === 'Enter') {
        return '\r';
    }
    // If key is not a single character, it is a normalized key value, and should be
    // presented as key, not text in the CDP command.
    return [...key].length === 1
        ? source.shift
            ? key.toLocaleUpperCase('en-US')
            : key
        : undefined;
};
const getKeyEventText = (code, source) => {
    if (source.ctrl) {
        switch (code) {
            case 'Digit2':
                if (source.shift) {
                    return '\x00';
                }
                break;
            case 'KeyA':
                return '\x01';
            case 'KeyB':
                return '\x02';
            case 'KeyC':
                return '\x03';
            case 'KeyD':
                return '\x04';
            case 'KeyE':
                return '\x05';
            case 'KeyF':
                return '\x06';
            case 'KeyG':
                return '\x07';
            case 'KeyH':
                return '\x08';
            case 'KeyI':
                return '\x09';
            case 'KeyJ':
                return '\x0A';
            case 'KeyK':
                return '\x0B';
            case 'KeyL':
                return '\x0C';
            case 'KeyM':
                return '\x0D';
            case 'KeyN':
                return '\x0E';
            case 'KeyO':
                return '\x0F';
            case 'KeyP':
                return '\x10';
            case 'KeyQ':
                return '\x11';
            case 'KeyR':
                return '\x12';
            case 'KeyS':
                return '\x13';
            case 'KeyT':
                return '\x14';
            case 'KeyU':
                return '\x15';
            case 'KeyV':
                return '\x16';
            case 'KeyW':
                return '\x17';
            case 'KeyX':
                return '\x18';
            case 'KeyY':
                return '\x19';
            case 'KeyZ':
                return '\x1A';
            case 'BracketLeft':
                return '\x1B';
            case 'Backslash':
                return '\x1C';
            case 'BracketRight':
                return '\x1D';
            case 'Digit6':
                if (source.shift) {
                    return '\x1E';
                }
                break;
            case 'Minus':
                return '\x1F';
        }
        return '';
    }
    if (source.alt) {
        return '';
    }
    return;
};
function getCdpButton(button) {
    switch (button) {
        case 0:
            return 'left';
        case 1:
            return 'middle';
        case 2:
            return 'right';
        case 3:
            return 'back';
        case 4:
            return 'forward';
        default:
            return 'none';
    }
}
function getTilt(action) {
    // https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle
    const altitudeAngle = action.altitudeAngle ?? 0;
    const azimuthAngle = action.azimuthAngle ?? 0;
    let tiltXRadians = 0;
    let tiltYRadians = 0;
    if (altitudeAngle === 0) {
        // the pen is in the X-Y plane
        if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {
            // pen is on positive X axis
            tiltXRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI / 2) {
            // pen is on positive Y axis
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle === Math.PI) {
            // pen is on negative X axis
            tiltXRadians = -Math.PI / 2;
        }
        if (azimuthAngle === (3 * Math.PI) / 2) {
            // pen is on negative Y axis
            tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = Math.PI / 2;
        }
        if (azimuthAngle > Math.PI && azimuthAngle < (3 * Math.PI) / 2) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
        }
        if (azimuthAngle > (3 * Math.PI) / 2 && azimuthAngle < 2 * Math.PI) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
        }
    }
    if (altitudeAngle !== 0) {
        const tanAlt = Math.tan(altitudeAngle);
        tiltXRadians = Math.atan(Math.cos(azimuthAngle) / tanAlt);
        tiltYRadians = Math.atan(Math.sin(azimuthAngle) / tanAlt);
    }
    const factor = 180 / Math.PI;
    return {
        tiltX: Math.round(tiltXRadians * factor),
        tiltY: Math.round(tiltYRadians * factor),
    };
}
function getRadii(width, height) {
    return {
        radiusX: width ? width / 2 : 0.5,
        radiusY: height ? height / 2 : 0.5,
    };
}
//# sourceMappingURL=ActionDispatcher.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputProcessor.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputProcessor = void 0;
/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const ActionDispatcher_js_1 = __webpack_require__(/*! ../input/ActionDispatcher.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/ActionDispatcher.js");
const InputStateManager_js_1 = __webpack_require__(/*! ../input/InputStateManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js");
class InputProcessor {
    #browsingContextStorage;
    #realmStorage;
    #inputStateManager = new InputStateManager_js_1.InputStateManager();
    constructor(browsingContextStorage, realmStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
    }
    async performActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const inputState = this.#inputStateManager.get(context.top);
        const actionsByTick = this.#getActionsByTick(params, inputState);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchActions(actionsByTick);
        return {};
    }
    async releaseActions(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const topContext = context.top;
        const inputState = this.#inputStateManager.get(topContext);
        const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
        await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
        this.#inputStateManager.delete(topContext);
        return {};
    }
    async setFiles(params) {
        const context = this.#browsingContextStorage.getContext(params.context);
        const realm = await context.getOrCreateSandbox(undefined);
        let result;
        try {
            result = await realm.callFunction(String(function getFiles(fileListLength) {
                if (!(this instanceof HTMLInputElement)) {
                    if (this instanceof Element) {
                        return 1 /* ErrorCode.Element */;
                    }
                    return 0 /* ErrorCode.Node */;
                }
                if (this.type !== 'file') {
                    return 2 /* ErrorCode.Type */;
                }
                if (this.disabled) {
                    return 3 /* ErrorCode.Disabled */;
                }
                if (fileListLength > 1 && !this.multiple) {
                    return 4 /* ErrorCode.Multiple */;
                }
                return;
            }), false, params.element, [{ type: 'number', value: params.files.length }]);
        }
        catch {
            throw new protocol_js_1.NoSuchNodeException(`Could not find element ${params.element.sharedId}`);
        }
        (0, assert_js_1.assert)(result.type === 'success');
        if (result.result.type === 'number') {
            switch (result.result.value) {
                case 0 /* ErrorCode.Node */: {
                    throw new protocol_js_1.NoSuchElementException(`Could not find element ${params.element.sharedId}`);
                }
                case 1 /* ErrorCode.Element */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Element ${params.element.sharedId} is not a input`);
                }
                case 2 /* ErrorCode.Type */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is not a file type`);
                }
                case 3 /* ErrorCode.Disabled */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Input element ${params.element.sharedId} is disabled`);
                }
                case 4 /* ErrorCode.Multiple */: {
                    throw new protocol_js_1.UnableToSetFileInputException(`Cannot set multiple files on a non-multiple input element`);
                }
            }
        }
        /**
         * The zero-length array is a special case, it seems that
         * DOM.setFileInputFiles does not actually update the files in that case, so
         * the solution is to eval the element value to a new FileList directly.
         */
        if (params.files.length === 0) {
            // XXX: These events should converted to trusted events. Perhaps do this
            // in `DOM.setFileInputFiles`?
            await realm.callFunction(String(function dispatchEvent() {
                if (this.files?.length === 0) {
                    this.dispatchEvent(new Event('cancel', {
                        bubbles: true,
                    }));
                    return;
                }
                this.files = new DataTransfer().files;
                // Dispatch events for this case because it should behave akin to a user action.
                this.dispatchEvent(new Event('input', { bubbles: true, composed: true }));
                this.dispatchEvent(new Event('change', { bubbles: true }));
            }), false, params.element);
            return {};
        }
        // Our goal here is to iterate over the input element files and get their
        // file paths.
        const paths = [];
        for (let i = 0; i < params.files.length; ++i) {
            const result = await realm.callFunction(String(function getFiles(index) {
                return this.files?.item(index);
            }), false, params.element, [{ type: 'number', value: 0 }], "root" /* Script.ResultOwnership.Root */);
            (0, assert_js_1.assert)(result.type === 'success');
            if (result.result.type !== 'object') {
                break;
            }
            const { handle } = result.result;
            (0, assert_js_1.assert)(handle !== undefined);
            const { path } = await realm.cdpClient.sendCommand('DOM.getFileInfo', {
                objectId: handle,
            });
            paths.push(path);
            // Cleanup the handle.
            void realm.disown(handle).catch(undefined);
        }
        paths.sort();
        // We create a new array so we preserve the order of the original files.
        const sortedFiles = [...params.files].sort();
        if (paths.length !== params.files.length ||
            sortedFiles.some((path, index) => {
                return paths[index] !== path;
            })) {
            const { objectId } = await realm.deserializeForCdp(params.element);
            // This cannot throw since this was just used in `callFunction` above.
            (0, assert_js_1.assert)(objectId !== undefined);
            await realm.cdpClient.sendCommand('DOM.setFileInputFiles', {
                files: params.files,
                objectId,
            });
        }
        else {
            // XXX: We should dispatch a trusted event.
            await realm.callFunction(String(function dispatchEvent() {
                this.dispatchEvent(new Event('cancel', {
                    bubbles: true,
                }));
            }), false, params.element);
        }
        return {};
    }
    #getActionsByTick(params, inputState) {
        const actionsByTick = [];
        for (const action of params.actions) {
            switch (action.type) {
                case "pointer" /* SourceType.Pointer */: {
                    action.parameters ??= { pointerType: "mouse" /* Input.PointerType.Mouse */ };
                    action.parameters.pointerType ??= "mouse" /* Input.PointerType.Mouse */;
                    const source = inputState.getOrCreate(action.id, "pointer" /* SourceType.Pointer */, action.parameters.pointerType);
                    if (source.subtype !== action.parameters.pointerType) {
                        throw new protocol_js_1.InvalidArgumentException(`Expected input source ${action.id} to be ${source.subtype}; got ${action.parameters.pointerType}.`);
                    }
                    break;
                }
                default:
                    inputState.getOrCreate(action.id, action.type);
            }
            const actions = action.actions.map((item) => ({
                id: action.id,
                action: item,
            }));
            for (let i = 0; i < actions.length; i++) {
                if (actionsByTick.length === i) {
                    actionsByTick.push([]);
                }
                actionsByTick[i].push(actions[i]);
            }
        }
        return actionsByTick;
    }
}
exports.InputProcessor = InputProcessor;
//# sourceMappingURL=InputProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js":
/*!************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WheelSource = exports.PointerSource = exports.KeySource = exports.NoneSource = void 0;
class NoneSource {
    type = "none" /* SourceType.None */;
}
exports.NoneSource = NoneSource;
class KeySource {
    type = "key" /* SourceType.Key */;
    pressed = new Set();
    // This is a bitfield that matches the modifiers parameter of
    // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent
    #modifiers = 0;
    get modifiers() {
        return this.#modifiers;
    }
    get alt() {
        return (this.#modifiers & 1) === 1;
    }
    set alt(value) {
        this.#setModifier(value, 1);
    }
    get ctrl() {
        return (this.#modifiers & 2) === 2;
    }
    set ctrl(value) {
        this.#setModifier(value, 2);
    }
    get meta() {
        return (this.#modifiers & 4) === 4;
    }
    set meta(value) {
        this.#setModifier(value, 4);
    }
    get shift() {
        return (this.#modifiers & 8) === 8;
    }
    set shift(value) {
        this.#setModifier(value, 8);
    }
    #setModifier(value, bit) {
        if (value) {
            this.#modifiers |= bit;
        }
        else {
            this.#modifiers &= ~bit;
        }
    }
}
exports.KeySource = KeySource;
class PointerSource {
    type = "pointer" /* SourceType.Pointer */;
    subtype;
    pointerId;
    pressed = new Set();
    x = 0;
    y = 0;
    radiusX;
    radiusY;
    force;
    constructor(id, subtype) {
        this.pointerId = id;
        this.subtype = subtype;
    }
    // This is a bitfield that matches the buttons parameter of
    // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent
    get buttons() {
        let buttons = 0;
        for (const button of this.pressed) {
            switch (button) {
                case 0:
                    buttons |= 1;
                    break;
                case 1:
                    buttons |= 4;
                    break;
                case 2:
                    buttons |= 2;
                    break;
                case 3:
                    buttons |= 8;
                    break;
                case 4:
                    buttons |= 16;
                    break;
            }
        }
        return buttons;
    }
    // --- Platform-specific code starts here ---
    // Input.dispatchMouseEvent doesn't know the concept of double click, so we
    // need to create the logic, similar to how it's done for OSes:
    // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:ui/events/event.cc;l=479
    static ClickContext = class ClickContext {
        static #DOUBLE_CLICK_TIME_MS = 500;
        static #MAX_DOUBLE_CLICK_RADIUS = 2;
        count = 0;
        #x;
        #y;
        #time;
        constructor(x, y, time) {
            this.#x = x;
            this.#y = y;
            this.#time = time;
        }
        compare(context) {
            return (
            // The click needs to be within a certain amount of ms.
            context.#time - this.#time > ClickContext.#DOUBLE_CLICK_TIME_MS ||
                // The click needs to be within a certain square radius.
                Math.abs(context.#x - this.#x) >
                    ClickContext.#MAX_DOUBLE_CLICK_RADIUS ||
                Math.abs(context.#y - this.#y) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS);
        }
    };
    #clickContexts = new Map();
    setClickCount(button, context) {
        let storedContext = this.#clickContexts.get(button);
        if (!storedContext || storedContext.compare(context)) {
            storedContext = context;
        }
        ++storedContext.count;
        this.#clickContexts.set(button, storedContext);
        return storedContext.count;
    }
    getClickCount(button) {
        return this.#clickContexts.get(button)?.count ?? 0;
    }
}
exports.PointerSource = PointerSource;
class WheelSource {
    type = "wheel" /* SourceType.Wheel */;
}
exports.WheelSource = WheelSource;
//# sourceMappingURL=InputSource.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputState = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Mutex_js_1 = __webpack_require__(/*! ../../../utils/Mutex.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js");
const InputSource_js_1 = __webpack_require__(/*! ./InputSource.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputSource.js");
class InputState {
    cancelList = [];
    #sources = new Map();
    #mutex = new Mutex_js_1.Mutex();
    getOrCreate(id, type, subtype) {
        let source = this.#sources.get(id);
        if (!source) {
            switch (type) {
                case "none" /* SourceType.None */:
                    source = new InputSource_js_1.NoneSource();
                    break;
                case "key" /* SourceType.Key */:
                    source = new InputSource_js_1.KeySource();
                    break;
                case "pointer" /* SourceType.Pointer */: {
                    let pointerId = subtype === "mouse" /* Input.PointerType.Mouse */ ? 0 : 2;
                    const pointerIds = new Set();
                    for (const [, source] of this.#sources) {
                        if (source.type === "pointer" /* SourceType.Pointer */) {
                            pointerIds.add(source.pointerId);
                        }
                    }
                    while (pointerIds.has(pointerId)) {
                        ++pointerId;
                    }
                    source = new InputSource_js_1.PointerSource(pointerId, subtype);
                    break;
                }
                case "wheel" /* SourceType.Wheel */:
                    source = new InputSource_js_1.WheelSource();
                    break;
                default:
                    throw new protocol_js_1.InvalidArgumentException(`Expected "${"none" /* SourceType.None */}", "${"key" /* SourceType.Key */}", "${"pointer" /* SourceType.Pointer */}", or "${"wheel" /* SourceType.Wheel */}". Found unknown source type ${type}.`);
            }
            this.#sources.set(id, source);
            return source;
        }
        if (source.type !== type) {
            throw new protocol_js_1.InvalidArgumentException(`Input source type of ${id} is ${source.type}, but received ${type}.`);
        }
        return source;
    }
    get(id) {
        const source = this.#sources.get(id);
        if (!source) {
            throw new protocol_js_1.UnknownErrorException(`Internal error.`);
        }
        return source;
    }
    getGlobalKeyState() {
        const state = new InputSource_js_1.KeySource();
        for (const [, source] of this.#sources) {
            if (source.type !== "key" /* SourceType.Key */) {
                continue;
            }
            for (const pressed of source.pressed) {
                state.pressed.add(pressed);
            }
            state.alt ||= source.alt;
            state.ctrl ||= source.ctrl;
            state.meta ||= source.meta;
            state.shift ||= source.shift;
        }
        return state;
    }
    get queue() {
        return this.#mutex;
    }
}
exports.InputState = InputState;
//# sourceMappingURL=InputState.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputStateManager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputStateManager = void 0;
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const InputState_js_1 = __webpack_require__(/*! ./InputState.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/InputState.js");
// We use a weak map here as specified here:
// https://www.w3.org/TR/webdriver/#dfn-browsing-context-input-state-map
class InputStateManager extends WeakMap {
    get(context) {
        (0, assert_js_1.assert)(context.isTopLevelContext());
        if (!this.has(context)) {
            this.set(context, new InputState_js_1.InputState());
        }
        return super.get(context);
    }
}
exports.InputStateManager = InputStateManager;
//# sourceMappingURL=InputStateManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/USKeyboardLayout.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeyToKeyCode = void 0;
// TODO: Remove this once https://crrev.com/c/4548290 is stably in Chromium.
// `Input.dispatchKeyboardEvent` will automatically handle these conversions.
exports.KeyToKeyCode = {
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    Abort: 3,
    Help: 6,
    Backspace: 8,
    Tab: 9,
    Numpad5: 12,
    NumpadEnter: 13,
    Enter: 13,
    '\\r': 13,
    '\\n': 13,
    ShiftLeft: 16,
    ShiftRight: 16,
    ControlLeft: 17,
    ControlRight: 17,
    AltLeft: 18,
    AltRight: 18,
    Pause: 19,
    CapsLock: 20,
    Escape: 27,
    Convert: 28,
    NonConvert: 29,
    Space: 32,
    Numpad9: 33,
    PageUp: 33,
    Numpad3: 34,
    PageDown: 34,
    End: 35,
    Numpad1: 35,
    Home: 36,
    Numpad7: 36,
    ArrowLeft: 37,
    Numpad4: 37,
    Numpad8: 38,
    ArrowUp: 38,
    ArrowRight: 39,
    Numpad6: 39,
    Numpad2: 40,
    ArrowDown: 40,
    Select: 41,
    Open: 43,
    PrintScreen: 44,
    Insert: 45,
    Numpad0: 45,
    Delete: 46,
    NumpadDecimal: 46,
    Digit0: 48,
    Digit1: 49,
    Digit2: 50,
    Digit3: 51,
    Digit4: 52,
    Digit5: 53,
    Digit6: 54,
    Digit7: 55,
    Digit8: 56,
    Digit9: 57,
    KeyA: 65,
    KeyB: 66,
    KeyC: 67,
    KeyD: 68,
    KeyE: 69,
    KeyF: 70,
    KeyG: 71,
    KeyH: 72,
    KeyI: 73,
    KeyJ: 74,
    KeyK: 75,
    KeyL: 76,
    KeyM: 77,
    KeyN: 78,
    KeyO: 79,
    KeyP: 80,
    KeyQ: 81,
    KeyR: 82,
    KeyS: 83,
    KeyT: 84,
    KeyU: 85,
    KeyV: 86,
    KeyW: 87,
    KeyX: 88,
    KeyY: 89,
    KeyZ: 90,
    MetaLeft: 91,
    MetaRight: 92,
    ContextMenu: 93,
    NumpadMultiply: 106,
    NumpadAdd: 107,
    NumpadSubtract: 109,
    NumpadDivide: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    F13: 124,
    F14: 125,
    F15: 126,
    F16: 127,
    F17: 128,
    F18: 129,
    F19: 130,
    F20: 131,
    F21: 132,
    F22: 133,
    F23: 134,
    F24: 135,
    NumLock: 144,
    ScrollLock: 145,
    AudioVolumeMute: 173,
    AudioVolumeDown: 174,
    AudioVolumeUp: 175,
    MediaTrackNext: 176,
    MediaTrackPrevious: 177,
    MediaStop: 178,
    MediaPlayPause: 179,
    Semicolon: 186,
    Equal: 187,
    NumpadEqual: 187,
    Comma: 188,
    Minus: 189,
    Period: 190,
    Slash: 191,
    Backquote: 192,
    BracketLeft: 219,
    Backslash: 220,
    BracketRight: 221,
    Quote: 222,
    AltGraph: 225,
    Props: 247,
    Cancel: 3,
    Clear: 12,
    Shift: 16,
    Control: 17,
    Alt: 18,
    Accept: 30,
    ModeChange: 31,
    ' ': 32,
    Print: 42,
    Execute: 43,
    '\\u0000': 46,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    Meta: 91,
    '*': 106,
    '+': 107,
    '-': 109,
    '/': 111,
    ';': 186,
    '=': 187,
    ',': 188,
    '.': 190,
    '`': 192,
    '[': 219,
    '\\\\': 220,
    ']': 221,
    "'": 222,
    Attn: 246,
    CrSel: 247,
    ExSel: 248,
    EraseEof: 249,
    Play: 250,
    ZoomOut: 251,
    ')': 48,
    '!': 49,
    '@': 50,
    '#': 51,
    $: 52,
    '%': 53,
    '^': 54,
    '&': 55,
    '(': 57,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    ':': 186,
    '<': 188,
    _: 189,
    '>': 190,
    '?': 191,
    '~': 192,
    '{': 219,
    '|': 220,
    '}': 221,
    '"': 222,
    Camera: 44,
    EndCall: 95,
    VolumeDown: 182,
    VolumeUp: 183,
};
//# sourceMappingURL=USKeyboardLayout.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/input/keyUtils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNormalizedKey = getNormalizedKey;
exports.getKeyCode = getKeyCode;
exports.getKeyLocation = getKeyLocation;
/**
 * Returns the normalized key value for a given key according to the table:
 * https://w3c.github.io/webdriver/#dfn-normalized-key-value
 */
function getNormalizedKey(value) {
    switch (value) {
        case '\uE000':
            return 'Unidentified';
        case '\uE001':
            return 'Cancel';
        case '\uE002':
            return 'Help';
        case '\uE003':
            return 'Backspace';
        case '\uE004':
            return 'Tab';
        case '\uE005':
            return 'Clear';
        // Specification declares the '\uE006' to be `Return`, but it is not supported by
        // Chrome, so fall back to `Enter`, which aligns with WPT.
        case '\uE006':
        case '\uE007':
            return 'Enter';
        case '\uE008':
            return 'Shift';
        case '\uE009':
            return 'Control';
        case '\uE00A':
            return 'Alt';
        case '\uE00B':
            return 'Pause';
        case '\uE00C':
            return 'Escape';
        case '\uE00D':
            return ' ';
        case '\uE00E':
            return 'PageUp';
        case '\uE00F':
            return 'PageDown';
        case '\uE010':
            return 'End';
        case '\uE011':
            return 'Home';
        case '\uE012':
            return 'ArrowLeft';
        case '\uE013':
            return 'ArrowUp';
        case '\uE014':
            return 'ArrowRight';
        case '\uE015':
            return 'ArrowDown';
        case '\uE016':
            return 'Insert';
        case '\uE017':
            return 'Delete';
        case '\uE018':
            return ';';
        case '\uE019':
            return '=';
        case '\uE01A':
            return '0';
        case '\uE01B':
            return '1';
        case '\uE01C':
            return '2';
        case '\uE01D':
            return '3';
        case '\uE01E':
            return '4';
        case '\uE01F':
            return '5';
        case '\uE020':
            return '6';
        case '\uE021':
            return '7';
        case '\uE022':
            return '8';
        case '\uE023':
            return '9';
        case '\uE024':
            return '*';
        case '\uE025':
            return '+';
        case '\uE026':
            return ',';
        case '\uE027':
            return '-';
        case '\uE028':
            return '.';
        case '\uE029':
            return '/';
        case '\uE031':
            return 'F1';
        case '\uE032':
            return 'F2';
        case '\uE033':
            return 'F3';
        case '\uE034':
            return 'F4';
        case '\uE035':
            return 'F5';
        case '\uE036':
            return 'F6';
        case '\uE037':
            return 'F7';
        case '\uE038':
            return 'F8';
        case '\uE039':
            return 'F9';
        case '\uE03A':
            return 'F10';
        case '\uE03B':
            return 'F11';
        case '\uE03C':
            return 'F12';
        case '\uE03D':
            return 'Meta';
        case '\uE040':
            return 'ZenkakuHankaku';
        case '\uE050':
            return 'Shift';
        case '\uE051':
            return 'Control';
        case '\uE052':
            return 'Alt';
        case '\uE053':
            return 'Meta';
        case '\uE054':
            return 'PageUp';
        case '\uE055':
            return 'PageDown';
        case '\uE056':
            return 'End';
        case '\uE057':
            return 'Home';
        case '\uE058':
            return 'ArrowLeft';
        case '\uE059':
            return 'ArrowUp';
        case '\uE05A':
            return 'ArrowRight';
        case '\uE05B':
            return 'ArrowDown';
        case '\uE05C':
            return 'Insert';
        case '\uE05D':
            return 'Delete';
        default:
            return value;
    }
}
/**
 * Returns the key code for a given key according to the table:
 * https://w3c.github.io/webdriver/#dfn-shifted-character
 */
function getKeyCode(key) {
    switch (key) {
        case '`':
        case '~':
            return 'Backquote';
        case '\\':
        case '|':
            return 'Backslash';
        case '\uE003':
            return 'Backspace';
        case '[':
        case '{':
            return 'BracketLeft';
        case ']':
        case '}':
            return 'BracketRight';
        case ',':
        case '<':
            return 'Comma';
        case '0':
        case ')':
            return 'Digit0';
        case '1':
        case '!':
            return 'Digit1';
        case '2':
        case '@':
            return 'Digit2';
        case '3':
        case '#':
            return 'Digit3';
        case '4':
        case '$':
            return 'Digit4';
        case '5':
        case '%':
            return 'Digit5';
        case '6':
        case '^':
            return 'Digit6';
        case '7':
        case '&':
            return 'Digit7';
        case '8':
        case '*':
            return 'Digit8';
        case '9':
        case '(':
            return 'Digit9';
        case '=':
        case '+':
            return 'Equal';
        // The spec declares the '<' to be `IntlBackslash` as well, but it is already covered
        // in the `Comma` above.
        case '>':
            return 'IntlBackslash';
        case 'a':
        case 'A':
            return 'KeyA';
        case 'b':
        case 'B':
            return 'KeyB';
        case 'c':
        case 'C':
            return 'KeyC';
        case 'd':
        case 'D':
            return 'KeyD';
        case 'e':
        case 'E':
            return 'KeyE';
        case 'f':
        case 'F':
            return 'KeyF';
        case 'g':
        case 'G':
            return 'KeyG';
        case 'h':
        case 'H':
            return 'KeyH';
        case 'i':
        case 'I':
            return 'KeyI';
        case 'j':
        case 'J':
            return 'KeyJ';
        case 'k':
        case 'K':
            return 'KeyK';
        case 'l':
        case 'L':
            return 'KeyL';
        case 'm':
        case 'M':
            return 'KeyM';
        case 'n':
        case 'N':
            return 'KeyN';
        case 'o':
        case 'O':
            return 'KeyO';
        case 'p':
        case 'P':
            return 'KeyP';
        case 'q':
        case 'Q':
            return 'KeyQ';
        case 'r':
        case 'R':
            return 'KeyR';
        case 's':
        case 'S':
            return 'KeyS';
        case 't':
        case 'T':
            return 'KeyT';
        case 'u':
        case 'U':
            return 'KeyU';
        case 'v':
        case 'V':
            return 'KeyV';
        case 'w':
        case 'W':
            return 'KeyW';
        case 'x':
        case 'X':
            return 'KeyX';
        case 'y':
        case 'Y':
            return 'KeyY';
        case 'z':
        case 'Z':
            return 'KeyZ';
        case '-':
        case '_':
            return 'Minus';
        case '.':
            return 'Period';
        case "'":
        case '"':
            return 'Quote';
        case ';':
        case ':':
            return 'Semicolon';
        case '/':
        case '?':
            return 'Slash';
        case '\uE00A':
            return 'AltLeft';
        case '\uE052':
            return 'AltRight';
        case '\uE009':
            return 'ControlLeft';
        case '\uE051':
            return 'ControlRight';
        case '\uE006':
            return 'Enter';
        case '\uE00B':
            return 'Pause';
        case '\uE03D':
            return 'MetaLeft';
        case '\uE053':
            return 'MetaRight';
        case '\uE008':
            return 'ShiftLeft';
        case '\uE050':
            return 'ShiftRight';
        case ' ':
        case '\uE00D':
            return 'Space';
        case '\uE004':
            return 'Tab';
        case '\uE017':
            return 'Delete';
        case '\uE010':
            return 'End';
        case '\uE002':
            return 'Help';
        case '\uE011':
            return 'Home';
        case '\uE016':
            return 'Insert';
        case '\uE00F':
            return 'PageDown';
        case '\uE00E':
            return 'PageUp';
        case '\uE015':
            return 'ArrowDown';
        case '\uE012':
            return 'ArrowLeft';
        case '\uE014':
            return 'ArrowRight';
        case '\uE013':
            return 'ArrowUp';
        case '\uE00C':
            return 'Escape';
        case '\uE031':
            return 'F1';
        case '\uE032':
            return 'F2';
        case '\uE033':
            return 'F3';
        case '\uE034':
            return 'F4';
        case '\uE035':
            return 'F5';
        case '\uE036':
            return 'F6';
        case '\uE037':
            return 'F7';
        case '\uE038':
            return 'F8';
        case '\uE039':
            return 'F9';
        case '\uE03A':
            return 'F10';
        case '\uE03B':
            return 'F11';
        case '\uE03C':
            return 'F12';
        case '\uE019':
            return 'NumpadEqual';
        case '\uE01A':
        case '\uE05C':
            return 'Numpad0';
        case '\uE01B':
        case '\uE056':
            return 'Numpad1';
        case '\uE01C':
        case '\uE05B':
            return 'Numpad2';
        case '\uE01D':
        case '\uE055':
            return 'Numpad3';
        case '\uE01E':
        case '\uE058':
            return 'Numpad4';
        case '\uE01F':
            return 'Numpad5';
        case '\uE020':
        case '\uE05A':
            return 'Numpad6';
        case '\uE021':
        case '\uE057':
            return 'Numpad7';
        case '\uE022':
        case '\uE059':
            return 'Numpad8';
        case '\uE023':
        case '\uE054':
            return 'Numpad9';
        case '\uE025':
            return 'NumpadAdd';
        case '\uE026':
            return 'NumpadComma';
        case '\uE028':
        case '\uE05D':
            return 'NumpadDecimal';
        case '\uE029':
            return 'NumpadDivide';
        case '\uE007':
            return 'NumpadEnter';
        case '\uE024':
            return 'NumpadMultiply';
        case '\uE027':
            return 'NumpadSubtract';
        default:
            return;
    }
}
/**
 * Returns the location of the key according to the table:
 * https://w3c.github.io/webdriver/#dfn-key-location
 */
function getKeyLocation(key) {
    switch (key) {
        case '\uE007':
        case '\uE008':
        case '\uE009':
        case '\uE00A':
        case '\uE03D':
            return 1;
        case '\uE019':
        case '\uE01A':
        case '\uE01B':
        case '\uE01C':
        case '\uE01D':
        case '\uE01E':
        case '\uE01F':
        case '\uE020':
        case '\uE021':
        case '\uE022':
        case '\uE023':
        case '\uE024':
        case '\uE025':
        case '\uE026':
        case '\uE027':
        case '\uE028':
        case '\uE029':
        case '\uE054':
        case '\uE055':
        case '\uE056':
        case '\uE057':
        case '\uE058':
        case '\uE059':
        case '\uE05A':
        case '\uE05B':
        case '\uE05C':
        case '\uE05D':
            return 3;
        case '\uE050':
        case '\uE051':
        case '\uE052':
        case '\uE053':
            return 2;
        default:
            return 0;
    }
}
//# sourceMappingURL=keyUtils.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/LogManager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogManager = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const logHelper_js_1 = __webpack_require__(/*! ./logHelper.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js");
/** Converts CDP StackTrace object to BiDi StackTrace object. */
function getBidiStackTrace(cdpStackTrace) {
    const stackFrames = cdpStackTrace?.callFrames.map((callFrame) => {
        return {
            columnNumber: callFrame.columnNumber,
            functionName: callFrame.functionName,
            lineNumber: callFrame.lineNumber,
            url: callFrame.url,
        };
    });
    return stackFrames ? { callFrames: stackFrames } : undefined;
}
function getLogLevel(consoleApiType) {
    if (["error" /* Log.Level.Error */, 'assert'].includes(consoleApiType)) {
        return "error" /* Log.Level.Error */;
    }
    if (["debug" /* Log.Level.Debug */, 'trace'].includes(consoleApiType)) {
        return "debug" /* Log.Level.Debug */;
    }
    if (["warn" /* Log.Level.Warn */, 'warning'].includes(consoleApiType)) {
        return "warn" /* Log.Level.Warn */;
    }
    return "info" /* Log.Level.Info */;
}
class LogManager {
    #eventManager;
    #realmStorage;
    #cdpTarget;
    #logger;
    constructor(cdpTarget, realmStorage, eventManager, logger) {
        this.#cdpTarget = cdpTarget;
        this.#realmStorage = realmStorage;
        this.#eventManager = eventManager;
        this.#logger = logger;
    }
    static create(cdpTarget, realmStorage, eventManager, logger) {
        const logManager = new LogManager(cdpTarget, realmStorage, eventManager, logger);
        logManager.#initializeEntryAddedEventListener();
        return logManager;
    }
    #initializeEntryAddedEventListener() {
        this.#cdpTarget.cdpClient.on('Runtime.consoleAPICalled', (params) => {
            // Try to find realm by `cdpSessionId` and `executionContextId`,
            // if provided.
            const realm = this.#realmStorage.findRealm({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.executionContextId,
            });
            if (realm === undefined) {
                // Ignore exceptions not attached to any realm.
                this.#logger?.(log_js_1.LogType.cdp, params);
                return;
            }
            const argsPromise = realm === undefined
                ? Promise.resolve(params.args)
                : // Properly serialize arguments if possible.
                    Promise.all(params.args.map((arg) => {
                        return realm.serializeCdpObject(arg, "none" /* Script.ResultOwnership.None */);
                    }));
            for (const browsingContext of realm.associatedBrowsingContexts) {
                this.#eventManager.registerPromiseEvent(argsPromise.then((args) => ({
                    kind: 'success',
                    value: {
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                        params: {
                            level: getLogLevel(params.type),
                            source: realm.source,
                            text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
                            timestamp: Math.round(params.timestamp),
                            stackTrace: getBidiStackTrace(params.stackTrace),
                            type: 'console',
                            // Console method is `warn`, not `warning`.
                            method: params.type === 'warning' ? 'warn' : params.type,
                            args,
                        },
                    },
                }), (error) => ({
                    kind: 'error',
                    error,
                })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
            }
        });
        this.#cdpTarget.cdpClient.on('Runtime.exceptionThrown', (params) => {
            // Try to find realm by `cdpSessionId` and `executionContextId`,
            // if provided.
            const realm = this.#realmStorage.findRealm({
                cdpSessionId: this.#cdpTarget.cdpSessionId,
                executionContextId: params.exceptionDetails.executionContextId,
            });
            if (realm === undefined) {
                // Ignore exceptions not attached to any realm.
                this.#logger?.(log_js_1.LogType.cdp, params);
                return;
            }
            for (const browsingContext of realm.associatedBrowsingContexts) {
                this.#eventManager.registerPromiseEvent(LogManager.#getExceptionText(params, realm).then((text) => ({
                    kind: 'success',
                    value: {
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                        params: {
                            level: "error" /* Log.Level.Error */,
                            source: realm.source,
                            text,
                            timestamp: Math.round(params.timestamp),
                            stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
                            type: 'javascript',
                        },
                    },
                }), (error) => ({
                    kind: 'error',
                    error,
                })), browsingContext.id, protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
            }
        });
    }
    /**
     * Try the best to get the exception text.
     */
    static async #getExceptionText(params, realm) {
        if (!params.exceptionDetails.exception) {
            return params.exceptionDetails.text;
        }
        if (realm === undefined) {
            return JSON.stringify(params.exceptionDetails.exception);
        }
        return await realm.stringifyObject(params.exceptionDetails.exception);
    }
}
exports.LogManager = LogManager;
//# sourceMappingURL=LogManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/log/logHelper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logMessageFormatter = logMessageFormatter;
exports.getRemoteValuesText = getRemoteValuesText;
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const specifiers = ['%s', '%d', '%i', '%f', '%o', '%O', '%c'];
function isFormatSpecifier(str) {
    return specifiers.some((spec) => str.includes(spec));
}
/**
 * @param args input remote values to be format printed
 * @return parsed text of the remote values in specific format
 */
function logMessageFormatter(args) {
    let output = '';
    const argFormat = args[0].value.toString();
    const argValues = args.slice(1, undefined);
    const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join('|'), 'g'));
    for (const token of tokens) {
        if (token === undefined || token === '') {
            continue;
        }
        if (isFormatSpecifier(token)) {
            const arg = argValues.shift();
            // raise an exception when less value is provided
            (0, assert_js_1.assert)(arg, `Less value is provided: "${getRemoteValuesText(args, false)}"`);
            if (token === '%s') {
                output += stringFromArg(arg);
            }
            else if (token === '%d' || token === '%i') {
                if (arg.type === 'bigint' ||
                    arg.type === 'number' ||
                    arg.type === 'string') {
                    output += parseInt(arg.value.toString(), 10);
                }
                else {
                    output += 'NaN';
                }
            }
            else if (token === '%f') {
                if (arg.type === 'bigint' ||
                    arg.type === 'number' ||
                    arg.type === 'string') {
                    output += parseFloat(arg.value.toString());
                }
                else {
                    output += 'NaN';
                }
            }
            else {
                // %o, %O, %c
                output += toJson(arg);
            }
        }
        else {
            output += token;
        }
    }
    // raise an exception when more value is provided
    if (argValues.length > 0) {
        throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
    }
    return output;
}
/**
 * @param arg input remote value to be parsed
 * @return parsed text of the remote value
 *
 * input: {"type": "number", "value": 1}
 * output: 1
 *
 * input: {"type": "string", "value": "abc"}
 * output: "abc"
 *
 * input: {"type": "object",  "value": [["id", {"type": "number", "value": 1}]]}
 * output: '{"id": 1}'
 *
 * input: {"type": "object", "value": [["font-size", {"type": "string", "value": "20px"}]]}
 * output: '{"font-size": "20px"}'
 */
function toJson(arg) {
    // arg type validation
    if (arg.type !== 'array' &&
        arg.type !== 'bigint' &&
        arg.type !== 'date' &&
        arg.type !== 'number' &&
        arg.type !== 'object' &&
        arg.type !== 'string') {
        return stringFromArg(arg);
    }
    if (arg.type === 'bigint') {
        return `${arg.value.toString()}n`;
    }
    if (arg.type === 'number') {
        return arg.value.toString();
    }
    if (['date', 'string'].includes(arg.type)) {
        return JSON.stringify(arg.value);
    }
    if (arg.type === 'object') {
        return `{${arg.value
            .map((pair) => {
            return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
        })
            .join(',')}}`;
    }
    if (arg.type === 'array') {
        return `[${arg.value?.map((val) => toJson(val)).join(',') ?? ''}]`;
    }
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    throw Error(`Invalid value type: ${arg}`);
}
function stringFromArg(arg) {
    if (!Object.hasOwn(arg, 'value')) {
        return arg.type;
    }
    switch (arg.type) {
        case 'string':
        case 'number':
        case 'boolean':
        case 'bigint':
            return String(arg.value);
        case 'regexp':
            return `/${arg.value.pattern}/${arg.value.flags ?? ''}`;
        case 'date':
            return new Date(arg.value).toString();
        case 'object':
            return `Object(${arg.value?.length ?? ''})`;
        case 'array':
            return `Array(${arg.value?.length ?? ''})`;
        case 'map':
            return `Map(${arg.value?.length})`;
        case 'set':
            return `Set(${arg.value?.length})`;
        default:
            return arg.type;
    }
}
function getRemoteValuesText(args, formatText) {
    const arg = args[0];
    if (!arg) {
        return '';
    }
    // if args[0] is a format specifier, format the args as output
    if (arg.type === 'string' &&
        isFormatSpecifier(arg.value.toString()) &&
        formatText) {
        return logMessageFormatter(args);
    }
    // if args[0] is not a format specifier, just join the args with \u0020 (unicode 'SPACE')
    return args
        .map((arg) => {
        return stringFromArg(arg);
    })
        .join('\u0020');
}
//# sourceMappingURL=logHelper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/** Dispatches Network domain commands. */
class NetworkProcessor {
    #browsingContextStorage;
    #networkStorage;
    constructor(browsingContextStorage, networkStorage) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#networkStorage = networkStorage;
    }
    async addIntercept(params) {
        this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const urlPatterns = params.urlPatterns ?? [];
        const parsedUrlPatterns = NetworkProcessor.parseUrlPatterns(urlPatterns);
        const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases,
            contexts: params.contexts,
        });
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context) => {
            return context.cdpTarget.toggleFetchIfNeeded();
        }));
        return {
            intercept,
        };
    }
    async continueRequest(params) {
        if (params.url !== undefined) {
            NetworkProcessor.parseUrlString(params.url);
        }
        if (params.method !== undefined) {
            if (!NetworkProcessor.isMethodValid(params.method)) {
                throw new protocol_js_1.InvalidArgumentException(`Method '${params.method}' is invalid.`);
            }
        }
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
            "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */,
        ]);
        // TODO: Set / expand.
        // ; Step 9. cookies
        try {
            await request.continueRequest(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async continueResponse(params) {
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        const request = this.#getBlockedRequestOrFail(params.request, [
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
            "responseStarted" /* Network.InterceptPhase.ResponseStarted */,
        ]);
        // TODO: Set / expand.
        // ; Step 10. cookies
        try {
            await request.continueResponse(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async continueWithAuth(params) {
        const networkId = params.request;
        const request = this.#getBlockedRequestOrFail(networkId, [
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
        ]);
        await request.continueWithAuth(params);
        return {};
    }
    async failRequest({ request: networkId, }) {
        const request = this.#getRequestOrFail(networkId);
        if (request.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            throw new protocol_js_1.InvalidArgumentException(`Request '${networkId}' in 'authRequired' phase cannot be failed`);
        }
        if (!request.interceptPhase) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
        }
        await request.failRequest('Failed');
        return {};
    }
    async provideResponse(params) {
        if (params.headers) {
            NetworkProcessor.validateHeaders(params.headers);
        }
        // TODO: Set / expand.
        // ; Step 10. cookies
        const request = this.#getBlockedRequestOrFail(params.request, [
            "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */,
            "responseStarted" /* Network.InterceptPhase.ResponseStarted */,
            "authRequired" /* Network.InterceptPhase.AuthRequired */,
        ]);
        try {
            await request.provideResponse(params);
        }
        catch (error) {
            throw NetworkProcessor.wrapInterceptionError(error);
        }
        return {};
    }
    async removeIntercept(params) {
        this.#networkStorage.removeIntercept(params.intercept);
        await Promise.all(this.#browsingContextStorage.getAllContexts().map((context) => {
            return context.cdpTarget.toggleFetchIfNeeded();
        }));
        return {};
    }
    #getRequestOrFail(id) {
        const request = this.#networkStorage.getRequestById(id);
        if (!request) {
            throw new protocol_js_1.NoSuchRequestException(`Network request with ID '${id}' doesn't exist`);
        }
        return request;
    }
    #getBlockedRequestOrFail(id, phases) {
        const request = this.#getRequestOrFail(id);
        if (!request.interceptPhase) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${id}'`);
        }
        if (request.interceptPhase && !phases.includes(request.interceptPhase)) {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${id}' is in '${request.interceptPhase}' phase`);
        }
        return request;
    }
    /**
     * Validate https://fetch.spec.whatwg.org/#header-value
     */
    static validateHeaders(headers) {
        for (const header of headers) {
            let headerValue;
            if (header.value.type === 'string') {
                headerValue = header.value.value;
            }
            else {
                headerValue = atob(header.value.value);
            }
            if (headerValue !== headerValue.trim() ||
                headerValue.includes('\n') ||
                headerValue.includes('\0')) {
                throw new protocol_js_1.InvalidArgumentException(`Header value '${headerValue}' is not acceptable value`);
            }
        }
    }
    static isMethodValid(method) {
        // https://httpwg.org/specs/rfc9110.html#method.overview
        return /^[!#$%&'*+\-.^_`|~a-zA-Z\d]+$/.test(method);
    }
    /**
     * Attempts to parse the given url.
     * Throws an InvalidArgumentException if the url is invalid.
     */
    static parseUrlString(url) {
        try {
            return new URL(url);
        }
        catch (error) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
        }
    }
    static parseUrlPatterns(urlPatterns) {
        return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
                case 'string': {
                    NetworkProcessor.parseUrlString(urlPattern.pattern);
                    return urlPattern;
                }
                case 'pattern':
                    // No params signifies intercept all
                    if (urlPattern.protocol === undefined &&
                        urlPattern.hostname === undefined &&
                        urlPattern.port === undefined &&
                        urlPattern.pathname === undefined &&
                        urlPattern.search === undefined) {
                        return urlPattern;
                    }
                    if (urlPattern.protocol) {
                        urlPattern.protocol = unescapeURLPattern(urlPattern.protocol);
                        if (!urlPattern.protocol.match(/^[a-zA-Z+-.]+$/)) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    if (urlPattern.hostname) {
                        urlPattern.hostname = unescapeURLPattern(urlPattern.hostname);
                    }
                    if (urlPattern.port) {
                        urlPattern.port = unescapeURLPattern(urlPattern.port);
                    }
                    if (urlPattern.pathname) {
                        urlPattern.pathname = unescapeURLPattern(urlPattern.pathname);
                        if (urlPattern.pathname[0] !== '/') {
                            urlPattern.pathname = `/${urlPattern.pathname}`;
                        }
                        if (urlPattern.pathname.includes('#') ||
                            urlPattern.pathname.includes('?')) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    else if (urlPattern.pathname === '') {
                        urlPattern.pathname = '/';
                    }
                    if (urlPattern.search) {
                        urlPattern.search = unescapeURLPattern(urlPattern.search);
                        if (urlPattern.search[0] !== '?') {
                            urlPattern.search = `?${urlPattern.search}`;
                        }
                        if (urlPattern.search.includes('#')) {
                            throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
                        }
                    }
                    if (urlPattern.protocol === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                    }
                    if (urlPattern.hostname === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                    }
                    if ((urlPattern.hostname?.length ?? 0) > 0) {
                        if (urlPattern.protocol?.match(/^file/i)) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                        }
                        if (urlPattern.hostname?.includes(':')) {
                            throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                        }
                    }
                    if (urlPattern.port === '') {
                        throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                    }
                    try {
                        new URLPattern(urlPattern);
                    }
                    catch (error) {
                        throw new protocol_js_1.InvalidArgumentException(`${error}`);
                    }
                    return urlPattern;
            }
        });
    }
    static wrapInterceptionError(error) {
        // https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/fetch_handler.cc;l=169
        if (error?.message.includes('Invalid header')) {
            return new protocol_js_1.InvalidArgumentException('Invalid header');
        }
        return error;
    }
}
exports.NetworkProcessor = NetworkProcessor;
/**
 * See https://w3c.github.io/webdriver-bidi/#unescape-url-pattern
 */
function unescapeURLPattern(pattern) {
    const forbidden = new Set(['(', ')', '*', '{', '}']);
    let result = '';
    let isEscaped = false;
    for (const c of pattern) {
        if (!isEscaped) {
            if (forbidden.has(c)) {
                throw new protocol_js_1.InvalidArgumentException('Forbidden characters');
            }
            if (c === '\\') {
                isEscaped = true;
                continue;
            }
        }
        result += c;
        isEscaped = false;
    }
    return result;
}
//# sourceMappingURL=NetworkProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkRequest = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const Deferred_js_1 = __webpack_require__(/*! ../../../utils/Deferred.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ./NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
const REALM_REGEX = /(?<=realm=").*(?=")/;
/** Abstracts one individual network request. */
class NetworkRequest {
    static unknownParameter = 'UNKNOWN';
    /**
     * Each network request has an associated request id, which is a string
     * uniquely identifying that request.
     *
     * The identifier for a request resulting from a redirect matches that of the
     * request that initiated it.
     */
    #id;
    #fetchId;
    /**
     * Indicates the network intercept phase, if the request is currently blocked.
     * Undefined necessarily implies that the request is not blocked.
     */
    #interceptPhase;
    #servedFromCache = false;
    #redirectCount;
    #request = {};
    #requestOverrides;
    #response = {};
    #eventManager;
    #networkStorage;
    #cdpTarget;
    #logger;
    #emittedEvents = {
        [protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.FetchError]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted]: false,
        [protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted]: false,
    };
    waitNextPhase = new Deferred_js_1.Deferred();
    constructor(id, eventManager, networkStorage, cdpTarget, redirectCount = 0, logger) {
        this.#id = id;
        this.#eventManager = eventManager;
        this.#networkStorage = networkStorage;
        this.#cdpTarget = cdpTarget;
        this.#redirectCount = redirectCount;
        this.#logger = logger;
    }
    get id() {
        return this.#id;
    }
    get fetchId() {
        return this.#fetchId;
    }
    /**
     * When blocked returns the phase for it
     */
    get interceptPhase() {
        return this.#interceptPhase;
    }
    get url() {
        const fragment = this.#request.info?.request.urlFragment ??
            this.#request.paused?.request.urlFragment ??
            '';
        const url = this.#response.info?.url ??
            this.#response.paused?.request.url ??
            this.#requestOverrides?.url ??
            this.#request.auth?.request.url ??
            this.#request.info?.request.url ??
            this.#request.paused?.request.url ??
            NetworkRequest.unknownParameter;
        return `${url}${fragment}`;
    }
    get method() {
        return (this.#requestOverrides?.method ??
            this.#request.info?.request.method ??
            this.#request.paused?.request.method ??
            this.#request.auth?.request.method ??
            this.#response.paused?.request.method ??
            NetworkRequest.unknownParameter);
    }
    get redirectCount() {
        return this.#redirectCount;
    }
    get cdpTarget() {
        return this.#cdpTarget;
    }
    get cdpClient() {
        return this.#cdpTarget.cdpClient;
    }
    isRedirecting() {
        return Boolean(this.#request.info);
    }
    isDataUrl() {
        return this.url.startsWith('data:');
    }
    #phaseChanged() {
        this.waitNextPhase.resolve();
        this.waitNextPhase = new Deferred_js_1.Deferred();
    }
    #interceptsInPhase(phase) {
        if (!this.#cdpTarget.isSubscribedTo(`network.${phase}`)) {
            return new Set();
        }
        return this.#networkStorage.getInterceptsForPhase(this, phase);
    }
    #isBlockedInPhase(phase) {
        return this.#interceptsInPhase(phase).size > 0;
    }
    handleRedirect(event) {
        // TODO: use event.redirectResponse;
        // Temporary workaround to emit ResponseCompleted event for redirects
        this.#response.hasExtraInfo = false;
        this.#response.info = event.redirectResponse;
        this.#emitEventsIfReady({
            wasRedirected: true,
        });
    }
    #emitEventsIfReady(options = {}) {
        const requestExtraInfoCompleted = 
        // Flush redirects
        options.wasRedirected ||
            options.hasFailed ||
            this.isDataUrl() ||
            Boolean(this.#request.extraInfo) ||
            // Requests from cache don't have extra info
            this.#servedFromCache ||
            // Sometimes there is no extra info and the response
            // is the only place we can find out
            Boolean(this.#response.info && !this.#response.hasExtraInfo);
        const noInterceptionExpected = 
        // We can't intercept data urls from CDP
        this.isDataUrl() ||
            // Cached requests never hit the network
            this.#servedFromCache;
        const requestInterceptionExpected = !noInterceptionExpected &&
            this.#isBlockedInPhase("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */);
        const requestInterceptionCompleted = !requestInterceptionExpected ||
            (requestInterceptionExpected && Boolean(this.#request.paused));
        if (Boolean(this.#request.info) &&
            (requestInterceptionExpected
                ? requestInterceptionCompleted
                : requestExtraInfoCompleted)) {
            this.#emitEvent(this.#getBeforeRequestEvent.bind(this));
        }
        const responseExtraInfoCompleted = Boolean(this.#response.extraInfo) ||
            // Response from cache don't have extra info
            this.#servedFromCache ||
            // Don't expect extra info if the flag is false
            Boolean(this.#response.info && !this.#response.hasExtraInfo);
        const responseInterceptionExpected = !noInterceptionExpected &&
            this.#isBlockedInPhase("responseStarted" /* Network.InterceptPhase.ResponseStarted */);
        if (this.#response.info ||
            (responseInterceptionExpected && Boolean(this.#response.paused))) {
            this.#emitEvent(this.#getResponseStartedEvent.bind(this));
        }
        const responseInterceptionCompleted = !responseInterceptionExpected ||
            (responseInterceptionExpected && Boolean(this.#response.paused));
        if (Boolean(this.#response.info) &&
            responseExtraInfoCompleted &&
            responseInterceptionCompleted) {
            this.#emitEvent(this.#getResponseReceivedEvent.bind(this));
            this.#networkStorage.deleteRequest(this.id);
        }
    }
    onRequestWillBeSentEvent(event) {
        this.#request.info = event;
        this.#emitEventsIfReady();
    }
    onRequestWillBeSentExtraInfoEvent(event) {
        this.#request.extraInfo = event;
        this.#emitEventsIfReady();
    }
    onResponseReceivedExtraInfoEvent(event) {
        if (event.statusCode >= 300 &&
            event.statusCode <= 399 &&
            this.#request.info &&
            event.headers['location'] === this.#request.info.request.url) {
            // We received the Response Extra info for the redirect
            // Too late so we need to skip it as it will
            // fire wrongly for the last one
            return;
        }
        this.#response.extraInfo = event;
        this.#emitEventsIfReady();
    }
    onResponseReceivedEvent(event) {
        this.#response.hasExtraInfo = event.hasExtraInfo;
        this.#response.info = event.response;
        this.#emitEventsIfReady();
    }
    onServedFromCache() {
        this.#servedFromCache = true;
        this.#emitEventsIfReady();
    }
    onLoadingFailedEvent(event) {
        this.#emitEventsIfReady({
            hasFailed: true,
        });
        this.#emitEvent(() => {
            return {
                method: protocol_js_1.ChromiumBidi.Network.EventNames.FetchError,
                params: {
                    ...this.#getBaseEventParams(),
                    errorText: event.errorText,
                },
            };
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest */
    async failRequest(errorReason) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.failRequest', {
            requestId: this.#fetchId,
            errorReason,
        });
        this.#interceptPhase = undefined;
    }
    onRequestPaused(event) {
        this.#fetchId = event.requestId;
        // CDP https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-requestPaused
        if (event.responseStatusCode || event.responseErrorReason) {
            this.#response.paused = event;
            if (this.#isBlockedInPhase("responseStarted" /* Network.InterceptPhase.ResponseStarted */) &&
                // CDP may emit multiple events for a single request
                !this.#emittedEvents[protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted] &&
                // Continue all response that have not enabled Network domain
                this.#fetchId !== this.id) {
                this.#interceptPhase = "responseStarted" /* Network.InterceptPhase.ResponseStarted */;
            }
            else {
                void this.#continueResponse();
            }
        }
        else {
            this.#request.paused = event;
            if (this.#isBlockedInPhase("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */) &&
                // CDP may emit multiple events for a single request
                !this.#emittedEvents[protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent] &&
                // Continue all requests that have not enabled Network domain
                this.#fetchId !== this.id) {
                this.#interceptPhase = "beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */;
            }
            else {
                void this.#continueRequest();
            }
        }
        this.#emitEventsIfReady();
    }
    onAuthRequired(event) {
        this.#fetchId = event.requestId;
        this.#request.auth = event;
        if (this.#isBlockedInPhase("authRequired" /* Network.InterceptPhase.AuthRequired */) &&
            // Continue all auth requests that have not enabled Network domain
            this.#fetchId !== this.id) {
            this.#interceptPhase = "authRequired" /* Network.InterceptPhase.AuthRequired */;
        }
        else {
            void this.#continueWithAuth({
                response: 'Default',
            });
        }
        this.#emitEvent(() => {
            return {
                method: protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired,
                params: {
                    ...this.#getBaseEventParams("authRequired" /* Network.InterceptPhase.AuthRequired */),
                    response: this.#getResponseEventParams(),
                },
            };
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest */
    async continueRequest(overrides = {}) {
        const headers = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrides.headers);
        const postData = getCdpBodyFromBiDiBytesValue(overrides.body);
        await this.#continueRequest({
            url: overrides.url,
            method: overrides.method,
            headers,
            postData,
        });
        // TODO: Store postData's size only
        this.#requestOverrides = {
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            bodySize: getSizeFromBiDiBytesValue(overrides.body),
        };
    }
    async #continueRequest(overrides = {}) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueRequest', {
            requestId: this.#fetchId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData,
        });
        this.#interceptPhase = undefined;
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse */
    async continueResponse(overrides = {}) {
        if (this.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            if (overrides.credentials) {
                await Promise.all([
                    this.waitNextPhase,
                    await this.#continueWithAuth({
                        response: 'ProvideCredentials',
                        username: overrides.credentials.username,
                        password: overrides.credentials.password,
                    }),
                ]);
            }
            else {
                // We need to use `ProvideCredentials`
                // As `Default` may cancel the request
                return await this.#continueWithAuth({
                    response: 'ProvideCredentials',
                });
            }
        }
        if (this.#interceptPhase === "responseStarted" /* Network.InterceptPhase.ResponseStarted */) {
            const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrides.headers);
            await this.#continueResponse({
                responseCode: overrides.statusCode,
                responsePhrase: overrides.reasonPhrase,
                responseHeaders,
            });
        }
    }
    async #continueResponse({ responseCode, responsePhrase, responseHeaders, } = {}) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueResponse', {
            requestId: this.#fetchId,
            responseCode,
            responsePhrase,
            responseHeaders,
        });
        this.#interceptPhase = undefined;
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth */
    async continueWithAuth(authChallenge) {
        let username;
        let password;
        if (authChallenge.action === 'provideCredentials') {
            const { credentials } = authChallenge;
            username = credentials.username;
            password = credentials.password;
        }
        const response = (0, NetworkUtils_js_1.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(authChallenge.action);
        await this.#continueWithAuth({
            response,
            username,
            password,
        });
    }
    /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-provideResponse */
    async provideResponse(overrides) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        // We need to pass through if the request is already in
        // AuthRequired phase
        if (this.interceptPhase === "authRequired" /* Network.InterceptPhase.AuthRequired */) {
            // We need to use `ProvideCredentials`
            // As `Default` may cancel the request
            return await this.#continueWithAuth({
                response: 'ProvideCredentials',
            });
        }
        // If we don't modify the response
        // just continue the request
        if (!overrides.body && !overrides.headers) {
            return await this.#continueRequest();
        }
        // TODO: Step 6
        // https://w3c.github.io/webdriver-bidi/#command-network-continueResponse
        const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(overrides.headers);
        const responseCode = overrides.statusCode ?? this.statusCode ?? 200;
        await this.cdpClient.sendCommand('Fetch.fulfillRequest', {
            requestId: this.#fetchId,
            responseCode,
            responsePhrase: overrides.reasonPhrase,
            responseHeaders,
            body: getCdpBodyFromBiDiBytesValue(overrides.body),
        });
        this.#interceptPhase = undefined;
    }
    get #context() {
        return (this.#response.paused?.frameId ??
            this.#request.info?.frameId ??
            this.#request.paused?.frameId ??
            this.#request.auth?.frameId ??
            null);
    }
    /** Returns the HTTP status code associated with this request if any. */
    get statusCode() {
        return (this.#response.paused?.responseStatusCode ??
            this.#response.extraInfo?.statusCode ??
            this.#response.info?.status);
    }
    async #continueWithAuth(authChallengeResponse) {
        (0, assert_js_1.assert)(this.#fetchId, 'Network Interception not set-up.');
        await this.cdpClient.sendCommand('Fetch.continueWithAuth', {
            requestId: this.#fetchId,
            authChallengeResponse,
        });
        this.#interceptPhase = undefined;
    }
    #emitEvent(getEvent) {
        let event;
        try {
            event = getEvent();
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, error);
            return;
        }
        if (this.#isIgnoredEvent() ||
            (this.#emittedEvents[event.method] &&
                // Special case this event can be emitted multiple times
                event.method !== protocol_js_1.ChromiumBidi.Network.EventNames.AuthRequired)) {
            return;
        }
        this.#phaseChanged();
        this.#emittedEvents[event.method] = true;
        this.#eventManager.registerEvent(Object.assign(event, {
            type: 'event',
        }), this.#context);
    }
    #getBaseEventParams(phase) {
        const interceptProps = {
            isBlocked: false,
        };
        if (phase) {
            const blockedBy = this.#interceptsInPhase(phase);
            interceptProps.isBlocked = blockedBy.size > 0;
            if (interceptProps.isBlocked) {
                interceptProps.intercepts = [...blockedBy];
            }
        }
        return {
            context: this.#context,
            navigation: this.#getNavigationId(),
            redirectCount: this.#redirectCount,
            request: this.#getRequestData(),
            // Timestamp should be in milliseconds, while CDP provides it in seconds.
            timestamp: Math.round((this.#request.info?.wallTime ?? 0) * 1000),
            // Contains isBlocked and intercepts
            ...interceptProps,
        };
    }
    #getResponseEventParams() {
        // Chromium sends wrong extraInfo events for responses served from cache.
        // See https://github.com/puppeteer/puppeteer/issues/9965 and
        // https://crbug.com/1340398.
        if (this.#response.info?.fromDiskCache) {
            this.#response.extraInfo = undefined;
        }
        const headers = [
            ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.info?.headers),
            ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.extraInfo?.headers),
            // TODO: Verify how to dedupe these
            // ...bidiNetworkHeadersFromCdpNetworkHeadersEntries(
            //   this.#response.paused?.responseHeaders
            // ),
        ];
        // TODO: get headers from Fetch.requestPaused
        const authChallenges = this.#authChallenges(this.#response.info?.headers ?? {});
        return {
            url: this.url,
            protocol: this.#response.info?.protocol ?? '',
            status: this.statusCode ?? -1, // TODO: Throw an exception or use some other status code?
            statusText: this.#response.info?.statusText ||
                this.#response.paused?.responseStatusText ||
                '',
            fromCache: this.#response.info?.fromDiskCache ||
                this.#response.info?.fromPrefetchCache ||
                this.#servedFromCache,
            headers,
            mimeType: this.#response.info?.mimeType || '',
            bytesReceived: this.#response.info?.encodedDataLength || 0,
            headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
            // TODO: consider removing from spec.
            bodySize: 0,
            content: {
                // TODO: consider removing from spec.
                size: 0,
            },
            ...(authChallenges ? { authChallenges } : {}),
        };
    }
    #getNavigationId() {
        // Heuristic to determine if this is a navigation request, and if not return null.
        if (!this.#request.info ||
            !this.#request.info.loaderId ||
            // When we navigate all CDP network events have `loaderId`
            // CDP's `loaderId` and `requestId` match when
            // that request triggered the loading
            this.#request.info.loaderId !== this.#request.info.requestId) {
            return null;
        }
        // Get virtual navigation ID from the browsing context.
        return this.#networkStorage.getVirtualNavigationId(this.#request?.info?.frameId);
    }
    #getRequestData() {
        const cookies = this.#request.extraInfo
            ? NetworkRequest.#getCookies(this.#request.extraInfo.associatedCookies)
            : [];
        let headers = [];
        if (this.#requestOverrides?.headers) {
            headers = this.#requestOverrides.headers;
        }
        else {
            headers = [
                ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#request.info?.request.headers),
                ...(0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#request.extraInfo?.headers),
            ];
        }
        let bodySize = 0;
        if (typeof this.#requestOverrides?.bodySize === 'number') {
            bodySize = this.#requestOverrides.bodySize;
        }
        else {
            bodySize = (0, NetworkUtils_js_1.bidiBodySizeFromCdpPostDataEntries)(this.#request.info?.request.postDataEntries ?? []);
        }
        return {
            request: this.#id,
            url: this.url,
            method: this.method,
            headers,
            cookies,
            headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
            bodySize,
            timings: this.#getTimings(),
        };
    }
    // TODO: implement.
    #getTimings() {
        return {
            timeOrigin: 0,
            requestTime: 0,
            redirectStart: 0,
            redirectEnd: 0,
            fetchStart: 0,
            dnsStart: 0,
            dnsEnd: 0,
            connectStart: 0,
            connectEnd: 0,
            tlsStart: 0,
            requestStart: 0,
            responseStart: 0,
            responseEnd: 0,
        };
    }
    #getBeforeRequestEvent() {
        (0, assert_js_1.assert)(this.#request.info, 'RequestWillBeSentEvent is not set');
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent,
            params: {
                ...this.#getBaseEventParams("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */),
                initiator: {
                    type: NetworkRequest.#getInitiatorType(this.#request.info.initiator.type),
                    columnNumber: this.#request.info.initiator.columnNumber,
                    lineNumber: this.#request.info.initiator.lineNumber,
                    stackTrace: this.#request.info.initiator.stack,
                    request: this.#request.info.initiator.requestId,
                },
            },
        };
    }
    #getResponseStartedEvent() {
        (0, assert_js_1.assert)(this.#request.info, 'RequestWillBeSentEvent is not set');
        (0, assert_js_1.assert)(
        // The response paused comes before any data for the response
        this.#response.paused || this.#response.info, 'ResponseReceivedEvent is not set');
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted,
            params: {
                ...this.#getBaseEventParams("responseStarted" /* Network.InterceptPhase.ResponseStarted */),
                response: this.#getResponseEventParams(),
            },
        };
    }
    #getResponseReceivedEvent() {
        (0, assert_js_1.assert)(this.#request.info, 'RequestWillBeSentEvent is not set');
        (0, assert_js_1.assert)(this.#response.info, 'ResponseReceivedEvent is not set');
        return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted,
            params: {
                ...this.#getBaseEventParams(),
                response: this.#getResponseEventParams(),
            },
        };
    }
    #isIgnoredEvent() {
        const faviconUrl = '/favicon.ico';
        return (this.#request.paused?.request.url.endsWith(faviconUrl) ??
            this.#request.info?.request.url.endsWith(faviconUrl) ??
            false);
    }
    #authChallenges(headers) {
        if (!(this.statusCode === 401 || this.statusCode === 407)) {
            return undefined;
        }
        const headerName = this.statusCode === 401 ? 'WWW-Authenticate' : 'Proxy-Authenticate';
        const authChallenges = [];
        for (const [header, value] of Object.entries(headers)) {
            // TODO: Do a proper match based on https://httpwg.org/specs/rfc9110.html#credentials
            // Or verify this works
            if (header.localeCompare(headerName, undefined, { sensitivity: 'base' }) === 0) {
                authChallenges.push({
                    scheme: value.split(' ').at(0) ?? '',
                    realm: value.match(REALM_REGEX)?.at(0) ?? '',
                });
            }
        }
        return authChallenges;
    }
    static #getInitiatorType(initiatorType) {
        switch (initiatorType) {
            case 'parser':
            case 'script':
            case 'preflight':
                return initiatorType;
            default:
                return 'other';
        }
    }
    static #getCookies(associatedCookies) {
        return associatedCookies
            .filter(({ blockedReasons }) => {
            return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
        })
            .map(({ cookie }) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(cookie));
    }
}
exports.NetworkRequest = NetworkRequest;
function getCdpBodyFromBiDiBytesValue(body) {
    let parsedBody;
    if (body?.type === 'string') {
        parsedBody = btoa(body.value);
    }
    else if (body?.type === 'base64') {
        parsedBody = body.value;
    }
    return parsedBody;
}
function getSizeFromBiDiBytesValue(body) {
    if (body?.type === 'string') {
        return body.value.length;
    }
    else if (body?.type === 'base64') {
        return atob(body.value).length;
    }
    return 0;
}
//# sourceMappingURL=NetworkRequest.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkStorage.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const NetworkRequest_js_1 = __webpack_require__(/*! ./NetworkRequest.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkRequest.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ./NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
/** Stores network and intercept maps. */
class NetworkStorage {
    #browsingContextStorage;
    #eventManager;
    #logger;
    /**
     * A map from network request ID to Network Request objects.
     * Needed as long as information about requests comes from different events.
     */
    #requests = new Map();
    /** A map from intercept ID to track active network intercepts. */
    #intercepts = new Map();
    constructor(eventManager, browsingContextStorage, browserClient, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#eventManager = eventManager;
        browserClient.on('Target.detachedFromTarget', ({ sessionId }) => {
            this.disposeRequestMap(sessionId);
        });
        this.#logger = logger;
    }
    /**
     * Gets the network request with the given ID, if any.
     * Otherwise, creates a new network request with the given ID and cdp target.
     */
    #getOrCreateNetworkRequest(id, cdpTarget, redirectCount) {
        let request = this.getRequestById(id);
        if (request) {
            return request;
        }
        request = new NetworkRequest_js_1.NetworkRequest(id, this.#eventManager, this, cdpTarget, redirectCount, this.#logger);
        this.addRequest(request);
        return request;
    }
    onCdpTargetCreated(cdpTarget) {
        const cdpClient = cdpTarget.cdpClient;
        // TODO: Wrap into object
        const listeners = [
            [
                'Network.requestWillBeSent',
                (params) => {
                    const request = this.getRequestById(params.requestId);
                    if (request && request.isRedirecting()) {
                        request.handleRedirect(params);
                        this.deleteRequest(params.requestId);
                        this.#getOrCreateNetworkRequest(params.requestId, cdpTarget, request.redirectCount + 1).onRequestWillBeSentEvent(params);
                    }
                    else {
                        this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentEvent(params);
                    }
                },
            ],
            [
                'Network.requestWillBeSentExtraInfo',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onRequestWillBeSentExtraInfoEvent(params);
                },
            ],
            [
                'Network.responseReceived',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedEvent(params);
                },
            ],
            [
                'Network.responseReceivedExtraInfo',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onResponseReceivedExtraInfoEvent(params);
                },
            ],
            [
                'Network.requestServedFromCache',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onServedFromCache();
                },
            ],
            [
                'Network.loadingFailed',
                (params) => {
                    this.#getOrCreateNetworkRequest(params.requestId, cdpTarget).onLoadingFailedEvent(params);
                },
            ],
            [
                'Fetch.requestPaused',
                (event) => {
                    this.#getOrCreateNetworkRequest(
                    // CDP quirk if the Network domain is not present this is undefined
                    event.networkId ?? event.requestId, cdpTarget).onRequestPaused(event);
                },
            ],
            [
                'Fetch.authRequired',
                (event) => {
                    let request = this.getRequestByFetchId(event.requestId);
                    if (!request) {
                        request = this.#getOrCreateNetworkRequest(event.requestId, cdpTarget);
                    }
                    request.onAuthRequired(event);
                },
            ],
        ];
        for (const [event, listener] of listeners) {
            cdpClient.on(event, listener);
        }
    }
    getInterceptionStages(browsingContextId) {
        const stages = {
            request: false,
            response: false,
            auth: false,
        };
        for (const intercept of this.#intercepts.values()) {
            if (intercept.contexts &&
                !intercept.contexts.includes(browsingContextId)) {
                continue;
            }
            stages.request ||= intercept.phases.includes("beforeRequestSent" /* Network.InterceptPhase.BeforeRequestSent */);
            stages.response ||= intercept.phases.includes("responseStarted" /* Network.InterceptPhase.ResponseStarted */);
            stages.auth ||= intercept.phases.includes("authRequired" /* Network.InterceptPhase.AuthRequired */);
        }
        return stages;
    }
    getInterceptsForPhase(request, phase) {
        if (request.url === NetworkRequest_js_1.NetworkRequest.unknownParameter) {
            return new Set();
        }
        const intercepts = new Set();
        for (const [interceptId, intercept] of this.#intercepts.entries()) {
            if (!intercept.phases.includes(phase) ||
                (intercept.contexts &&
                    !intercept.contexts.includes(request.cdpTarget.topLevelId))) {
                continue;
            }
            if (intercept.urlPatterns.length === 0) {
                intercepts.add(interceptId);
                continue;
            }
            for (const pattern of intercept.urlPatterns) {
                if ((0, NetworkUtils_js_1.matchUrlPattern)(pattern, request.url)) {
                    intercepts.add(interceptId);
                    break;
                }
            }
        }
        return intercepts;
    }
    disposeRequestMap(sessionId) {
        for (const request of this.#requests.values()) {
            if (request.cdpClient.sessionId === sessionId) {
                this.#requests.delete(request.id);
            }
        }
    }
    /**
     * Adds the given entry to the intercept map.
     * URL patterns are assumed to be parsed.
     *
     * @return The intercept ID.
     */
    addIntercept(value) {
        const interceptId = (0, uuid_js_1.uuidv4)();
        this.#intercepts.set(interceptId, value);
        return interceptId;
    }
    /**
     * Removes the given intercept from the intercept map.
     * Throws NoSuchInterceptException if the intercept does not exist.
     */
    removeIntercept(intercept) {
        if (!this.#intercepts.has(intercept)) {
            throw new protocol_js_1.NoSuchInterceptException(`Intercept '${intercept}' does not exist.`);
        }
        this.#intercepts.delete(intercept);
    }
    getRequestById(id) {
        return this.#requests.get(id);
    }
    getRequestByFetchId(fetchId) {
        for (const request of this.#requests.values()) {
            if (request.fetchId === fetchId) {
                return request;
            }
        }
        return;
    }
    addRequest(request) {
        this.#requests.set(request.id, request);
    }
    deleteRequest(id) {
        this.#requests.delete(id);
    }
    /**
     * Gets the virtual navigation ID for the given navigable ID.
     */
    getVirtualNavigationId(contextId) {
        if (contextId === undefined) {
            return null;
        }
        return (this.#browsingContextStorage.findContext(contextId)
            ?.virtualNavigationId ?? null);
    }
}
exports.NetworkStorage = NetworkStorage;
//# sourceMappingURL=NetworkStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.computeHeadersSize = computeHeadersSize;
exports.bidiNetworkHeadersFromCdpNetworkHeaders = bidiNetworkHeadersFromCdpNetworkHeaders;
exports.bidiNetworkHeadersFromCdpNetworkHeadersEntries = bidiNetworkHeadersFromCdpNetworkHeadersEntries;
exports.cdpNetworkHeadersFromBidiNetworkHeaders = cdpNetworkHeadersFromBidiNetworkHeaders;
exports.bidiNetworkHeadersFromCdpFetchHeaders = bidiNetworkHeadersFromCdpFetchHeaders;
exports.cdpFetchHeadersFromBidiNetworkHeaders = cdpFetchHeadersFromBidiNetworkHeaders;
exports.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction;
exports.cdpToBiDiCookie = cdpToBiDiCookie;
exports.deserializeByteValue = deserializeByteValue;
exports.bidiToCdpCookie = bidiToCdpCookie;
exports.sameSiteBiDiToCdp = sameSiteBiDiToCdp;
exports.isSpecialScheme = isSpecialScheme;
exports.matchUrlPattern = matchUrlPattern;
exports.bidiBodySizeFromCdpPostDataEntries = bidiBodySizeFromCdpPostDataEntries;
const ErrorResponse_js_1 = __webpack_require__(/*! ../../../protocol/ErrorResponse.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js");
const Base64_js_1 = __webpack_require__(/*! ../../../utils/Base64.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Base64.js");
const UrlPattern_js_1 = __webpack_require__(/*! ../../../utils/UrlPattern.js */ "./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js");
function computeHeadersSize(headers) {
    const requestHeaders = headers.reduce((acc, header) => {
        return `${acc}${header.name}: ${header.value.value}\r\n`;
    }, '');
    return new TextEncoder().encode(requestHeaders).length;
}
/** Converts from CDP Network domain headers to BiDi network headers. */
function bidiNetworkHeadersFromCdpNetworkHeaders(headers) {
    if (!headers) {
        return [];
    }
    return Object.entries(headers).map(([name, value]) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from CDP Fetch domain headers to BiDi network headers. */
function bidiNetworkHeadersFromCdpNetworkHeadersEntries(headers) {
    if (!headers) {
        return [];
    }
    return headers.map(({ name, value }) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from Bidi network headers to CDP Network domain headers. */
function cdpNetworkHeadersFromBidiNetworkHeaders(headers) {
    if (headers === undefined) {
        return undefined;
    }
    return headers.reduce((result, header) => {
        // TODO: Distinguish between string and bytes?
        result[header.name] = header.value.value;
        return result;
    }, {});
}
/** Converts from CDP Fetch domain header entries to Bidi network headers. */
function bidiNetworkHeadersFromCdpFetchHeaders(headers) {
    if (!headers) {
        return [];
    }
    return headers.map(({ name, value }) => ({
        name,
        value: {
            type: 'string',
            value,
        },
    }));
}
/** Converts from Bidi network headers to CDP Fetch domain header entries. */
function cdpFetchHeadersFromBidiNetworkHeaders(headers) {
    if (headers === undefined) {
        return undefined;
    }
    return headers.map(({ name, value }) => ({
        name,
        value: value.value,
    }));
}
/** Converts from Bidi auth action to CDP auth challenge response. */
function cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(action) {
    switch (action) {
        case 'default':
            return 'Default';
        case 'cancel':
            return 'CancelAuth';
        case 'provideCredentials':
            return 'ProvideCredentials';
    }
}
/**
 * Converts from CDP Network domain cookie to BiDi network cookie.
 * * https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-Cookie
 * * https://w3c.github.io/webdriver-bidi/#type-network-Cookie
 */
function cdpToBiDiCookie(cookie) {
    const result = {
        name: cookie.name,
        value: { type: 'string', value: cookie.value },
        domain: cookie.domain,
        path: cookie.path,
        size: cookie.size,
        httpOnly: cookie.httpOnly,
        secure: cookie.secure,
        sameSite: cookie.sameSite === undefined
            ? "none" /* Network.SameSite.None */
            : sameSiteCdpToBiDi(cookie.sameSite),
        ...(cookie.expires >= 0 ? { expiry: cookie.expires } : undefined),
    };
    // Extending with CDP-specific properties with `goog:` prefix.
    result[`goog:session`] = cookie.session;
    result[`goog:priority`] = cookie.priority;
    result[`goog:sameParty`] = cookie.sameParty;
    result[`goog:sourceScheme`] = cookie.sourceScheme;
    result[`goog:sourcePort`] = cookie.sourcePort;
    if (cookie.partitionKey !== undefined) {
        result[`goog:partitionKey`] = cookie.partitionKey;
    }
    if (cookie.partitionKeyOpaque !== undefined) {
        result[`goog:partitionKeyOpaque`] = cookie.partitionKeyOpaque;
    }
    return result;
}
/**
 * Decodes a byte value to a string.
 * @param {Network.BytesValue} value
 * @return {string}
 */
function deserializeByteValue(value) {
    if (value.type === 'base64') {
        return (0, Base64_js_1.base64ToString)(value.value);
    }
    return value.value;
}
/**
 * Converts from BiDi set network cookie params to CDP Network domain cookie.
 * * https://w3c.github.io/webdriver-bidi/#type-network-Cookie
 * * https://chromedevtools.github.io/devtools-protocol/tot/Network/#type-CookieParam
 */
function bidiToCdpCookie(params, partitionKey) {
    const deserializedValue = deserializeByteValue(params.cookie.value);
    const result = {
        name: params.cookie.name,
        value: deserializedValue,
        domain: params.cookie.domain,
        path: params.cookie.path ?? '/',
        secure: params.cookie.secure ?? false,
        httpOnly: params.cookie.httpOnly ?? false,
        ...(partitionKey.sourceOrigin !== undefined && {
            partitionKey: {
                hasCrossSiteAncestor: false,
                // CDP's `partitionKey.topLevelSite` is the BiDi's `partition.sourceOrigin`.
                topLevelSite: partitionKey.sourceOrigin,
            },
        }),
        ...(params.cookie.expiry !== undefined && {
            expires: params.cookie.expiry,
        }),
        ...(params.cookie.sameSite !== undefined && {
            sameSite: sameSiteBiDiToCdp(params.cookie.sameSite),
        }),
    };
    // Extending with CDP-specific properties with `goog:` prefix.
    if (params.cookie[`goog:url`] !== undefined) {
        result.url = params.cookie[`goog:url`];
    }
    if (params.cookie[`goog:priority`] !== undefined) {
        result.priority = params.cookie[`goog:priority`];
    }
    if (params.cookie[`goog:sameParty`] !== undefined) {
        result.sameParty = params.cookie[`goog:sameParty`];
    }
    if (params.cookie[`goog:sourceScheme`] !== undefined) {
        result.sourceScheme = params.cookie[`goog:sourceScheme`];
    }
    if (params.cookie[`goog:sourcePort`] !== undefined) {
        result.sourcePort = params.cookie[`goog:sourcePort`];
    }
    return result;
}
function sameSiteCdpToBiDi(sameSite) {
    switch (sameSite) {
        case 'Strict':
            return "strict" /* Network.SameSite.Strict */;
        case 'None':
            return "none" /* Network.SameSite.None */;
        case 'Lax':
            return "lax" /* Network.SameSite.Lax */;
        default:
            // Defaults to `Lax`:
            // https://web.dev/articles/samesite-cookies-explained#samesitelax_by_default
            return "lax" /* Network.SameSite.Lax */;
    }
}
function sameSiteBiDiToCdp(sameSite) {
    switch (sameSite) {
        case "strict" /* Network.SameSite.Strict */:
            return 'Strict';
        case "lax" /* Network.SameSite.Lax */:
            return 'Lax';
        case "none" /* Network.SameSite.None */:
            return 'None';
    }
    throw new ErrorResponse_js_1.InvalidArgumentException(`Unknown 'sameSite' value ${sameSite}`);
}
/**
 * Returns true if the given protocol is special.
 * Special protocols are those that have a default port.
 *
 * Example inputs: 'http', 'http:'
 *
 * @see https://url.spec.whatwg.org/#special-scheme
 */
function isSpecialScheme(protocol) {
    return ['ftp', 'file', 'http', 'https', 'ws', 'wss'].includes(protocol.replace(/:$/, ''));
}
/** Matches the given URLPattern against the given URL. */
function matchUrlPattern(urlPattern, url) {
    switch (urlPattern.type) {
        case 'string': {
            const pattern = new UrlPattern_js_1.URLPattern(urlPattern.pattern);
            return new UrlPattern_js_1.URLPattern({
                protocol: pattern.protocol,
                hostname: pattern.hostname,
                port: pattern.port,
                pathname: pattern.pathname,
                search: pattern.search,
            }).test(url);
        }
        case 'pattern':
            return new UrlPattern_js_1.URLPattern(urlPattern).test(url);
    }
}
function bidiBodySizeFromCdpPostDataEntries(entries) {
    let size = 0;
    for (const entry of entries) {
        size += atob(entry.bytes ?? '').length;
    }
    return size;
}
//# sourceMappingURL=NetworkUtils.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/permissions/PermissionsProcessor.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
class PermissionsProcessor {
    #browserCdpClient;
    constructor(browserCdpClient) {
        this.#browserCdpClient = browserCdpClient;
    }
    async setPermissions(params) {
        try {
            const userContextId = params['goog:userContext'] ||
                params.userContext;
            await this.#browserCdpClient.sendCommand('Browser.setPermission', {
                origin: params.origin,
                browserContextId: userContextId && userContextId !== 'default'
                    ? userContextId
                    : undefined,
                permission: {
                    name: params.descriptor.name,
                },
                setting: params.state,
            });
        }
        catch (err) {
            if (err.message ===
                `Permission can't be granted to opaque origins.`) {
                // Return success if the origin is not valid (does not match any
                // existing origins).
                return {};
            }
            throw new protocol_js_1.InvalidArgumentException(err.message);
        }
        return {};
    }
}
exports.PermissionsProcessor = PermissionsProcessor;
//# sourceMappingURL=PermissionsProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelProxy = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
/**
 * Used to send messages from realm to BiDi user.
 */
class ChannelProxy {
    #properties;
    #id = (0, uuid_js_1.uuidv4)();
    #logger;
    constructor(channel, logger) {
        this.#properties = channel;
        this.#logger = logger;
    }
    /**
     * Creates a channel proxy in the given realm, initialises listener and
     * returns a handle to `sendMessage` delegate.
     */
    async init(realm, eventManager) {
        const channelHandle = await ChannelProxy.#createAndGetHandleInRealm(realm);
        const sendMessageHandle = await ChannelProxy.#createSendMessageHandle(realm, channelHandle);
        void this.#startListener(realm, channelHandle, eventManager);
        return sendMessageHandle;
    }
    /** Gets a ChannelProxy from window and returns its handle. */
    async startListenerFromWindow(realm, eventManager) {
        try {
            const channelHandle = await this.#getHandleFromWindow(realm);
            void this.#startListener(realm, channelHandle, eventManager);
        }
        catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, error);
        }
    }
    /**
     * Evaluation string which creates a ChannelProxy object on the client side.
     */
    static #createChannelProxyEvalStr() {
        const functionStr = String(() => {
            const queue = [];
            let queueNonEmptyResolver = null;
            return {
                /**
                 * Gets a promise, which is resolved as soon as a message occurs
                 * in the queue.
                 */
                async getMessage() {
                    const onMessage = queue.length > 0
                        ? Promise.resolve()
                        : new Promise((resolve) => {
                            queueNonEmptyResolver = resolve;
                        });
                    await onMessage;
                    return queue.shift();
                },
                /**
                 * Adds a message to the queue.
                 * Resolves the pending promise if needed.
                 */
                sendMessage(message) {
                    queue.push(message);
                    if (queueNonEmptyResolver !== null) {
                        queueNonEmptyResolver();
                        queueNonEmptyResolver = null;
                    }
                },
            };
        });
        return `(${functionStr})()`;
    }
    /** Creates a ChannelProxy in the given realm. */
    static async #createAndGetHandleInRealm(realm) {
        const createChannelHandleResult = await realm.cdpClient.sendCommand('Runtime.evaluate', {
            expression: this.#createChannelProxyEvalStr(),
            contextId: realm.executionContextId,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        if (createChannelHandleResult.exceptionDetails ||
            createChannelHandleResult.result.objectId === undefined) {
            throw new Error(`Cannot create channel`);
        }
        return createChannelHandleResult.result.objectId;
    }
    /** Gets a handle to `sendMessage` delegate from the ChannelProxy handle. */
    static async #createSendMessageHandle(realm, channelHandle) {
        const sendMessageArgResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((channelHandle) => {
                return channelHandle.sendMessage;
            }),
            arguments: [{ objectId: channelHandle }],
            executionContextId: realm.executionContextId,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        // TODO: check for exceptionDetails.
        return sendMessageArgResult.result.objectId;
    }
    /** Starts listening for the channel events of the provided ChannelProxy. */
    async #startListener(realm, channelHandle, eventManager) {
        // noinspection InfiniteLoopJS
        for (;;) {
            try {
                const message = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String(async (channelHandle) => await channelHandle.getMessage()),
                    arguments: [
                        {
                            objectId: channelHandle,
                        },
                    ],
                    awaitPromise: true,
                    executionContextId: realm.executionContextId,
                    serializationOptions: {
                        serialization: "deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */,
                        maxDepth: this.#properties.serializationOptions?.maxObjectDepth ??
                            undefined,
                    },
                });
                if (message.exceptionDetails) {
                    throw message.exceptionDetails;
                }
                for (const browsingContext of realm.associatedBrowsingContexts) {
                    eventManager.registerEvent({
                        type: 'event',
                        method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,
                        params: {
                            channel: this.#properties.channel,
                            data: realm.cdpToBidiValue(message, this.#properties.ownership ?? "none" /* Script.ResultOwnership.None */),
                            source: realm.source,
                        },
                    }, browsingContext.id);
                }
            }
            catch (error) {
                // If an error is thrown, then the channel is permanently broken, so we
                // exit the loop.
                this.#logger?.(log_js_1.LogType.debugError, error);
                break;
            }
        }
    }
    /**
     * Returns a handle of ChannelProxy from window's property which was set there
     * by `getEvalInWindowStr`. If window property is not set yet, sets a promise
     * resolver to the window property, so that `getEvalInWindowStr` can resolve
     * the promise later on with the channel.
     * This is needed because `getEvalInWindowStr` can be called before or
     * after this method.
     */
    async #getHandleFromWindow(realm) {
        const channelHandleResult = await realm.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((id) => {
                const w = window;
                if (w[id] === undefined) {
                    // The channelProxy is not created yet. Create a promise, put the
                    // resolver to window property and return the promise.
                    // `getEvalInWindowStr` will resolve the promise later.
                    return new Promise((resolve) => (w[id] = resolve));
                }
                // The channelProxy is already created by `getEvalInWindowStr` and
                // is set into window property. Return it.
                const channelProxy = w[id];
                delete w[id];
                return channelProxy;
            }),
            arguments: [{ value: this.#id }],
            executionContextId: realm.executionContextId,
            awaitPromise: true,
            serializationOptions: {
                serialization: "idOnly" /* Protocol.Runtime.SerializationOptionsSerialization.IdOnly */,
            },
        });
        if (channelHandleResult.exceptionDetails !== undefined ||
            channelHandleResult.result.objectId === undefined) {
            throw new Error(`ChannelHandle not found in window["${this.#id}"]`);
        }
        return channelHandleResult.result.objectId;
    }
    /**
     * String to be evaluated to create a ProxyChannel and put it to window.
     * Returns the delegate `sendMessage`. Used to provide an argument for preload
     * script. Does the following:
     * 1. Creates a ChannelProxy.
     * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise
     *    by calling delegate stored in window['${this.#id}'].
     *    This is needed because `#getHandleFromWindow` can be called before or
     *    after this method.
     * 3. Returns the delegate `sendMessage` of the created ChannelProxy.
     */
    getEvalInWindowStr() {
        const delegate = String((id, channelProxy) => {
            const w = window;
            if (w[id] === undefined) {
                // `#getHandleFromWindow` is not initialized yet, and will get the
                // channelProxy later.
                w[id] = channelProxy;
            }
            else {
                // `#getHandleFromWindow` is already set a delegate to window property
                // and is waiting for it to be called with the channelProxy.
                w[id](channelProxy);
                delete w[id];
            }
            return channelProxy.sendMessage;
        });
        const channelProxyEval = ChannelProxy.#createChannelProxyEvalStr();
        return `(${delegate})('${this.#id}',${channelProxyEval})`;
    }
}
exports.ChannelProxy = ChannelProxy;
//# sourceMappingURL=ChannelProxy.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreloadScript = void 0;
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const ChannelProxy_js_1 = __webpack_require__(/*! ./ChannelProxy.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js");
/**
 * BiDi IDs are generated by the server and are unique within contexts.
 *
 * CDP preload script IDs are generated by the client and are unique
 * within sessions.
 *
 * The mapping between BiDi and CDP preload script IDs is 1:many.
 * BiDi IDs are needed by the mapper to keep track of potential multiple CDP IDs
 * in the client.
 */
class PreloadScript {
    /** BiDi ID, an automatically generated UUID. */
    #id = (0, uuid_js_1.uuidv4)();
    /** CDP preload scripts. */
    #cdpPreloadScripts = [];
    /** The script itself, in a format expected by the spec i.e. a function. */
    #functionDeclaration;
    /** Targets, in which the preload script is initialized. */
    #targetIds = new Set();
    /** Channels to be added as arguments to functionDeclaration. */
    #channels;
    /** The script sandbox / world name. */
    #sandbox;
    /** The browsing contexts to execute the preload scripts in, if any. */
    #contexts;
    get id() {
        return this.#id;
    }
    get targetIds() {
        return this.#targetIds;
    }
    constructor(params, logger) {
        this.#channels =
            params.arguments?.map((a) => new ChannelProxy_js_1.ChannelProxy(a.value, logger)) ?? [];
        this.#functionDeclaration = params.functionDeclaration;
        this.#sandbox = params.sandbox;
        this.#contexts = params.contexts;
    }
    /** Channels of the preload script. */
    get channels() {
        return this.#channels;
    }
    /** Contexts of the preload script, if any */
    get contexts() {
        return this.#contexts;
    }
    /**
     * String to be evaluated. Wraps user-provided function so that the following
     * steps are run:
     * 1. Create channels.
     * 2. Store the created channels in window.
     * 3. Call the user-provided function with channels as arguments.
     */
    #getEvaluateString() {
        const channelsArgStr = `[${this.channels
            .map((c) => c.getEvalInWindowStr())
            .join(', ')}]`;
        return `(()=>{(${this.#functionDeclaration})(...${channelsArgStr})})()`;
    }
    /**
     * Adds the script to the given CDP targets by calling the
     * `Page.addScriptToEvaluateOnNewDocument` command.
     */
    async initInTargets(cdpTargets, runImmediately) {
        await Promise.all(Array.from(cdpTargets).map((cdpTarget) => this.initInTarget(cdpTarget, runImmediately)));
    }
    /**
     * Adds the script to the given CDP target by calling the
     * `Page.addScriptToEvaluateOnNewDocument` command.
     */
    async initInTarget(cdpTarget, runImmediately) {
        const addCdpPreloadScriptResult = await cdpTarget.cdpClient.sendCommand('Page.addScriptToEvaluateOnNewDocument', {
            source: this.#getEvaluateString(),
            worldName: this.#sandbox,
            runImmediately,
        });
        this.#cdpPreloadScripts.push({
            target: cdpTarget,
            preloadScriptId: addCdpPreloadScriptResult.identifier,
        });
        this.#targetIds.add(cdpTarget.id);
    }
    /**
     * Removes this script from all CDP targets.
     */
    async remove() {
        await Promise.all([
            this.#cdpPreloadScripts.map(async (cdpPreloadScript) => {
                const cdpTarget = cdpPreloadScript.target;
                const cdpPreloadScriptId = cdpPreloadScript.preloadScriptId;
                return await cdpTarget.cdpClient.sendCommand('Page.removeScriptToEvaluateOnNewDocument', {
                    identifier: cdpPreloadScriptId,
                });
            }),
        ]);
    }
    /** Removes the provided cdp target from the list of cdp preload scripts. */
    dispose(cdpTargetId) {
        this.#cdpPreloadScripts = this.#cdpPreloadScripts.filter((cdpPreloadScript) => cdpPreloadScript.target?.id !== cdpTargetId);
        this.#targetIds.delete(cdpTargetId);
    }
}
exports.PreloadScript = PreloadScript;
//# sourceMappingURL=PreloadScript.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScriptStorage.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreloadScriptStorage = void 0;
/**
 * Container class for preload scripts.
 */
class PreloadScriptStorage {
    /** Tracks all BiDi preload scripts.  */
    #scripts = new Set();
    /**
     * Finds all entries that match the given filter (OR logic).
     */
    find(filter) {
        if (!filter) {
            return [...this.#scripts];
        }
        return [...this.#scripts].filter((script) => {
            if (filter.id !== undefined && filter.id === script.id) {
                return true;
            }
            if (filter.targetId !== undefined &&
                script.targetIds.has(filter.targetId)) {
                return true;
            }
            if (filter.global !== undefined &&
                // Global scripts have no contexts
                ((filter.global && script.contexts === undefined) ||
                    // Non global scripts always have contexts
                    (!filter.global && script.contexts !== undefined))) {
                return true;
            }
            return false;
        });
    }
    add(preloadScript) {
        this.#scripts.add(preloadScript);
    }
    /** Deletes all BiDi preload script entries that match the given filter. */
    remove(filter) {
        for (const preloadScript of this.find(filter)) {
            this.#scripts.delete(preloadScript);
        }
    }
}
exports.PreloadScriptStorage = PreloadScriptStorage;
//# sourceMappingURL=PreloadScriptStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Realm = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const uuid_js_1 = __webpack_require__(/*! ../../../utils/uuid.js */ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js");
const ChannelProxy_js_1 = __webpack_require__(/*! ./ChannelProxy.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ChannelProxy.js");
class Realm {
    #cdpClient;
    #eventManager;
    #executionContextId;
    #logger;
    #origin;
    #realmId;
    #realmStorage;
    constructor(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage) {
        this.#cdpClient = cdpClient;
        this.#eventManager = eventManager;
        this.#executionContextId = executionContextId;
        this.#logger = logger;
        this.#origin = origin;
        this.#realmId = realmId;
        this.#realmStorage = realmStorage;
        this.#realmStorage.addRealm(this);
    }
    cdpToBidiValue(cdpValue, resultOwnership) {
        const bidiValue = this.serializeForBiDi(cdpValue.result.deepSerializedValue, new Map());
        if (cdpValue.result.objectId) {
            const objectId = cdpValue.result.objectId;
            if (resultOwnership === "root" /* Script.ResultOwnership.Root */) {
                // Extend BiDi value with `handle` based on required `resultOwnership`
                // and  CDP response but not on the actual BiDi type.
                bidiValue.handle = objectId;
                // Remember all the handles sent to client.
                this.#realmStorage.knownHandlesToRealmMap.set(objectId, this.realmId);
            }
            else {
                // No need to await for the object to be released.
                void this.#releaseObject(objectId).catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
            }
        }
        return bidiValue;
    }
    /**
     * Relies on the CDP to implement proper BiDi serialization, except:
     * * CDP integer property `backendNodeId` is replaced with `sharedId` of
     * `{documentId}_element_{backendNodeId}`;
     * * CDP integer property `weakLocalObjectReference` is replaced with UUID `internalId`
     * using unique-per serialization `internalIdMap`.
     * * CDP type `platformobject` is replaced with `object`.
     * @param deepSerializedValue - CDP value to be converted to BiDi.
     * @param internalIdMap - Map from CDP integer `weakLocalObjectReference` to BiDi UUID
     * `internalId`.
     */
    serializeForBiDi(deepSerializedValue, internalIdMap) {
        if (Object.hasOwn(deepSerializedValue, 'weakLocalObjectReference')) {
            const weakLocalObjectReference = deepSerializedValue.weakLocalObjectReference;
            if (!internalIdMap.has(weakLocalObjectReference)) {
                internalIdMap.set(weakLocalObjectReference, (0, uuid_js_1.uuidv4)());
            }
            deepSerializedValue.internalId = internalIdMap.get(weakLocalObjectReference);
            delete deepSerializedValue['weakLocalObjectReference'];
        }
        // Platform object is a special case. It should have only `{type: object}`
        // without `value` field.
        if (deepSerializedValue.type === 'platformobject') {
            return { type: 'object' };
        }
        const bidiValue = deepSerializedValue.value;
        if (bidiValue === undefined) {
            return deepSerializedValue;
        }
        // Recursively update the nested values.
        if (['array', 'set', 'htmlcollection', 'nodelist'].includes(deepSerializedValue.type)) {
            for (const i in bidiValue) {
                bidiValue[i] = this.serializeForBiDi(bidiValue[i], internalIdMap);
            }
        }
        if (['object', 'map'].includes(deepSerializedValue.type)) {
            for (const i in bidiValue) {
                bidiValue[i] = [
                    this.serializeForBiDi(bidiValue[i][0], internalIdMap),
                    this.serializeForBiDi(bidiValue[i][1], internalIdMap),
                ];
            }
        }
        return deepSerializedValue;
    }
    get realmId() {
        return this.#realmId;
    }
    get executionContextId() {
        return this.#executionContextId;
    }
    get origin() {
        return this.#origin;
    }
    get source() {
        return {
            realm: this.realmId,
        };
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    get baseInfo() {
        return {
            realm: this.realmId,
            origin: this.origin,
        };
    }
    async evaluate(expression, awaitPromise, resultOwnership = "none" /* Script.ResultOwnership.None */, serializationOptions = {}, userActivation = false, includeCommandLineApi = false) {
        const cdpEvaluateResult = await this.cdpClient.sendCommand('Runtime.evaluate', {
            contextId: this.executionContextId,
            expression,
            awaitPromise,
            serializationOptions: Realm.#getSerializationOptions("deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */, serializationOptions),
            userGesture: userActivation,
            includeCommandLineAPI: includeCommandLineApi,
        });
        if (cdpEvaluateResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpEvaluateResult.exceptionDetails, 0, resultOwnership);
        }
        return {
            realm: this.realmId,
            result: this.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
            type: 'success',
        };
    }
    #registerEvent(event) {
        if (this.associatedBrowsingContexts.length === 0) {
            this.#eventManager.registerEvent(event, null);
        }
        else {
            for (const browsingContext of this.associatedBrowsingContexts) {
                this.#eventManager.registerEvent(event, browsingContext.id);
            }
        }
    }
    initialize() {
        this.#registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
            params: this.realmInfo,
        });
    }
    /**
     * Serializes a given CDP object into BiDi, keeping references in the
     * target's `globalThis`.
     */
    async serializeCdpObject(cdpRemoteObject, resultOwnership) {
        const argument = Realm.#cdpRemoteObjectToCallArgument(cdpRemoteObject);
        const cdpValue = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((remoteObject) => remoteObject),
            awaitPromise: false,
            arguments: [argument],
            serializationOptions: {
                serialization: "deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */,
            },
            executionContextId: this.executionContextId,
        });
        return this.cdpToBidiValue(cdpValue, resultOwnership);
    }
    static #cdpRemoteObjectToCallArgument(cdpRemoteObject) {
        if (cdpRemoteObject.objectId !== undefined) {
            return { objectId: cdpRemoteObject.objectId };
        }
        if (cdpRemoteObject.unserializableValue !== undefined) {
            return { unserializableValue: cdpRemoteObject.unserializableValue };
        }
        return { value: cdpRemoteObject.value };
    }
    /**
     * Gets the string representation of an object. This is equivalent to
     * calling `toString()` on the object value.
     */
    async stringifyObject(cdpRemoteObject) {
        const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
            functionDeclaration: String((remoteObject) => String(remoteObject)),
            awaitPromise: false,
            arguments: [cdpRemoteObject],
            returnByValue: true,
            executionContextId: this.executionContextId,
        });
        return result.value;
    }
    async #flattenKeyValuePairs(mappingLocalValue) {
        const keyValueArray = await Promise.all(mappingLocalValue.map(async ([key, value]) => {
            let keyArg;
            if (typeof key === 'string') {
                // Key is a string.
                keyArg = { value: key };
            }
            else {
                // Key is a serialized value.
                keyArg = await this.deserializeForCdp(key);
            }
            const valueArg = await this.deserializeForCdp(value);
            return [keyArg, valueArg];
        }));
        return keyValueArray.flat();
    }
    async #flattenValueList(listLocalValue) {
        return await Promise.all(listLocalValue.map((localValue) => this.deserializeForCdp(localValue)));
    }
    async #serializeCdpExceptionDetails(cdpExceptionDetails, lineOffset, resultOwnership) {
        const callFrames = cdpExceptionDetails.stackTrace?.callFrames.map((frame) => ({
            url: frame.url,
            functionName: frame.functionName,
            lineNumber: frame.lineNumber - lineOffset,
            columnNumber: frame.columnNumber,
        })) ?? [];
        // Exception should always be there.
        const exception = cdpExceptionDetails.exception;
        return {
            exception: await this.serializeCdpObject(exception, resultOwnership),
            columnNumber: cdpExceptionDetails.columnNumber,
            lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
            stackTrace: {
                callFrames,
            },
            text: (await this.stringifyObject(exception)) || cdpExceptionDetails.text,
        };
    }
    async callFunction(functionDeclaration, awaitPromise, thisLocalValue = {
        type: 'undefined',
    }, argumentsLocalValues = [], resultOwnership = "none" /* Script.ResultOwnership.None */, serializationOptions = {}, userActivation = false) {
        const callFunctionAndSerializeScript = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${functionDeclaration}
      ), args);
    }`;
        const thisAndArgumentsList = [
            await this.deserializeForCdp(thisLocalValue),
            ...(await Promise.all(argumentsLocalValues.map(async (argumentLocalValue) => await this.deserializeForCdp(argumentLocalValue)))),
        ];
        let cdpCallFunctionResult;
        try {
            cdpCallFunctionResult = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                functionDeclaration: callFunctionAndSerializeScript,
                awaitPromise,
                arguments: thisAndArgumentsList,
                serializationOptions: Realm.#getSerializationOptions("deep" /* Protocol.Runtime.SerializationOptionsSerialization.Deep */, serializationOptions),
                executionContextId: this.executionContextId,
                userGesture: userActivation,
            });
        }
        catch (error) {
            // Heuristic to determine if the problem is in the argument.
            // The check can be done on the `deserialization` step, but this approach
            // helps to save round-trips.
            if (error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                [
                    'Could not find object with given id',
                    'Argument should belong to the same JavaScript world as target object',
                    'Invalid remote object id',
                ].includes(error.message)) {
                throw new protocol_js_1.NoSuchHandleException('Handle was not found.');
            }
            throw error;
        }
        if (cdpCallFunctionResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpCallFunctionResult.exceptionDetails, 1, resultOwnership);
        }
        return {
            type: 'success',
            result: this.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
            realm: this.realmId,
        };
    }
    async deserializeForCdp(localValue) {
        if ('handle' in localValue && localValue.handle) {
            return { objectId: localValue.handle };
            // We tried to find a handle value but failed
            // This allows us to have exhaustive switch on `localValue.type`
        }
        else if ('handle' in localValue || 'sharedId' in localValue) {
            throw new protocol_js_1.NoSuchHandleException('Handle was not found.');
        }
        switch (localValue.type) {
            case 'undefined':
                return { unserializableValue: 'undefined' };
            case 'null':
                return { unserializableValue: 'null' };
            case 'string':
                return { value: localValue.value };
            case 'number':
                if (localValue.value === 'NaN') {
                    return { unserializableValue: 'NaN' };
                }
                else if (localValue.value === '-0') {
                    return { unserializableValue: '-0' };
                }
                else if (localValue.value === 'Infinity') {
                    return { unserializableValue: 'Infinity' };
                }
                else if (localValue.value === '-Infinity') {
                    return { unserializableValue: '-Infinity' };
                }
                return {
                    value: localValue.value,
                };
            case 'boolean':
                return { value: Boolean(localValue.value) };
            case 'bigint':
                return {
                    unserializableValue: `BigInt(${JSON.stringify(localValue.value)})`,
                };
            case 'date':
                return {
                    unserializableValue: `new Date(Date.parse(${JSON.stringify(localValue.value)}))`,
                };
            case 'regexp':
                return {
                    unserializableValue: `new RegExp(${JSON.stringify(localValue.value.pattern)}, ${JSON.stringify(localValue.value.flags)})`,
                };
            case 'map': {
                // TODO: If none of the nested keys and values has a remote
                // reference, serialize to `unserializableValue` without CDP roundtrip.
                const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => {
                        const result = new Map();
                        for (let i = 0; i < args.length; i += 2) {
                            result.set(args[i], args[i + 1]);
                        }
                        return result;
                    }),
                    awaitPromise: false,
                    arguments: keyValueArray,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'object': {
                // TODO: If none of the nested keys and values has a remote
                // reference, serialize to `unserializableValue` without CDP roundtrip.
                const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => {
                        const result = {};
                        for (let i = 0; i < args.length; i += 2) {
                            // Key should be either `string`, `number`, or `symbol`.
                            const key = args[i];
                            result[key] = args[i + 1];
                        }
                        return result;
                    }),
                    awaitPromise: false,
                    arguments: keyValueArray,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'array': {
                // TODO: If none of the nested items has a remote reference,
                // serialize to `unserializableValue` without CDP roundtrip.
                const args = await this.#flattenValueList(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => args),
                    awaitPromise: false,
                    arguments: args,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'set': {
                // TODO: if none of the nested items has a remote reference,
                // serialize to `unserializableValue` without CDP roundtrip.
                const args = await this.#flattenValueList(localValue.value);
                const { result } = await this.cdpClient.sendCommand('Runtime.callFunctionOn', {
                    functionDeclaration: String((...args) => new Set(args)),
                    awaitPromise: false,
                    arguments: args,
                    returnByValue: false,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `result.objectId` after using.
                return { objectId: result.objectId };
            }
            case 'channel': {
                const channelProxy = new ChannelProxy_js_1.ChannelProxy(localValue.value, this.#logger);
                const channelProxySendMessageHandle = await channelProxy.init(this, this.#eventManager);
                return { objectId: channelProxySendMessageHandle };
            }
            // TODO(#375): Dispose of nested objects.
        }
        // Intentionally outside to handle unknown types
        throw new Error(`Value ${JSON.stringify(localValue)} is not deserializable.`);
    }
    async #getExceptionResult(exceptionDetails, lineOffset, resultOwnership) {
        return {
            exceptionDetails: await this.#serializeCdpExceptionDetails(exceptionDetails, lineOffset, resultOwnership),
            realm: this.realmId,
            type: 'exception',
        };
    }
    static #getSerializationOptions(serialization, serializationOptions) {
        return {
            serialization,
            additionalParameters: Realm.#getAdditionalSerializationParameters(serializationOptions),
            ...Realm.#getMaxObjectDepth(serializationOptions),
        };
    }
    static #getAdditionalSerializationParameters(serializationOptions) {
        const additionalParameters = {};
        if (serializationOptions.maxDomDepth !== undefined) {
            additionalParameters['maxNodeDepth'] =
                serializationOptions.maxDomDepth === null
                    ? 1000
                    : serializationOptions.maxDomDepth;
        }
        if (serializationOptions.includeShadowTree !== undefined) {
            additionalParameters['includeShadowTree'] =
                serializationOptions.includeShadowTree;
        }
        return additionalParameters;
    }
    static #getMaxObjectDepth(serializationOptions) {
        return serializationOptions.maxObjectDepth === undefined ||
            serializationOptions.maxObjectDepth === null
            ? {}
            : { maxDepth: serializationOptions.maxObjectDepth };
    }
    async #releaseObject(handle) {
        try {
            await this.cdpClient.sendCommand('Runtime.releaseObject', {
                objectId: handle,
            });
        }
        catch (error) {
            // Heuristic to determine if the problem is in the unknown handler.
            // Ignore the error if so.
            if (!(error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                error.message === 'Invalid remote object id')) {
                throw error;
            }
        }
    }
    async disown(handle) {
        // Disowning an object from different realm does nothing.
        if (this.#realmStorage.knownHandlesToRealmMap.get(handle) !== this.realmId) {
            return;
        }
        await this.#releaseObject(handle);
        this.#realmStorage.knownHandlesToRealmMap.delete(handle);
    }
    dispose() {
        this.#registerEvent({
            type: 'event',
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmDestroyed,
            params: {
                realm: this.realmId,
            },
        });
    }
}
exports.Realm = Realm;
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/RealmStorage.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RealmStorage = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const WindowRealm_js_1 = __webpack_require__(/*! ./WindowRealm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js");
/** Container class for browsing realms. */
class RealmStorage {
    /** Tracks handles and their realms sent to the client. */
    #knownHandlesToRealmMap = new Map();
    /** Map from realm ID to Realm. */
    #realmMap = new Map();
    get knownHandlesToRealmMap() {
        return this.#knownHandlesToRealmMap;
    }
    addRealm(realm) {
        this.#realmMap.set(realm.realmId, realm);
    }
    /** Finds all realms that match the given filter. */
    findRealms(filter) {
        return Array.from(this.#realmMap.values()).filter((realm) => {
            if (filter.realmId !== undefined && filter.realmId !== realm.realmId) {
                return false;
            }
            if (filter.browsingContextId !== undefined &&
                !realm.associatedBrowsingContexts
                    .map((browsingContext) => browsingContext.id)
                    .includes(filter.browsingContextId)) {
                return false;
            }
            if (filter.sandbox !== undefined &&
                (!(realm instanceof WindowRealm_js_1.WindowRealm) || filter.sandbox !== realm.sandbox)) {
                return false;
            }
            if (filter.executionContextId !== undefined &&
                filter.executionContextId !== realm.executionContextId) {
                return false;
            }
            if (filter.origin !== undefined && filter.origin !== realm.origin) {
                return false;
            }
            if (filter.type !== undefined && filter.type !== realm.realmType) {
                return false;
            }
            if (filter.cdpSessionId !== undefined &&
                filter.cdpSessionId !== realm.cdpClient.sessionId) {
                return false;
            }
            return true;
        });
    }
    findRealm(filter) {
        const maybeRealms = this.findRealms(filter);
        if (maybeRealms.length !== 1) {
            return undefined;
        }
        return maybeRealms[0];
    }
    /** Gets the only realm that matches the given filter, if any, otherwise throws. */
    getRealm(filter) {
        const maybeRealm = this.findRealm(filter);
        if (maybeRealm === undefined) {
            throw new protocol_js_1.NoSuchFrameException(`Realm ${JSON.stringify(filter)} not found`);
        }
        return maybeRealm;
    }
    /** Deletes all realms that match the given filter. */
    deleteRealms(filter) {
        this.findRealms(filter).map((realm) => {
            realm.dispose();
            this.#realmMap.delete(realm.realmId);
            Array.from(this.knownHandlesToRealmMap.entries())
                .filter(([, r]) => r === realm.realmId)
                .map(([handle]) => this.knownHandlesToRealmMap.delete(handle));
        });
    }
}
exports.RealmStorage = RealmStorage;
//# sourceMappingURL=RealmStorage.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/ScriptProcessor.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const PreloadScript_js_1 = __webpack_require__(/*! ./PreloadScript.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/PreloadScript.js");
class ScriptProcessor {
    #browsingContextStorage;
    #realmStorage;
    #preloadScriptStorage;
    #logger;
    constructor(browsingContextStorage, realmStorage, preloadScriptStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#realmStorage = realmStorage;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#logger = logger;
    }
    async addPreloadScript(params) {
        const contexts = this.#browsingContextStorage.verifyTopLevelContextsList(params.contexts);
        const preloadScript = new PreloadScript_js_1.PreloadScript(params, this.#logger);
        this.#preloadScriptStorage.add(preloadScript);
        const cdpTargets = contexts.size === 0
            ? new Set(this.#browsingContextStorage
                .getTopLevelContexts()
                .map((context) => context.cdpTarget))
            : new Set([...contexts.values()].map((context) => context.cdpTarget));
        await preloadScript.initInTargets(cdpTargets, false);
        return {
            script: preloadScript.id,
        };
    }
    async removePreloadScript(params) {
        const { script: id } = params;
        const scripts = this.#preloadScriptStorage.find({ id });
        if (scripts.length === 0) {
            throw new protocol_js_1.NoSuchScriptException(`No preload script with id '${id}'`);
        }
        await Promise.all(scripts.map((script) => script.remove()));
        this.#preloadScriptStorage.remove({ id });
        return {};
    }
    async callFunction(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.callFunction(params.functionDeclaration, params.awaitPromise, params.this, params.arguments, params.resultOwnership, params.serializationOptions, params.userActivation);
    }
    async evaluate(params) {
        const realm = await this.#getRealm(params.target);
        return await realm.evaluate(params.expression, params.awaitPromise, params.resultOwnership, params.serializationOptions, params.userActivation);
    }
    async disown(params) {
        const realm = await this.#getRealm(params.target);
        await Promise.all(params.handles.map(async (handle) => await realm.disown(handle)));
        return {};
    }
    getRealms(params) {
        if (params.context !== undefined) {
            // Make sure the context is known.
            this.#browsingContextStorage.getContext(params.context);
        }
        const realms = this.#realmStorage
            .findRealms({
            browsingContextId: params.context,
            type: params.type,
        })
            .map((realm) => realm.realmInfo);
        return { realms };
    }
    async #getRealm(target) {
        if ('context' in target) {
            const context = this.#browsingContextStorage.getContext(target.context);
            return await context.getOrCreateSandbox(target.sandbox);
        }
        return this.#realmStorage.getRealm({
            realmId: target.realm,
        });
    }
}
exports.ScriptProcessor = ScriptProcessor;
//# sourceMappingURL=ScriptProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSharedId = getSharedId;
exports.parseSharedId = parseSharedId;
const SHARED_ID_DIVIDER = '_element_';
function getSharedId(frameId, documentId, backendNodeId) {
    return `f.${frameId}.d.${documentId}.e.${backendNodeId}`;
}
function parseLegacySharedId(sharedId) {
    const match = sharedId.match(new RegExp(`(.*)${SHARED_ID_DIVIDER}(.*)`));
    if (!match) {
        // SharedId is incorrectly formatted.
        return null;
    }
    const documentId = match[1];
    const elementId = match[2];
    if (documentId === undefined || elementId === undefined) {
        return null;
    }
    const backendNodeId = parseInt(elementId ?? '');
    if (isNaN(backendNodeId)) {
        return null;
    }
    return {
        documentId,
        backendNodeId,
    };
}
function parseSharedId(sharedId) {
    // TODO: remove legacy check once ChromeDriver provides sharedId in the new format.
    const legacyFormattedSharedId = parseLegacySharedId(sharedId);
    if (legacyFormattedSharedId !== null) {
        return { ...legacyFormattedSharedId, frameId: undefined };
    }
    const match = sharedId.match(/f\.(.*)\.d\.(.*)\.e\.([0-9]*)/);
    if (!match) {
        // SharedId is incorrectly formatted.
        return null;
    }
    const frameId = match[1];
    const documentId = match[2];
    const elementId = match[3];
    if (frameId === undefined ||
        documentId === undefined ||
        elementId === undefined) {
        return null;
    }
    const backendNodeId = parseInt(elementId ?? '');
    if (isNaN(backendNodeId)) {
        return null;
    }
    return {
        frameId,
        documentId,
        backendNodeId,
    };
}
//# sourceMappingURL=SharedId.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WindowRealm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowRealm = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Realm_js_1 = __webpack_require__(/*! ./Realm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js");
const SharedId_js_1 = __webpack_require__(/*! ./SharedId.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/SharedId.js");
class WindowRealm extends Realm_js_1.Realm {
    #browsingContextId;
    #browsingContextStorage;
    sandbox;
    constructor(browsingContextId, browsingContextStorage, cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage, sandbox) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#browsingContextId = browsingContextId;
        this.#browsingContextStorage = browsingContextStorage;
        this.sandbox = sandbox;
        this.initialize();
    }
    #getBrowsingContextId(navigableId) {
        const maybeBrowsingContext = this.#browsingContextStorage
            .getAllContexts()
            .find((context) => context.navigableId === navigableId);
        return maybeBrowsingContext?.id ?? 'UNKNOWN';
    }
    get browsingContext() {
        return this.#browsingContextStorage.getContext(this.#browsingContextId);
    }
    get associatedBrowsingContexts() {
        return [this.browsingContext];
    }
    get realmType() {
        return 'window';
    }
    get realmInfo() {
        return {
            ...this.baseInfo,
            type: this.realmType,
            context: this.#browsingContextId,
            sandbox: this.sandbox,
        };
    }
    get source() {
        return {
            realm: this.realmId,
            context: this.browsingContext.id,
        };
    }
    serializeForBiDi(deepSerializedValue, internalIdMap) {
        const bidiValue = deepSerializedValue.value;
        if (deepSerializedValue.type === 'node' && bidiValue !== undefined) {
            if (Object.hasOwn(bidiValue, 'backendNodeId')) {
                let navigableId = this.browsingContext.navigableId ?? 'UNKNOWN';
                if (Object.hasOwn(bidiValue, 'loaderId')) {
                    // `loaderId` should be always there after ~2024-03-05, when
                    // https://crrev.com/c/5116240 reaches stable.
                    // TODO: remove the check after the date.
                    navigableId = bidiValue.loaderId;
                    delete bidiValue['loaderId'];
                }
                deepSerializedValue.sharedId =
                    (0, SharedId_js_1.getSharedId)(this.#getBrowsingContextId(navigableId), navigableId, bidiValue.backendNodeId);
                delete bidiValue['backendNodeId'];
            }
            if (Object.hasOwn(bidiValue, 'children')) {
                for (const i in bidiValue.children) {
                    bidiValue.children[i] = this.serializeForBiDi(bidiValue.children[i], internalIdMap);
                }
            }
            if (Object.hasOwn(bidiValue, 'shadowRoot') &&
                bidiValue.shadowRoot !== null) {
                bidiValue.shadowRoot = this.serializeForBiDi(bidiValue.shadowRoot, internalIdMap);
            }
            // `namespaceURI` can be is either `null` or non-empty string.
            if (bidiValue.namespaceURI === '') {
                bidiValue.namespaceURI = null;
            }
        }
        return super.serializeForBiDi(deepSerializedValue, internalIdMap);
    }
    async deserializeForCdp(localValue) {
        if ('sharedId' in localValue && localValue.sharedId) {
            const parsedSharedId = (0, SharedId_js_1.parseSharedId)(localValue.sharedId);
            if (parsedSharedId === null) {
                throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
            }
            const { documentId, backendNodeId } = parsedSharedId;
            // TODO: add proper validation if the element is accessible from the current realm.
            if (this.browsingContext.navigableId !== documentId) {
                throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" belongs to different document. Current document is ${this.browsingContext.navigableId}.`);
            }
            try {
                const { object } = await this.cdpClient.sendCommand('DOM.resolveNode', {
                    backendNodeId,
                    executionContextId: this.executionContextId,
                });
                // TODO(#375): Release `obj.object.objectId` after using.
                return { objectId: object.objectId };
            }
            catch (error) {
                // Heuristic to detect "no such node" exception. Based on the  specific
                // CDP implementation.
                if (error.code === -32000 /* CdpErrorConstants.GENERIC_ERROR */ &&
                    error.message === 'No node with given id found') {
                    throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
                }
                throw new protocol_js_1.UnknownErrorException(error.message, error.stack);
            }
        }
        return await super.deserializeForCdp(localValue);
    }
    async evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi) {
        await this.#browsingContextStorage
            .getContext(this.#browsingContextId)
            .targetUnblockedOrThrow();
        return await super.evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation, includeCommandLineApi);
    }
    async callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation) {
        await this.#browsingContextStorage
            .getContext(this.#browsingContextId)
            .targetUnblockedOrThrow();
        return await super.callFunction(functionDeclaration, awaitPromise, thisLocalValue, argumentsLocalValues, resultOwnership, serializationOptions, userActivation);
    }
}
exports.WindowRealm = WindowRealm;
//# sourceMappingURL=WindowRealm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/WorkerRealm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkerRealm = void 0;
const Realm_js_1 = __webpack_require__(/*! ./Realm.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/script/Realm.js");
class WorkerRealm extends Realm_js_1.Realm {
    #realmType;
    #ownerRealms;
    constructor(cdpClient, eventManager, executionContextId, logger, origin, ownerRealms, realmId, realmStorage, realmType) {
        super(cdpClient, eventManager, executionContextId, logger, origin, realmId, realmStorage);
        this.#ownerRealms = ownerRealms;
        this.#realmType = realmType;
        this.initialize();
    }
    get associatedBrowsingContexts() {
        return this.#ownerRealms.flatMap((realm) => realm.associatedBrowsingContexts);
    }
    get realmType() {
        return this.#realmType;
    }
    get source() {
        return {
            realm: this.realmId,
            // This is a hack to make Puppeteer able to track workers.
            // TODO: remove after Puppeteer tracks workers by owners and use the base version.
            context: this.associatedBrowsingContexts[0]?.id,
        };
    }
    get realmInfo() {
        const owners = this.#ownerRealms.map((realm) => realm.realmId);
        const { realmType } = this;
        switch (realmType) {
            case 'dedicated-worker': {
                const owner = owners[0];
                if (owner === undefined || owners.length !== 1) {
                    throw new Error('Dedicated worker must have exactly one owner');
                }
                return {
                    ...this.baseInfo,
                    type: realmType,
                    owners: [owner],
                };
            }
            case 'service-worker':
            case 'shared-worker': {
                return {
                    ...this.baseInfo,
                    type: realmType,
                };
            }
        }
    }
}
exports.WorkerRealm = WorkerRealm;
//# sourceMappingURL=WorkerRealm.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/EventManager.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventManager = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const Buffer_js_1 = __webpack_require__(/*! ../../../utils/Buffer.js */ "./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js");
const DefaultMap_js_1 = __webpack_require__(/*! ../../../utils/DefaultMap.js */ "./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js");
const DistinctValues_js_1 = __webpack_require__(/*! ../../../utils/DistinctValues.js */ "./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js");
const EventEmitter_js_1 = __webpack_require__(/*! ../../../utils/EventEmitter.js */ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js");
const IdWrapper_js_1 = __webpack_require__(/*! ../../../utils/IdWrapper.js */ "./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js");
const OutgoingMessage_js_1 = __webpack_require__(/*! ../../OutgoingMessage.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js");
const events_js_1 = __webpack_require__(/*! ./events.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js");
const SubscriptionManager_js_1 = __webpack_require__(/*! ./SubscriptionManager.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js");
class EventWrapper {
    #idWrapper = new IdWrapper_js_1.IdWrapper();
    #contextId;
    #event;
    constructor(event, contextId) {
        this.#event = event;
        this.#contextId = contextId;
    }
    get id() {
        return this.#idWrapper.id;
    }
    get contextId() {
        return this.#contextId;
    }
    get event() {
        return this.#event;
    }
}
/**
 * Maps event name to a desired buffer length.
 */
const eventBufferLength = new Map([[protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
class EventManager extends EventEmitter_js_1.EventEmitter {
    /**
     * Maps event name to a set of contexts where this event already happened.
     * Needed for getting buffered events from all the contexts in case of
     * subscripting to all contexts.
     */
    #eventToContextsMap = new DefaultMap_js_1.DefaultMap(() => new Set());
    /**
     * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
     * during subscription. Channel-agnostic.
     */
    #eventBuffers = new Map();
    /**
     * Maps `eventName` + `browsingContext` + `channel` to last sent event id.
     * Used to avoid sending duplicated events when user
     * subscribes -> unsubscribes -> subscribes.
     */
    #lastMessageSent = new Map();
    #subscriptionManager;
    #browsingContextStorage;
    /**
     * Map of event name to hooks to be called when client is subscribed to the event.
     */
    #subscribeHooks;
    constructor(browsingContextStorage) {
        super();
        this.#browsingContextStorage = browsingContextStorage;
        this.#subscriptionManager = new SubscriptionManager_js_1.SubscriptionManager(browsingContextStorage);
        this.#subscribeHooks = new DefaultMap_js_1.DefaultMap(() => []);
    }
    get subscriptionManager() {
        return this.#subscriptionManager;
    }
    /**
     * Returns consistent key to be used to access value maps.
     */
    static #getMapKey(eventName, browsingContext, channel) {
        return JSON.stringify({ eventName, browsingContext, channel });
    }
    addSubscribeHook(event, hook) {
        this.#subscribeHooks.get(event).push(hook);
    }
    registerEvent(event, contextId) {
        this.registerPromiseEvent(Promise.resolve({
            kind: 'success',
            value: event,
        }), contextId, event.method);
    }
    registerPromiseEvent(event, contextId, eventName) {
        const eventWrapper = new EventWrapper(event, contextId);
        const sortedChannels = this.#subscriptionManager.getChannelsSubscribedToEvent(eventName, contextId);
        this.#bufferEvent(eventWrapper, eventName);
        // Send events to channels in the subscription priority.
        for (const channel of sortedChannels) {
            this.emit("event" /* EventManagerEvents.Event */, {
                message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
                event: eventName,
            });
            this.#markEventSent(eventWrapper, channel, eventName);
        }
    }
    async subscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name);
        }
        // First check if all the contexts are known.
        for (const contextId of contextIds) {
            if (contextId !== null) {
                // Assert the context is known. Throw exception otherwise.
                this.#browsingContextStorage.getContext(contextId);
            }
        }
        // List of the subscription items that were actually added. Each contains a specific
        // event and context. No domain event (like "network") or global context subscription
        // (like null) are included.
        const addedSubscriptionItems = [];
        for (const eventName of eventNames) {
            for (const contextId of contextIds) {
                addedSubscriptionItems.push(...this.#subscriptionManager.subscribe(eventName, contextId, channel));
                for (const eventWrapper of this.#getBufferedEvents(eventName, contextId, channel)) {
                    // The order of the events is important.
                    this.emit("event" /* EventManagerEvents.Event */, {
                        message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(eventWrapper.event, channel),
                        event: eventName,
                    });
                    this.#markEventSent(eventWrapper, channel, eventName);
                }
            }
        }
        // Iterate over all new subscription items and call hooks if any. There can be
        // duplicates, e.g. when subscribing to the whole domain and some specific event in
        // the same time ("network", "network.responseCompleted"). `distinctValues` guarantees
        // that hooks are called only once per pair event + context.
        (0, DistinctValues_js_1.distinctValues)(addedSubscriptionItems).forEach(({ contextId, event }) => {
            this.#subscribeHooks.get(event).forEach((hook) => hook(contextId));
        });
        await this.toggleModulesIfNeeded();
    }
    async unsubscribe(eventNames, contextIds, channel) {
        for (const name of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name);
        }
        this.#subscriptionManager.unsubscribeAll(eventNames, contextIds, channel);
        await this.toggleModulesIfNeeded();
    }
    async toggleModulesIfNeeded() {
        // TODO(1): Only update changed subscribers
        // TODO(2): Enable for Worker Targets
        await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            return await context.toggleModulesIfNeeded();
        }));
    }
    /**
     * If the event is buffer-able, put it in the buffer.
     */
    #bufferEvent(eventWrapper, eventName) {
        if (!eventBufferLength.has(eventName)) {
            // Do nothing if the event is no buffer-able.
            return;
        }
        const bufferMapKey = EventManager.#getMapKey(eventName, eventWrapper.contextId);
        if (!this.#eventBuffers.has(bufferMapKey)) {
            this.#eventBuffers.set(bufferMapKey, new Buffer_js_1.Buffer(eventBufferLength.get(eventName)));
        }
        this.#eventBuffers.get(bufferMapKey).add(eventWrapper);
        // Add the context to the list of contexts having `eventName` events.
        this.#eventToContextsMap.get(eventName).add(eventWrapper.contextId);
    }
    /**
     * If the event is buffer-able, mark it as sent to the given contextId and channel.
     */
    #markEventSent(eventWrapper, channel, eventName) {
        if (!eventBufferLength.has(eventName)) {
            // Do nothing if the event is no buffer-able.
            return;
        }
        const lastSentMapKey = EventManager.#getMapKey(eventName, eventWrapper.contextId, channel);
        this.#lastMessageSent.set(lastSentMapKey, Math.max(this.#lastMessageSent.get(lastSentMapKey) ?? 0, eventWrapper.id));
    }
    /**
     * Returns events which are buffered and not yet sent to the given channel events.
     */
    #getBufferedEvents(eventName, contextId, channel) {
        const bufferMapKey = EventManager.#getMapKey(eventName, contextId);
        const lastSentMapKey = EventManager.#getMapKey(eventName, contextId, channel);
        const lastSentMessageId = this.#lastMessageSent.get(lastSentMapKey) ?? -Infinity;
        const result = this.#eventBuffers
            .get(bufferMapKey)
            ?.get()
            .filter((wrapper) => wrapper.id > lastSentMessageId) ?? [];
        if (contextId === null) {
            // For global subscriptions, events buffered in each context should be sent back.
            Array.from(this.#eventToContextsMap.get(eventName).keys())
                .filter((_contextId) => 
            // Events without context are already in the result.
            _contextId !== null &&
                // Events from deleted contexts should not be sent.
                this.#browsingContextStorage.hasContext(_contextId))
                .map((_contextId) => this.#getBufferedEvents(eventName, _contextId, channel))
                .forEach((events) => result.push(...events));
        }
        return result.sort((e1, e2) => e1.id - e2.id);
    }
}
exports.EventManager = EventManager;
//# sourceMappingURL=EventManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SessionProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionProcessor = void 0;
class SessionProcessor {
    #eventManager;
    #browserCdpClient;
    constructor(eventManager, browserCdpClient) {
        this.#eventManager = eventManager;
        this.#browserCdpClient = browserCdpClient;
    }
    status() {
        return { ready: false, message: 'already connected' };
    }
    async create(_params) {
        // Since mapper exists, there is a session already.
        // Still the mapper can handle capabilities for us.
        // Currently, only Puppeteer calls here but, eventually, every client
        // should delegrate capability processing here.
        const version = await this.#browserCdpClient.sendCommand('Browser.getVersion');
        return {
            sessionId: 'unknown',
            capabilities: {
                acceptInsecureCerts: false,
                browserName: version.product,
                browserVersion: version.revision,
                platformName: '',
                setWindowRect: false,
                webSocketUrl: '',
                userAgent: version.userAgent,
            },
        };
    }
    async subscribe(params, channel = null) {
        await this.#eventManager.subscribe(params.events, params.contexts ?? [null], channel);
        return {};
    }
    async unsubscribe(params, channel = null) {
        await this.#eventManager.unsubscribe(params.events, params.contexts ?? [null], channel);
        return {};
    }
}
exports.SessionProcessor = SessionProcessor;
//# sourceMappingURL=SessionProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/SubscriptionManager.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubscriptionManager = void 0;
exports.cartesianProduct = cartesianProduct;
exports.unrollEvents = unrollEvents;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const events_js_1 = __webpack_require__(/*! ./events.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js");
/**
 * Returns the cartesian product of the given arrays.
 *
 * Example:
 *   cartesian([1, 2], ['a', 'b']); => [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
 */
function cartesianProduct(...a) {
    return a.reduce((a, b) => a.flatMap((d) => b.map((e) => [d, e].flat())));
}
/** Expands "AllEvents" events into atomic events. */
function unrollEvents(events) {
    const allEvents = new Set();
    function addEvents(events) {
        for (const event of events) {
            allEvents.add(event);
        }
    }
    for (const event of events) {
        switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Log.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Network.EventNames));
                break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
                addEvents(Object.values(protocol_js_1.ChromiumBidi.Script.EventNames));
                break;
            default:
                allEvents.add(event);
        }
    }
    return [...allEvents.values()];
}
class SubscriptionManager {
    #subscriptionPriority = 0;
    // BrowsingContext `null` means the event has subscription across all the
    // browsing contexts.
    // Channel `null` means no `channel` should be added.
    #channelToContextToEventMap = new Map();
    #browsingContextStorage;
    constructor(browsingContextStorage) {
        this.#browsingContextStorage = browsingContextStorage;
    }
    getChannelsSubscribedToEvent(eventMethod, contextId) {
        const prioritiesAndChannels = Array.from(this.#channelToContextToEventMap.keys())
            .map((channel) => ({
            priority: this.#getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel),
            channel,
        }))
            .filter(({ priority }) => priority !== null);
        // Sort channels by priority.
        return prioritiesAndChannels
            .sort((a, b) => a.priority - b.priority)
            .map(({ channel }) => channel);
    }
    #getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel) {
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (contextToEventMap === undefined) {
            return null;
        }
        const maybeTopLevelContextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        // `null` covers global subscription.
        const relevantContexts = [...new Set([null, maybeTopLevelContextId])];
        // Get all the subscription priorities.
        const priorities = relevantContexts
            .map((context) => {
            // Get the priority for exact event name
            const priority = contextToEventMap.get(context)?.get(eventMethod);
            // For CDP we can't provide specific event name when subscribing
            // to the module directly.
            // Because of that we need to see event `cdp` exits in the map.
            if ((0, events_js_1.isCdpEvent)(eventMethod)) {
                const cdpPriority = contextToEventMap
                    .get(context)
                    ?.get(protocol_js_1.ChromiumBidi.BiDiModule.Cdp);
                // If we subscribe to the event directly and `cdp` module as well
                // priority will be different we take minimal priority
                return priority && cdpPriority
                    ? Math.min(priority, cdpPriority)
                    : // At this point we know that we have subscribed
                        // to only one of the two
                        priority ?? cdpPriority;
            }
            return priority;
        })
            .filter((p) => p !== undefined);
        if (priorities.length === 0) {
            // Not subscribed, return null.
            return null;
        }
        // Return minimal priority.
        return Math.min(...priorities);
    }
    /**
     * @param module BiDi+ module
     * @param contextId `null` == globally subscribed
     *
     * @returns
     */
    isSubscribedTo(moduleOrEvent, contextId = null) {
        const topLevelContext = this.#browsingContextStorage.findTopLevelContextId(contextId);
        for (const browserContextToEventMap of this.#channelToContextToEventMap.values()) {
            for (const [id, eventMap] of browserContextToEventMap.entries()) {
                // Not subscribed to this context or globally
                if (topLevelContext !== id && id !== null) {
                    continue;
                }
                for (const event of eventMap.keys()) {
                    // This also covers the `cdp` case where
                    // we don't unroll the event names
                    if (
                    // Event explicitly subscribed
                    event === moduleOrEvent ||
                        // Event subscribed via module
                        event === moduleOrEvent.split('.').at(0) ||
                        // Event explicitly subscribed compared to module
                        event.split('.').at(0) === moduleOrEvent) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    /**
     * Subscribes to event in the given context and channel.
     * @param {EventNames} event
     * @param {BrowsingContext.BrowsingContext | null} contextId
     * @param {BidiPlusChannel} channel
     * @return {SubscriptionItem[]} List of
     * subscriptions. If the event is a whole module, it will return all the specific
     * events. If the contextId is null, it will return all the top-level contexts which were
     * not subscribed before the command.
     */
    subscribe(event, contextId, channel) {
        // All the subscriptions are handled on the top-level contexts.
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        // Check if subscribed event is a whole module
        switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
                return Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
                return Object.values(protocol_js_1.ChromiumBidi.Log.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
                return Object.values(protocol_js_1.ChromiumBidi.Network.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
                return Object.values(protocol_js_1.ChromiumBidi.Script.EventNames)
                    .map((specificEvent) => this.subscribe(specificEvent, contextId, channel))
                    .flat();
            default:
            // Intentionally left empty.
        }
        if (!this.#channelToContextToEventMap.has(channel)) {
            this.#channelToContextToEventMap.set(channel, new Map());
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
            contextToEventMap.set(contextId, new Map());
        }
        const eventMap = contextToEventMap.get(contextId);
        const affectedContextIds = (contextId === null
            ? this.#browsingContextStorage.getTopLevelContexts().map((c) => c.id)
            : [contextId])
            // There can be contexts that are already subscribed to the event. Do not include
            // them to the output.
            .filter((contextId) => !this.isSubscribedTo(event, contextId));
        if (!eventMap.has(event)) {
            // Add subscription only if it's not already subscribed.
            eventMap.set(event, this.#subscriptionPriority++);
        }
        return affectedContextIds.map((contextId) => ({
            event,
            contextId,
        }));
    }
    /**
     * Unsubscribes atomically from all events in the given contexts and channel.
     */
    unsubscribeAll(events, contextIds, channel) {
        // Assert all contexts are known.
        for (const contextId of contextIds) {
            if (contextId !== null) {
                this.#browsingContextStorage.getContext(contextId);
            }
        }
        const eventContextPairs = cartesianProduct(unrollEvents(events), contextIds);
        // Assert all unsubscriptions are valid.
        // If any of the unsubscriptions are invalid, do not unsubscribe from anything.
        eventContextPairs
            .map(([event, contextId]) => this.#checkUnsubscribe(event, contextId, channel))
            .forEach((unsubscribe) => unsubscribe());
    }
    /**
     * Unsubscribes from the event in the given context and channel.
     * Syntactic sugar for "unsubscribeAll".
     */
    unsubscribe(eventName, contextId, channel) {
        this.unsubscribeAll([eventName], [contextId], channel);
    }
    #checkUnsubscribe(event, contextId, channel) {
        // All the subscriptions are handled on the top-level contexts.
        contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
        if (!this.#channelToContextToEventMap.has(channel)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        const contextToEventMap = this.#channelToContextToEventMap.get(channel);
        if (!contextToEventMap.has(contextId)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        const eventMap = contextToEventMap.get(contextId);
        if (!eventMap.has(event)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? 'null' : contextId}. No subscription found.`);
        }
        return () => {
            eventMap.delete(event);
            // Clean up maps if empty.
            if (eventMap.size === 0) {
                contextToEventMap.delete(event);
            }
            if (contextToEventMap.size === 0) {
                this.#channelToContextToEventMap.delete(channel);
            }
        };
    }
}
exports.SubscriptionManager = SubscriptionManager;
//# sourceMappingURL=SubscriptionManager.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/session/events.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isCdpEvent = isCdpEvent;
exports.assertSupportedEvent = assertSupportedEvent;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/**
 * Returns true if the given event is a CDP event.
 * @see https://chromedevtools.github.io/devtools-protocol/
 */
function isCdpEvent(name) {
    return (name.split('.').at(0)?.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.Cdp) ?? false);
}
/**
 * Asserts that the given event is known to BiDi or BiDi+, or throws otherwise.
 */
function assertSupportedEvent(name) {
    if (!protocol_js_1.ChromiumBidi.EVENT_NAMES.has(name) && !isCdpEvent(name)) {
        throw new protocol_js_1.InvalidArgumentException(`Unknown event: ${name}`);
    }
}
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/storage/StorageProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageProcessor = void 0;
const protocol_js_1 = __webpack_require__(/*! ../../../protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
const assert_js_1 = __webpack_require__(/*! ../../../utils/assert.js */ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js");
const log_js_1 = __webpack_require__(/*! ../../../utils/log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
const NetworkProcessor_js_1 = __webpack_require__(/*! ../network/NetworkProcessor.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkProcessor.js");
const NetworkUtils_js_1 = __webpack_require__(/*! ../network/NetworkUtils.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/modules/network/NetworkUtils.js");
/**
 * Responsible for handling the `storage` domain.
 */
class StorageProcessor {
    #browserCdpClient;
    #browsingContextStorage;
    #logger;
    constructor(browserCdpClient, browsingContextStorage, logger) {
        this.#browsingContextStorage = browsingContextStorage;
        this.#browserCdpClient = browserCdpClient;
        this.#logger = logger;
    }
    async deleteCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
            cdpResponse = await this.#browserCdpClient.sendCommand('Storage.getCookies', {
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        const cdpCookiesToDelete = cdpResponse.cookies
            .filter(
        // CDP's partition key is the source origin. If the request specifies the
        // `sourceOrigin` partition key, only cookies with the requested source origin
        // are returned.
        (c) => partitionKey.sourceOrigin === undefined ||
            c.partitionKey?.topLevelSite === partitionKey.sourceOrigin)
            .filter((cdpCookie) => {
            const bidiCookie = (0, NetworkUtils_js_1.cdpToBiDiCookie)(cdpCookie);
            return this.#matchCookie(bidiCookie, params.filter);
        })
            .map((cookie) => ({
            ...cookie,
            // Set expiry to pass date to delete the cookie.
            expires: 1,
        }));
        await this.#browserCdpClient.sendCommand('Storage.setCookies', {
            cookies: cdpCookiesToDelete,
            browserContextId: this.#getCdpBrowserContextId(partitionKey),
        });
        return {
            partitionKey,
        };
    }
    async getCookies(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        let cdpResponse;
        try {
            cdpResponse = await this.#browserCdpClient.sendCommand('Storage.getCookies', {
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            throw err;
        }
        const filteredBiDiCookies = cdpResponse.cookies
            .filter(
        // CDP's partition key is the source origin. If the request specifies the
        // `sourceOrigin` partition key, only cookies with the requested source origin
        // are returned.
        (c) => partitionKey.sourceOrigin === undefined ||
            c.partitionKey?.topLevelSite === partitionKey.sourceOrigin)
            .map((c) => (0, NetworkUtils_js_1.cdpToBiDiCookie)(c))
            .filter((c) => this.#matchCookie(c, params.filter));
        return {
            cookies: filteredBiDiCookies,
            partitionKey,
        };
    }
    async setCookie(params) {
        const partitionKey = this.#expandStoragePartitionSpec(params.partition);
        const cdpCookie = (0, NetworkUtils_js_1.bidiToCdpCookie)(params, partitionKey);
        try {
            await this.#browserCdpClient.sendCommand('Storage.setCookies', {
                cookies: [cdpCookie],
                browserContextId: this.#getCdpBrowserContextId(partitionKey),
            });
        }
        catch (err) {
            if (this.#isNoSuchUserContextError(err)) {
                // If the user context is not found, special error is thrown.
                throw new protocol_js_1.NoSuchUserContextException(err.message);
            }
            this.#logger?.(log_js_1.LogType.debugError, err);
            throw new protocol_js_1.UnableToSetCookieException(err.toString());
        }
        return {
            partitionKey,
        };
    }
    #isNoSuchUserContextError(err) {
        // Heuristic to detect if the user context is not found.
        // See https://source.chromium.org/chromium/chromium/src/+/main:content/browser/devtools/protocol/browser_handler.cc;drc=a56154dd81e4679712422ac6eed2c9581cb51ab0;l=314
        return err.message?.startsWith('Failed to find browser context for id');
    }
    #getCdpBrowserContextId(partitionKey) {
        return partitionKey.userContext === 'default'
            ? undefined
            : partitionKey.userContext;
    }
    #expandStoragePartitionSpecByBrowsingContext(descriptor) {
        const browsingContextId = descriptor.context;
        const browsingContext = this.#browsingContextStorage.getContext(browsingContextId);
        // https://w3c.github.io/webdriver-bidi/#associated-storage-partition.
        // Each browsing context also has an associated storage partition, which is the
        // storage partition it uses to persist data. In Chromium it's a `BrowserContext`
        // which maps to BiDi `UserContext`.
        return {
            userContext: browsingContext.userContext,
        };
    }
    #expandStoragePartitionSpecByStorageKey(descriptor) {
        const unsupportedPartitionKeys = new Map();
        let sourceOrigin = descriptor.sourceOrigin;
        if (sourceOrigin !== undefined) {
            const url = NetworkProcessor_js_1.NetworkProcessor.parseUrlString(sourceOrigin);
            if (url.origin === 'null') {
                // Origin `null` is a special case for local pages.
                sourceOrigin = url.origin;
            }
            else {
                // Port is not supported in CDP Cookie's `partitionKey`, so it should be stripped
                // from the requested source origin.
                sourceOrigin = `${url.protocol}//${url.hostname}`;
            }
        }
        for (const [key, value] of Object.entries(descriptor)) {
            if (key !== undefined &&
                value !== undefined &&
                !['type', 'sourceOrigin', 'userContext'].includes(key)) {
                unsupportedPartitionKeys.set(key, value);
            }
        }
        if (unsupportedPartitionKeys.size > 0) {
            this.#logger?.(log_js_1.LogType.debugInfo, `Unsupported partition keys: ${JSON.stringify(Object.fromEntries(unsupportedPartitionKeys))}`);
        }
        // Set `userContext` to `default` if not provided, as it's required in Chromium.
        const userContext = descriptor.userContext ?? 'default';
        return {
            userContext,
            ...(sourceOrigin === undefined ? {} : { sourceOrigin }),
        };
    }
    #expandStoragePartitionSpec(partitionSpec) {
        if (partitionSpec === undefined) {
            // `userContext` is required in Chromium.
            return { userContext: 'default' };
        }
        if (partitionSpec.type === 'context') {
            return this.#expandStoragePartitionSpecByBrowsingContext(partitionSpec);
        }
        (0, assert_js_1.assert)(partitionSpec.type === 'storageKey', 'Unknown partition type');
        // Partition spec is a storage partition.
        // Let partition key be partition spec.
        return this.#expandStoragePartitionSpecByStorageKey(partitionSpec);
    }
    #matchCookie(cookie, filter) {
        if (filter === undefined) {
            return true;
        }
        return ((filter.domain === undefined || filter.domain === cookie.domain) &&
            (filter.name === undefined || filter.name === cookie.name) &&
            // `value` contains fields `type` and `value`.
            (filter.value === undefined ||
                (0, NetworkUtils_js_1.deserializeByteValue)(filter.value) ===
                    (0, NetworkUtils_js_1.deserializeByteValue)(cookie.value)) &&
            (filter.path === undefined || filter.path === cookie.path) &&
            (filter.size === undefined || filter.size === cookie.size) &&
            (filter.httpOnly === undefined || filter.httpOnly === cookie.httpOnly) &&
            (filter.secure === undefined || filter.secure === cookie.secure) &&
            (filter.sameSite === undefined || filter.sameSite === cookie.sameSite) &&
            (filter.expiry === undefined || filter.expiry === cookie.expiry));
    }
}
exports.StorageProcessor = StorageProcessor;
//# sourceMappingURL=StorageProcessor.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnderspecifiedStoragePartitionException = exports.UnableToSetFileInputException = exports.UnableToSetCookieException = exports.NoSuchStoragePartitionException = exports.UnsupportedOperationException = exports.UnableToCloseBrowserException = exports.UnableToCaptureScreenException = exports.UnknownErrorException = exports.UnknownCommandException = exports.SessionNotCreatedException = exports.NoSuchUserContextException = exports.NoSuchScriptException = exports.NoSuchRequestException = exports.NoSuchNodeException = exports.NoSuchInterceptException = exports.NoSuchHistoryEntryException = exports.NoSuchHandleException = exports.NoSuchFrameException = exports.NoSuchElementException = exports.NoSuchAlertException = exports.MoveTargetOutOfBoundsException = exports.InvalidSessionIdException = exports.InvalidSelectorException = exports.InvalidArgumentException = exports.Exception = void 0;
class Exception {
    error;
    message;
    stacktrace;
    constructor(error, message, stacktrace) {
        this.error = error;
        this.message = message;
        this.stacktrace = stacktrace;
    }
    toErrorResponse(commandId) {
        return {
            type: 'error',
            id: commandId,
            error: this.error,
            message: this.message,
            stacktrace: this.stacktrace,
        };
    }
}
exports.Exception = Exception;
class InvalidArgumentException extends Exception {
    constructor(message, stacktrace) {
        super("invalid argument" /* ErrorCode.InvalidArgument */, message, stacktrace);
    }
}
exports.InvalidArgumentException = InvalidArgumentException;
class InvalidSelectorException extends Exception {
    constructor(message, stacktrace) {
        super("invalid selector" /* ErrorCode.InvalidSelector */, message, stacktrace);
    }
}
exports.InvalidSelectorException = InvalidSelectorException;
class InvalidSessionIdException extends Exception {
    constructor(message, stacktrace) {
        super("invalid session id" /* ErrorCode.InvalidSessionId */, message, stacktrace);
    }
}
exports.InvalidSessionIdException = InvalidSessionIdException;
class MoveTargetOutOfBoundsException extends Exception {
    constructor(message, stacktrace) {
        super("move target out of bounds" /* ErrorCode.MoveTargetOutOfBounds */, message, stacktrace);
    }
}
exports.MoveTargetOutOfBoundsException = MoveTargetOutOfBoundsException;
class NoSuchAlertException extends Exception {
    constructor(message, stacktrace) {
        super("no such alert" /* ErrorCode.NoSuchAlert */, message, stacktrace);
    }
}
exports.NoSuchAlertException = NoSuchAlertException;
class NoSuchElementException extends Exception {
    constructor(message, stacktrace) {
        super("no such element" /* ErrorCode.NoSuchElement */, message, stacktrace);
    }
}
exports.NoSuchElementException = NoSuchElementException;
class NoSuchFrameException extends Exception {
    constructor(message, stacktrace) {
        super("no such frame" /* ErrorCode.NoSuchFrame */, message, stacktrace);
    }
}
exports.NoSuchFrameException = NoSuchFrameException;
class NoSuchHandleException extends Exception {
    constructor(message, stacktrace) {
        super("no such handle" /* ErrorCode.NoSuchHandle */, message, stacktrace);
    }
}
exports.NoSuchHandleException = NoSuchHandleException;
class NoSuchHistoryEntryException extends Exception {
    constructor(message, stacktrace) {
        super("no such history entry" /* ErrorCode.NoSuchHistoryEntry */, message, stacktrace);
    }
}
exports.NoSuchHistoryEntryException = NoSuchHistoryEntryException;
class NoSuchInterceptException extends Exception {
    constructor(message, stacktrace) {
        super("no such intercept" /* ErrorCode.NoSuchIntercept */, message, stacktrace);
    }
}
exports.NoSuchInterceptException = NoSuchInterceptException;
class NoSuchNodeException extends Exception {
    constructor(message, stacktrace) {
        super("no such node" /* ErrorCode.NoSuchNode */, message, stacktrace);
    }
}
exports.NoSuchNodeException = NoSuchNodeException;
class NoSuchRequestException extends Exception {
    constructor(message, stacktrace) {
        super("no such request" /* ErrorCode.NoSuchRequest */, message, stacktrace);
    }
}
exports.NoSuchRequestException = NoSuchRequestException;
class NoSuchScriptException extends Exception {
    constructor(message, stacktrace) {
        super("no such script" /* ErrorCode.NoSuchScript */, message, stacktrace);
    }
}
exports.NoSuchScriptException = NoSuchScriptException;
class NoSuchUserContextException extends Exception {
    constructor(message, stacktrace) {
        super("no such user context" /* ErrorCode.NoSuchUserContext */, message, stacktrace);
    }
}
exports.NoSuchUserContextException = NoSuchUserContextException;
class SessionNotCreatedException extends Exception {
    constructor(message, stacktrace) {
        super("session not created" /* ErrorCode.SessionNotCreated */, message, stacktrace);
    }
}
exports.SessionNotCreatedException = SessionNotCreatedException;
class UnknownCommandException extends Exception {
    constructor(message, stacktrace) {
        super("unknown command" /* ErrorCode.UnknownCommand */, message, stacktrace);
    }
}
exports.UnknownCommandException = UnknownCommandException;
class UnknownErrorException extends Exception {
    constructor(message, stacktrace = new Error().stack) {
        super("unknown error" /* ErrorCode.UnknownError */, message, stacktrace);
    }
}
exports.UnknownErrorException = UnknownErrorException;
class UnableToCaptureScreenException extends Exception {
    constructor(message, stacktrace) {
        super("unable to capture screen" /* ErrorCode.UnableToCaptureScreen */, message, stacktrace);
    }
}
exports.UnableToCaptureScreenException = UnableToCaptureScreenException;
class UnableToCloseBrowserException extends Exception {
    constructor(message, stacktrace) {
        super("unable to close browser" /* ErrorCode.UnableToCloseBrowser */, message, stacktrace);
    }
}
exports.UnableToCloseBrowserException = UnableToCloseBrowserException;
class UnsupportedOperationException extends Exception {
    constructor(message, stacktrace) {
        super("unsupported operation" /* ErrorCode.UnsupportedOperation */, message, stacktrace);
    }
}
exports.UnsupportedOperationException = UnsupportedOperationException;
class NoSuchStoragePartitionException extends Exception {
    constructor(message, stacktrace) {
        super("no such storage partition" /* ErrorCode.NoSuchStoragePartition */, message, stacktrace);
    }
}
exports.NoSuchStoragePartitionException = NoSuchStoragePartitionException;
class UnableToSetCookieException extends Exception {
    constructor(message, stacktrace) {
        super("unable to set cookie" /* ErrorCode.UnableToSetCookie */, message, stacktrace);
    }
}
exports.UnableToSetCookieException = UnableToSetCookieException;
class UnableToSetFileInputException extends Exception {
    constructor(message, stacktrace) {
        super("unable to set file input" /* ErrorCode.UnableToSetFileInput */, message, stacktrace);
    }
}
exports.UnableToSetFileInputException = UnableToSetFileInputException;
class UnderspecifiedStoragePartitionException extends Exception {
    constructor(message, stacktrace) {
        super("underspecified storage partition" /* ErrorCode.UnderspecifiedStoragePartition */, message, stacktrace);
    }
}
exports.UnderspecifiedStoragePartitionException = UnderspecifiedStoragePartitionException;
//# sourceMappingURL=ErrorResponse.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=cdp.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EVENT_NAMES = exports.Network = exports.BrowsingContext = exports.Log = exports.Script = exports.BiDiModule = void 0;
// keep-sorted end
var BiDiModule;
(function (BiDiModule) {
    // keep-sorted start
    BiDiModule["Browser"] = "browser";
    BiDiModule["BrowsingContext"] = "browsingContext";
    BiDiModule["Cdp"] = "cdp";
    BiDiModule["Input"] = "input";
    BiDiModule["Log"] = "log";
    BiDiModule["Network"] = "network";
    BiDiModule["Script"] = "script";
    BiDiModule["Session"] = "session";
    // keep-sorted end
})(BiDiModule || (exports.BiDiModule = BiDiModule = {}));
var Script;
(function (Script) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["Message"] = "script.message";
        EventNames["RealmCreated"] = "script.realmCreated";
        EventNames["RealmDestroyed"] = "script.realmDestroyed";
        // keep-sorted end
    })(EventNames = Script.EventNames || (Script.EventNames = {}));
})(Script || (exports.Script = Script = {}));
var Log;
(function (Log) {
    let EventNames;
    (function (EventNames) {
        EventNames["LogEntryAdded"] = "log.entryAdded";
    })(EventNames = Log.EventNames || (Log.EventNames = {}));
})(Log || (exports.Log = Log = {}));
var BrowsingContext;
(function (BrowsingContext) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["ContextCreated"] = "browsingContext.contextCreated";
        EventNames["ContextDestroyed"] = "browsingContext.contextDestroyed";
        EventNames["DomContentLoaded"] = "browsingContext.domContentLoaded";
        EventNames["DownloadWillBegin"] = "browsingContext.downloadWillBegin";
        EventNames["FragmentNavigated"] = "browsingContext.fragmentNavigated";
        EventNames["Load"] = "browsingContext.load";
        EventNames["NavigationAborted"] = "browsingContext.navigationAborted";
        EventNames["NavigationFailed"] = "browsingContext.navigationFailed";
        EventNames["NavigationStarted"] = "browsingContext.navigationStarted";
        EventNames["UserPromptClosed"] = "browsingContext.userPromptClosed";
        EventNames["UserPromptOpened"] = "browsingContext.userPromptOpened";
        // keep-sorted end
    })(EventNames = BrowsingContext.EventNames || (BrowsingContext.EventNames = {}));
})(BrowsingContext || (exports.BrowsingContext = BrowsingContext = {}));
var Network;
(function (Network) {
    let EventNames;
    (function (EventNames) {
        // keep-sorted start
        EventNames["AuthRequired"] = "network.authRequired";
        EventNames["BeforeRequestSent"] = "network.beforeRequestSent";
        EventNames["FetchError"] = "network.fetchError";
        EventNames["ResponseCompleted"] = "network.responseCompleted";
        EventNames["ResponseStarted"] = "network.responseStarted";
        // keep-sorted end
    })(EventNames = Network.EventNames || (Network.EventNames = {}));
})(Network || (exports.Network = Network = {}));
exports.EVENT_NAMES = new Set([
    // keep-sorted start
    ...Object.values(BiDiModule),
    ...Object.values(BrowsingContext.EventNames),
    ...Object.values(Log.EventNames),
    ...Object.values(Network.EventNames),
    ...Object.values(Script.EventNames),
    // keep-sorted end
]);
//# sourceMappingURL=chromium-bidi.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=webdriver-bidi-permissions.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=webdriver-bidi.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChromiumBidi = exports.Cdp = void 0;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
exports.Cdp = __importStar(__webpack_require__(/*! ./cdp.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/cdp.js"));
exports.ChromiumBidi = __importStar(__webpack_require__(/*! ./chromium-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js"));
__exportStar(__webpack_require__(/*! ./generated/webdriver-bidi.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi.js"), exports);
__exportStar(__webpack_require__(/*! ./ErrorResponse.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js"), exports);
__exportStar(__webpack_require__(/*! ./generated/webdriver-bidi-permissions.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/generated/webdriver-bidi-permissions.js"), exports);
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Base64.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Base64.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64ToString = base64ToString;
/**
 * Encodes a string to base64.
 *
 * Uses the native Web API if available, otherwise falls back to a NodeJS Buffer.
 * @param {string} base64Str
 * @return {string}
 */
function base64ToString(base64Str) {
    // Available only if run in a browser context.
    if ('atob' in globalThis) {
        return globalThis.atob(base64Str);
    }
    // Available only if run in a NodeJS context.
    return Buffer.from(base64Str, 'base64').toString('ascii');
}
//# sourceMappingURL=Base64.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Buffer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Buffer = void 0;
/** Implements a FIFO buffer with a fixed size. */
class Buffer {
    #capacity;
    #entries = [];
    #onItemRemoved;
    /**
     * @param capacity The buffer capacity.
     * @param onItemRemoved Delegate called for each removed element.
     */
    constructor(capacity, onItemRemoved) {
        this.#capacity = capacity;
        this.#onItemRemoved = onItemRemoved;
    }
    get() {
        return this.#entries;
    }
    add(value) {
        this.#entries.push(value);
        while (this.#entries.length > this.#capacity) {
            const item = this.#entries.shift();
            if (item !== undefined) {
                this.#onItemRemoved?.(item);
            }
        }
    }
}
exports.Buffer = Buffer;
//# sourceMappingURL=Buffer.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultMap = void 0;
/**
 * A subclass of Map whose functionality is almost the same as its parent
 * except for the fact that DefaultMap never returns undefined. It provides a
 * default value for keys that do not exist.
 */
class DefaultMap extends Map {
    /** The default value to return whenever a key is not present in the map. */
    #getDefaultValue;
    constructor(getDefaultValue, entries) {
        super(entries);
        this.#getDefaultValue = getDefaultValue;
    }
    get(key) {
        if (!this.has(key)) {
            this.set(key, this.#getDefaultValue(key));
        }
        return super.get(key);
    }
}
exports.DefaultMap = DefaultMap;
//# sourceMappingURL=DefaultMap.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js":
/*!**************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Deferred.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deferred = void 0;
class Deferred {
    #isFinished = false;
    #promise;
    #result;
    #resolve;
    #reject;
    get isFinished() {
        return this.#isFinished;
    }
    get result() {
        if (!this.#isFinished) {
            throw new Error('Deferred is not finished yet');
        }
        return this.#result;
    }
    constructor() {
        this.#promise = new Promise((resolve, reject) => {
            this.#resolve = resolve;
            this.#reject = reject;
        });
        // Needed to avoid `Uncaught (in promise)`. The promises returned by `then`
        // and `catch` will be rejected anyway.
        this.#promise.catch((_error) => {
            // Intentionally empty.
        });
    }
    then(onFulfilled, onRejected) {
        return this.#promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
        return this.#promise.catch(onRejected);
    }
    resolve(value) {
        this.#result = value;
        if (!this.#isFinished) {
            this.#isFinished = true;
            this.#resolve(value);
        }
    }
    reject(reason) {
        if (!this.#isFinished) {
            this.#isFinished = true;
            this.#reject(reason);
        }
    }
    finally(onFinally) {
        return this.#promise.finally(onFinally);
    }
    [Symbol.toStringTag] = 'Promise';
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js":
/*!********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/DistinctValues.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.distinctValues = distinctValues;
exports.deterministicJSONStringify = deterministicJSONStringify;
/**
 * Returns an array of distinct values. Order is not guaranteed.
 * @param values - The values to filter. Should be JSON-serializable.
 * @return - An array of distinct values.
 */
function distinctValues(values) {
    const map = new Map();
    for (const value of values) {
        map.set(deterministicJSONStringify(value), value);
    }
    return Array.from(map.values());
}
/**
 * Returns a stringified version of the object with keys sorted. This is required to
 * ensure that the stringified version of an object is deterministic independent of the
 * order of keys.
 * @param obj
 * @return {string}
 */
function deterministicJSONStringify(obj) {
    return JSON.stringify(normalizeObject(obj));
}
function normalizeObject(obj) {
    if (obj === undefined ||
        obj === null ||
        Array.isArray(obj) ||
        typeof obj !== 'object') {
        return obj;
    }
    // Copy the original object key and values to a new object in sorted order.
    const newObj = {};
    for (const key of Object.keys(obj).sort()) {
        const value = obj[key];
        newObj[key] = normalizeObject(value); // Recursively sort nested objects
    }
    return newObj;
}
//# sourceMappingURL=DistinctValues.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js":
/*!******************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mitt_1 = __importDefault(__webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.mjs"));
class EventEmitter {
    #emitter = (0, mitt_1.default)();
    on(type, handler) {
        this.#emitter.on(type, handler);
        return this;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param event The event you'd like to listen to
     * @param handler The handler function to run when the event occurs
     * @return `this` to enable chaining method calls.
     */
    once(event, handler) {
        const onceHandler = (eventData) => {
            handler(eventData);
            this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
    }
    off(type, handler) {
        this.#emitter.off(type, handler);
        return this;
    }
    /**
     * Emits an event and call any associated listeners.
     *
     * @param event The event to emit.
     * @param eventData Any data to emit with the event.
     * @return `true` if there are any listeners, `false` otherwise.
     */
    emit(event, eventData) {
        this.#emitter.emit(event, eventData);
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     * @param event - the event to remove listeners for.
     * @returns `this` to enable you to chain method calls.
     */
    removeAllListeners(event) {
        if (event) {
            this.#emitter.all.delete(event);
        }
        else {
            this.#emitter.all.clear();
        }
        return this;
    }
}
exports.EventEmitter = EventEmitter;
//# sourceMappingURL=EventEmitter.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/GraphemeTools.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*
 * Copyright 2024 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSingleComplexGrapheme = isSingleComplexGrapheme;
exports.isSingleGrapheme = isSingleGrapheme;
/**
 * Check if the given string is a single complex grapheme. A complex grapheme is one that
 * is made up of multiple characters.
 */
function isSingleComplexGrapheme(value) {
    return isSingleGrapheme(value) && value.length > 1;
}
/**
 * Check if the given string is a single grapheme.
 */
function isSingleGrapheme(value) {
    // Theoretically there can be some strings considered a grapheme in some locales, like
    // slovak "ch" digraph. Use english locale for consistency.
    // https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
    const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });
    return [...segmenter.segment(value)].length === 1;
}
//# sourceMappingURL=GraphemeTools.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js":
/*!***************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdWrapper = void 0;
/**
 * Creates an object with a positive unique incrementing id.
 */
class IdWrapper {
    static #counter = 0;
    #id;
    constructor() {
        this.#id = ++IdWrapper.#counter;
    }
    get id() {
        return this.#id;
    }
}
exports.IdWrapper = IdWrapper;
//# sourceMappingURL=IdWrapper.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js":
/*!***********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/Mutex.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 * Copyright 2022 The Chromium Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mutex = void 0;
/**
 * Use Mutex class to coordinate local concurrent operations.
 * Once `acquire` promise resolves, you hold the lock and must
 * call `release` function returned by `acquire` to release the
 * lock. Failing to `release` the lock may lead to deadlocks.
 */
class Mutex {
    #locked = false;
    #acquirers = [];
    // This is FIFO.
    acquire() {
        const state = { resolved: false };
        if (this.#locked) {
            return new Promise((resolve) => {
                this.#acquirers.push(() => resolve(this.#release.bind(this, state)));
            });
        }
        this.#locked = true;
        return Promise.resolve(this.#release.bind(this, state));
    }
    #release(state) {
        if (state.resolved) {
            throw new Error('Cannot release more than once.');
        }
        state.resolved = true;
        const resolve = this.#acquirers.shift();
        if (!resolve) {
            this.#locked = false;
            return;
        }
        resolve();
    }
    async run(action) {
        const release = await this.acquire();
        try {
            // Note we need to await here because we want the await to release AFTER
            // that await happens. Returning action() will trigger the release
            // immediately which is counter to what we want.
            const result = await action();
            return result;
        }
        finally {
            release();
        }
    }
}
exports.Mutex = Mutex;
//# sourceMappingURL=Mutex.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProcessingQueue = void 0;
const log_js_1 = __webpack_require__(/*! ./log.js */ "./node_modules/chromium-bidi/lib/cjs/utils/log.js");
class ProcessingQueue {
    static LOGGER_PREFIX = `${log_js_1.LogType.debug}:queue`;
    #logger;
    #processor;
    #queue = [];
    // Flag to keep only 1 active processor.
    #isProcessing = false;
    constructor(processor, logger) {
        this.#processor = processor;
        this.#logger = logger;
    }
    add(entry, name) {
        this.#queue.push([entry, name]);
        // No need in waiting. Just initialize processor if needed.
        void this.#processIfNeeded();
    }
    async #processIfNeeded() {
        if (this.#isProcessing) {
            return;
        }
        this.#isProcessing = true;
        while (this.#queue.length > 0) {
            const arrayEntry = this.#queue.shift();
            if (!arrayEntry) {
                continue;
            }
            const [entryPromise, name] = arrayEntry;
            this.#logger?.(ProcessingQueue.LOGGER_PREFIX, 'Processing event:', name);
            await entryPromise
                .then((entry) => {
                if (entry.kind === 'error') {
                    this.#logger?.(log_js_1.LogType.debugError, 'Event threw before sending:', entry.error.message, entry.error.stack);
                    return;
                }
                return this.#processor(entry.value);
            })
                .catch((error) => {
                this.#logger?.(log_js_1.LogType.debugError, 'Event was not processed:', error?.message);
            });
        }
        this.#isProcessing = false;
    }
}
exports.ProcessingQueue = ProcessingQueue;
//# sourceMappingURL=ProcessingQueue.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js":
/*!****************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.URLPattern = void 0;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const urlpattern_polyfill_1 = __webpack_require__(/*! urlpattern-polyfill */ "./node_modules/urlpattern-polyfill/index.cjs");
// XXX: Switch to native URLPattern when available.
// https://github.com/nodejs/node/issues/40844
let URLPattern = urlpattern_polyfill_1.URLPattern;
exports.URLPattern = URLPattern;
if ('URLPattern' in globalThis) {
    exports.URLPattern = URLPattern = globalThis.URLPattern;
}
//# sourceMappingURL=UrlPattern.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/assert.js":
/*!************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/assert.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = assert;
/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assert(predicate, message) {
    if (!predicate) {
        throw new Error(message ?? 'Internal assertion failed.');
    }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/log.js":
/*!*********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/log.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogType = void 0;
var LogType;
(function (LogType) {
    // keep-sorted start
    LogType["bidi"] = "bidi";
    LogType["cdp"] = "cdp";
    LogType["debug"] = "debug";
    LogType["debugError"] = "debug:error";
    LogType["debugInfo"] = "debug:info";
    // keep-sorted end
})(LogType || (exports.LogType = LogType = {}));
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inchesFromCm = inchesFromCm;
/** @return Given an input in cm, convert it to inches. */
function inchesFromCm(cm) {
    return cm / 2.54;
}
//# sourceMappingURL=unitConversions.js.map

/***/ }),

/***/ "./node_modules/chromium-bidi/lib/cjs/utils/uuid.js":
/*!**********************************************************!*\
  !*** ./node_modules/chromium-bidi/lib/cjs/utils/uuid.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidv4 = uuidv4;
/**
 * Generates a random v4 UUID, as specified in RFC4122.
 *
 * Uses the native Web Crypto API if available, otherwise falls back to a
 * polyfill.
 *
 * Example: '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
 */
function uuidv4() {
    // Available only in secure contexts
    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API
    if ('crypto' in globalThis && 'randomUUID' in globalThis.crypto) {
        // Node with
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1 or
        // secure browser context.
        return globalThis.crypto.randomUUID();
    }
    const randomValues = new Uint8Array(16);
    if ('crypto' in globalThis && 'getRandomValues' in globalThis.crypto) {
        // Node with
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1 or
        // browser.
        globalThis.crypto.getRandomValues(randomValues);
    }
    else {
        // Node without
        // https://nodejs.org/dist/latest-v20.x/docs/api/globals.html#crypto_1.
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        (__webpack_require__(/*! crypto */ "crypto").webcrypto).getRandomValues(randomValues);
    }
    // Set version (4) and variant (RFC4122) bits.
    randomValues[6] = (randomValues[6] & 0x0f) | 0x40;
    randomValues[8] = (randomValues[8] & 0x3f) | 0x80;
    const bytesToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
    return [
        bytesToHex(randomValues.subarray(0, 4)),
        bytesToHex(randomValues.subarray(4, 6)),
        bytesToHex(randomValues.subarray(6, 8)),
        bytesToHex(randomValues.subarray(8, 10)),
        bytesToHex(randomValues.subarray(10, 16)),
    ].join('-');
}
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/urlpattern-polyfill/dist/urlpattern.cjs":
/*!**************************************************************!*\
  !*** ./node_modules/urlpattern-polyfill/dist/urlpattern.cjs ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
var M=Object.defineProperty;var Pe=Object.getOwnPropertyDescriptor;var Re=Object.getOwnPropertyNames;var Ee=Object.prototype.hasOwnProperty;var Oe=(e,t)=>{for(var r in t)M(e,r,{get:t[r],enumerable:!0})},ke=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of Re(t))!Ee.call(e,a)&&a!==r&&M(e,a,{get:()=>t[a],enumerable:!(n=Pe(t,a))||n.enumerable});return e};var Te=e=>ke(M({},"__esModule",{value:!0}),e);var Ne={};Oe(Ne,{URLPattern:()=>Y});module.exports=Te(Ne);var R=class{type=3;name="";prefix="";value="";suffix="";modifier=3;constructor(t,r,n,a,c,l){this.type=t,this.name=r,this.prefix=n,this.value=a,this.suffix=c,this.modifier=l}hasCustomName(){return this.name!==""&&typeof this.name!="number"}},Ae=/[$_\p{ID_Start}]/u,ye=/[$_\u200C\u200D\p{ID_Continue}]/u,v=".*";function we(e,t){return(t?/^[\x00-\xFF]*$/:/^[\x00-\x7F]*$/).test(e)}function D(e,t=!1){let r=[],n=0;for(;n<e.length;){let a=e[n],c=function(l){if(!t)throw new TypeError(l);r.push({type:"INVALID_CHAR",index:n,value:e[n++]})};if(a==="*"){r.push({type:"ASTERISK",index:n,value:e[n++]});continue}if(a==="+"||a==="?"){r.push({type:"OTHER_MODIFIER",index:n,value:e[n++]});continue}if(a==="\\"){r.push({type:"ESCAPED_CHAR",index:n++,value:e[n++]});continue}if(a==="{"){r.push({type:"OPEN",index:n,value:e[n++]});continue}if(a==="}"){r.push({type:"CLOSE",index:n,value:e[n++]});continue}if(a===":"){let l="",s=n+1;for(;s<e.length;){let i=e.substr(s,1);if(s===n+1&&Ae.test(i)||s!==n+1&&ye.test(i)){l+=e[s++];continue}break}if(!l){c(`Missing parameter name at ${n}`);continue}r.push({type:"NAME",index:n,value:l}),n=s;continue}if(a==="("){let l=1,s="",i=n+1,o=!1;if(e[i]==="?"){c(`Pattern cannot start with "?" at ${i}`);continue}for(;i<e.length;){if(!we(e[i],!1)){c(`Invalid character '${e[i]}' at ${i}.`),o=!0;break}if(e[i]==="\\"){s+=e[i++]+e[i++];continue}if(e[i]===")"){if(l--,l===0){i++;break}}else if(e[i]==="("&&(l++,e[i+1]!=="?")){c(`Capturing groups are not allowed at ${i}`),o=!0;break}s+=e[i++]}if(o)continue;if(l){c(`Unbalanced pattern at ${n}`);continue}if(!s){c(`Missing pattern at ${n}`);continue}r.push({type:"REGEX",index:n,value:s}),n=i;continue}r.push({type:"CHAR",index:n,value:e[n++]})}return r.push({type:"END",index:n,value:""}),r}function F(e,t={}){let r=D(e);t.delimiter??="/#?",t.prefixes??="./";let n=`[^${S(t.delimiter)}]+?`,a=[],c=0,l=0,s="",i=new Set,o=h=>{if(l<r.length&&r[l].type===h)return r[l++].value},f=()=>o("OTHER_MODIFIER")??o("ASTERISK"),d=h=>{let u=o(h);if(u!==void 0)return u;let{type:p,index:A}=r[l];throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`)},T=()=>{let h="",u;for(;u=o("CHAR")??o("ESCAPED_CHAR");)h+=u;return h},xe=h=>h,L=t.encodePart||xe,I="",U=h=>{I+=h},$=()=>{I.length&&(a.push(new R(3,"","",L(I),"",3)),I="")},X=(h,u,p,A,Z)=>{let g=3;switch(Z){case"?":g=1;break;case"*":g=0;break;case"+":g=2;break}if(!u&&!p&&g===3){U(h);return}if($(),!u&&!p){if(!h)return;a.push(new R(3,"","",L(h),"",g));return}let m;p?p==="*"?m=v:m=p:m=n;let O=2;m===n?(O=1,m=""):m===v&&(O=0,m="");let P;if(u?P=u:p&&(P=c++),i.has(P))throw new TypeError(`Duplicate name '${P}'.`);i.add(P),a.push(new R(O,P,L(h),m,L(A),g))};for(;l<r.length;){let h=o("CHAR"),u=o("NAME"),p=o("REGEX");if(!u&&!p&&(p=o("ASTERISK")),u||p){let g=h??"";t.prefixes.indexOf(g)===-1&&(U(g),g=""),$();let m=f();X(g,u,p,"",m);continue}let A=h??o("ESCAPED_CHAR");if(A){U(A);continue}if(o("OPEN")){let g=T(),m=o("NAME"),O=o("REGEX");!m&&!O&&(O=o("ASTERISK"));let P=T();d("CLOSE");let be=f();X(g,m,O,P,be);continue}$(),d("END")}return a}function S(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function B(e){return e&&e.ignoreCase?"ui":"u"}function q(e,t,r){return W(F(e,r),t,r)}function k(e){switch(e){case 0:return"*";case 1:return"?";case 2:return"+";case 3:return""}}function W(e,t,r={}){r.delimiter??="/#?",r.prefixes??="./",r.sensitive??=!1,r.strict??=!1,r.end??=!0,r.start??=!0,r.endsWith="";let n=r.start?"^":"";for(let s of e){if(s.type===3){s.modifier===3?n+=S(s.value):n+=`(?:${S(s.value)})${k(s.modifier)}`;continue}t&&t.push(s.name);let i=`[^${S(r.delimiter)}]+?`,o=s.value;if(s.type===1?o=i:s.type===0&&(o=v),!s.prefix.length&&!s.suffix.length){s.modifier===3||s.modifier===1?n+=`(${o})${k(s.modifier)}`:n+=`((?:${o})${k(s.modifier)})`;continue}if(s.modifier===3||s.modifier===1){n+=`(?:${S(s.prefix)}(${o})${S(s.suffix)})`,n+=k(s.modifier);continue}n+=`(?:${S(s.prefix)}`,n+=`((?:${o})(?:`,n+=S(s.suffix),n+=S(s.prefix),n+=`(?:${o}))*)${S(s.suffix)})`,s.modifier===0&&(n+="?")}let a=`[${S(r.endsWith)}]|$`,c=`[${S(r.delimiter)}]`;if(r.end)return r.strict||(n+=`${c}?`),r.endsWith.length?n+=`(?=${a})`:n+="$",new RegExp(n,B(r));r.strict||(n+=`(?:${c}(?=${a}))?`);let l=!1;if(e.length){let s=e[e.length-1];s.type===3&&s.modifier===3&&(l=r.delimiter.indexOf(s)>-1)}return l||(n+=`(?=${c}|${a})`),new RegExp(n,B(r))}var x={delimiter:"",prefixes:"",sensitive:!0,strict:!0},J={delimiter:".",prefixes:"",sensitive:!0,strict:!0},Q={delimiter:"/",prefixes:"/",sensitive:!0,strict:!0};function ee(e,t){return e.length?e[0]==="/"?!0:!t||e.length<2?!1:(e[0]=="\\"||e[0]=="{")&&e[1]=="/":!1}function te(e,t){return e.startsWith(t)?e.substring(t.length,e.length):e}function Ce(e,t){return e.endsWith(t)?e.substr(0,e.length-t.length):e}function _(e){return!e||e.length<2?!1:e[0]==="["||(e[0]==="\\"||e[0]==="{")&&e[1]==="["}var re=["ftp","file","http","https","ws","wss"];function N(e){if(!e)return!0;for(let t of re)if(e.test(t))return!0;return!1}function ne(e,t){if(e=te(e,"#"),t||e==="")return e;let r=new URL("https://example.com");return r.hash=e,r.hash?r.hash.substring(1,r.hash.length):""}function se(e,t){if(e=te(e,"?"),t||e==="")return e;let r=new URL("https://example.com");return r.search=e,r.search?r.search.substring(1,r.search.length):""}function ie(e,t){return t||e===""?e:_(e)?K(e):j(e)}function ae(e,t){if(t||e==="")return e;let r=new URL("https://example.com");return r.password=e,r.password}function oe(e,t){if(t||e==="")return e;let r=new URL("https://example.com");return r.username=e,r.username}function ce(e,t,r){if(r||e==="")return e;if(t&&!re.includes(t))return new URL(`${t}:${e}`).pathname;let n=e[0]=="/";return e=new URL(n?e:"/-"+e,"https://example.com").pathname,n||(e=e.substring(2,e.length)),e}function le(e,t,r){return z(t)===e&&(e=""),r||e===""?e:G(e)}function fe(e,t){return e=Ce(e,":"),t||e===""?e:y(e)}function z(e){switch(e){case"ws":case"http":return"80";case"wws":case"https":return"443";case"ftp":return"21";default:return""}}function y(e){if(e==="")return e;if(/^[-+.A-Za-z0-9]*$/.test(e))return e.toLowerCase();throw new TypeError(`Invalid protocol '${e}'.`)}function he(e){if(e==="")return e;let t=new URL("https://example.com");return t.username=e,t.username}function ue(e){if(e==="")return e;let t=new URL("https://example.com");return t.password=e,t.password}function j(e){if(e==="")return e;if(/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))throw new TypeError(`Invalid hostname '${e}'`);let t=new URL("https://example.com");return t.hostname=e,t.hostname}function K(e){if(e==="")return e;if(/[^0-9a-fA-F[\]:]/g.test(e))throw new TypeError(`Invalid IPv6 hostname '${e}'`);return e.toLowerCase()}function G(e){if(e===""||/^[0-9]*$/.test(e)&&parseInt(e)<=65535)return e;throw new TypeError(`Invalid port '${e}'.`)}function de(e){if(e==="")return e;let t=new URL("https://example.com");return t.pathname=e[0]!=="/"?"/-"+e:e,e[0]!=="/"?t.pathname.substring(2,t.pathname.length):t.pathname}function pe(e){return e===""?e:new URL(`data:${e}`).pathname}function ge(e){if(e==="")return e;let t=new URL("https://example.com");return t.search=e,t.search.substring(1,t.search.length)}function me(e){if(e==="")return e;let t=new URL("https://example.com");return t.hash=e,t.hash.substring(1,t.hash.length)}var H=class{#i;#n=[];#t={};#e=0;#s=1;#l=0;#o=0;#d=0;#p=0;#g=!1;constructor(t){this.#i=t}get result(){return this.#t}parse(){for(this.#n=D(this.#i,!0);this.#e<this.#n.length;this.#e+=this.#s){if(this.#s=1,this.#n[this.#e].type==="END"){if(this.#o===0){this.#b(),this.#f()?this.#r(9,1):this.#h()?this.#r(8,1):this.#r(7,0);continue}else if(this.#o===2){this.#u(5);continue}this.#r(10,0);break}if(this.#d>0)if(this.#A())this.#d-=1;else continue;if(this.#T()){this.#d+=1;continue}switch(this.#o){case 0:this.#P()&&this.#u(1);break;case 1:if(this.#P()){this.#C();let t=7,r=1;this.#E()?(t=2,r=3):this.#g&&(t=2),this.#r(t,r)}break;case 2:this.#S()?this.#u(3):(this.#x()||this.#h()||this.#f())&&this.#u(5);break;case 3:this.#O()?this.#r(4,1):this.#S()&&this.#r(5,1);break;case 4:this.#S()&&this.#r(5,1);break;case 5:this.#y()?this.#p+=1:this.#w()&&(this.#p-=1),this.#k()&&!this.#p?this.#r(6,1):this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 6:this.#x()?this.#r(7,0):this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 7:this.#h()?this.#r(8,1):this.#f()&&this.#r(9,1);break;case 8:this.#f()&&this.#r(9,1);break;case 9:break;case 10:break}}this.#t.hostname!==void 0&&this.#t.port===void 0&&(this.#t.port="")}#r(t,r){switch(this.#o){case 0:break;case 1:this.#t.protocol=this.#c();break;case 2:break;case 3:this.#t.username=this.#c();break;case 4:this.#t.password=this.#c();break;case 5:this.#t.hostname=this.#c();break;case 6:this.#t.port=this.#c();break;case 7:this.#t.pathname=this.#c();break;case 8:this.#t.search=this.#c();break;case 9:this.#t.hash=this.#c();break;case 10:break}this.#o!==0&&t!==10&&([1,2,3,4].includes(this.#o)&&[6,7,8,9].includes(t)&&(this.#t.hostname??=""),[1,2,3,4,5,6].includes(this.#o)&&[8,9].includes(t)&&(this.#t.pathname??=this.#g?"/":""),[1,2,3,4,5,6,7].includes(this.#o)&&t===9&&(this.#t.search??="")),this.#R(t,r)}#R(t,r){this.#o=t,this.#l=this.#e+r,this.#e+=r,this.#s=0}#b(){this.#e=this.#l,this.#s=0}#u(t){this.#b(),this.#o=t}#m(t){return t<0&&(t=this.#n.length-t),t<this.#n.length?this.#n[t]:this.#n[this.#n.length-1]}#a(t,r){let n=this.#m(t);return n.value===r&&(n.type==="CHAR"||n.type==="ESCAPED_CHAR"||n.type==="INVALID_CHAR")}#P(){return this.#a(this.#e,":")}#E(){return this.#a(this.#e+1,"/")&&this.#a(this.#e+2,"/")}#S(){return this.#a(this.#e,"@")}#O(){return this.#a(this.#e,":")}#k(){return this.#a(this.#e,":")}#x(){return this.#a(this.#e,"/")}#h(){if(this.#a(this.#e,"?"))return!0;if(this.#n[this.#e].value!=="?")return!1;let t=this.#m(this.#e-1);return t.type!=="NAME"&&t.type!=="REGEX"&&t.type!=="CLOSE"&&t.type!=="ASTERISK"}#f(){return this.#a(this.#e,"#")}#T(){return this.#n[this.#e].type=="OPEN"}#A(){return this.#n[this.#e].type=="CLOSE"}#y(){return this.#a(this.#e,"[")}#w(){return this.#a(this.#e,"]")}#c(){let t=this.#n[this.#e],r=this.#m(this.#l).index;return this.#i.substring(r,t.index)}#C(){let t={};Object.assign(t,x),t.encodePart=y;let r=q(this.#c(),void 0,t);this.#g=N(r)}};var V=["protocol","username","password","hostname","port","pathname","search","hash"],E="*";function Se(e,t){if(typeof e!="string")throw new TypeError("parameter 1 is not of type 'string'.");let r=new URL(e,t);return{protocol:r.protocol.substring(0,r.protocol.length-1),username:r.username,password:r.password,hostname:r.hostname,port:r.port,pathname:r.pathname,search:r.search!==""?r.search.substring(1,r.search.length):void 0,hash:r.hash!==""?r.hash.substring(1,r.hash.length):void 0}}function b(e,t){return t?C(e):e}function w(e,t,r){let n;if(typeof t.baseURL=="string")try{n=new URL(t.baseURL),t.protocol===void 0&&(e.protocol=b(n.protocol.substring(0,n.protocol.length-1),r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&(e.username=b(n.username,r)),!r&&t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.username===void 0&&t.password===void 0&&(e.password=b(n.password,r)),t.protocol===void 0&&t.hostname===void 0&&(e.hostname=b(n.hostname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&(e.port=b(n.port,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&(e.pathname=b(n.pathname,r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&(e.search=b(n.search.substring(1,n.search.length),r)),t.protocol===void 0&&t.hostname===void 0&&t.port===void 0&&t.pathname===void 0&&t.search===void 0&&t.hash===void 0&&(e.hash=b(n.hash.substring(1,n.hash.length),r))}catch{throw new TypeError(`invalid baseURL '${t.baseURL}'.`)}if(typeof t.protocol=="string"&&(e.protocol=fe(t.protocol,r)),typeof t.username=="string"&&(e.username=oe(t.username,r)),typeof t.password=="string"&&(e.password=ae(t.password,r)),typeof t.hostname=="string"&&(e.hostname=ie(t.hostname,r)),typeof t.port=="string"&&(e.port=le(t.port,e.protocol,r)),typeof t.pathname=="string"){if(e.pathname=t.pathname,n&&!ee(e.pathname,r)){let a=n.pathname.lastIndexOf("/");a>=0&&(e.pathname=b(n.pathname.substring(0,a+1),r)+e.pathname)}e.pathname=ce(e.pathname,e.protocol,r)}return typeof t.search=="string"&&(e.search=se(t.search,r)),typeof t.hash=="string"&&(e.hash=ne(t.hash,r)),e}function C(e){return e.replace(/([+*?:{}()\\])/g,"\\$1")}function Le(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function Ie(e,t){t.delimiter??="/#?",t.prefixes??="./",t.sensitive??=!1,t.strict??=!1,t.end??=!0,t.start??=!0,t.endsWith="";let r=".*",n=`[^${Le(t.delimiter)}]+?`,a=/[$_\u200C\u200D\p{ID_Continue}]/u,c="";for(let l=0;l<e.length;++l){let s=e[l];if(s.type===3){if(s.modifier===3){c+=C(s.value);continue}c+=`{${C(s.value)}}${k(s.modifier)}`;continue}let i=s.hasCustomName(),o=!!s.suffix.length||!!s.prefix.length&&(s.prefix.length!==1||!t.prefixes.includes(s.prefix)),f=l>0?e[l-1]:null,d=l<e.length-1?e[l+1]:null;if(!o&&i&&s.type===1&&s.modifier===3&&d&&!d.prefix.length&&!d.suffix.length)if(d.type===3){let T=d.value.length>0?d.value[0]:"";o=a.test(T)}else o=!d.hasCustomName();if(!o&&!s.prefix.length&&f&&f.type===3){let T=f.value[f.value.length-1];o=t.prefixes.includes(T)}o&&(c+="{"),c+=C(s.prefix),i&&(c+=`:${s.name}`),s.type===2?c+=`(${s.value})`:s.type===1?i||(c+=`(${n})`):s.type===0&&(!i&&(!f||f.type===3||f.modifier!==3||o||s.prefix!=="")?c+="*":c+=`(${r})`),s.type===1&&i&&s.suffix.length&&a.test(s.suffix[0])&&(c+="\\"),c+=C(s.suffix),o&&(c+="}"),s.modifier!==3&&(c+=k(s.modifier))}return c}var Y=class{#i;#n={};#t={};#e={};#s={};#l=!1;constructor(t={},r,n){try{let a;if(typeof r=="string"?a=r:n=r,typeof t=="string"){let i=new H(t);if(i.parse(),t=i.result,a===void 0&&typeof t.protocol!="string")throw new TypeError("A base URL must be provided for a relative constructor string.");t.baseURL=a}else{if(!t||typeof t!="object")throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");if(a)throw new TypeError("parameter 1 is not of type 'string'.")}typeof n>"u"&&(n={ignoreCase:!1});let c={ignoreCase:n.ignoreCase===!0},l={pathname:E,protocol:E,username:E,password:E,hostname:E,port:E,search:E,hash:E};this.#i=w(l,t,!0),z(this.#i.protocol)===this.#i.port&&(this.#i.port="");let s;for(s of V){if(!(s in this.#i))continue;let i={},o=this.#i[s];switch(this.#t[s]=[],s){case"protocol":Object.assign(i,x),i.encodePart=y;break;case"username":Object.assign(i,x),i.encodePart=he;break;case"password":Object.assign(i,x),i.encodePart=ue;break;case"hostname":Object.assign(i,J),_(o)?i.encodePart=K:i.encodePart=j;break;case"port":Object.assign(i,x),i.encodePart=G;break;case"pathname":N(this.#n.protocol)?(Object.assign(i,Q,c),i.encodePart=de):(Object.assign(i,x,c),i.encodePart=pe);break;case"search":Object.assign(i,x,c),i.encodePart=ge;break;case"hash":Object.assign(i,x,c),i.encodePart=me;break}try{this.#s[s]=F(o,i),this.#n[s]=W(this.#s[s],this.#t[s],i),this.#e[s]=Ie(this.#s[s],i),this.#l=this.#l||this.#s[s].some(f=>f.type===2)}catch{throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`)}}}catch(a){throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`)}}test(t={},r){let n={pathname:"",protocol:"",username:"",password:"",hostname:"",port:"",search:"",hash:""};if(typeof t!="string"&&r)throw new TypeError("parameter 1 is not of type 'string'.");if(typeof t>"u")return!1;try{typeof t=="object"?n=w(n,t,!1):n=w(n,Se(t,r),!1)}catch{return!1}let a;for(a of V)if(!this.#n[a].exec(n[a]))return!1;return!0}exec(t={},r){let n={pathname:"",protocol:"",username:"",password:"",hostname:"",port:"",search:"",hash:""};if(typeof t!="string"&&r)throw new TypeError("parameter 1 is not of type 'string'.");if(typeof t>"u")return;try{typeof t=="object"?n=w(n,t,!1):n=w(n,Se(t,r),!1)}catch{return null}let a={};r?a.inputs=[t,r]:a.inputs=[t];let c;for(c of V){let l=this.#n[c].exec(n[c]);if(!l)return null;let s={};for(let[i,o]of this.#t[c].entries())if(typeof o=="string"||typeof o=="number"){let f=l[i+1];s[o]=f}a[c]={input:n[c]??"",groups:s}}return a}static compareComponent(t,r,n){let a=(i,o)=>{for(let f of["type","modifier","prefix","value","suffix"]){if(i[f]<o[f])return-1;if(i[f]===o[f])continue;return 1}return 0},c=new R(3,"","","","",3),l=new R(0,"","","","",3),s=(i,o)=>{let f=0;for(;f<Math.min(i.length,o.length);++f){let d=a(i[f],o[f]);if(d)return d}return i.length===o.length?0:a(i[f]??c,o[f]??c)};return!r.#e[t]&&!n.#e[t]?0:r.#e[t]&&!n.#e[t]?s(r.#s[t],[l]):!r.#e[t]&&n.#e[t]?s([l],n.#s[t]):s(r.#s[t],n.#s[t])}get protocol(){return this.#e.protocol}get username(){return this.#e.username}get password(){return this.#e.password}get hostname(){return this.#e.hostname}get port(){return this.#e.port}get pathname(){return this.#e.pathname}get search(){return this.#e.search}get hash(){return this.#e.hash}get hasRegExpGroups(){return this.#l}};


/***/ }),

/***/ "./node_modules/urlpattern-polyfill/index.cjs":
/*!****************************************************!*\
  !*** ./node_modules/urlpattern-polyfill/index.cjs ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { URLPattern } = __webpack_require__(/*! ./dist/urlpattern.cjs */ "./node_modules/urlpattern-polyfill/dist/urlpattern.cjs");

module.exports = { URLPattern };

if (!globalThis.URLPattern) {
  globalThis.URLPattern = URLPattern;
}


/***/ }),

/***/ "./node_modules/mitt/dist/mitt.mjs":
/*!*****************************************!*\
  !*** ./node_modules/mitt/dist/mitt.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}
//# sourceMappingURL=mitt.mjs.map


/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   connectBidiOverCdp: () => (/* binding */ connectBidiOverCdp)
/* harmony export */ });
/* harmony import */ var chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js */ "./node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js");
/* harmony import */ var _common_Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */




const bidiServerLogger = (prefix, ...args) => {
    (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)(`bidi:${prefix}`)(args);
};
/**
 * @internal
 */
async function connectBidiOverCdp(cdp, options) {
    const transportBiDi = new NoOpTransport();
    const cdpConnectionAdapter = new CdpConnectionAdapter(cdp);
    const pptrTransport = {
        send(message) {
            // Forwards a BiDi command sent by Puppeteer to the input of the BidiServer.
            transportBiDi.emitMessage(JSON.parse(message));
        },
        close() {
            bidiServer.close();
            cdpConnectionAdapter.close();
            cdp.dispose();
        },
        onmessage(_message) {
            // The method is overridden by the Connection.
        },
    };
    transportBiDi.on('bidiResponse', (message) => {
        // Forwards a BiDi event sent by BidiServer to Puppeteer.
        pptrTransport.onmessage(JSON.stringify(message));
    });
    const pptrBiDiConnection = new _Connection_js__WEBPACK_IMPORTED_MODULE_3__.BidiConnection(cdp.url(), pptrTransport, cdp.delay, cdp.timeout);
    const bidiServer = await chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.BidiServer.createAndStart(transportBiDi, cdpConnectionAdapter, 
    // TODO: most likely need a little bit of refactoring
    cdpConnectionAdapter.browserClient(), '', {
        // Override Mapper's `unhandledPromptBehavior` default value of `dismiss` to
        // `ignore`, so that user can handle the prompt instead of just closing it.
        unhandledPromptBehavior: {
            default: "ignore" /* Bidi.Session.UserPromptHandlerType.Ignore */,
        },
        ...options,
    }, undefined, bidiServerLogger);
    return pptrBiDiConnection;
}
/**
 * Manages CDPSessions for BidiServer.
 * @internal
 */
class CdpConnectionAdapter {
    #cdp;
    #adapters = new Map();
    #browserCdpConnection;
    constructor(cdp) {
        this.#cdp = cdp;
        this.#browserCdpConnection = new CDPClientAdapter(cdp);
    }
    browserClient() {
        return this.#browserCdpConnection;
    }
    getCdpClient(id) {
        const session = this.#cdp.session(id);
        if (!session) {
            throw new Error(`Unknown CDP session with id ${id}`);
        }
        if (!this.#adapters.has(session)) {
            const adapter = new CDPClientAdapter(session, id, this.#browserCdpConnection);
            this.#adapters.set(session, adapter);
            return adapter;
        }
        return this.#adapters.get(session);
    }
    close() {
        this.#browserCdpConnection.close();
        for (const adapter of this.#adapters.values()) {
            adapter.close();
        }
    }
}
/**
 * Wrapper on top of CDPSession/CDPConnection to satisfy CDP interface that
 * BidiServer needs.
 *
 * @internal
 */
class CDPClientAdapter extends chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #closed = false;
    #client;
    sessionId = undefined;
    #browserClient;
    constructor(client, sessionId, browserClient) {
        super();
        this.#client = client;
        this.sessionId = sessionId;
        this.#browserClient = browserClient;
        this.#client.on('*', this.#forwardMessage);
    }
    browserClient() {
        return this.#browserClient;
    }
    #forwardMessage = (method, event) => {
        this.emit(method, event);
    };
    async sendCommand(method, ...params) {
        if (this.#closed) {
            return;
        }
        try {
            return await this.#client.send(method, ...params);
        }
        catch (err) {
            if (this.#closed) {
                return;
            }
            throw err;
        }
    }
    close() {
        this.#client.off('*', this.#forwardMessage);
        this.#closed = true;
    }
    isCloseError(error) {
        return error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_2__.TargetCloseError;
    }
}
/**
 * This transport is given to the BiDi server instance and allows Puppeteer
 * to send and receive commands to the BiDiServer.
 * @internal
 */
class NoOpTransport extends chromium_bidi_lib_cjs_bidiMapper_BidiMapper_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
    #onMessage = async (_m) => {
        return;
    };
    emitMessage(message) {
        void this.#onMessage(message);
    }
    setOnMessage(onMessage) {
        this.#onMessage = onMessage;
    }
    async sendMessage(message) {
        this.emit('bidiResponse', message);
    }
    close() {
        this.#onMessage = async (_m) => {
            return;
        };
    }
}
//# sourceMappingURL=BidiOverCdp.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowser: () => (/* binding */ BidiBrowser)
/* harmony export */ });
/* harmony import */ var _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _BrowserContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js");
/* harmony import */ var _core_Session_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/Session.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js");
/* harmony import */ var _Target_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};







/**
 * @internal
 */
let BidiBrowser = (() => {
    let _classSuper = _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.Browser;
    let _private_trustedEmitter_decorators;
    let _private_trustedEmitter_initializers = [];
    let _private_trustedEmitter_extraInitializers = [];
    let _private_trustedEmitter_descriptor;
    return class BidiBrowser extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _private_trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_3__.bubble)()];
            __esDecorate(this, _private_trustedEmitter_descriptor = { get: __setFunctionName(function () { return this.#trustedEmitter_accessor_storage; }, "#trustedEmitter", "get"), set: __setFunctionName(function (value) { this.#trustedEmitter_accessor_storage = value; }, "#trustedEmitter", "set") }, _private_trustedEmitter_decorators, { kind: "accessor", name: "#trustedEmitter", static: false, private: true, access: { has: obj => #trustedEmitter in obj, get: obj => obj.#trustedEmitter, set: (obj, value) => { obj.#trustedEmitter = value; } }, metadata: _metadata }, _private_trustedEmitter_initializers, _private_trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        protocol = 'webDriverBiDi';
        // TODO: Update generator to include fully module
        static subscribeModules = [
            'browsingContext',
            'network',
            'log',
            'script',
        ];
        static subscribeCdpEvents = [
            // Coverage
            'cdp.Debugger.scriptParsed',
            'cdp.CSS.styleSheetAdded',
            'cdp.Runtime.executionContextsCleared',
            // Tracing
            'cdp.Tracing.tracingComplete',
            // TODO: subscribe to all CDP events in the future.
            'cdp.Network.requestWillBeSent',
            'cdp.Debugger.scriptParsed',
            'cdp.Page.screencastFrame',
        ];
        static async create(opts) {
            const session = await _core_Session_js__WEBPACK_IMPORTED_MODULE_5__.Session.from(opts.connection, {
                alwaysMatch: {
                    acceptInsecureCerts: opts.ignoreHTTPSErrors,
                    webSocketUrl: true,
                },
            });
            await session.subscribe(session.capabilities.browserName.toLocaleLowerCase().includes('firefox')
                ? BidiBrowser.subscribeModules
                : [...BidiBrowser.subscribeModules, ...BidiBrowser.subscribeCdpEvents]);
            const browser = new BidiBrowser(session.browser, opts);
            browser.#initialize();
            return browser;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _private_trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__.EventEmitter());
        get #trustedEmitter() { return _private_trustedEmitter_descriptor.get.call(this); }
        set #trustedEmitter(value) { return _private_trustedEmitter_descriptor.set.call(this, value); }
        #process = __runInitializers(this, _private_trustedEmitter_extraInitializers);
        #closeCallback;
        #browserCore;
        #defaultViewport;
        #browserContexts = new WeakMap();
        #target = new _Target_js__WEBPACK_IMPORTED_MODULE_6__.BidiBrowserTarget(this);
        constructor(browserCore, opts) {
            super();
            this.#process = opts.process;
            this.#closeCallback = opts.closeCallback;
            this.#browserCore = browserCore;
            this.#defaultViewport = opts.defaultViewport;
        }
        #initialize() {
            // Initializing existing contexts.
            for (const userContext of this.#browserCore.userContexts) {
                this.#createBrowserContext(userContext);
            }
            this.#browserCore.once('disconnected', () => {
                this.#trustedEmitter.emit("disconnected" /* BrowserEvent.Disconnected */, undefined);
                this.#trustedEmitter.removeAllListeners();
            });
            this.#process?.once('close', () => {
                this.#browserCore.dispose('Browser process exited.', true);
                this.connection.dispose();
            });
        }
        get #browserName() {
            return this.#browserCore.session.capabilities.browserName;
        }
        get #browserVersion() {
            return this.#browserCore.session.capabilities.browserVersion;
        }
        get cdpSupported() {
            return !this.#browserName.toLocaleLowerCase().includes('firefox');
        }
        async userAgent() {
            return this.#browserCore.session.capabilities.userAgent;
        }
        #createBrowserContext(userContext) {
            const browserContext = _BrowserContext_js__WEBPACK_IMPORTED_MODULE_4__.BidiBrowserContext.from(this, userContext, {
                defaultViewport: this.#defaultViewport,
            });
            this.#browserContexts.set(userContext, browserContext);
            browserContext.trustedEmitter.on("targetcreated" /* BrowserContextEvent.TargetCreated */, target => {
                this.#trustedEmitter.emit("targetcreated" /* BrowserEvent.TargetCreated */, target);
            });
            browserContext.trustedEmitter.on("targetchanged" /* BrowserContextEvent.TargetChanged */, target => {
                this.#trustedEmitter.emit("targetchanged" /* BrowserEvent.TargetChanged */, target);
            });
            browserContext.trustedEmitter.on("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target => {
                this.#trustedEmitter.emit("targetdestroyed" /* BrowserEvent.TargetDestroyed */, target);
            });
            return browserContext;
        }
        get connection() {
            // SAFETY: We only have one implementation.
            return this.#browserCore.session.connection;
        }
        wsEndpoint() {
            return this.connection.url;
        }
        async close() {
            if (this.connection.closed) {
                return;
            }
            try {
                await this.#browserCore.close();
                await this.#closeCallback?.call(null);
            }
            catch (error) {
                // Fail silently.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
            finally {
                this.connection.dispose();
            }
        }
        get connected() {
            return !this.#browserCore.disconnected;
        }
        process() {
            return this.#process ?? null;
        }
        async createBrowserContext(_options) {
            const userContext = await this.#browserCore.createUserContext();
            return this.#createBrowserContext(userContext);
        }
        async version() {
            return `${this.#browserName}/${this.#browserVersion}`;
        }
        browserContexts() {
            return [...this.#browserCore.userContexts].map(context => {
                return this.#browserContexts.get(context);
            });
        }
        defaultBrowserContext() {
            return this.#browserContexts.get(this.#browserCore.defaultUserContext);
        }
        newPage() {
            return this.defaultBrowserContext().newPage();
        }
        targets() {
            return [
                this.#target,
                ...this.browserContexts().flatMap(context => {
                    return context.targets();
                }),
            ];
        }
        target() {
            return this.#target;
        }
        async disconnect() {
            try {
                await this.#browserCore.session.end();
            }
            catch (error) {
                // Fail silently.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
            finally {
                this.connection.dispose();
            }
        }
        get debugInfo() {
            return {
                pendingProtocolErrors: this.connection.getPendingProtocolErrors(),
            };
        }
    };
})();

//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js":
/*!******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowserContext: () => (/* binding */ BidiBrowserContext)
/* harmony export */ });
/* harmony import */ var _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js");
/* harmony import */ var _api_BrowserContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _core_UserContext_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/UserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/* harmony import */ var _Target_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});









/**
 * @internal
 */
let BidiBrowserContext = (() => {
    let _classSuper = _api_BrowserContext_js__WEBPACK_IMPORTED_MODULE_1__.BrowserContext;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return class BidiBrowserContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_4__.bubble)()];
            __esDecorate(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: obj => "trustedEmitter" in obj, get: obj => obj.trustedEmitter, set: (obj, value) => { obj.trustedEmitter = value; } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browser, userContext, options) {
            const context = new BidiBrowserContext(browser, userContext, options);
            context.#initialize();
            return context;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter());
        get trustedEmitter() { return this.#trustedEmitter_accessor_storage; }
        set trustedEmitter(value) { this.#trustedEmitter_accessor_storage = value; }
        #browser = __runInitializers(this, _trustedEmitter_extraInitializers);
        #defaultViewport;
        // This is public because of cookies.
        userContext;
        #pages = new WeakMap();
        #targets = new Map();
        #overrides = [];
        constructor(browser, userContext, options) {
            super();
            this.#browser = browser;
            this.userContext = userContext;
            this.#defaultViewport = options.defaultViewport;
        }
        #initialize() {
            // Create targets for existing browsing contexts.
            for (const browsingContext of this.userContext.browsingContexts) {
                this.#createPage(browsingContext);
            }
            this.userContext.on('browsingcontext', ({ browsingContext }) => {
                const page = this.#createPage(browsingContext);
                // We need to wait for the DOMContentLoaded as the
                // browsingContext still may be navigating from the about:blank
                browsingContext.once('DOMContentLoaded', () => {
                    if (browsingContext.originalOpener) {
                        for (const context of this.userContext.browsingContexts) {
                            if (context.id === browsingContext.originalOpener) {
                                this.#pages
                                    .get(context)
                                    .trustedEmitter.emit("popup" /* PageEvent.Popup */, page);
                            }
                        }
                    }
                });
            });
            this.userContext.on('closed', () => {
                this.trustedEmitter.removeAllListeners();
            });
        }
        #createPage(browsingContext) {
            const page = _Page_js__WEBPACK_IMPORTED_MODULE_6__.BidiPage.from(this, browsingContext);
            this.#pages.set(browsingContext, page);
            page.trustedEmitter.on("close" /* PageEvent.Close */, () => {
                this.#pages.delete(browsingContext);
            });
            // -- Target stuff starts here --
            const pageTarget = new _Target_js__WEBPACK_IMPORTED_MODULE_7__.BidiPageTarget(page);
            const pageTargets = new Map();
            this.#targets.set(page, [pageTarget, pageTargets]);
            page.trustedEmitter.on("frameattached" /* PageEvent.FrameAttached */, frame => {
                const bidiFrame = frame;
                const target = new _Target_js__WEBPACK_IMPORTED_MODULE_7__.BidiFrameTarget(bidiFrame);
                pageTargets.set(bidiFrame, target);
                this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, target);
            });
            page.trustedEmitter.on("framenavigated" /* PageEvent.FrameNavigated */, frame => {
                const bidiFrame = frame;
                const target = pageTargets.get(bidiFrame);
                // If there is no target, then this is the page's frame.
                if (target === undefined) {
                    this.trustedEmitter.emit("targetchanged" /* BrowserContextEvent.TargetChanged */, pageTarget);
                }
                else {
                    this.trustedEmitter.emit("targetchanged" /* BrowserContextEvent.TargetChanged */, target);
                }
            });
            page.trustedEmitter.on("framedetached" /* PageEvent.FrameDetached */, frame => {
                const bidiFrame = frame;
                const target = pageTargets.get(bidiFrame);
                if (target === undefined) {
                    return;
                }
                pageTargets.delete(bidiFrame);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target);
            });
            page.trustedEmitter.on("workercreated" /* PageEvent.WorkerCreated */, worker => {
                const bidiWorker = worker;
                const target = new _Target_js__WEBPACK_IMPORTED_MODULE_7__.BidiWorkerTarget(bidiWorker);
                pageTargets.set(bidiWorker, target);
                this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, target);
            });
            page.trustedEmitter.on("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker => {
                const bidiWorker = worker;
                const target = pageTargets.get(bidiWorker);
                if (target === undefined) {
                    return;
                }
                pageTargets.delete(worker);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, target);
            });
            page.trustedEmitter.on("close" /* PageEvent.Close */, () => {
                this.#targets.delete(page);
                this.trustedEmitter.emit("targetdestroyed" /* BrowserContextEvent.TargetDestroyed */, pageTarget);
            });
            this.trustedEmitter.emit("targetcreated" /* BrowserContextEvent.TargetCreated */, pageTarget);
            // -- Target stuff ends here --
            return page;
        }
        targets() {
            return [...this.#targets.values()].flatMap(([target, frames]) => {
                return [target, ...frames.values()];
            });
        }
        async newPage() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const _guard = __addDisposableResource(env_1, await this.waitForScreenshotOperations(), false);
                const context = await this.userContext.createBrowsingContext("tab" /* Bidi.BrowsingContext.CreateType.Tab */);
                const page = this.#pages.get(context);
                if (!page) {
                    throw new Error('Page is not found');
                }
                if (this.#defaultViewport) {
                    try {
                        await page.setViewport(this.#defaultViewport);
                    }
                    catch {
                        // No support for setViewport in Firefox.
                    }
                }
                return page;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        async close() {
            if (!this.isIncognito()) {
                throw new Error('Default context cannot be closed!');
            }
            try {
                await this.userContext.remove();
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError)(error);
            }
            this.#targets.clear();
        }
        browser() {
            return this.#browser;
        }
        async pages() {
            return [...this.userContext.browsingContexts].map(context => {
                return this.#pages.get(context);
            });
        }
        isIncognito() {
            return this.userContext.id !== _core_UserContext_js__WEBPACK_IMPORTED_MODULE_5__.UserContext.DEFAULT;
        }
        async overridePermissions(origin, permissions) {
            const permissionsSet = new Set(permissions.map(permission => {
                const protocolPermission = _api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
                if (!protocolPermission) {
                    throw new Error('Unknown permission: ' + permission);
                }
                return permission;
            }));
            await Promise.all(Array.from(_api_Browser_js__WEBPACK_IMPORTED_MODULE_0__.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.keys()).map(permission => {
                const result = this.userContext.setPermissions(origin, {
                    name: permission,
                }, permissionsSet.has(permission)
                    ? "granted" /* Bidi.Permissions.PermissionState.Granted */
                    : "denied" /* Bidi.Permissions.PermissionState.Denied */);
                this.#overrides.push({ origin, permission });
                // TODO: some permissions are outdated and setting them to denied does
                // not work.
                if (!permissionsSet.has(permission)) {
                    return result.catch(_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError);
                }
                return result;
            }));
        }
        async clearPermissionOverrides() {
            const promises = this.#overrides.map(({ permission, origin }) => {
                return this.userContext
                    .setPermissions(origin, {
                    name: permission,
                }, "prompt" /* Bidi.Permissions.PermissionState.Prompt */)
                    .catch(_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError);
            });
            this.#overrides = [];
            await Promise.all(promises);
        }
        get id() {
            if (this.userContext.id === _core_UserContext_js__WEBPACK_IMPORTED_MODULE_5__.UserContext.DEFAULT) {
                return undefined;
            }
            return this.userContext.id;
        }
    };
})();

//# sourceMappingURL=BrowserContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiCdpSession: () => (/* binding */ BidiCdpSession)
/* harmony export */ });
/* harmony import */ var _api_CDPSession_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _util_Deferred_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Deferred.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js");



/**
 * @internal
 */
class BidiCdpSession extends _api_CDPSession_js__WEBPACK_IMPORTED_MODULE_0__.CDPSession {
    static sessions = new Map();
    #detached = false;
    #connection;
    #sessionId = _util_Deferred_js__WEBPACK_IMPORTED_MODULE_2__.Deferred.create();
    frame;
    constructor(frame, sessionId) {
        super();
        this.frame = frame;
        if (!this.frame.page().browser().cdpSupported) {
            return;
        }
        const connection = this.frame.page().browser().connection;
        this.#connection = connection;
        if (sessionId) {
            this.#sessionId.resolve(sessionId);
            BidiCdpSession.sessions.set(sessionId, this);
        }
        else {
            (async () => {
                try {
                    const { result } = await connection.send('cdp.getSession', {
                        context: frame._id,
                    });
                    this.#sessionId.resolve(result.session);
                    BidiCdpSession.sessions.set(result.session, this);
                }
                catch (error) {
                    this.#sessionId.reject(error);
                }
            })();
        }
        // SAFETY: We never throw #sessionId.
        BidiCdpSession.sessions.set(this.#sessionId.value(), this);
    }
    connection() {
        return undefined;
    }
    async send(method, params, options) {
        if (this.#connection === undefined) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation('CDP support is required for this feature. The current browser does not support CDP.');
        }
        if (this.#detached) {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
        }
        const session = await this.#sessionId.valueOrThrow();
        const { result } = await this.#connection.send('cdp.sendCommand', {
            method: method,
            params: params,
            session,
        }, options?.timeout);
        return result.result;
    }
    async detach() {
        if (this.#connection === undefined ||
            this.#connection.closed ||
            this.#detached) {
            return;
        }
        try {
            await this.frame.client.send('Target.detachFromTarget', {
                sessionId: this.id(),
            });
        }
        finally {
            this.onClose();
        }
    }
    /**
     * @internal
     */
    onClose = () => {
        BidiCdpSession.sessions.delete(this.id());
        this.#detached = true;
    };
    id() {
        const value = this.#sessionId.value();
        return typeof value === 'string' ? value : '';
    }
}
//# sourceMappingURL=CDPSession.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiConnection: () => (/* binding */ BidiConnection)
/* harmony export */ });
/* harmony import */ var _common_CallbackRegistry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/CallbackRegistry.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js");
/* harmony import */ var _common_Debug_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Debug.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _CDPSession_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */






const debugProtocolSend = (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:webDriverBiDi:SEND ►');
const debugProtocolReceive = (0,_common_Debug_js__WEBPACK_IMPORTED_MODULE_1__.debug)('puppeteer:webDriverBiDi:RECV ◀');
/**
 * @internal
 */
class BidiConnection extends _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {
    #url;
    #transport;
    #delay;
    #timeout = 0;
    #closed = false;
    #callbacks = new _common_CallbackRegistry_js__WEBPACK_IMPORTED_MODULE_0__.CallbackRegistry();
    #emitters = [];
    constructor(url, transport, delay = 0, timeout) {
        super();
        this.#url = url;
        this.#delay = delay;
        this.#timeout = timeout ?? 180_000;
        this.#transport = transport;
        this.#transport.onmessage = this.onMessage.bind(this);
        this.#transport.onclose = this.unbind.bind(this);
    }
    get closed() {
        return this.#closed;
    }
    get url() {
        return this.#url;
    }
    pipeTo(emitter) {
        this.#emitters.push(emitter);
    }
    emit(type, event) {
        for (const emitter of this.#emitters) {
            emitter.emit(type, event);
        }
        return super.emit(type, event);
    }
    send(method, params, timeout) {
        (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_4__.assert)(!this.#closed, 'Protocol error: Connection closed.');
        return this.#callbacks.create(method, timeout ?? this.#timeout, id => {
            const stringifiedMessage = JSON.stringify({
                id,
                method,
                params,
            });
            debugProtocolSend(stringifiedMessage);
            this.#transport.send(stringifiedMessage);
        });
    }
    /**
     * @internal
     */
    async onMessage(message) {
        if (this.#delay) {
            await new Promise(f => {
                return setTimeout(f, this.#delay);
            });
        }
        debugProtocolReceive(message);
        const object = JSON.parse(message);
        if ('type' in object) {
            switch (object.type) {
                case 'success':
                    this.#callbacks.resolve(object.id, object);
                    return;
                case 'error':
                    if (object.id === null) {
                        break;
                    }
                    this.#callbacks.reject(object.id, createProtocolError(object), `${object.error}: ${object.message}`);
                    return;
                case 'event':
                    if (isCdpEvent(object)) {
                        _CDPSession_js__WEBPACK_IMPORTED_MODULE_5__.BidiCdpSession.sessions
                            .get(object.params.session)
                            ?.emit(object.params.event, object.params.params);
                        return;
                    }
                    // SAFETY: We know the method and parameter still match here.
                    this.emit(object.method, object.params);
                    return;
            }
        }
        // Even if the response in not in BiDi protocol format but `id` is provided, reject
        // the callback. This can happen if the endpoint supports CDP instead of BiDi.
        if ('id' in object) {
            this.#callbacks.reject(object.id, `Protocol Error. Message is not in BiDi protocol format: '${message}'`, object.message);
        }
        (0,_common_util_js__WEBPACK_IMPORTED_MODULE_3__.debugError)(object);
    }
    /**
     * Unbinds the connection, but keeps the transport open. Useful when the transport will
     * be reused by other connection e.g. with different protocol.
     * @internal
     */
    unbind() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        // Both may still be invoked and produce errors
        this.#transport.onmessage = () => { };
        this.#transport.onclose = () => { };
        this.#callbacks.clear();
    }
    /**
     * Unbinds the connection and closes the transport.
     */
    dispose() {
        this.unbind();
        this.#transport.close();
    }
    getPendingProtocolErrors() {
        return this.#callbacks.getPendingProtocolErrors();
    }
}
/**
 * @internal
 */
function createProtocolError(object) {
    let message = `${object.error} ${object.message}`;
    if (object.stacktrace) {
        message += ` ${object.stacktrace}`;
    }
    return message;
}
function isCdpEvent(event) {
    return event.method.startsWith('cdp.');
}
//# sourceMappingURL=Connection.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiDeserializer: () => (/* binding */ BidiDeserializer)
/* harmony export */ });
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @internal
 */
class BidiDeserializer {
    static deserialize(result) {
        if (!result) {
            (0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.debugError)('Service did not produce a result.');
            return undefined;
        }
        switch (result.type) {
            case 'array':
                return result.value?.map(value => {
                    return this.deserialize(value);
                });
            case 'set':
                return result.value?.reduce((acc, value) => {
                    return acc.add(this.deserialize(value));
                }, new Set());
            case 'object':
                return result.value?.reduce((acc, tuple) => {
                    const { key, value } = this.#deserializeTuple(tuple);
                    acc[key] = value;
                    return acc;
                }, {});
            case 'map':
                return result.value?.reduce((acc, tuple) => {
                    const { key, value } = this.#deserializeTuple(tuple);
                    return acc.set(key, value);
                }, new Map());
            case 'promise':
                return {};
            case 'regexp':
                return new RegExp(result.value.pattern, result.value.flags);
            case 'date':
                return new Date(result.value);
            case 'undefined':
                return undefined;
            case 'null':
                return null;
            case 'number':
                return this.#deserializeNumber(result.value);
            case 'bigint':
                return BigInt(result.value);
            case 'boolean':
                return Boolean(result.value);
            case 'string':
                return result.value;
        }
        (0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.debugError)(`Deserialization of type ${result.type} not supported.`);
        return undefined;
    }
    static #deserializeNumber(value) {
        switch (value) {
            case '-0':
                return -0;
            case 'NaN':
                return NaN;
            case 'Infinity':
                return Infinity;
            case '-Infinity':
                return -Infinity;
            default:
                return value;
        }
    }
    static #deserializeTuple([serializedKey, serializedValue]) {
        const key = typeof serializedKey === 'string'
            ? serializedKey
            : this.deserialize(serializedKey);
        const value = this.deserialize(serializedValue);
        return { key, value };
    }
}
//# sourceMappingURL=Deserializer.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiDialog: () => (/* binding */ BidiDialog)
/* harmony export */ });
/* harmony import */ var _api_Dialog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Dialog.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

class BidiDialog extends _api_Dialog_js__WEBPACK_IMPORTED_MODULE_0__.Dialog {
    static from(prompt) {
        return new BidiDialog(prompt);
    }
    #prompt;
    constructor(prompt) {
        super(prompt.info.type, prompt.info.message, prompt.info.defaultValue);
        this.#prompt = prompt;
    }
    async handle(options) {
        await this.#prompt.handle({
            accept: options.accept,
            userText: options.text,
        });
    }
}
//# sourceMappingURL=Dialog.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiElementHandle: () => (/* binding */ BidiElementHandle)
/* harmony export */ });
/* harmony import */ var _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js");
/* harmony import */ var _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/AsyncIterableUtil.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});




/**
 * @internal
 */
let BidiElementHandle = (() => {
    var _a;
    let _classSuper = _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__.ElementHandle;
    let _instanceExtraInitializers = [];
    let _autofill_decorators;
    let _contentFrame_decorators;
    return class BidiElementHandle extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _autofill_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)()];
            _contentFrame_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(), (_a = _api_ElementHandle_js__WEBPACK_IMPORTED_MODULE_0__.ElementHandle).bindIsolatedHandle.bind(_a)];
            __esDecorate(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: obj => "autofill" in obj, get: obj => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: obj => "contentFrame" in obj, get: obj => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(value, realm) {
            return new BidiElementHandle(value, realm);
        }
        constructor(value, realm) {
            super(_JSHandle_js__WEBPACK_IMPORTED_MODULE_3__.BidiJSHandle.from(value, realm));
            __runInitializers(this, _instanceExtraInitializers);
        }
        get realm() {
            // SAFETY: See the super call in the constructor.
            return this.handle.realm;
        }
        get frame() {
            return this.realm.environment;
        }
        remoteValue() {
            return this.handle.remoteValue();
        }
        async autofill(data) {
            const client = this.frame.client;
            const nodeInfo = await client.send('DOM.describeNode', {
                objectId: this.handle.id,
            });
            const fieldId = nodeInfo.node.backendNodeId;
            const frameId = this.frame._id;
            await client.send('Autofill.trigger', {
                fieldId,
                frameId,
                card: data.creditCard,
            });
        }
        async contentFrame() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource(env_1, (await this.evaluateHandle(element => {
                    if (element instanceof HTMLIFrameElement ||
                        element instanceof HTMLFrameElement) {
                        return element.contentWindow;
                    }
                    return;
                })), false);
                const value = handle.remoteValue();
                if (value.type === 'window') {
                    return (this.frame
                        .page()
                        .frames()
                        .find(frame => {
                        return frame._id === value.value.context;
                    }) ?? null);
                }
                return null;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        async uploadFile(...files) {
            // Locate all files and confirm that they exist.
            // eslint-disable-next-line @typescript-eslint/consistent-type-imports
            let path;
            try {
                path = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ "path", 19));
            }
            catch (error) {
                if (error instanceof TypeError) {
                    throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
                }
                throw error;
            }
            files = files.map(file => {
                if (path.win32.isAbsolute(file) || path.posix.isAbsolute(file)) {
                    return file;
                }
                else {
                    return path.resolve(file);
                }
            });
            await this.frame.setFiles(this, files);
        }
        async *queryAXTree(name, role) {
            const results = await this.frame.locateNodes(this, {
                type: 'accessibility',
                value: {
                    role,
                    name,
                },
            });
            return yield* _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_1__.AsyncIterableUtil.map(results, node => {
                // TODO: maybe change ownership since the default ownership is probably none.
                return Promise.resolve(BidiElementHandle.from(node, this.realm));
            });
        }
    };
})();

//# sourceMappingURL=ElementHandle.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExposeableFunction: () => (/* binding */ ExposeableFunction)
/* harmony export */ });
/* harmony import */ var chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chromium-bidi/lib/cjs/protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _util_Function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/Function.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});







/**
 * @internal
 */
class ExposeableFunction {
    static async from(frame, name, apply, isolate = false) {
        const func = new ExposeableFunction(frame, name, apply, isolate);
        await func.#initialize();
        return func;
    }
    #frame;
    name;
    #apply;
    #isolate;
    #channel;
    #scripts = [];
    #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack();
    constructor(frame, name, apply, isolate = false) {
        this.#frame = frame;
        this.name = name;
        this.#apply = apply;
        this.#isolate = isolate;
        this.#channel = `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}`;
    }
    async #initialize() {
        const connection = this.#connection;
        const channel = {
            type: 'channel',
            value: {
                channel: this.#channel,
                ownership: "root" /* Bidi.Script.ResultOwnership.Root */,
            },
        };
        const connectionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_1__.EventEmitter(connection));
        connectionEmitter.on(chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__.ChromiumBidi.Script.EventNames.Message, this.#handleMessage);
        const functionDeclaration = (0,_util_Function_js__WEBPACK_IMPORTED_MODULE_4__.stringifyFunction)((0,_util_Function_js__WEBPACK_IMPORTED_MODULE_4__.interpolateFunction)((callback) => {
            Object.assign(globalThis, {
                [PLACEHOLDER('name')]: function (...args) {
                    return new Promise((resolve, reject) => {
                        callback([resolve, reject, args]);
                    });
                },
            });
        }, { name: JSON.stringify(this.name) }));
        const frames = [this.#frame];
        for (const frame of frames) {
            frames.push(...frame.childFrames());
        }
        await Promise.all(frames.map(async (frame) => {
            const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
            try {
                const [script] = await Promise.all([
                    frame.browsingContext.addPreloadScript(functionDeclaration, {
                        arguments: [channel],
                        sandbox: realm.sandbox,
                    }),
                    realm.realm.callFunction(functionDeclaration, false, {
                        arguments: [channel],
                    }),
                ]);
                this.#scripts.push([frame, script]);
            }
            catch (error) {
                // If it errors, the frame probably doesn't support call function. We
                // fail gracefully.
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }));
    }
    get #connection() {
        return this.#frame.page().browser().connection;
    }
    #handleMessage = async (params) => {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            if (params.channel !== this.#channel) {
                return;
            }
            const realm = this.#getRealm(params.source);
            if (!realm) {
                // Unrelated message.
                return;
            }
            const dataHandle = __addDisposableResource(env_1, _JSHandle_js__WEBPACK_IMPORTED_MODULE_6__.BidiJSHandle.from(params.data, realm), false);
            const argsHandle = __addDisposableResource(env_1, await dataHandle.evaluateHandle(([, , args]) => {
                return args;
            }), false);
            const stack = __addDisposableResource(env_1, new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack(), false);
            const args = [];
            for (const [index, handle] of await argsHandle.getProperties()) {
                stack.use(handle);
                // Element handles are passed as is.
                if (handle instanceof _ElementHandle_js__WEBPACK_IMPORTED_MODULE_5__.BidiElementHandle) {
                    args[+index] = handle;
                    stack.use(handle);
                    continue;
                }
                // Everything else is passed as the JS value.
                args[+index] = handle.jsonValue();
            }
            let result;
            try {
                result = await this.#apply(...(await Promise.all(args)));
            }
            catch (error) {
                try {
                    if (error instanceof Error) {
                        await dataHandle.evaluate(([, reject], name, message, stack) => {
                            const error = new Error(message);
                            error.name = name;
                            if (stack) {
                                error.stack = stack;
                            }
                            reject(error);
                        }, error.name, error.message, error.stack);
                    }
                    else {
                        await dataHandle.evaluate(([, reject], error) => {
                            reject(error);
                        }, error);
                    }
                }
                catch (error) {
                    (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
                }
                return;
            }
            try {
                await dataHandle.evaluate(([resolve], result) => {
                    resolve(result);
                }, result);
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    };
    #getRealm(source) {
        const frame = this.#findFrame(source.context);
        if (!frame) {
            // Unrelated message.
            return;
        }
        return frame.realm(source.realm);
    }
    #findFrame(id) {
        const frames = [this.#frame];
        for (const frame of frames) {
            if (frame._id === id) {
                return frame;
            }
            frames.push(...frame.childFrames());
        }
        return;
    }
    [Symbol.dispose]() {
        void this[Symbol.asyncDispose]().catch(_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError);
    }
    async [Symbol.asyncDispose]() {
        this.#disposables.dispose();
        await Promise.all(this.#scripts.map(async ([frame, script]) => {
            const realm = this.#isolate ? frame.isolatedRealm() : frame.mainRealm();
            try {
                await Promise.all([
                    realm.evaluate(name => {
                        delete globalThis[name];
                    }, this.name),
                    ...frame.childFrames().map(childFrame => {
                        return childFrame.evaluate(name => {
                            delete globalThis[name];
                        }, this.name);
                    }),
                    frame.browsingContext.removePreloadScript(script),
                ]);
            }
            catch (error) {
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_2__.debugError)(error);
            }
        }));
    }
}
//# sourceMappingURL=ExposedFunction.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiFrame: () => (/* binding */ BidiFrame)
/* harmony export */ });
/* harmony import */ var chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chromium-bidi/lib/cjs/protocol/protocol.js */ "./node_modules/chromium-bidi/lib/cjs/protocol/protocol.js");
/* harmony import */ var _third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../third_party/rxjs/rxjs.js */ "./node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js");
/* harmony import */ var _api_Frame_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api/Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js");
/* harmony import */ var _cdp_Accessibility_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cdp/Accessibility.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js");
/* harmony import */ var _common_ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/ConsoleMessage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/ErrorLike.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js");
/* harmony import */ var _CDPSession_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CDPSession.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/CDPSession.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/* harmony import */ var _Dialog_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Dialog.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js");
/* harmony import */ var _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ExposedFunction.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js");
/* harmony import */ var _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
/* harmony import */ var _WebWorker_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName = (undefined && undefined.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

















let BidiFrame = (() => {
    var _a;
    let _classSuper = _api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _setContent_decorators;
    let _waitForNavigation_decorators;
    let _private_waitForLoad$_decorators;
    let _private_waitForLoad$_descriptor;
    let _private_waitForNetworkIdle$_decorators;
    let _private_waitForNetworkIdle$_descriptor;
    let _setFiles_decorators;
    let _locateNodes_decorators;
    return class BidiFrame extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _goto_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _setContent_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _waitForNavigation_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _private_waitForLoad$_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _private_waitForNetworkIdle$_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _setFiles_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            _locateNodes_decorators = [_api_Frame_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDetached];
            __esDecorate(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: obj => "goto" in obj, get: obj => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: obj => "setContent" in obj, get: obj => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: obj => "waitForNavigation" in obj, get: obj => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_waitForLoad$_descriptor = { value: __setFunctionName(function (options = {}) {
                    let { waitUntil = 'load' } = options;
                    const { timeout: ms = this.timeoutSettings.navigationTimeout() } = options;
                    if (!Array.isArray(waitUntil)) {
                        waitUntil = [waitUntil];
                    }
                    const events = new Set();
                    for (const lifecycleEvent of waitUntil) {
                        switch (lifecycleEvent) {
                            case 'load': {
                                events.add('load');
                                break;
                            }
                            case 'domcontentloaded': {
                                events.add('DOMContentLoaded');
                                break;
                            }
                        }
                    }
                    if (events.size === 0) {
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(undefined);
                    }
                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([...events].map(event => {
                        return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(this.browsingContext, event);
                    })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.map)(() => { }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.first)(), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(ms), this.#detached$().pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.map)(() => {
                        throw new Error('Frame detached.');
                    }))));
                }, "#waitForLoad$") }, _private_waitForLoad$_decorators, { kind: "method", name: "#waitForLoad$", static: false, private: true, access: { has: obj => #waitForLoad$ in obj, get: obj => obj.#waitForLoad$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_waitForNetworkIdle$_descriptor = { value: __setFunctionName(function (options = {}) {
                    let { waitUntil = 'load' } = options;
                    if (!Array.isArray(waitUntil)) {
                        waitUntil = [waitUntil];
                    }
                    let concurrency = Infinity;
                    for (const event of waitUntil) {
                        switch (event) {
                            case 'networkidle0': {
                                concurrency = Math.min(0, concurrency);
                                break;
                            }
                            case 'networkidle2': {
                                concurrency = Math.min(2, concurrency);
                                break;
                            }
                        }
                    }
                    if (concurrency === Infinity) {
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(undefined);
                    }
                    return this.page().waitForNetworkIdle$({
                        idleTime: 500,
                        timeout: options.timeout ?? this.timeoutSettings.timeout(),
                        concurrency,
                    });
                }, "#waitForNetworkIdle$") }, _private_waitForNetworkIdle$_decorators, { kind: "method", name: "#waitForNetworkIdle$", static: false, private: true, access: { has: obj => #waitForNetworkIdle$ in obj, get: obj => obj.#waitForNetworkIdle$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: obj => "setFiles" in obj, get: obj => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: obj => "locateNodes" in obj, get: obj => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(parent, browsingContext) {
            const frame = new BidiFrame(parent, browsingContext);
            frame.#initialize();
            return frame;
        }
        #parent = __runInitializers(this, _instanceExtraInitializers);
        browsingContext;
        #frames = new WeakMap();
        realms;
        _id;
        client;
        accessibility;
        constructor(parent, browsingContext) {
            super();
            this.#parent = parent;
            this.browsingContext = browsingContext;
            this._id = browsingContext.id;
            this.client = new _CDPSession_js__WEBPACK_IMPORTED_MODULE_8__.BidiCdpSession(this);
            this.realms = {
                default: _Realm_js__WEBPACK_IMPORTED_MODULE_14__.BidiFrameRealm.from(this.browsingContext.defaultRealm, this),
                internal: _Realm_js__WEBPACK_IMPORTED_MODULE_14__.BidiFrameRealm.from(this.browsingContext.createWindowRealm(`__puppeteer_internal_${Math.ceil(Math.random() * 10000)}`), this),
            };
            this.accessibility = new _cdp_Accessibility_js__WEBPACK_IMPORTED_MODULE_3__.Accessibility(this.realms.default);
        }
        #initialize() {
            for (const browsingContext of this.browsingContext.children) {
                this.#createFrameTarget(browsingContext);
            }
            this.browsingContext.on('browsingcontext', ({ browsingContext }) => {
                this.#createFrameTarget(browsingContext);
            });
            this.browsingContext.on('closed', () => {
                for (const session of _CDPSession_js__WEBPACK_IMPORTED_MODULE_8__.BidiCdpSession.sessions.values()) {
                    if (session.frame === this) {
                        session.onClose();
                    }
                }
                this.page().trustedEmitter.emit("framedetached" /* PageEvent.FrameDetached */, this);
            });
            this.browsingContext.on('request', ({ request }) => {
                const httpRequest = _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_12__.BidiHTTPRequest.from(request, this);
                request.once('success', () => {
                    this.page().trustedEmitter.emit("requestfinished" /* PageEvent.RequestFinished */, httpRequest);
                });
                request.once('error', () => {
                    this.page().trustedEmitter.emit("requestfailed" /* PageEvent.RequestFailed */, httpRequest);
                });
                void httpRequest.finalizeInterceptions();
            });
            this.browsingContext.on('navigation', ({ navigation }) => {
                navigation.once('fragment', () => {
                    this.page().trustedEmitter.emit("framenavigated" /* PageEvent.FrameNavigated */, this);
                });
            });
            this.browsingContext.on('load', () => {
                this.page().trustedEmitter.emit("load" /* PageEvent.Load */, undefined);
            });
            this.browsingContext.on('DOMContentLoaded', () => {
                this._hasStartedLoading = true;
                this.page().trustedEmitter.emit("domcontentloaded" /* PageEvent.DOMContentLoaded */, undefined);
                this.page().trustedEmitter.emit("framenavigated" /* PageEvent.FrameNavigated */, this);
            });
            this.browsingContext.on('userprompt', ({ userPrompt }) => {
                this.page().trustedEmitter.emit("dialog" /* PageEvent.Dialog */, _Dialog_js__WEBPACK_IMPORTED_MODULE_10__.BidiDialog.from(userPrompt));
            });
            this.browsingContext.on('log', ({ entry }) => {
                if (this._id !== entry.source.context) {
                    return;
                }
                if (isConsoleLogEntry(entry)) {
                    const args = entry.args.map(arg => {
                        return this.mainRealm().createHandle(arg);
                    });
                    const text = args
                        .reduce((value, arg) => {
                        const parsedValue = arg instanceof _JSHandle_js__WEBPACK_IMPORTED_MODULE_13__.BidiJSHandle && arg.isPrimitiveValue
                            ? _Deserializer_js__WEBPACK_IMPORTED_MODULE_9__.BidiDeserializer.deserialize(arg.remoteValue())
                            : arg.toString();
                        return `${value} ${parsedValue}`;
                    }, '')
                        .slice(1);
                    this.page().trustedEmitter.emit("console" /* PageEvent.Console */, new _common_ConsoleMessage_js__WEBPACK_IMPORTED_MODULE_4__.ConsoleMessage(entry.method, text, args, getStackTraceLocations(entry.stackTrace)));
                }
                else if (isJavaScriptLogEntry(entry)) {
                    const error = new Error(entry.text ?? '');
                    const messageHeight = error.message.split('\n').length;
                    const messageLines = error.stack.split('\n').splice(0, messageHeight);
                    const stackLines = [];
                    if (entry.stackTrace) {
                        for (const frame of entry.stackTrace.callFrames) {
                            // Note we need to add `1` because the values are 0-indexed.
                            stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
                            if (stackLines.length >= Error.stackTraceLimit) {
                                break;
                            }
                        }
                    }
                    error.stack = [...messageLines, ...stackLines].join('\n');
                    this.page().trustedEmitter.emit("pageerror" /* PageEvent.PageError */, error);
                }
                else {
                    (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.debugError)(`Unhandled LogEntry with type "${entry.type}", text "${entry.text}" and level "${entry.level}"`);
                }
            });
            this.browsingContext.on('worker', ({ realm }) => {
                const worker = _WebWorker_js__WEBPACK_IMPORTED_MODULE_16__.BidiWebWorker.from(this, realm);
                realm.on('destroyed', () => {
                    this.page().trustedEmitter.emit("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker);
                });
                this.page().trustedEmitter.emit("workercreated" /* PageEvent.WorkerCreated */, worker);
            });
        }
        #createFrameTarget(browsingContext) {
            const frame = BidiFrame.from(this, browsingContext);
            this.#frames.set(browsingContext, frame);
            this.page().trustedEmitter.emit("frameattached" /* PageEvent.FrameAttached */, frame);
            browsingContext.on('closed', () => {
                this.#frames.delete(browsingContext);
            });
            return frame;
        }
        get timeoutSettings() {
            return this.page()._timeoutSettings;
        }
        mainRealm() {
            return this.realms.default;
        }
        isolatedRealm() {
            return this.realms.internal;
        }
        realm(id) {
            for (const realm of Object.values(this.realms)) {
                if (realm.realm.id === id) {
                    return realm;
                }
            }
            return;
        }
        page() {
            let parent = this.#parent;
            while (parent instanceof BidiFrame) {
                parent = parent.#parent;
            }
            return parent;
        }
        isOOPFrame() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        url() {
            return this.browsingContext.url;
        }
        parentFrame() {
            if (this.#parent instanceof BidiFrame) {
                return this.#parent;
            }
            return null;
        }
        childFrames() {
            return [...this.browsingContext.children].map(child => {
                return this.#frames.get(child);
            });
        }
        #detached$() {
            return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.defer)(() => {
                if (this.detached) {
                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(this);
                }
                return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(this.page().trustedEmitter, "framedetached" /* PageEvent.FrameDetached */).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.filter)(detachedFrame => {
                    return detachedFrame === this;
                }));
            });
        }
        async goto(url, options = {}) {
            const [response] = await Promise.all([
                this.waitForNavigation(options),
                // Some implementations currently only report errors when the
                // readiness=interactive.
                //
                // Related: https://bugzilla.mozilla.org/show_bug.cgi?id=1846601
                this.browsingContext
                    .navigate(url, "interactive" /* Bidi.BrowsingContext.ReadinessState.Interactive */)
                    .catch(error => {
                    if ((0,_util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_7__.isErrorLike)(error) &&
                        error.message.includes('net::ERR_HTTP_RESPONSE_CODE_FAILURE')) {
                        return;
                    }
                    throw error;
                }),
            ]).catch((0,_util_js__WEBPACK_IMPORTED_MODULE_15__.rewriteNavigationError)(url, options.timeout ?? this.timeoutSettings.navigationTimeout()));
            return response;
        }
        async setContent(html, options = {}) {
            await Promise.all([
                this.setFrameContent(html),
                (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([
                    this.#waitForLoad$(options),
                    this.#waitForNetworkIdle$(options),
                ])),
            ]);
        }
        async waitForNavigation(options = {}) {
            const { timeout: ms = this.timeoutSettings.navigationTimeout() } = options;
            const frames = this.childFrames().map(frame => {
                return frame.#detached$();
            });
            return await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([
                (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(this.browsingContext, 'navigation').pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.switchMap)(({ navigation }) => {
                    return this.#waitForLoad$(options).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.delayWhen)(() => {
                        if (frames.length === 0) {
                            return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(undefined);
                        }
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.combineLatest)(frames);
                    }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(navigation, 'fragment'), (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(navigation, 'failed'), (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(navigation, 'aborted').pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.map)(({ url }) => {
                        throw new Error(`Navigation aborted: ${url}`);
                    }))), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.switchMap)(() => {
                        if (navigation.request) {
                            function requestFinished$(request) {
                                // Reduces flakiness if the response events arrive after
                                // the load event.
                                // Usually, the response or error is already there at this point.
                                if (request.response || request.error) {
                                    return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(navigation);
                                }
                                if (request.redirect) {
                                    return requestFinished$(request.redirect);
                                }
                                return (0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(request, 'success')
                                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(request, 'error')), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.fromEmitterEvent)(request, 'redirect')))
                                    .pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.switchMap)(() => {
                                    return requestFinished$(request);
                                }));
                            }
                            return requestFinished$(navigation.request);
                        }
                        return (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.of)(navigation);
                    }));
                })),
                this.#waitForNetworkIdle$(options),
            ]).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.map)(([navigation]) => {
                const request = navigation.request;
                if (!request) {
                    return null;
                }
                const lastRequest = request.lastRedirect ?? request;
                const httpRequest = _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_12__.requests.get(lastRequest);
                return httpRequest.response();
            }), (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(ms), this.#detached$().pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_1__.map)(() => {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.TargetCloseError('Frame detached.');
            })))));
        }
        waitForDevicePrompt() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        get detached() {
            return this.browsingContext.closed;
        }
        #exposedFunctions = new Map();
        async exposeFunction(name, apply) {
            if (this.#exposedFunctions.has(name)) {
                throw new Error(`Failed to add page binding with name ${name}: globalThis['${name}'] already exists!`);
            }
            const exposeable = await _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_11__.ExposeableFunction.from(this, name, apply);
            this.#exposedFunctions.set(name, exposeable);
        }
        async removeExposedFunction(name) {
            const exposedFunction = this.#exposedFunctions.get(name);
            if (!exposedFunction) {
                throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);
            }
            this.#exposedFunctions.delete(name);
            await exposedFunction[Symbol.asyncDispose]();
        }
        async createCDPSession() {
            const { sessionId } = await this.client.send('Target.attachToTarget', {
                targetId: this._id,
                flatten: true,
            });
            await this.browsingContext.subscribe([chromium_bidi_lib_cjs_protocol_protocol_js__WEBPACK_IMPORTED_MODULE_0__.ChromiumBidi.BiDiModule.Cdp]);
            return new _CDPSession_js__WEBPACK_IMPORTED_MODULE_8__.BidiCdpSession(this, sessionId);
        }
        get #waitForLoad$() { return _private_waitForLoad$_descriptor.value; }
        get #waitForNetworkIdle$() { return _private_waitForNetworkIdle$_descriptor.value; }
        async setFiles(element, files) {
            await this.browsingContext.setFiles(
            // SAFETY: ElementHandles are always remote references.
            element.remoteValue(), files);
        }
        async locateNodes(element, locator) {
            return await this.browsingContext.locateNodes(locator, 
            // SAFETY: ElementHandles are always remote references.
            [element.remoteValue()]);
        }
    };
})();

function isConsoleLogEntry(event) {
    return event.type === 'console';
}
function isJavaScriptLogEntry(event) {
    return event.type === 'javascript';
}
function getStackTraceLocations(stackTrace) {
    const stackTraceLocations = [];
    if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
            stackTraceLocations.push({
                url: callFrame.url,
                lineNumber: callFrame.lineNumber,
                columnNumber: callFrame.columnNumber,
            });
        }
    }
    return stackTraceLocations;
}
//# sourceMappingURL=Frame.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js":
/*!***************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiHTTPRequest: () => (/* binding */ BidiHTTPRequest),
/* harmony export */   requests: () => (/* binding */ requests)
/* harmony export */ });
/* harmony import */ var _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js");
var _a;



const requests = new WeakMap();
/**
 * @internal
 */
class BidiHTTPRequest extends _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.HTTPRequest {
    static from(bidiRequest, frame, redirect) {
        const request = new _a(bidiRequest, frame, redirect);
        request.#initialize();
        return request;
    }
    #redirectChain;
    #response = null;
    id;
    #frame;
    #request;
    constructor(request, frame, redirect) {
        super();
        requests.set(request, this);
        this.interception.enabled = request.isBlocked;
        this.#request = request;
        this.#frame = frame;
        this.#redirectChain = redirect ? redirect.#redirectChain : [];
        this.id = request.id;
    }
    get client() {
        return this.#frame.client;
    }
    #initialize() {
        this.#request.on('redirect', request => {
            const httpRequest = _a.from(request, this.#frame, this);
            this.#redirectChain.push(this);
            request.once('success', () => {
                this.#frame
                    .page()
                    .trustedEmitter.emit("requestfinished" /* PageEvent.RequestFinished */, httpRequest);
            });
            request.once('error', () => {
                this.#frame
                    .page()
                    .trustedEmitter.emit("requestfailed" /* PageEvent.RequestFailed */, httpRequest);
            });
            void httpRequest.finalizeInterceptions();
        });
        this.#request.once('success', data => {
            this.#response = _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_2__.BidiHTTPResponse.from(data, this);
        });
        this.#request.on('authenticate', this.#handleAuthentication);
        this.#frame.page().trustedEmitter.emit("request" /* PageEvent.Request */, this);
        if (this.#hasInternalHeaderOverwrite) {
            this.interception.handlers.push(async () => {
                await this.continue({
                    headers: this.headers(),
                }, 0);
            });
        }
    }
    url() {
        return this.#request.url;
    }
    resourceType() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    method() {
        return this.#request.method;
    }
    postData() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    hasPostData() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    async fetchPostData() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    get #hasInternalHeaderOverwrite() {
        return Boolean(Object.keys(this.#extraHTTPHeaders).length ||
            Object.keys(this.#userAgentHeaders).length);
    }
    get #extraHTTPHeaders() {
        return this.#frame?.page()._extraHTTPHeaders ?? {};
    }
    get #userAgentHeaders() {
        return this.#frame?.page()._userAgentHeaders ?? {};
    }
    headers() {
        const headers = {};
        for (const header of this.#request.headers) {
            headers[header.name.toLowerCase()] = header.value.value;
        }
        return {
            ...headers,
            ...this.#extraHTTPHeaders,
            ...this.#userAgentHeaders,
        };
    }
    response() {
        return this.#response;
    }
    failure() {
        if (this.#request.error === undefined) {
            return null;
        }
        return { errorText: this.#request.error };
    }
    isNavigationRequest() {
        return this.#request.navigation !== undefined;
    }
    initiator() {
        return this.#request.initiator;
    }
    redirectChain() {
        return this.#redirectChain.slice();
    }
    frame() {
        return this.#frame;
    }
    async continue(overrides, priority) {
        return await super.continue({
            headers: this.#hasInternalHeaderOverwrite ? this.headers() : undefined,
            ...overrides,
        }, priority);
    }
    async _continue(overrides = {}) {
        const headers = getBidiHeaders(overrides.headers);
        this.interception.handled = true;
        return await this.#request
            .continueRequest({
            url: overrides.url,
            method: overrides.method,
            body: overrides.postData
                ? {
                    type: 'base64',
                    value: btoa(overrides.postData),
                }
                : undefined,
            headers: headers.length > 0 ? headers : undefined,
        })
            .catch(error => {
            this.interception.handled = false;
            return (0,_api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.handleError)(error);
        });
    }
    async _abort() {
        this.interception.handled = true;
        return await this.#request.failRequest().catch(error => {
            this.interception.handled = false;
            throw error;
        });
    }
    async _respond(response, _priority) {
        this.interception.handled = true;
        let parsedBody;
        if (response.body) {
            parsedBody = _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.HTTPRequest.getResponse(response.body);
        }
        const headers = getBidiHeaders(response.headers);
        const hasContentLength = headers.some(header => {
            return header.name === 'content-length';
        });
        if (response.contentType) {
            headers.push({
                name: 'content-type',
                value: {
                    type: 'string',
                    value: response.contentType,
                },
            });
        }
        if (parsedBody?.contentLength && !hasContentLength) {
            headers.push({
                name: 'content-length',
                value: {
                    type: 'string',
                    value: String(parsedBody.contentLength),
                },
            });
        }
        const status = response.status || 200;
        return await this.#request
            .provideResponse({
            statusCode: status,
            headers: headers.length > 0 ? headers : undefined,
            reasonPhrase: _api_HTTPRequest_js__WEBPACK_IMPORTED_MODULE_0__.STATUS_TEXTS[status],
            body: parsedBody?.base64
                ? {
                    type: 'base64',
                    value: parsedBody?.base64,
                }
                : undefined,
        })
            .catch(error => {
            this.interception.handled = false;
            throw error;
        });
    }
    #authenticationHandled = false;
    #handleAuthentication = async () => {
        if (!this.#frame) {
            return;
        }
        const credentials = this.#frame.page()._credentials;
        if (credentials && !this.#authenticationHandled) {
            this.#authenticationHandled = true;
            void this.#request.continueWithAuth({
                action: 'provideCredentials',
                credentials: {
                    type: 'password',
                    username: credentials.username,
                    password: credentials.password,
                },
            });
        }
        else {
            void this.#request.continueWithAuth({
                action: 'cancel',
            });
        }
    };
}
_a = BidiHTTPRequest;
function getBidiHeaders(rawHeaders) {
    const headers = [];
    for (const [name, value] of Object.entries(rawHeaders ?? [])) {
        if (!Object.is(value, undefined)) {
            const values = Array.isArray(value) ? value : [value];
            for (const value of values) {
                headers.push({
                    name: name.toLowerCase(),
                    value: {
                        type: 'string',
                        value: String(value),
                    },
                });
            }
        }
    }
    return headers;
}
//# sourceMappingURL=HTTPRequest.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiHTTPResponse: () => (/* binding */ BidiHTTPResponse)
/* harmony export */ });
/* harmony import */ var _api_HTTPResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let BidiHTTPResponse = (() => {
    let _classSuper = _api_HTTPResponse_js__WEBPACK_IMPORTED_MODULE_0__.HTTPResponse;
    let _instanceExtraInitializers = [];
    let _remoteAddress_decorators;
    return class BidiHTTPResponse extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _remoteAddress_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.invokeAtMostOnceForArguments];
            __esDecorate(this, null, _remoteAddress_decorators, { kind: "method", name: "remoteAddress", static: false, private: false, access: { has: obj => "remoteAddress" in obj, get: obj => obj.remoteAddress }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(data, request) {
            const response = new BidiHTTPResponse(data, request);
            response.#initialize();
            return response;
        }
        #data = __runInitializers(this, _instanceExtraInitializers);
        #request;
        constructor(data, request) {
            super();
            this.#data = data;
            this.#request = request;
        }
        #initialize() {
            if (this.#data.fromCache) {
                this.#request
                    .frame()
                    ?.page()
                    .trustedEmitter.emit("requestservedfromcache" /* PageEvent.RequestServedFromCache */, this.#request);
            }
            this.#request.frame()?.page().trustedEmitter.emit("response" /* PageEvent.Response */, this);
        }
        remoteAddress() {
            return {
                ip: '',
                port: -1,
            };
        }
        url() {
            return this.#data.url;
        }
        status() {
            return this.#data.status;
        }
        statusText() {
            return this.#data.statusText;
        }
        headers() {
            const headers = {};
            // TODO: Remove once the Firefox implementation is compliant with https://w3c.github.io/webdriver-bidi/#get-the-response-data.
            for (const header of this.#data.headers || []) {
                // TODO: How to handle Binary Headers
                // https://w3c.github.io/webdriver-bidi/#type-network-Header
                if (header.value.type === 'string') {
                    headers[header.name.toLowerCase()] = header.value.value;
                }
            }
            return headers;
        }
        request() {
            return this.#request;
        }
        fromCache() {
            return this.#data.fromCache;
        }
        timing() {
            // TODO: File and issue with BiDi spec
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
        frame() {
            return this.#request.frame();
        }
        fromServiceWorker() {
            return false;
        }
        securityDetails() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
        buffer() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
        }
    };
})();

//# sourceMappingURL=HTTPResponse.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiKeyboard: () => (/* binding */ BidiKeyboard),
/* harmony export */   BidiMouse: () => (/* binding */ BidiMouse),
/* harmony export */   BidiTouchscreen: () => (/* binding */ BidiTouchscreen)
/* harmony export */ });
/* harmony import */ var _api_Input_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */


var SourceActionsType;
(function (SourceActionsType) {
    SourceActionsType["None"] = "none";
    SourceActionsType["Key"] = "key";
    SourceActionsType["Pointer"] = "pointer";
    SourceActionsType["Wheel"] = "wheel";
})(SourceActionsType || (SourceActionsType = {}));
var ActionType;
(function (ActionType) {
    ActionType["Pause"] = "pause";
    ActionType["KeyDown"] = "keyDown";
    ActionType["KeyUp"] = "keyUp";
    ActionType["PointerUp"] = "pointerUp";
    ActionType["PointerDown"] = "pointerDown";
    ActionType["PointerMove"] = "pointerMove";
    ActionType["Scroll"] = "scroll";
})(ActionType || (ActionType = {}));
const getBidiKeyValue = (key) => {
    switch (key) {
        case '\r':
        case '\n':
            key = 'Enter';
            break;
    }
    // Measures the number of code points rather than UTF-16 code units.
    if ([...key].length === 1) {
        return key;
    }
    switch (key) {
        case 'Cancel':
            return '\uE001';
        case 'Help':
            return '\uE002';
        case 'Backspace':
            return '\uE003';
        case 'Tab':
            return '\uE004';
        case 'Clear':
            return '\uE005';
        case 'Enter':
            return '\uE007';
        case 'Shift':
        case 'ShiftLeft':
            return '\uE008';
        case 'Control':
        case 'ControlLeft':
            return '\uE009';
        case 'Alt':
        case 'AltLeft':
            return '\uE00A';
        case 'Pause':
            return '\uE00B';
        case 'Escape':
            return '\uE00C';
        case 'PageUp':
            return '\uE00E';
        case 'PageDown':
            return '\uE00F';
        case 'End':
            return '\uE010';
        case 'Home':
            return '\uE011';
        case 'ArrowLeft':
            return '\uE012';
        case 'ArrowUp':
            return '\uE013';
        case 'ArrowRight':
            return '\uE014';
        case 'ArrowDown':
            return '\uE015';
        case 'Insert':
            return '\uE016';
        case 'Delete':
            return '\uE017';
        case 'NumpadEqual':
            return '\uE019';
        case 'Numpad0':
            return '\uE01A';
        case 'Numpad1':
            return '\uE01B';
        case 'Numpad2':
            return '\uE01C';
        case 'Numpad3':
            return '\uE01D';
        case 'Numpad4':
            return '\uE01E';
        case 'Numpad5':
            return '\uE01F';
        case 'Numpad6':
            return '\uE020';
        case 'Numpad7':
            return '\uE021';
        case 'Numpad8':
            return '\uE022';
        case 'Numpad9':
            return '\uE023';
        case 'NumpadMultiply':
            return '\uE024';
        case 'NumpadAdd':
            return '\uE025';
        case 'NumpadSubtract':
            return '\uE027';
        case 'NumpadDecimal':
            return '\uE028';
        case 'NumpadDivide':
            return '\uE029';
        case 'F1':
            return '\uE031';
        case 'F2':
            return '\uE032';
        case 'F3':
            return '\uE033';
        case 'F4':
            return '\uE034';
        case 'F5':
            return '\uE035';
        case 'F6':
            return '\uE036';
        case 'F7':
            return '\uE037';
        case 'F8':
            return '\uE038';
        case 'F9':
            return '\uE039';
        case 'F10':
            return '\uE03A';
        case 'F11':
            return '\uE03B';
        case 'F12':
            return '\uE03C';
        case 'Meta':
        case 'MetaLeft':
            return '\uE03D';
        case 'ShiftRight':
            return '\uE050';
        case 'ControlRight':
            return '\uE051';
        case 'AltRight':
            return '\uE052';
        case 'MetaRight':
            return '\uE053';
        case 'Digit0':
            return '0';
        case 'Digit1':
            return '1';
        case 'Digit2':
            return '2';
        case 'Digit3':
            return '3';
        case 'Digit4':
            return '4';
        case 'Digit5':
            return '5';
        case 'Digit6':
            return '6';
        case 'Digit7':
            return '7';
        case 'Digit8':
            return '8';
        case 'Digit9':
            return '9';
        case 'KeyA':
            return 'a';
        case 'KeyB':
            return 'b';
        case 'KeyC':
            return 'c';
        case 'KeyD':
            return 'd';
        case 'KeyE':
            return 'e';
        case 'KeyF':
            return 'f';
        case 'KeyG':
            return 'g';
        case 'KeyH':
            return 'h';
        case 'KeyI':
            return 'i';
        case 'KeyJ':
            return 'j';
        case 'KeyK':
            return 'k';
        case 'KeyL':
            return 'l';
        case 'KeyM':
            return 'm';
        case 'KeyN':
            return 'n';
        case 'KeyO':
            return 'o';
        case 'KeyP':
            return 'p';
        case 'KeyQ':
            return 'q';
        case 'KeyR':
            return 'r';
        case 'KeyS':
            return 's';
        case 'KeyT':
            return 't';
        case 'KeyU':
            return 'u';
        case 'KeyV':
            return 'v';
        case 'KeyW':
            return 'w';
        case 'KeyX':
            return 'x';
        case 'KeyY':
            return 'y';
        case 'KeyZ':
            return 'z';
        case 'Semicolon':
            return ';';
        case 'Equal':
            return '=';
        case 'Comma':
            return ',';
        case 'Minus':
            return '-';
        case 'Period':
            return '.';
        case 'Slash':
            return '/';
        case 'Backquote':
            return '`';
        case 'BracketLeft':
            return '[';
        case 'Backslash':
            return '\\';
        case 'BracketRight':
            return ']';
        case 'Quote':
            return '"';
        default:
            throw new Error(`Unknown key: "${key}"`);
    }
};
/**
 * @internal
 */
class BidiKeyboard extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Keyboard {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async down(key, _options) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions: [
                    {
                        type: ActionType.KeyDown,
                        value: getBidiKeyValue(key),
                    },
                ],
            },
        ]);
    }
    async up(key) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions: [
                    {
                        type: ActionType.KeyUp,
                        value: getBidiKeyValue(key),
                    },
                ],
            },
        ]);
    }
    async press(key, options = {}) {
        const { delay = 0 } = options;
        const actions = [
            {
                type: ActionType.KeyDown,
                value: getBidiKeyValue(key),
            },
        ];
        if (delay > 0) {
            actions.push({
                type: ActionType.Pause,
                duration: delay,
            });
        }
        actions.push({
            type: ActionType.KeyUp,
            value: getBidiKeyValue(key),
        });
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions,
            },
        ]);
    }
    async type(text, options = {}) {
        const { delay = 0 } = options;
        // This spread separates the characters into code points rather than UTF-16
        // code units.
        const values = [...text].map(getBidiKeyValue);
        const actions = [];
        if (delay <= 0) {
            for (const value of values) {
                actions.push({
                    type: ActionType.KeyDown,
                    value,
                }, {
                    type: ActionType.KeyUp,
                    value,
                });
            }
        }
        else {
            for (const value of values) {
                actions.push({
                    type: ActionType.KeyDown,
                    value,
                }, {
                    type: ActionType.Pause,
                    duration: delay,
                }, {
                    type: ActionType.KeyUp,
                    value,
                });
            }
        }
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard" /* InputId.Keyboard */,
                actions,
            },
        ]);
    }
    async sendCharacter(char) {
        // Measures the number of code points rather than UTF-16 code units.
        if ([...char].length > 1) {
            throw new Error('Cannot send more than 1 character.');
        }
        const frame = await this.#page.focusedFrame();
        await frame.isolatedRealm().evaluate(async (char) => {
            document.execCommand('insertText', false, char);
        }, char);
    }
}
const getBidiButton = (button) => {
    switch (button) {
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left:
            return 0;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Middle:
            return 1;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Right:
            return 2;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Back:
            return 3;
        case _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Forward:
            return 4;
    }
};
/**
 * @internal
 */
class BidiMouse extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Mouse {
    #page;
    #lastMovePoint = { x: 0, y: 0 };
    constructor(page) {
        super();
        this.#page = page;
    }
    async reset() {
        this.#lastMovePoint = { x: 0, y: 0 };
        await this.#page.mainFrame().browsingContext.releaseActions();
    }
    async move(x, y, options = {}) {
        const from = this.#lastMovePoint;
        const to = {
            x: Math.round(x),
            y: Math.round(y),
        };
        const actions = [];
        const steps = options.steps ?? 0;
        for (let i = 0; i < steps; ++i) {
            actions.push({
                type: ActionType.PointerMove,
                x: from.x + (to.x - from.x) * (i / steps),
                y: from.y + (to.y - from.y) * (i / steps),
                origin: options.origin,
            });
        }
        actions.push({
            type: ActionType.PointerMove,
            ...to,
            origin: options.origin,
        });
        // https://w3c.github.io/webdriver-bidi/#command-input-performActions:~:text=input.PointerMoveAction%20%3D%20%7B%0A%20%20type%3A%20%22pointerMove%22%2C%0A%20%20x%3A%20js%2Dint%2C
        this.#lastMovePoint = to;
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions,
            },
        ]);
    }
    async down(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions: [
                    {
                        type: ActionType.PointerDown,
                        button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
                    },
                ],
            },
        ]);
    }
    async up(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions: [
                    {
                        type: ActionType.PointerUp,
                        button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
                    },
                ],
            },
        ]);
    }
    async click(x, y, options = {}) {
        const actions = [
            {
                type: ActionType.PointerMove,
                x: Math.round(x),
                y: Math.round(y),
                origin: options.origin,
            },
        ];
        const pointerDownAction = {
            type: ActionType.PointerDown,
            button: getBidiButton(options.button ?? _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.MouseButton.Left),
        };
        const pointerUpAction = {
            type: ActionType.PointerUp,
            button: pointerDownAction.button,
        };
        for (let i = 1; i < (options.count ?? 1); ++i) {
            actions.push(pointerDownAction, pointerUpAction);
        }
        actions.push(pointerDownAction);
        if (options.delay) {
            actions.push({
                type: ActionType.Pause,
                duration: options.delay,
            });
        }
        actions.push(pointerUpAction);
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse" /* InputId.Mouse */,
                actions,
            },
        ]);
    }
    async wheel(options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Wheel,
                id: "__puppeteer_wheel" /* InputId.Wheel */,
                actions: [
                    {
                        type: ActionType.Scroll,
                        ...(this.#lastMovePoint ?? {
                            x: 0,
                            y: 0,
                        }),
                        deltaX: options.deltaX ?? 0,
                        deltaY: options.deltaY ?? 0,
                    },
                ],
            },
        ]);
    }
    drag() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragOver() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragEnter() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    drop() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    dragAndDrop() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiTouchscreen extends _api_Input_js__WEBPACK_IMPORTED_MODULE_0__.Touchscreen {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async touchStart(x, y, options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerMove,
                        x: Math.round(x),
                        y: Math.round(y),
                        origin: options.origin,
                    },
                    {
                        type: ActionType.PointerDown,
                        button: 0,
                        width: 0.5 * 2, // 2 times default touch radius.
                        height: 0.5 * 2, // 2 times default touch radius.
                        pressure: 0.5,
                        altitudeAngle: Math.PI / 2,
                    },
                ],
            },
        ]);
    }
    async touchMove(x, y, options = {}) {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerMove,
                        x: Math.round(x),
                        y: Math.round(y),
                        origin: options.origin,
                        width: 0.5 * 2, // 2 times default touch radius.
                        height: 0.5 * 2, // 2 times default touch radius.
                        pressure: 0.5,
                        altitudeAngle: Math.PI / 2,
                    },
                ],
            },
        ]);
    }
    async touchEnd() {
        await this.#page.mainFrame().browsingContext.performActions([
            {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger" /* InputId.Finger */,
                parameters: {
                    pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
                },
                actions: [
                    {
                        type: ActionType.PointerUp,
                        button: 0,
                    },
                ],
            },
        ]);
    }
}
//# sourceMappingURL=Input.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js":
/*!************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiJSHandle: () => (/* binding */ BidiJSHandle)
/* harmony export */ });
/* harmony import */ var _api_JSHandle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiJSHandle extends _api_JSHandle_js__WEBPACK_IMPORTED_MODULE_0__.JSHandle {
    static from(value, realm) {
        return new BidiJSHandle(value, realm);
    }
    #remoteValue;
    realm;
    #disposed = false;
    constructor(value, realm) {
        super();
        this.#remoteValue = value;
        this.realm = realm;
    }
    get disposed() {
        return this.#disposed;
    }
    async jsonValue() {
        return await this.evaluate(value => {
            return value;
        });
    }
    asElement() {
        return null;
    }
    async dispose() {
        if (this.#disposed) {
            return;
        }
        this.#disposed = true;
        await this.realm.destroyHandles([this]);
    }
    get isPrimitiveValue() {
        switch (this.#remoteValue.type) {
            case 'string':
            case 'number':
            case 'bigint':
            case 'boolean':
            case 'undefined':
            case 'null':
                return true;
            default:
                return false;
        }
    }
    toString() {
        if (this.isPrimitiveValue) {
            return 'JSHandle:' + _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__.BidiDeserializer.deserialize(this.#remoteValue);
        }
        return 'JSHandle@' + this.#remoteValue.type;
    }
    get id() {
        return 'handle' in this.#remoteValue ? this.#remoteValue.handle : undefined;
    }
    remoteValue() {
        return this.#remoteValue;
    }
    remoteObject() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation('Not available in WebDriver BiDi');
    }
}
//# sourceMappingURL=JSHandle.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiPage: () => (/* binding */ BidiPage)
/* harmony export */ });
/* harmony import */ var _third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../third_party/rxjs/rxjs.js */ "./node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js");
/* harmony import */ var _api_Page_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js");
/* harmony import */ var _cdp_Coverage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cdp/Coverage.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js");
/* harmony import */ var _cdp_EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cdp/EmulationManager.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js");
/* harmony import */ var _cdp_Tracing_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cdp/Tracing.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/ErrorLike.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js");
/* harmony import */ var _Frame_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js");
/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});














/**
 * Implements Page using WebDriver BiDi.
 *
 * @internal
 */
let BidiPage = (() => {
    let _classSuper = _api_Page_js__WEBPACK_IMPORTED_MODULE_1__.Page;
    let _trustedEmitter_decorators;
    let _trustedEmitter_initializers = [];
    let _trustedEmitter_extraInitializers = [];
    return class BidiPage extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _trustedEmitter_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_9__.bubble)()];
            __esDecorate(this, null, _trustedEmitter_decorators, { kind: "accessor", name: "trustedEmitter", static: false, private: false, access: { has: obj => "trustedEmitter" in obj, get: obj => obj.trustedEmitter, set: (obj, value) => { obj.trustedEmitter = value; } }, metadata: _metadata }, _trustedEmitter_initializers, _trustedEmitter_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browserContext, browsingContext) {
            const page = new BidiPage(browserContext, browsingContext);
            page.#initialize();
            return page;
        }
        #trustedEmitter_accessor_storage = __runInitializers(this, _trustedEmitter_initializers, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_6__.EventEmitter());
        get trustedEmitter() { return this.#trustedEmitter_accessor_storage; }
        set trustedEmitter(value) { this.#trustedEmitter_accessor_storage = value; }
        #browserContext = __runInitializers(this, _trustedEmitter_extraInitializers);
        #frame;
        #viewport = null;
        #workers = new Set();
        keyboard;
        mouse;
        touchscreen;
        tracing;
        coverage;
        #cdpEmulationManager;
        #emulatedNetworkConditions;
        _client() {
            return this.#frame.client;
        }
        constructor(browserContext, browsingContext) {
            super();
            this.#browserContext = browserContext;
            this.#frame = _Frame_js__WEBPACK_IMPORTED_MODULE_11__.BidiFrame.from(this, browsingContext);
            this.#cdpEmulationManager = new _cdp_EmulationManager_js__WEBPACK_IMPORTED_MODULE_3__.EmulationManager(this.#frame.client);
            this.tracing = new _cdp_Tracing_js__WEBPACK_IMPORTED_MODULE_4__.Tracing(this.#frame.client);
            this.coverage = new _cdp_Coverage_js__WEBPACK_IMPORTED_MODULE_2__.Coverage(this.#frame.client);
            this.keyboard = new _Input_js__WEBPACK_IMPORTED_MODULE_12__.BidiKeyboard(this);
            this.mouse = new _Input_js__WEBPACK_IMPORTED_MODULE_12__.BidiMouse(this);
            this.touchscreen = new _Input_js__WEBPACK_IMPORTED_MODULE_12__.BidiTouchscreen(this);
        }
        #initialize() {
            this.#frame.browsingContext.on('closed', () => {
                this.trustedEmitter.emit("close" /* PageEvent.Close */, undefined);
                this.trustedEmitter.removeAllListeners();
            });
            this.trustedEmitter.on("workercreated" /* PageEvent.WorkerCreated */, worker => {
                this.#workers.add(worker);
            });
            this.trustedEmitter.on("workerdestroyed" /* PageEvent.WorkerDestroyed */, worker => {
                this.#workers.delete(worker);
            });
        }
        /**
         * @internal
         */
        _userAgentHeaders = {};
        #userAgentInterception;
        #userAgentPreloadScript;
        async setUserAgent(userAgent, userAgentMetadata) {
            if (!this.#browserContext.browser().cdpSupported && userAgentMetadata) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation('Current Browser does not support `userAgentMetadata`');
            }
            else if (this.#browserContext.browser().cdpSupported &&
                userAgentMetadata) {
                return await this._client().send('Network.setUserAgentOverride', {
                    userAgent: userAgent,
                    userAgentMetadata: userAgentMetadata,
                });
            }
            const enable = userAgent !== '';
            userAgent = userAgent ?? (await this.#browserContext.browser().userAgent());
            this._userAgentHeaders = enable
                ? {
                    'User-Agent': userAgent,
                }
                : {};
            this.#userAgentInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#userAgentInterception, enable);
            const changeUserAgent = (userAgent) => {
                Object.defineProperty(navigator, 'userAgent', {
                    value: userAgent,
                });
            };
            const frames = [this.#frame];
            for (const frame of frames) {
                frames.push(...frame.childFrames());
            }
            if (this.#userAgentPreloadScript) {
                await this.removeScriptToEvaluateOnNewDocument(this.#userAgentPreloadScript);
            }
            const [evaluateToken] = await Promise.all([
                enable
                    ? this.evaluateOnNewDocument(changeUserAgent, userAgent)
                    : undefined,
                // When we disable the UserAgent we want to
                // evaluate the original value in all Browsing Contexts
                frames.map(frame => {
                    return frame.evaluate(changeUserAgent, userAgent);
                }),
            ]);
            this.#userAgentPreloadScript = evaluateToken?.identifier;
        }
        async setBypassCSP(enabled) {
            // TODO: handle CDP-specific cases such as mprach.
            await this._client().send('Page.setBypassCSP', { enabled });
        }
        async queryObjects(prototypeHandle) {
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(prototypeHandle.id, 'Prototype JSHandle must not be referencing primitive value');
            const response = await this.#frame.client.send('Runtime.queryObjects', {
                prototypeObjectId: prototypeHandle.id,
            });
            return this.#frame.mainRealm().createHandle({
                type: 'array',
                handle: response.objects.objectId,
            });
        }
        browser() {
            return this.browserContext().browser();
        }
        browserContext() {
            return this.#browserContext;
        }
        mainFrame() {
            return this.#frame;
        }
        async focusedFrame() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
                const handle = __addDisposableResource(env_1, (await this.mainFrame()
                    .isolatedRealm()
                    .evaluateHandle(() => {
                    let win = window;
                    while (win.document.activeElement instanceof win.HTMLIFrameElement ||
                        win.document.activeElement instanceof win.HTMLFrameElement) {
                        if (win.document.activeElement.contentWindow === null) {
                            break;
                        }
                        win = win.document.activeElement.contentWindow;
                    }
                    return win;
                })), false);
                const value = handle.remoteValue();
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(value.type === 'window');
                const frame = this.frames().find(frame => {
                    return frame._id === value.value.context;
                });
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(frame);
                return frame;
            }
            catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
            }
            finally {
                __disposeResources(env_1);
            }
        }
        frames() {
            const frames = [this.#frame];
            for (const frame of frames) {
                frames.push(...frame.childFrames());
            }
            return frames;
        }
        isClosed() {
            return this.#frame.detached;
        }
        async close(options) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
                const _guard = __addDisposableResource(env_2, await this.#browserContext.waitForScreenshotOperations(), false);
                try {
                    await this.#frame.browsingContext.close(options?.runBeforeUnload);
                }
                catch {
                    return;
                }
            }
            catch (e_2) {
                env_2.error = e_2;
                env_2.hasError = true;
            }
            finally {
                __disposeResources(env_2);
            }
        }
        async reload(options = {}) {
            const [response] = await Promise.all([
                this.#frame.waitForNavigation(options),
                this.#frame.browsingContext.reload(),
            ]).catch((0,_util_js__WEBPACK_IMPORTED_MODULE_13__.rewriteNavigationError)(this.url(), options.timeout ?? this._timeoutSettings.navigationTimeout()));
            return response;
        }
        setDefaultNavigationTimeout(timeout) {
            this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        }
        setDefaultTimeout(timeout) {
            this._timeoutSettings.setDefaultTimeout(timeout);
        }
        getDefaultTimeout() {
            return this._timeoutSettings.timeout();
        }
        isJavaScriptEnabled() {
            return this.#cdpEmulationManager.javascriptEnabled;
        }
        async setGeolocation(options) {
            return await this.#cdpEmulationManager.setGeolocation(options);
        }
        async setJavaScriptEnabled(enabled) {
            return await this.#cdpEmulationManager.setJavaScriptEnabled(enabled);
        }
        async emulateMediaType(type) {
            return await this.#cdpEmulationManager.emulateMediaType(type);
        }
        async emulateCPUThrottling(factor) {
            return await this.#cdpEmulationManager.emulateCPUThrottling(factor);
        }
        async emulateMediaFeatures(features) {
            return await this.#cdpEmulationManager.emulateMediaFeatures(features);
        }
        async emulateTimezone(timezoneId) {
            return await this.#cdpEmulationManager.emulateTimezone(timezoneId);
        }
        async emulateIdleState(overrides) {
            return await this.#cdpEmulationManager.emulateIdleState(overrides);
        }
        async emulateVisionDeficiency(type) {
            return await this.#cdpEmulationManager.emulateVisionDeficiency(type);
        }
        async setViewport(viewport) {
            if (!this.browser().cdpSupported) {
                await this.#frame.browsingContext.setViewport({
                    viewport: viewport?.width && viewport?.height
                        ? {
                            width: viewport.width,
                            height: viewport.height,
                        }
                        : null,
                    devicePixelRatio: viewport?.deviceScaleFactor
                        ? viewport.deviceScaleFactor
                        : null,
                });
                this.#viewport = viewport;
                return;
            }
            const needsReload = await this.#cdpEmulationManager.emulateViewport(viewport);
            this.#viewport = viewport;
            if (needsReload) {
                await this.reload();
            }
        }
        viewport() {
            return this.#viewport;
        }
        async pdf(options = {}) {
            const { timeout: ms = this._timeoutSettings.timeout(), path = undefined } = options;
            const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize, } = (0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.parsePDFOptions)(options, 'cm');
            const pageRanges = ranges ? ranges.split(', ') : [];
            await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.from)(this.mainFrame()
                .isolatedRealm()
                .evaluate(() => {
                return document.fonts.ready;
            })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(ms))));
            const data = await (0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.firstValueFrom)((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.from)(this.#frame.browsingContext.print({
                background,
                margin,
                orientation: landscape ? 'landscape' : 'portrait',
                page: {
                    width,
                    height,
                },
                pageRanges,
                scale,
                shrinkToFit: !preferCSSPageSize,
            })).pipe((0,_third_party_rxjs_rxjs_js__WEBPACK_IMPORTED_MODULE_0__.raceWith)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.timeout)(ms))));
            const buffer = Buffer.from(data, 'base64');
            await this._maybeWriteBufferToFile(path, buffer);
            return buffer;
        }
        async createPDFStream(options) {
            const buffer = await this.pdf(options);
            return new ReadableStream({
                start(controller) {
                    controller.enqueue(buffer);
                    controller.close();
                },
            });
        }
        async _screenshot(options) {
            const { clip, type, captureBeyondViewport, quality } = options;
            if (options.omitBackground !== undefined && options.omitBackground) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'omitBackground'.`);
            }
            if (options.optimizeForSpeed !== undefined && options.optimizeForSpeed) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'optimizeForSpeed'.`);
            }
            if (options.fromSurface !== undefined && !options.fromSurface) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'fromSurface'.`);
            }
            if (clip !== undefined && clip.scale !== undefined && clip.scale !== 1) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation(`BiDi does not support 'scale' in 'clip'.`);
            }
            let box;
            if (clip) {
                if (captureBeyondViewport) {
                    box = clip;
                }
                else {
                    // The clip is always with respect to the document coordinates, so we
                    // need to convert this to viewport coordinates when we aren't capturing
                    // beyond the viewport.
                    const [pageLeft, pageTop] = await this.evaluate(() => {
                        if (!window.visualViewport) {
                            throw new Error('window.visualViewport is not supported.');
                        }
                        return [
                            window.visualViewport.pageLeft,
                            window.visualViewport.pageTop,
                        ];
                    });
                    box = {
                        ...clip,
                        x: clip.x - pageLeft,
                        y: clip.y - pageTop,
                    };
                }
            }
            const data = await this.#frame.browsingContext.captureScreenshot({
                origin: captureBeyondViewport ? 'document' : 'viewport',
                format: {
                    type: `image/${type}`,
                    ...(quality !== undefined ? { quality: quality / 100 } : {}),
                },
                ...(box ? { clip: { type: 'box', ...box } } : {}),
            });
            return data;
        }
        async createCDPSession() {
            return await this.#frame.createCDPSession();
        }
        async bringToFront() {
            await this.#frame.browsingContext.activate();
        }
        async evaluateOnNewDocument(pageFunction, ...args) {
            const expression = evaluationExpression(pageFunction, ...args);
            const script = await this.#frame.browsingContext.addPreloadScript(expression);
            return { identifier: script };
        }
        async removeScriptToEvaluateOnNewDocument(id) {
            await this.#frame.browsingContext.removePreloadScript(id);
        }
        async exposeFunction(name, pptrFunction) {
            return await this.mainFrame().exposeFunction(name, 'default' in pptrFunction ? pptrFunction.default : pptrFunction);
        }
        isDragInterceptionEnabled() {
            return false;
        }
        async setCacheEnabled(enabled) {
            if (!this.#browserContext.browser().cdpSupported) {
                await this.#frame.browsingContext.setCacheBehavior(enabled ? 'default' : 'bypass');
                return;
            }
            // TODO: handle CDP-specific cases such as mprach.
            await this._client().send('Network.setCacheDisabled', {
                cacheDisabled: !enabled,
            });
        }
        async cookies(...urls) {
            const normalizedUrls = (urls.length ? urls : [this.url()]).map(url => {
                return new URL(url);
            });
            const cookies = await this.#frame.browsingContext.getCookies();
            return cookies
                .map(cookie => {
                return bidiToPuppeteerCookie(cookie);
            })
                .filter(cookie => {
                return normalizedUrls.some(url => {
                    return testUrlMatchCookie(cookie, url);
                });
            });
        }
        isServiceWorkerBypassed() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        target() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        waitForFileChooser() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        workers() {
            return [...this.#workers];
        }
        #userInterception;
        async setRequestInterception(enable) {
            this.#userInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#userInterception, enable);
        }
        /**
         * @internal
         */
        _extraHTTPHeaders = {};
        #extraHeadersInterception;
        async setExtraHTTPHeaders(headers) {
            const extraHTTPHeaders = {};
            for (const [key, value] of Object.entries(headers)) {
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.isString)(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
                extraHTTPHeaders[key.toLowerCase()] = value;
            }
            this._extraHTTPHeaders = extraHTTPHeaders;
            this.#extraHeadersInterception = await this.#toggleInterception(["beforeRequestSent" /* Bidi.Network.InterceptPhase.BeforeRequestSent */], this.#extraHeadersInterception, Boolean(Object.keys(this._extraHTTPHeaders).length));
        }
        /**
         * @internal
         */
        _credentials = null;
        #authInterception;
        async authenticate(credentials) {
            this.#authInterception = await this.#toggleInterception(["authRequired" /* Bidi.Network.InterceptPhase.AuthRequired */], this.#authInterception, Boolean(credentials));
            this._credentials = credentials;
        }
        async #toggleInterception(phases, interception, expected) {
            if (expected && !interception) {
                return await this.#frame.browsingContext.addIntercept({
                    phases,
                });
            }
            else if (!expected && interception) {
                await this.#frame.browsingContext.userContext.browser.removeIntercept(interception);
                return;
            }
            return interception;
        }
        setDragInterception() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        setBypassServiceWorker() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        async setOfflineMode(enabled) {
            if (!this.#browserContext.browser().cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
            }
            if (!this.#emulatedNetworkConditions) {
                this.#emulatedNetworkConditions = {
                    offline: false,
                    upload: -1,
                    download: -1,
                    latency: 0,
                };
            }
            this.#emulatedNetworkConditions.offline = enabled;
            return await this.#applyNetworkConditions();
        }
        async emulateNetworkConditions(networkConditions) {
            if (!this.#browserContext.browser().cdpSupported) {
                throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
            }
            if (!this.#emulatedNetworkConditions) {
                this.#emulatedNetworkConditions = {
                    offline: false,
                    upload: -1,
                    download: -1,
                    latency: 0,
                };
            }
            this.#emulatedNetworkConditions.upload = networkConditions
                ? networkConditions.upload
                : -1;
            this.#emulatedNetworkConditions.download = networkConditions
                ? networkConditions.download
                : -1;
            this.#emulatedNetworkConditions.latency = networkConditions
                ? networkConditions.latency
                : 0;
            return await this.#applyNetworkConditions();
        }
        async #applyNetworkConditions() {
            if (!this.#emulatedNetworkConditions) {
                return;
            }
            await this._client().send('Network.emulateNetworkConditions', {
                offline: this.#emulatedNetworkConditions.offline,
                latency: this.#emulatedNetworkConditions.latency,
                uploadThroughput: this.#emulatedNetworkConditions.upload,
                downloadThroughput: this.#emulatedNetworkConditions.download,
            });
        }
        async setCookie(...cookies) {
            const pageURL = this.url();
            const pageUrlStartsWithHTTP = pageURL.startsWith('http');
            for (const cookie of cookies) {
                let cookieUrl = cookie.url || '';
                if (!cookieUrl && pageUrlStartsWithHTTP) {
                    cookieUrl = pageURL;
                }
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(cookieUrl !== 'about:blank', `Blank page can not have cookie "${cookie.name}"`);
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(!String.prototype.startsWith.call(cookieUrl || '', 'data:'), `Data URL page can not have cookie "${cookie.name}"`);
                const normalizedUrl = URL.canParse(cookieUrl)
                    ? new URL(cookieUrl)
                    : undefined;
                const domain = cookie.domain ?? normalizedUrl?.hostname;
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(domain !== undefined, `At least one of the url and domain needs to be specified`);
                const bidiCookie = {
                    domain: domain,
                    name: cookie.name,
                    value: {
                        type: 'string',
                        value: cookie.value,
                    },
                    ...(cookie.path !== undefined ? { path: cookie.path } : {}),
                    ...(cookie.httpOnly !== undefined ? { httpOnly: cookie.httpOnly } : {}),
                    ...(cookie.secure !== undefined ? { secure: cookie.secure } : {}),
                    ...(cookie.sameSite !== undefined
                        ? { sameSite: convertCookiesSameSiteCdpToBiDi(cookie.sameSite) }
                        : {}),
                    ...(cookie.expires !== undefined ? { expiry: cookie.expires } : {}),
                    // Chrome-specific properties.
                    ...cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookie, 'sameParty', 'sourceScheme', 'priority', 'url'),
                };
                if (cookie.partitionKey !== undefined) {
                    await this.browserContext().userContext.setCookie(bidiCookie, cookie.partitionKey);
                }
                else {
                    await this.#frame.browsingContext.setCookie(bidiCookie);
                }
            }
        }
        async deleteCookie(...cookies) {
            await Promise.all(cookies.map(async (deleteCookieRequest) => {
                const cookieUrl = deleteCookieRequest.url ?? this.url();
                const normalizedUrl = URL.canParse(cookieUrl)
                    ? new URL(cookieUrl)
                    : undefined;
                const domain = deleteCookieRequest.domain ?? normalizedUrl?.hostname;
                (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(domain !== undefined, `At least one of the url and domain needs to be specified`);
                const filter = {
                    domain: domain,
                    name: deleteCookieRequest.name,
                    ...(deleteCookieRequest.path !== undefined
                        ? { path: deleteCookieRequest.path }
                        : {}),
                };
                await this.#frame.browsingContext.deleteCookie(filter);
            }));
        }
        async removeExposedFunction(name) {
            await this.#frame.removeExposedFunction(name);
        }
        metrics() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
        async goBack(options = {}) {
            return await this.#go(-1, options);
        }
        async goForward(options = {}) {
            return await this.#go(1, options);
        }
        async #go(delta, options) {
            try {
                const [response] = await Promise.all([
                    this.waitForNavigation(options),
                    this.#frame.browsingContext.traverseHistory(delta),
                ]);
                return response;
            }
            catch (error) {
                // TODO: waitForNavigation should be cancelled if an error happens.
                if ((0,_util_ErrorLike_js__WEBPACK_IMPORTED_MODULE_10__.isErrorLike)(error)) {
                    if (error.message.includes('no such history entry')) {
                        return null;
                    }
                }
                throw error;
            }
        }
        waitForDevicePrompt() {
            throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_5__.UnsupportedOperation();
        }
    };
})();

function evaluationExpression(fun, ...args) {
    return `() => {${(0,_common_util_js__WEBPACK_IMPORTED_MODULE_7__.evaluationString)(fun, ...args)}}`;
}
/**
 * Check domains match.
 * According to cookies spec, this check should match subdomains as well, but CDP
 * implementation does not do that, so this method matches only the exact domains, not
 * what is written in the spec:
 * https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.3
 */
function testUrlMatchCookieHostname(cookie, normalizedUrl) {
    const cookieDomain = cookie.domain.toLowerCase();
    const urlHostname = normalizedUrl.hostname.toLowerCase();
    return cookieDomain === urlHostname;
}
/**
 * Check paths match.
 * Spec: https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4
 */
function testUrlMatchCookiePath(cookie, normalizedUrl) {
    const uriPath = normalizedUrl.pathname;
    const cookiePath = cookie.path;
    if (uriPath === cookiePath) {
        // The cookie-path and the request-path are identical.
        return true;
    }
    if (uriPath.startsWith(cookiePath)) {
        // The cookie-path is a prefix of the request-path.
        if (cookiePath.endsWith('/')) {
            // The last character of the cookie-path is %x2F ("/").
            return true;
        }
        if (uriPath[cookiePath.length] === '/') {
            // The first character of the request-path that is not included in the cookie-path
            // is a %x2F ("/") character.
            return true;
        }
    }
    return false;
}
/**
 * Checks the cookie matches the URL according to the spec:
 */
function testUrlMatchCookie(cookie, url) {
    const normalizedUrl = new URL(url);
    (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_8__.assert)(cookie !== undefined);
    if (!testUrlMatchCookieHostname(cookie, normalizedUrl)) {
        return false;
    }
    return testUrlMatchCookiePath(cookie, normalizedUrl);
}
function bidiToPuppeteerCookie(bidiCookie) {
    return {
        name: bidiCookie.name,
        // Presents binary value as base64 string.
        value: bidiCookie.value.value,
        domain: bidiCookie.domain,
        path: bidiCookie.path,
        size: bidiCookie.size,
        httpOnly: bidiCookie.httpOnly,
        secure: bidiCookie.secure,
        sameSite: convertCookiesSameSiteBiDiToCdp(bidiCookie.sameSite),
        expires: bidiCookie.expiry ?? -1,
        session: bidiCookie.expiry === undefined || bidiCookie.expiry <= 0,
        // Extending with CDP-specific properties with `goog:` prefix.
        ...cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, 'sameParty', 'sourceScheme', 'partitionKey', 'partitionKeyOpaque', 'priority'),
    };
}
const CDP_SPECIFIC_PREFIX = 'goog:';
/**
 * Gets CDP-specific properties from the BiDi cookie and returns them as a new object.
 */
function cdpSpecificCookiePropertiesFromBidiToPuppeteer(bidiCookie, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
        if (bidiCookie[CDP_SPECIFIC_PREFIX + property] !== undefined) {
            result[property] = bidiCookie[CDP_SPECIFIC_PREFIX + property];
        }
    }
    return result;
}
/**
 * Gets CDP-specific properties from the cookie, adds CDP-specific prefixes and returns
 * them as a new object which can be used in BiDi.
 */
function cdpSpecificCookiePropertiesFromPuppeteerToBidi(cookieParam, ...propertyNames) {
    const result = {};
    for (const property of propertyNames) {
        if (cookieParam[property] !== undefined) {
            result[CDP_SPECIFIC_PREFIX + property] = cookieParam[property];
        }
    }
    return result;
}
function convertCookiesSameSiteBiDiToCdp(sameSite) {
    return sameSite === 'strict' ? 'Strict' : sameSite === 'lax' ? 'Lax' : 'None';
}
function convertCookiesSameSiteCdpToBiDi(sameSite) {
    return sameSite === 'Strict'
        ? "strict" /* Bidi.Network.SameSite.Strict */
        : sameSite === 'Lax'
            ? "lax" /* Bidi.Network.SameSite.Lax */
            : "none" /* Bidi.Network.SameSite.None */;
}
//# sourceMappingURL=Page.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiFrameRealm: () => (/* binding */ BidiFrameRealm),
/* harmony export */   BidiRealm: () => (/* binding */ BidiRealm),
/* harmony export */   BidiWorkerRealm: () => (/* binding */ BidiWorkerRealm)
/* harmony export */ });
/* harmony import */ var _api_Realm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js");
/* harmony import */ var _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cdp/AriaQueryHandler.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js");
/* harmony import */ var _common_LazyArg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/LazyArg.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js");
/* harmony import */ var _common_ScriptInjector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/ScriptInjector.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/AsyncIterableUtil.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js");
/* harmony import */ var _util_Function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/Function.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ExposedFunction.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Serializer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Serializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js");
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});













/**
 * @internal
 */
class BidiRealm extends _api_Realm_js__WEBPACK_IMPORTED_MODULE_0__.Realm {
    realm;
    constructor(realm, timeoutSettings) {
        super(timeoutSettings);
        this.realm = realm;
    }
    initialize() {
        this.realm.on('destroyed', ({ reason }) => {
            this.taskManager.terminateAll(new Error(reason));
            this.dispose();
        });
        this.realm.on('updated', () => {
            this.internalPuppeteerUtil = undefined;
            void this.taskManager.rerunAll();
        });
    }
    internalPuppeteerUtil;
    get puppeteerUtil() {
        const promise = Promise.resolve();
        _common_ScriptInjector_js__WEBPACK_IMPORTED_MODULE_3__.scriptInjector.inject(script => {
            if (this.internalPuppeteerUtil) {
                void this.internalPuppeteerUtil.then(handle => {
                    void handle.dispose();
                });
            }
            this.internalPuppeteerUtil = promise.then(() => {
                return this.evaluateHandle(script);
            });
        }, !this.internalPuppeteerUtil);
        return this.internalPuppeteerUtil;
    }
    async evaluateHandle(pageFunction, ...args) {
        return await this.#evaluate(false, pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
        return await this.#evaluate(true, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
        const sourceUrlComment = (0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.getSourceUrlComment)((0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
            _common_util_js__WEBPACK_IMPORTED_MODULE_4__.PuppeteerURL.INTERNAL_URL);
        let responsePromise;
        const resultOwnership = returnByValue
            ? "none" /* Bidi.Script.ResultOwnership.None */
            : "root" /* Bidi.Script.ResultOwnership.Root */;
        const serializationOptions = returnByValue
            ? {}
            : {
                maxObjectDepth: 0,
                maxDomDepth: 0,
            };
        if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.isString)(pageFunction)) {
            const expression = _common_util_js__WEBPACK_IMPORTED_MODULE_4__.SOURCE_URL_REGEX.test(pageFunction)
                ? pageFunction
                : `${pageFunction}\n${sourceUrlComment}\n`;
            responsePromise = this.realm.evaluate(expression, true, {
                resultOwnership,
                userActivation: true,
                serializationOptions,
            });
        }
        else {
            let functionDeclaration = (0,_util_Function_js__WEBPACK_IMPORTED_MODULE_6__.stringifyFunction)(pageFunction);
            functionDeclaration = _common_util_js__WEBPACK_IMPORTED_MODULE_4__.SOURCE_URL_REGEX.test(functionDeclaration)
                ? functionDeclaration
                : `${functionDeclaration}\n${sourceUrlComment}\n`;
            responsePromise = this.realm.callFunction(functionDeclaration, 
            /* awaitPromise= */ true, {
                arguments: args.length
                    ? await Promise.all(args.map(arg => {
                        return this.serialize(arg);
                    }))
                    : [],
                resultOwnership,
                userActivation: true,
                serializationOptions,
            });
        }
        const result = await responsePromise;
        if ('type' in result && result.type === 'exception') {
            throw (0,_util_js__WEBPACK_IMPORTED_MODULE_12__.createEvaluationError)(result.exceptionDetails);
        }
        return returnByValue
            ? _Deserializer_js__WEBPACK_IMPORTED_MODULE_7__.BidiDeserializer.deserialize(result.result)
            : this.createHandle(result.result);
    }
    createHandle(result) {
        if ((result.type === 'node' || result.type === 'window') &&
            this instanceof BidiFrameRealm) {
            return _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle.from(result, this);
        }
        return _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__.BidiJSHandle.from(result, this);
    }
    async serialize(arg) {
        if (arg instanceof _common_LazyArg_js__WEBPACK_IMPORTED_MODULE_2__.LazyArg) {
            arg = await arg.get(this);
        }
        if (arg instanceof _JSHandle_js__WEBPACK_IMPORTED_MODULE_10__.BidiJSHandle || arg instanceof _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle) {
            if (arg.realm !== this) {
                if (!(arg.realm instanceof BidiFrameRealm) ||
                    !(this instanceof BidiFrameRealm)) {
                    throw new Error("Trying to evaluate JSHandle from different global types. Usually this means you're using a handle from a worker in a page or vice versa.");
                }
                if (arg.realm.environment !== this.environment) {
                    throw new Error("Trying to evaluate JSHandle from different frames. Usually this means you're using a handle from a page on a different page.");
                }
            }
            if (arg.disposed) {
                throw new Error('JSHandle is disposed!');
            }
            return arg.remoteValue();
        }
        return _Serializer_js__WEBPACK_IMPORTED_MODULE_11__.BidiSerializer.serialize(arg);
    }
    async destroyHandles(handles) {
        if (this.disposed) {
            return;
        }
        const handleIds = handles
            .map(({ id }) => {
            return id;
        })
            .filter((id) => {
            return id !== undefined;
        });
        if (handleIds.length === 0) {
            return;
        }
        await this.realm.disown(handleIds).catch(error => {
            // Exceptions might happen in case of a page been navigated or closed.
            // Swallow these since they are harmless and we don't leak anything in this case.
            (0,_common_util_js__WEBPACK_IMPORTED_MODULE_4__.debugError)(error);
        });
    }
    async adoptHandle(handle) {
        return (await this.evaluateHandle(node => {
            return node;
        }, handle));
    }
    async transferHandle(handle) {
        if (handle.realm === this) {
            return handle;
        }
        const transferredHandle = this.adoptHandle(handle);
        await handle.dispose();
        return await transferredHandle;
    }
}
/**
 * @internal
 */
class BidiFrameRealm extends BidiRealm {
    static from(realm, frame) {
        const frameRealm = new BidiFrameRealm(realm, frame);
        frameRealm.#initialize();
        return frameRealm;
    }
    #frame;
    constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#frame = frame;
    }
    #initialize() {
        super.initialize();
        // This should run first.
        this.realm.on('updated', () => {
            this.environment.clearDocumentHandle();
            this.#bindingsInstalled = false;
        });
    }
    #bindingsInstalled = false;
    get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!this.#bindingsInstalled) {
            promise = Promise.all([
                _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__.ExposeableFunction.from(this.environment, '__ariaQuerySelector', _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__.ARIAQueryHandler.queryOne, !!this.sandbox),
                _ExposedFunction_js__WEBPACK_IMPORTED_MODULE_9__.ExposeableFunction.from(this.environment, '__ariaQuerySelectorAll', async (element, selector) => {
                    const results = _cdp_AriaQueryHandler_js__WEBPACK_IMPORTED_MODULE_1__.ARIAQueryHandler.queryAll(element, selector);
                    return await element.realm.evaluateHandle((...elements) => {
                        return elements;
                    }, ...(await _util_AsyncIterableUtil_js__WEBPACK_IMPORTED_MODULE_5__.AsyncIterableUtil.collect(results)));
                }, !!this.sandbox),
            ]);
            this.#bindingsInstalled = true;
        }
        return promise.then(() => {
            return super.puppeteerUtil;
        });
    }
    get sandbox() {
        return this.realm.sandbox;
    }
    get environment() {
        return this.#frame;
    }
    async adoptBackendNode(backendNodeId) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            const { object } = await this.#frame.client.send('DOM.resolveNode', {
                backendNodeId,
                executionContextId: await this.realm.resolveExecutionContextId(),
            });
            const handle = __addDisposableResource(env_1, _ElementHandle_js__WEBPACK_IMPORTED_MODULE_8__.BidiElementHandle.from({
                handle: object.objectId,
                type: 'node',
            }, this), false);
            // We need the sharedId, so we perform the following to obtain it.
            return await handle.evaluateHandle(element => {
                return element;
            });
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
}
/**
 * @internal
 */
class BidiWorkerRealm extends BidiRealm {
    static from(realm, worker) {
        const workerRealm = new BidiWorkerRealm(realm, worker);
        workerRealm.initialize();
        return workerRealm;
    }
    #worker;
    constructor(realm, frame) {
        super(realm, frame.timeoutSettings);
        this.#worker = frame;
    }
    get environment() {
        return this.#worker;
    }
    async adoptBackendNode() {
        throw new Error('Cannot adopt DOM nodes into a worker.');
    }
}
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiSerializer: () => (/* binding */ BidiSerializer)
/* harmony export */ });
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * @internal
 */
class UnserializableError extends Error {
}
/**
 * @internal
 */
class BidiSerializer {
    static serialize(arg) {
        switch (typeof arg) {
            case 'symbol':
            case 'function':
                throw new UnserializableError(`Unable to serializable ${typeof arg}`);
            case 'object':
                return this.#serializeObject(arg);
            case 'undefined':
                return {
                    type: 'undefined',
                };
            case 'number':
                return this.#serializeNumber(arg);
            case 'bigint':
                return {
                    type: 'bigint',
                    value: arg.toString(),
                };
            case 'string':
                return {
                    type: 'string',
                    value: arg,
                };
            case 'boolean':
                return {
                    type: 'boolean',
                    value: arg,
                };
        }
    }
    static #serializeNumber(arg) {
        let value;
        if (Object.is(arg, -0)) {
            value = '-0';
        }
        else if (Object.is(arg, Infinity)) {
            value = 'Infinity';
        }
        else if (Object.is(arg, -Infinity)) {
            value = '-Infinity';
        }
        else if (Object.is(arg, NaN)) {
            value = 'NaN';
        }
        else {
            value = arg;
        }
        return {
            type: 'number',
            value,
        };
    }
    static #serializeObject(arg) {
        if (arg === null) {
            return {
                type: 'null',
            };
        }
        else if (Array.isArray(arg)) {
            const parsedArray = arg.map(subArg => {
                return this.serialize(subArg);
            });
            return {
                type: 'array',
                value: parsedArray,
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(arg)) {
            try {
                JSON.stringify(arg);
            }
            catch (error) {
                if (error instanceof TypeError &&
                    error.message.startsWith('Converting circular structure to JSON')) {
                    error.message += ' Recursive objects are not allowed.';
                }
                throw error;
            }
            const parsedObject = [];
            for (const key in arg) {
                parsedObject.push([this.serialize(key), this.serialize(arg[key])]);
            }
            return {
                type: 'object',
                value: parsedObject,
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(arg)) {
            return {
                type: 'regexp',
                value: {
                    pattern: arg.source,
                    flags: arg.flags,
                },
            };
        }
        else if ((0,_common_util_js__WEBPACK_IMPORTED_MODULE_0__.isDate)(arg)) {
            return {
                type: 'date',
                value: arg.toISOString(),
            };
        }
        throw new UnserializableError('Custom object serialization not possible. Use plain objects instead.');
    }
}
//# sourceMappingURL=Serializer.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js":
/*!**********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowserTarget: () => (/* binding */ BidiBrowserTarget),
/* harmony export */   BidiFrameTarget: () => (/* binding */ BidiFrameTarget),
/* harmony export */   BidiPageTarget: () => (/* binding */ BidiPageTarget),
/* harmony export */   BidiWorkerTarget: () => (/* binding */ BidiWorkerTarget)
/* harmony export */ });
/* harmony import */ var _api_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Target.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiBrowserTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #browser;
    constructor(browser) {
        super();
        this.#browser = browser;
    }
    asPage() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    url() {
        return '';
    }
    createCDPSession() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.BROWSER;
    }
    browser() {
        return this.#browser;
    }
    browserContext() {
        return this.#browser.defaultBrowserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiPageTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #page;
    constructor(page) {
        super();
        this.#page = page;
    }
    async page() {
        return this.#page;
    }
    async asPage() {
        return _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#page.mainFrame().browsingContext);
    }
    url() {
        return this.#page.url();
    }
    createCDPSession() {
        return this.#page.createCDPSession();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.PAGE;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#page.browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiFrameTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #frame;
    #page;
    constructor(frame) {
        super();
        this.#frame = frame;
    }
    async page() {
        if (this.#page === undefined) {
            this.#page = _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#frame.browsingContext);
        }
        return this.#page;
    }
    async asPage() {
        return _Page_js__WEBPACK_IMPORTED_MODULE_2__.BidiPage.from(this.browserContext(), this.#frame.browsingContext);
    }
    url() {
        return this.#frame.url();
    }
    createCDPSession() {
        return this.#frame.createCDPSession();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.PAGE;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#frame.page().browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
/**
 * @internal
 */
class BidiWorkerTarget extends _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.Target {
    #worker;
    constructor(worker) {
        super();
        this.#worker = worker;
    }
    async page() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    async asPage() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    url() {
        return this.#worker.url();
    }
    createCDPSession() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
    type() {
        return _api_Target_js__WEBPACK_IMPORTED_MODULE_0__.TargetType.OTHER;
    }
    browser() {
        return this.browserContext().browser();
    }
    browserContext() {
        return this.#worker.frame.page().browserContext();
    }
    opener() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
//# sourceMappingURL=Target.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js":
/*!*************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/WebWorker.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiWebWorker: () => (/* binding */ BidiWebWorker)
/* harmony export */ });
/* harmony import */ var _api_WebWorker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/WebWorker.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js");
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
class BidiWebWorker extends _api_WebWorker_js__WEBPACK_IMPORTED_MODULE_0__.WebWorker {
    static from(frame, realm) {
        const worker = new BidiWebWorker(frame, realm);
        return worker;
    }
    #frame;
    #realm;
    constructor(frame, realm) {
        super(realm.origin);
        this.#frame = frame;
        this.#realm = _Realm_js__WEBPACK_IMPORTED_MODULE_2__.BidiWorkerRealm.from(realm, this);
    }
    get frame() {
        return this.#frame;
    }
    mainRealm() {
        return this.#realm;
    }
    get client() {
        throw new _common_Errors_js__WEBPACK_IMPORTED_MODULE_1__.UnsupportedOperation();
    }
}
//# sourceMappingURL=WebWorker.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BidiBrowser: () => (/* reexport safe */ _Browser_js__WEBPACK_IMPORTED_MODULE_1__.BidiBrowser),
/* harmony export */   BidiBrowserContext: () => (/* reexport safe */ _BrowserContext_js__WEBPACK_IMPORTED_MODULE_2__.BidiBrowserContext),
/* harmony export */   BidiConnection: () => (/* reexport safe */ _Connection_js__WEBPACK_IMPORTED_MODULE_3__.BidiConnection),
/* harmony export */   BidiElementHandle: () => (/* reexport safe */ _ElementHandle_js__WEBPACK_IMPORTED_MODULE_4__.BidiElementHandle),
/* harmony export */   BidiFrame: () => (/* reexport safe */ _Frame_js__WEBPACK_IMPORTED_MODULE_5__.BidiFrame),
/* harmony export */   BidiFrameRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiFrameRealm),
/* harmony export */   BidiHTTPRequest: () => (/* reexport safe */ _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__.BidiHTTPRequest),
/* harmony export */   BidiHTTPResponse: () => (/* reexport safe */ _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_7__.BidiHTTPResponse),
/* harmony export */   BidiJSHandle: () => (/* reexport safe */ _JSHandle_js__WEBPACK_IMPORTED_MODULE_9__.BidiJSHandle),
/* harmony export */   BidiKeyboard: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiKeyboard),
/* harmony export */   BidiMouse: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiMouse),
/* harmony export */   BidiPage: () => (/* reexport safe */ _Page_js__WEBPACK_IMPORTED_MODULE_10__.BidiPage),
/* harmony export */   BidiRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiRealm),
/* harmony export */   BidiTouchscreen: () => (/* reexport safe */ _Input_js__WEBPACK_IMPORTED_MODULE_8__.BidiTouchscreen),
/* harmony export */   BidiWorkerRealm: () => (/* reexport safe */ _Realm_js__WEBPACK_IMPORTED_MODULE_11__.BidiWorkerRealm),
/* harmony export */   connectBidiOverCdp: () => (/* reexport safe */ _BidiOverCdp_js__WEBPACK_IMPORTED_MODULE_0__.connectBidiOverCdp),
/* harmony export */   requests: () => (/* reexport safe */ _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__.requests)
/* harmony export */ });
/* harmony import */ var _BidiOverCdp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BidiOverCdp.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js");
/* harmony import */ var _Browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js");
/* harmony import */ var _BrowserContext_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BrowserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js");
/* harmony import */ var _Connection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Connection.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js");
/* harmony import */ var _ElementHandle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ElementHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js");
/* harmony import */ var _Frame_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Frame.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js");
/* harmony import */ var _HTTPRequest_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HTTPRequest.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js");
/* harmony import */ var _HTTPResponse_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HTTPResponse.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js");
/* harmony import */ var _Input_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Input.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js");
/* harmony import */ var _JSHandle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JSHandle.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js");
/* harmony import */ var _Page_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Page.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js");
/**
 * @license
 * Copyright 2022 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */












//# sourceMappingURL=bidi.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Browser: () => (/* binding */ Browser)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js");
/* harmony import */ var _UserContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UserContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __addDisposableResource = (undefined && undefined.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (undefined && undefined.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});





/**
 * @internal
 */
let Browser = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _close_decorators;
    let _addPreloadScript_decorators;
    let _removeIntercept_decorators;
    let _removePreloadScript_decorators;
    let _createUserContext_decorators;
    return class Browser extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: obj => "close" in obj, get: obj => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: obj => "addPreloadScript" in obj, get: obj => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removeIntercept_decorators, { kind: "method", name: "removeIntercept", static: false, private: false, access: { has: obj => "removeIntercept" in obj, get: obj => obj.removeIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: obj => "removePreloadScript" in obj, get: obj => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createUserContext_decorators, { kind: "method", name: "createUserContext", static: false, private: false, access: { has: obj => "createUserContext" in obj, get: obj => obj.createUserContext }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(session) {
            const browser = new Browser(session);
            await browser.#initialize();
            return browser;
        }
        #closed = (__runInitializers(this, _instanceExtraInitializers), false);
        #reason;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #userContexts = new Map();
        session;
        #sharedWorkers = new Map();
        constructor(session) {
            super();
            this.session = session;
        }
        async #initialize() {
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
            sessionEmitter.once('ended', ({ reason }) => {
                this.dispose(reason);
            });
            sessionEmitter.on('script.realmCreated', info => {
                if (info.type !== 'shared-worker') {
                    return;
                }
                this.#sharedWorkers.set(info.realm, _Realm_js__WEBPACK_IMPORTED_MODULE_3__.SharedWorkerRealm.from(this, info.realm, info.origin));
            });
            await this.#syncUserContexts();
            await this.#syncBrowsingContexts();
        }
        async #syncUserContexts() {
            const { result: { userContexts }, } = await this.session.send('browser.getUserContexts', {});
            for (const context of userContexts) {
                this.#createUserContext(context.userContext);
            }
        }
        async #syncBrowsingContexts() {
            // In case contexts are created or destroyed during `getTree`, we use this
            // set to detect them.
            const contextIds = new Set();
            let contexts;
            {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    const sessionEmitter = __addDisposableResource(env_1, new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session), false);
                    sessionEmitter.on('browsingContext.contextCreated', info => {
                        contextIds.add(info.context);
                    });
                    const { result } = await this.session.send('browsingContext.getTree', {});
                    contexts = result.contexts;
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources(env_1);
                }
            }
            // Simulating events so contexts are created naturally.
            for (const info of contexts) {
                if (!contextIds.has(info.context)) {
                    this.session.emit('browsingContext.contextCreated', info);
                }
                if (info.children) {
                    contexts.push(...info.children);
                }
            }
        }
        #createUserContext(id) {
            const userContext = _UserContext_js__WEBPACK_IMPORTED_MODULE_4__.UserContext.create(this, id);
            this.#userContexts.set(userContext.id, userContext);
            const userContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(userContext));
            userContextEmitter.once('closed', () => {
                userContextEmitter.removeAllListeners();
                this.#userContexts.delete(userContext.id);
            });
            return userContext;
        }
        get closed() {
            return this.#closed;
        }
        get defaultUserContext() {
            // SAFETY: A UserContext is always created for the default context.
            return this.#userContexts.get(_UserContext_js__WEBPACK_IMPORTED_MODULE_4__.UserContext.DEFAULT);
        }
        get disconnected() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.disconnected;
        }
        get userContexts() {
            return this.#userContexts.values();
        }
        dispose(reason, closed = false) {
            this.#closed = closed;
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async close() {
            try {
                await this.session.send('browser.close', {});
            }
            finally {
                this.dispose('Browser already closed.', true);
            }
        }
        async addPreloadScript(functionDeclaration, options = {}) {
            const { result: { script }, } = await this.session.send('script.addPreloadScript', {
                functionDeclaration,
                ...options,
                contexts: options.contexts?.map(context => {
                    return context.id;
                }),
            });
            return script;
        }
        async removeIntercept(intercept) {
            await this.session.send('network.removeIntercept', {
                intercept,
            });
        }
        async removePreloadScript(script) {
            await this.session.send('script.removePreloadScript', {
                script,
            });
        }
        async createUserContext() {
            const { result: { userContext: context }, } = await this.session.send('browser.createUserContext', {});
            return this.#createUserContext(context);
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _close_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _addPreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _removeIntercept_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _removePreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _createUserContext_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(browser => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return browser.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Browser was disconnected, probably because the session ended.';
            if (this.closed) {
                this.emit('closed', { reason: this.#reason });
            }
            this.emit('disconnected', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Browser.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js":
/*!************************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowsingContext: () => (/* binding */ BrowsingContext)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Navigation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Navigation.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js");
/* harmony import */ var _Realm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Realm.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js");
/* harmony import */ var _Request_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js");
/* harmony import */ var _UserPrompt_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UserPrompt.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};







/**
 * @internal
 */
let BrowsingContext = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _activate_decorators;
    let _captureScreenshot_decorators;
    let _close_decorators;
    let _traverseHistory_decorators;
    let _navigate_decorators;
    let _reload_decorators;
    let _setCacheBehavior_decorators;
    let _print_decorators;
    let _handleUserPrompt_decorators;
    let _setViewport_decorators;
    let _performActions_decorators;
    let _releaseActions_decorators;
    let _createWindowRealm_decorators;
    let _addPreloadScript_decorators;
    let _addIntercept_decorators;
    let _removePreloadScript_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setFiles_decorators;
    let _subscribe_decorators;
    let _addInterception_decorators;
    let _deleteCookie_decorators;
    let _locateNodes_decorators;
    return class BrowsingContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _deleteCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                    // SAFETY: Disposal implies this exists.
                    return context.#reason;
                })];
            _locateNodes_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                    // SAFETY: Disposal implies this exists.
                    return context.#reason;
                })];
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _activate_decorators, { kind: "method", name: "activate", static: false, private: false, access: { has: obj => "activate" in obj, get: obj => obj.activate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _captureScreenshot_decorators, { kind: "method", name: "captureScreenshot", static: false, private: false, access: { has: obj => "captureScreenshot" in obj, get: obj => obj.captureScreenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _close_decorators, { kind: "method", name: "close", static: false, private: false, access: { has: obj => "close" in obj, get: obj => obj.close }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _traverseHistory_decorators, { kind: "method", name: "traverseHistory", static: false, private: false, access: { has: obj => "traverseHistory" in obj, get: obj => obj.traverseHistory }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _navigate_decorators, { kind: "method", name: "navigate", static: false, private: false, access: { has: obj => "navigate" in obj, get: obj => obj.navigate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _reload_decorators, { kind: "method", name: "reload", static: false, private: false, access: { has: obj => "reload" in obj, get: obj => obj.reload }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCacheBehavior_decorators, { kind: "method", name: "setCacheBehavior", static: false, private: false, access: { has: obj => "setCacheBehavior" in obj, get: obj => obj.setCacheBehavior }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _print_decorators, { kind: "method", name: "print", static: false, private: false, access: { has: obj => "print" in obj, get: obj => obj.print }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _handleUserPrompt_decorators, { kind: "method", name: "handleUserPrompt", static: false, private: false, access: { has: obj => "handleUserPrompt" in obj, get: obj => obj.handleUserPrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setViewport_decorators, { kind: "method", name: "setViewport", static: false, private: false, access: { has: obj => "setViewport" in obj, get: obj => obj.setViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _performActions_decorators, { kind: "method", name: "performActions", static: false, private: false, access: { has: obj => "performActions" in obj, get: obj => obj.performActions }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _releaseActions_decorators, { kind: "method", name: "releaseActions", static: false, private: false, access: { has: obj => "releaseActions" in obj, get: obj => obj.releaseActions }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createWindowRealm_decorators, { kind: "method", name: "createWindowRealm", static: false, private: false, access: { has: obj => "createWindowRealm" in obj, get: obj => obj.createWindowRealm }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: obj => "addPreloadScript" in obj, get: obj => obj.addPreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addIntercept_decorators, { kind: "method", name: "addIntercept", static: false, private: false, access: { has: obj => "addIntercept" in obj, get: obj => obj.addIntercept }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _removePreloadScript_decorators, { kind: "method", name: "removePreloadScript", static: false, private: false, access: { has: obj => "removePreloadScript" in obj, get: obj => obj.removePreloadScript }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: obj => "getCookies" in obj, get: obj => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: obj => "setCookie" in obj, get: obj => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setFiles_decorators, { kind: "method", name: "setFiles", static: false, private: false, access: { has: obj => "setFiles" in obj, get: obj => obj.setFiles }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: obj => "subscribe" in obj, get: obj => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addInterception_decorators, { kind: "method", name: "addInterception", static: false, private: false, access: { has: obj => "addInterception" in obj, get: obj => obj.addInterception }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _deleteCookie_decorators, { kind: "method", name: "deleteCookie", static: false, private: false, access: { has: obj => "deleteCookie" in obj, get: obj => obj.deleteCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _locateNodes_decorators, { kind: "method", name: "locateNodes", static: false, private: false, access: { has: obj => "locateNodes" in obj, get: obj => obj.locateNodes }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(userContext, parent, id, url, originalOpener) {
            const browsingContext = new BrowsingContext(userContext, parent, id, url, originalOpener);
            browsingContext.#initialize();
            return browsingContext;
        }
        #navigation = __runInitializers(this, _instanceExtraInitializers);
        #reason;
        #url;
        #children = new Map();
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #realms = new Map();
        #requests = new Map();
        defaultRealm;
        id;
        parent;
        userContext;
        originalOpener;
        constructor(context, parent, id, url, originalOpener) {
            super();
            this.#url = url;
            this.id = id;
            this.parent = parent;
            this.userContext = context;
            this.originalOpener = originalOpener;
            this.defaultRealm = this.#createWindowRealm();
        }
        #initialize() {
            const userContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.userContext));
            userContextEmitter.once('closed', ({ reason }) => {
                this.dispose(`Browsing context already closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.contextCreated', info => {
                if (info.parent !== this.id) {
                    return;
                }
                const browsingContext = BrowsingContext.from(this.userContext, this, info.context, info.url, info.originalOpener);
                this.#children.set(info.context, browsingContext);
                const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(browsingContext));
                browsingContextEmitter.once('closed', () => {
                    browsingContextEmitter.removeAllListeners();
                    this.#children.delete(browsingContext.id);
                });
                this.emit('browsingcontext', { browsingContext });
            });
            sessionEmitter.on('browsingContext.contextDestroyed', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.dispose('Browsing context already closed.');
            });
            sessionEmitter.on('browsingContext.domContentLoaded', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.#url = info.url;
                this.emit('DOMContentLoaded', undefined);
            });
            sessionEmitter.on('browsingContext.load', info => {
                if (info.context !== this.id) {
                    return;
                }
                this.#url = info.url;
                this.emit('load', undefined);
            });
            sessionEmitter.on('browsingContext.navigationStarted', info => {
                if (info.context !== this.id) {
                    return;
                }
                // Note: we should not update this.#url at this point since the context
                // has not finished navigating to the info.url yet.
                for (const [id, request] of this.#requests) {
                    if (request.disposed) {
                        this.#requests.delete(id);
                    }
                }
                // If the navigation hasn't finished, then this is nested navigation. The
                // current navigation will handle this.
                if (this.#navigation !== undefined && !this.#navigation.disposed) {
                    return;
                }
                // Note the navigation ID is null for this event.
                this.#navigation = _Navigation_js__WEBPACK_IMPORTED_MODULE_3__.Navigation.from(this);
                const navigationEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#navigation));
                for (const eventName of ['fragment', 'failed', 'aborted']) {
                    navigationEmitter.once(eventName, ({ url }) => {
                        navigationEmitter[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
                        this.#url = url;
                    });
                }
                this.emit('navigation', { navigation: this.#navigation });
            });
            sessionEmitter.on('network.beforeRequestSent', event => {
                if (event.context !== this.id) {
                    return;
                }
                if (this.#requests.has(event.request.request)) {
                    // Means the request is a redirect. This is handled in Request.
                    // Or an Auth event was issued
                    return;
                }
                const request = _Request_js__WEBPACK_IMPORTED_MODULE_5__.Request.from(this, event);
                this.#requests.set(request.id, request);
                this.emit('request', { request });
            });
            sessionEmitter.on('log.entryAdded', entry => {
                if (entry.source.context !== this.id) {
                    return;
                }
                this.emit('log', { entry });
            });
            sessionEmitter.on('browsingContext.userPromptOpened', info => {
                if (info.context !== this.id) {
                    return;
                }
                const userPrompt = _UserPrompt_js__WEBPACK_IMPORTED_MODULE_6__.UserPrompt.from(this, info);
                this.emit('userprompt', { userPrompt });
            });
        }
        get #session() {
            return this.userContext.browser.session;
        }
        get children() {
            return this.#children.values();
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get realms() {
            // eslint-disable-next-line @typescript-eslint/no-this-alias -- Required
            const self = this;
            return (function* () {
                yield self.defaultRealm;
                yield* self.#realms.values();
            })();
        }
        get top() {
            let context = this;
            for (let { parent } = context; parent; { parent } = context) {
                context = parent;
            }
            return context;
        }
        get url() {
            return this.#url;
        }
        #createWindowRealm(sandbox) {
            const realm = _Realm_js__WEBPACK_IMPORTED_MODULE_4__.WindowRealm.from(this, sandbox);
            realm.on('worker', realm => {
                this.emit('worker', { realm });
            });
            return realm;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async activate() {
            await this.#session.send('browsingContext.activate', {
                context: this.id,
            });
        }
        async captureScreenshot(options = {}) {
            const { result: { data }, } = await this.#session.send('browsingContext.captureScreenshot', {
                context: this.id,
                ...options,
            });
            return data;
        }
        async close(promptUnload) {
            await Promise.all([...this.#children.values()].map(async (child) => {
                await child.close(promptUnload);
            }));
            await this.#session.send('browsingContext.close', {
                context: this.id,
                promptUnload,
            });
        }
        async traverseHistory(delta) {
            await this.#session.send('browsingContext.traverseHistory', {
                context: this.id,
                delta,
            });
        }
        async navigate(url, wait) {
            await this.#session.send('browsingContext.navigate', {
                context: this.id,
                url,
                wait,
            });
        }
        async reload(options = {}) {
            await this.#session.send('browsingContext.reload', {
                context: this.id,
                ...options,
            });
        }
        async setCacheBehavior(cacheBehavior) {
            // @ts-expect-error not in BiDi types yet.
            await this.#session.send('network.setCacheBehavior', {
                contexts: [this.id],
                cacheBehavior,
            });
        }
        async print(options = {}) {
            const { result: { data }, } = await this.#session.send('browsingContext.print', {
                context: this.id,
                ...options,
            });
            return data;
        }
        async handleUserPrompt(options = {}) {
            await this.#session.send('browsingContext.handleUserPrompt', {
                context: this.id,
                ...options,
            });
        }
        async setViewport(options = {}) {
            await this.#session.send('browsingContext.setViewport', {
                context: this.id,
                ...options,
            });
        }
        async performActions(actions) {
            await this.#session.send('input.performActions', {
                context: this.id,
                actions,
            });
        }
        async releaseActions() {
            await this.#session.send('input.releaseActions', {
                context: this.id,
            });
        }
        createWindowRealm(sandbox) {
            return this.#createWindowRealm(sandbox);
        }
        async addPreloadScript(functionDeclaration, options = {}) {
            return await this.userContext.browser.addPreloadScript(functionDeclaration, {
                ...options,
                contexts: [this],
            });
        }
        async addIntercept(options) {
            const { result: { intercept }, } = await this.userContext.browser.session.send('network.addIntercept', {
                ...options,
                contexts: [this.id],
            });
            return intercept;
        }
        async removePreloadScript(script) {
            await this.userContext.browser.removePreloadScript(script);
        }
        async getCookies(options = {}) {
            const { result: { cookies }, } = await this.#session.send('storage.getCookies', {
                ...options,
                partition: {
                    type: 'context',
                    context: this.id,
                },
            });
            return cookies;
        }
        async setCookie(cookie) {
            await this.#session.send('storage.setCookie', {
                cookie,
                partition: {
                    type: 'context',
                    context: this.id,
                },
            });
        }
        async setFiles(element, files) {
            await this.#session.send('input.setFiles', {
                context: this.id,
                element,
                files,
            });
        }
        async subscribe(events) {
            await this.#session.subscribe(events, [this.id]);
        }
        async addInterception(events) {
            await this.#session.subscribe(events, [this.id]);
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _activate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _captureScreenshot_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _close_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _traverseHistory_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _navigate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _reload_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCacheBehavior_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _print_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _handleUserPrompt_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setViewport_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _performActions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _releaseActions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _createWindowRealm_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addPreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addIntercept_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _removePreloadScript_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _getCookies_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setFiles_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _subscribe_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _addInterception_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Browsing context already closed, probably because the user context closed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async deleteCookie(...cookieFilters) {
            await Promise.all(cookieFilters.map(async (filter) => {
                await this.#session.send('storage.deleteCookies', {
                    filter: filter,
                    partition: {
                        type: 'context',
                        context: this.id,
                    },
                });
            }));
        }
        async locateNodes(locator, startNodes) {
            // TODO: add other locateNodes options if needed.
            const result = await this.#session.send('browsingContext.locateNodes', {
                context: this.id,
                locator,
                startNodes: startNodes.length ? startNodes : undefined,
            });
            return result.result.nodes;
        }
    };
})();

//# sourceMappingURL=BrowsingContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Navigation.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Navigation: () => (/* binding */ Navigation)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let Navigation = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return class Navigation extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(context) {
            const navigation = new Navigation(context);
            navigation.#initialize();
            return navigation;
        }
        #request = __runInitializers(this, _instanceExtraInitializers);
        #navigation;
        #browsingContext;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #id;
        constructor(context) {
            super();
            this.#browsingContext = context;
        }
        #initialize() {
            const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#browsingContext));
            browsingContextEmitter.once('closed', () => {
                this.emit('failed', {
                    url: this.#browsingContext.url,
                    timestamp: new Date(),
                });
                this.dispose();
            });
            browsingContextEmitter.on('request', ({ request }) => {
                if (request.navigation === undefined ||
                    // If a request with a navigation ID comes in, then the navigation ID is
                    // for this navigation.
                    !this.#matches(request.navigation)) {
                    return;
                }
                this.#request = request;
                this.emit('request', request);
                const requestEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#request));
                requestEmitter.on('redirect', request => {
                    this.#request = request;
                });
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.navigationStarted', info => {
                if (info.context !== this.#browsingContext.id ||
                    this.#navigation !== undefined) {
                    return;
                }
                this.#navigation = Navigation.from(this.#browsingContext);
            });
            for (const eventName of [
                'browsingContext.domContentLoaded',
                'browsingContext.load',
            ]) {
                sessionEmitter.on(eventName, info => {
                    if (info.context !== this.#browsingContext.id ||
                        info.navigation === null ||
                        !this.#matches(info.navigation)) {
                        return;
                    }
                    this.dispose();
                });
            }
            for (const [eventName, event] of [
                ['browsingContext.fragmentNavigated', 'fragment'],
                ['browsingContext.navigationFailed', 'failed'],
                ['browsingContext.navigationAborted', 'aborted'],
            ]) {
                sessionEmitter.on(eventName, info => {
                    if (info.context !== this.#browsingContext.id ||
                        // Note we don't check if `navigation` is null since `null` means the
                        // fragment navigated.
                        !this.#matches(info.navigation)) {
                        return;
                    }
                    this.emit(event, {
                        url: info.url,
                        timestamp: new Date(info.timestamp),
                    });
                    this.dispose();
                });
            }
        }
        #matches(navigation) {
            if (this.#navigation !== undefined && !this.#navigation.disposed) {
                return false;
            }
            if (this.#id === undefined) {
                this.#id = navigation;
                return true;
            }
            return this.#id === navigation;
        }
        get #session() {
            return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
            return this.#disposables.disposed;
        }
        get request() {
            return this.#request;
        }
        get navigation() {
            return this.#navigation;
        }
        dispose() {
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Navigation.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Realm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DedicatedWorkerRealm: () => (/* binding */ DedicatedWorkerRealm),
/* harmony export */   Realm: () => (/* binding */ Realm),
/* harmony export */   SharedWorkerRealm: () => (/* binding */ SharedWorkerRealm),
/* harmony export */   WindowRealm: () => (/* binding */ WindowRealm)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var _a;



/**
 * @internal
 */
let Realm = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _disown_decorators;
    let _callFunction_decorators;
    let _evaluate_decorators;
    let _resolveExecutionContextId_decorators;
    return class Realm extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _disown_decorators, { kind: "method", name: "disown", static: false, private: false, access: { has: obj => "disown" in obj, get: obj => obj.disown }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _callFunction_decorators, { kind: "method", name: "callFunction", static: false, private: false, access: { has: obj => "callFunction" in obj, get: obj => obj.callFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: obj => "evaluate" in obj, get: obj => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _resolveExecutionContextId_decorators, { kind: "method", name: "resolveExecutionContextId", static: false, private: false, access: { has: obj => "resolveExecutionContextId" in obj, get: obj => obj.resolveExecutionContextId }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        id;
        origin;
        executionContextId;
        constructor(id, origin) {
            super();
            this.id = id;
            this.origin = origin;
        }
        get disposed() {
            return this.#reason !== undefined;
        }
        get target() {
            return { realm: this.id };
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async disown(handles) {
            await this.session.send('script.disown', {
                target: this.target,
                handles,
            });
        }
        async callFunction(functionDeclaration, awaitPromise, options = {}) {
            const { result } = await this.session.send('script.callFunction', {
                functionDeclaration,
                awaitPromise,
                target: this.target,
                ...options,
            });
            return result;
        }
        async evaluate(expression, awaitPromise, options = {}) {
            const { result } = await this.session.send('script.evaluate', {
                expression,
                awaitPromise,
                target: this.target,
                ...options,
            });
            return result;
        }
        async resolveExecutionContextId() {
            if (!this.executionContextId) {
                const { result } = await this.session.connection.send('cdp.resolveRealm', { realm: this.id });
                this.executionContextId = result.executionContextId;
            }
            return this.executionContextId;
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _disown_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _callFunction_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _evaluate_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _resolveExecutionContextId_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(realm => {
                // SAFETY: Disposal implies this exists.
                return realm.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Realm already destroyed, probably because all associated browsing contexts closed.';
            this.emit('destroyed', { reason: this.#reason });
            this.disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

/**
 * @internal
 */
class WindowRealm extends Realm {
    static from(context, sandbox) {
        const realm = new WindowRealm(context, sandbox);
        realm.#initialize();
        return realm;
    }
    browsingContext;
    sandbox;
    #workers = new Map();
    constructor(context, sandbox) {
        super('', '');
        this.browsingContext = context;
        this.sandbox = sandbox;
    }
    #initialize() {
        const browsingContextEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browsingContext));
        browsingContextEmitter.on('closed', ({ reason }) => {
            this.dispose(reason);
        });
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'window' ||
                info.context !== this.browsingContext.id ||
                info.sandbox !== this.sandbox) {
                return;
            }
            this.id = info.realm;
            this.origin = info.origin;
            this.executionContextId = undefined;
            this.emit('updated', this);
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                realmEmitter.removeAllListeners();
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        return this.browsingContext.userContext.browser.session;
    }
    get target() {
        return { context: this.browsingContext.id, sandbox: this.sandbox };
    }
}
/**
 * @internal
 */
class DedicatedWorkerRealm extends Realm {
    static from(owner, id, origin) {
        const realm = new _a(owner, id, origin);
        realm.#initialize();
        return realm;
    }
    #workers = new Map();
    owners;
    constructor(owner, id, origin) {
        super(id, origin);
        this.owners = new Set([owner]);
    }
    #initialize() {
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmDestroyed', info => {
            if (info.realm !== this.id) {
                return;
            }
            this.dispose('Realm already destroyed.');
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = _a.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        // SAFETY: At least one owner will exist.
        return this.owners.values().next().value.session;
    }
}
_a = DedicatedWorkerRealm;
/**
 * @internal
 */
class SharedWorkerRealm extends Realm {
    static from(browser, id, origin) {
        const realm = new SharedWorkerRealm(browser, id, origin);
        realm.#initialize();
        return realm;
    }
    #workers = new Map();
    browser;
    constructor(browser, id, origin) {
        super(id, origin);
        this.browser = browser;
    }
    #initialize() {
        const sessionEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.session));
        sessionEmitter.on('script.realmDestroyed', info => {
            if (info.realm !== this.id) {
                return;
            }
            this.dispose('Realm already destroyed.');
        });
        sessionEmitter.on('script.realmCreated', info => {
            if (info.type !== 'dedicated-worker') {
                return;
            }
            if (!info.owners.includes(this.id)) {
                return;
            }
            const realm = DedicatedWorkerRealm.from(this, info.realm, info.origin);
            this.#workers.set(realm.id, realm);
            const realmEmitter = this.disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(realm));
            realmEmitter.once('destroyed', () => {
                this.#workers.delete(realm.id);
            });
            this.emit('worker', realm);
        });
    }
    get session() {
        return this.browser.session;
    }
}
//# sourceMappingURL=Realm.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Request.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Request: () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let Request = (() => {
    var _a;
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    return class Request extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, event) {
            const request = new Request(browsingContext, event);
            request.#initialize();
            return request;
        }
        #error = __runInitializers(this, _instanceExtraInitializers);
        #redirect;
        #response;
        #browsingContext;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #event;
        constructor(browsingContext, event) {
            super();
            this.#browsingContext = browsingContext;
            this.#event = event;
        }
        #initialize() {
            const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#browsingContext));
            browsingContextEmitter.once('closed', ({ reason }) => {
                this.#error = reason;
                this.emit('error', this.#error);
                this.dispose();
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('network.beforeRequestSent', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    event.redirectCount !== this.#event.redirectCount + 1) {
                    return;
                }
                this.#redirect = Request.from(this.#browsingContext, event);
                this.emit('redirect', this.#redirect);
                this.dispose();
            });
            sessionEmitter.on('network.authRequired', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    // Don't try to authenticate for events that are not blocked
                    !event.isBlocked) {
                    return;
                }
                this.emit('authenticate', undefined);
            });
            sessionEmitter.on('network.fetchError', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    this.#event.redirectCount !== event.redirectCount) {
                    return;
                }
                this.#error = event.errorText;
                this.emit('error', this.#error);
                this.dispose();
            });
            sessionEmitter.on('network.responseCompleted', event => {
                if (event.context !== this.#browsingContext.id ||
                    event.request.request !== this.id ||
                    this.#event.redirectCount !== event.redirectCount) {
                    return;
                }
                this.#response = event.response;
                this.emit('success', this.#response);
                // In case this is a redirect.
                if (this.#response.status >= 300 && this.#response.status < 400) {
                    return;
                }
                this.dispose();
            });
        }
        get #session() {
            return this.#browsingContext.userContext.browser.session;
        }
        get disposed() {
            return this.#disposables.disposed;
        }
        get error() {
            return this.#error;
        }
        get headers() {
            return this.#event.request.headers;
        }
        get id() {
            return this.#event.request.request;
        }
        get initiator() {
            return this.#event.initiator;
        }
        get method() {
            return this.#event.request.method;
        }
        get navigation() {
            return this.#event.navigation ?? undefined;
        }
        get redirect() {
            return this.#redirect;
        }
        get lastRedirect() {
            let redirect = this.#redirect;
            while (redirect) {
                if (redirect && !redirect.#redirect) {
                    return redirect;
                }
                redirect = redirect.#redirect;
            }
            return redirect;
        }
        get response() {
            return this.#response;
        }
        get url() {
            return this.#event.request.url;
        }
        get isBlocked() {
            return this.#event.isBlocked;
        }
        async continueRequest({ url, method, headers, cookies, body, }) {
            await this.#session.send('network.continueRequest', {
                request: this.id,
                url,
                method,
                headers,
                body,
                cookies,
            });
        }
        async failRequest() {
            await this.#session.send('network.failRequest', {
                request: this.id,
            });
        }
        async provideResponse({ statusCode, reasonPhrase, headers, body, }) {
            await this.#session.send('network.provideResponse', {
                request: this.id,
                statusCode,
                reasonPhrase,
                headers,
                body,
            });
        }
        async continueWithAuth(parameters) {
            if (parameters.action === 'provideCredentials') {
                await this.#session.send('network.continueWithAuth', {
                    request: this.id,
                    action: parameters.action,
                    credentials: parameters.credentials,
                });
            }
            else {
                await this.#session.send('network.continueWithAuth', {
                    request: this.id,
                    action: parameters.action,
                });
            }
        }
        dispose() {
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Request.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js":
/*!****************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Session.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Session: () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _Browser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Browser.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/Browser.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};




// TODO: Once Chrome supports session.status properly, uncomment this block.
// const MAX_RETRIES = 5;
/**
 * @internal
 */
let Session = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _connection_decorators;
    let _connection_initializers = [];
    let _connection_extraInitializers = [];
    let _dispose_decorators;
    let _send_decorators;
    let _subscribe_decorators;
    let _addIntercepts_decorators;
    let _end_decorators;
    return class Session extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _connection_decorators, { kind: "accessor", name: "connection", static: false, private: false, access: { has: obj => "connection" in obj, get: obj => obj.connection, set: (obj, value) => { obj.connection = value; } }, metadata: _metadata }, _connection_initializers, _connection_extraInitializers);
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _send_decorators, { kind: "method", name: "send", static: false, private: false, access: { has: obj => "send" in obj, get: obj => obj.send }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _subscribe_decorators, { kind: "method", name: "subscribe", static: false, private: false, access: { has: obj => "subscribe" in obj, get: obj => obj.subscribe }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _addIntercepts_decorators, { kind: "method", name: "addIntercepts", static: false, private: false, access: { has: obj => "addIntercepts" in obj, get: obj => obj.addIntercepts }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _end_decorators, { kind: "method", name: "end", static: false, private: false, access: { has: obj => "end" in obj, get: obj => obj.end }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static async from(connection, capabilities) {
            // Wait until the session is ready.
            //
            // TODO: Once Chrome supports session.status properly, uncomment this block
            // and remove `getBiDiConnection` in BrowserConnector.
            // let status = {message: '', ready: false};
            // for (let i = 0; i < MAX_RETRIES; ++i) {
            //   status = (await connection.send('session.status', {})).result;
            //   if (status.ready) {
            //     break;
            //   }
            //   // Backoff a little bit each time.
            //   await new Promise(resolve => {
            //     return setTimeout(resolve, (1 << i) * 100);
            //   });
            // }
            // if (!status.ready) {
            //   throw new Error(status.message);
            // }
            const { result } = await connection.send('session.new', {
                capabilities,
            });
            const session = new Session(connection, result);
            await session.#initialize();
            return session;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        #info;
        browser;
        #connection_accessor_storage = __runInitializers(this, _connection_initializers, void 0);
        get connection() { return this.#connection_accessor_storage; }
        set connection(value) { this.#connection_accessor_storage = value; }
        constructor(connection, info) {
            super();
            __runInitializers(this, _connection_extraInitializers);
            this.#info = info;
            this.connection = connection;
        }
        async #initialize() {
            // SAFETY: We use `any` to allow assignment of the readonly property.
            this.browser = await _Browser_js__WEBPACK_IMPORTED_MODULE_3__.Browser.from(this);
            const browserEmitter = this.#disposables.use(this.browser);
            browserEmitter.once('closed', ({ reason }) => {
                this.dispose(reason);
            });
            // TODO: Currently, some implementations do not emit navigationStarted event
            // for fragment navigations (as per spec) and some do. This could emits a
            // synthetic navigationStarted to work around this inconsistency.
            const seen = new WeakSet();
            this.on('browsingContext.fragmentNavigated', info => {
                if (seen.has(info)) {
                    return;
                }
                seen.add(info);
                this.emit('browsingContext.navigationStarted', info);
                this.emit('browsingContext.fragmentNavigated', info);
            });
        }
        get capabilities() {
            return this.#info.capabilities;
        }
        get disposed() {
            return this.ended;
        }
        get ended() {
            return this.#reason !== undefined;
        }
        get id() {
            return this.#info.sessionId;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        /**
         * Currently, there is a 1:1 relationship between the session and the
         * session. In the future, we might support multiple sessions and in that
         * case we always needs to make sure that the session for the right session
         * object is used, so we implement this method here, although it's not defined
         * in the spec.
         */
        async send(method, params) {
            return await this.connection.send(method, params);
        }
        async subscribe(events, contexts) {
            await this.send('session.subscribe', {
                events,
                contexts,
            });
        }
        async addIntercepts(events, contexts) {
            await this.send('session.subscribe', {
                events,
                contexts,
            });
        }
        async end() {
            try {
                await this.send('session.end', {});
            }
            finally {
                this.dispose(`Session already ended.`);
            }
        }
        [(_connection_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.bubble)()], _dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _send_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _subscribe_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _addIntercepts_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _end_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(session => {
                // SAFETY: By definition of `disposed`, `#reason` is defined.
                return session.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'Session already destroyed, probably because the connection broke.';
            this.emit('ended', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=Session.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js":
/*!********************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserContext.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UserContext: () => (/* binding */ UserContext)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/assert.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/* harmony import */ var _BrowsingContext_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BrowsingContext.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/BrowsingContext.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};





/**
 * @internal
 */
let UserContext = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _createBrowsingContext_decorators;
    let _remove_decorators;
    let _getCookies_decorators;
    let _setCookie_decorators;
    let _setPermissions_decorators;
    return class UserContext extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _createBrowsingContext_decorators, { kind: "method", name: "createBrowsingContext", static: false, private: false, access: { has: obj => "createBrowsingContext" in obj, get: obj => obj.createBrowsingContext }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _remove_decorators, { kind: "method", name: "remove", static: false, private: false, access: { has: obj => "remove" in obj, get: obj => obj.remove }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getCookies_decorators, { kind: "method", name: "getCookies", static: false, private: false, access: { has: obj => "getCookies" in obj, get: obj => obj.getCookies }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setCookie_decorators, { kind: "method", name: "setCookie", static: false, private: false, access: { has: obj => "setCookie" in obj, get: obj => obj.setCookie }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _setPermissions_decorators, { kind: "method", name: "setPermissions", static: false, private: false, access: { has: obj => "setPermissions" in obj, get: obj => obj.setPermissions }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static DEFAULT = 'default';
        static create(browser, id) {
            const context = new UserContext(browser, id);
            context.#initialize();
            return context;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        // Note these are only top-level contexts.
        #browsingContexts = new Map();
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.DisposableStack();
        #id;
        browser;
        constructor(browser, id) {
            super();
            this.#id = id;
            this.browser = browser;
        }
        #initialize() {
            const browserEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browser));
            browserEmitter.once('closed', ({ reason }) => {
                this.dispose(`User context already closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.contextCreated', info => {
                if (info.parent) {
                    return;
                }
                if (info.userContext !== this.#id) {
                    return;
                }
                const browsingContext = _BrowsingContext_js__WEBPACK_IMPORTED_MODULE_4__.BrowsingContext.from(this, undefined, info.context, info.url, info.originalOpener);
                this.#browsingContexts.set(browsingContext.id, browsingContext);
                const browsingContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(browsingContext));
                browsingContextEmitter.on('closed', () => {
                    browsingContextEmitter.removeAllListeners();
                    this.#browsingContexts.delete(browsingContext.id);
                });
                this.emit('browsingcontext', { browsingContext });
            });
        }
        get #session() {
            return this.browser.session;
        }
        get browsingContexts() {
            return this.#browsingContexts.values();
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get id() {
            return this.#id;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol]();
        }
        async createBrowsingContext(type, options = {}) {
            const { result: { context: contextId }, } = await this.#session.send('browsingContext.create', {
                type,
                ...options,
                referenceContext: options.referenceContext?.id,
                userContext: this.#id,
            });
            const browsingContext = this.#browsingContexts.get(contextId);
            (0,_util_assert_js__WEBPACK_IMPORTED_MODULE_1__.assert)(browsingContext, 'The WebDriver BiDi implementation is failing to create a browsing context correctly.');
            // We use an array to avoid the promise from being awaited.
            return browsingContext;
        }
        async remove() {
            try {
                await this.#session.send('browser.removeUserContext', {
                    userContext: this.#id,
                });
            }
            finally {
                this.dispose('User context already closed.');
            }
        }
        async getCookies(options = {}, sourceOrigin = undefined) {
            const { result: { cookies }, } = await this.#session.send('storage.getCookies', {
                ...options,
                partition: {
                    type: 'storageKey',
                    userContext: this.#id,
                    sourceOrigin,
                },
            });
            return cookies;
        }
        async setCookie(cookie, sourceOrigin) {
            await this.#session.send('storage.setCookie', {
                cookie,
                partition: {
                    type: 'storageKey',
                    sourceOrigin,
                    userContext: this.id,
                },
            });
        }
        async setPermissions(origin, descriptor, state) {
            await this.#session.send('permissions.setPermission', {
                origin,
                descriptor,
                state,
                userContext: this.#id,
            });
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.inertIfDisposed], _createBrowsingContext_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _remove_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _getCookies_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setCookie_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _setPermissions_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_2__.throwIfDisposed)(context => {
                // SAFETY: Disposal implies this exists.
                return context.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol)]() {
            this.#reason ??=
                'User context already closed, probably because the browser disconnected/closed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_3__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=UserContext.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/core/UserPrompt.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UserPrompt: () => (/* binding */ UserPrompt)
/* harmony export */ });
/* harmony import */ var _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../common/EventEmitter.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js");
/* harmony import */ var _util_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/decorators.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js");
/* harmony import */ var _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/disposable.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js");
/**
 * @license
 * Copyright 2024 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */
var __runInitializers = (undefined && undefined.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (undefined && undefined.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};



/**
 * @internal
 */
let UserPrompt = (() => {
    let _classSuper = _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter;
    let _instanceExtraInitializers = [];
    let _dispose_decorators;
    let _handle_decorators;
    return class UserPrompt extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate(this, null, _dispose_decorators, { kind: "method", name: "dispose", static: false, private: false, access: { has: obj => "dispose" in obj, get: obj => obj.dispose }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _handle_decorators, { kind: "method", name: "handle", static: false, private: false, access: { has: obj => "handle" in obj, get: obj => obj.handle }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static from(browsingContext, info) {
            const userPrompt = new UserPrompt(browsingContext, info);
            userPrompt.#initialize();
            return userPrompt;
        }
        #reason = __runInitializers(this, _instanceExtraInitializers);
        #result;
        #disposables = new _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.DisposableStack();
        browsingContext;
        info;
        constructor(context, info) {
            super();
            this.browsingContext = context;
            this.info = info;
        }
        #initialize() {
            const browserContextEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.browsingContext));
            browserContextEmitter.once('closed', ({ reason }) => {
                this.dispose(`User prompt already closed: ${reason}`);
            });
            const sessionEmitter = this.#disposables.use(new _common_EventEmitter_js__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(this.#session));
            sessionEmitter.on('browsingContext.userPromptClosed', parameters => {
                if (parameters.context !== this.browsingContext.id) {
                    return;
                }
                this.#result = parameters;
                this.emit('handled', parameters);
                this.dispose('User prompt already handled.');
            });
        }
        get #session() {
            return this.browsingContext.userContext.browser.session;
        }
        get closed() {
            return this.#reason !== undefined;
        }
        get disposed() {
            return this.closed;
        }
        get handled() {
            return this.#result !== undefined;
        }
        get result() {
            return this.#result;
        }
        dispose(reason) {
            this.#reason = reason;
            this[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
        async handle(options = {}) {
            await this.#session.send('browsingContext.handleUserPrompt', {
                ...options,
                context: this.info.context,
            });
            // SAFETY: `handled` is triggered before the above promise resolved.
            return this.#result;
        }
        [(_dispose_decorators = [_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.inertIfDisposed], _handle_decorators = [(0,_util_decorators_js__WEBPACK_IMPORTED_MODULE_1__.throwIfDisposed)(prompt => {
                // SAFETY: Disposal implies this exists.
                return prompt.#reason;
            })], _util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol)]() {
            this.#reason ??=
                'User prompt already closed, probably because the associated browsing context was destroyed.';
            this.emit('closed', { reason: this.#reason });
            this.#disposables.dispose();
            super[_util_disposable_js__WEBPACK_IMPORTED_MODULE_2__.disposeSymbol]();
        }
    };
})();

//# sourceMappingURL=UserPrompt.js.map

/***/ }),

/***/ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js":
/*!********************************************************************!*\
  !*** ./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEvaluationError: () => (/* binding */ createEvaluationError),
/* harmony export */   rewriteNavigationError: () => (/* binding */ rewriteNavigationError)
/* harmony export */ });
/* harmony import */ var _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Errors.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js");
/* harmony import */ var _common_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/util.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js");
/* harmony import */ var _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Deserializer.js */ "./node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js");
/**
 * @license
 * Copyright 2023 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */



/**
 * @internal
 */
function createEvaluationError(details) {
    if (details.exception.type !== 'error') {
        return _Deserializer_js__WEBPACK_IMPORTED_MODULE_2__.BidiDeserializer.deserialize(details.exception);
    }
    const [name = '', ...parts] = details.text.split(': ');
    const message = parts.join(': ');
    const error = new Error(message);
    error.name = name;
    // The first line is this function which we ignore.
    const stackLines = [];
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
        for (const frame of details.stackTrace.callFrames.reverse()) {
            if (_common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.isPuppeteerURL(frame.url) &&
                frame.url !== _common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.INTERNAL_URL) {
                const url = _common_util_js__WEBPACK_IMPORTED_MODULE_1__.PuppeteerURL.parse(frame.url);
                stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
            }
            else {
                stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
            }
            if (stackLines.length >= Error.stackTraceLimit) {
                break;
            }
        }
    }
    error.stack = [details.text, ...stackLines].join('\n');
    return error;
}
/**
 * @internal
 */
function rewriteNavigationError(message, ms) {
    return error => {
        if (error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__.ProtocolError) {
            error.message += ` at ${message}`;
        }
        else if (error instanceof _common_Errors_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError) {
            error.message = `Navigation timeout of ${ms} ms exceeded`;
        }
        throw error;
    };
}
//# sourceMappingURL=util.js.map

/***/ })

};
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcHVwcGV0ZWVyLWNvcmVfbGliX2VzbV9wdXBwZXRlZXJfYmlkaV9iaWRpX2pzLmNqcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQy9DLDhDQUE2QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUMzSCx3QkFBd0IsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDMUQsZ0RBQStDLEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2pJLDJCQUEyQixtQkFBTyxDQUFDLGdHQUFzQjtBQUN6RCxtREFBa0QsRUFBRSxxQ0FBcUMsZ0RBQWdELEVBQUM7QUFDMUk7Ozs7Ozs7Ozs7O0FDOUJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUMsdUdBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCLElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsSUFBSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixNQUFNO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGVBQWU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsV0FBVyxXQUFXLFlBQVk7QUFDaks7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixnQkFBZ0IsSUFBSSxlQUFlO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZLG1CQUFtQjtBQUNoRDtBQUNBLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwwSEFBMEgsc0JBQXNCO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCLHNDQUFzQztBQUNoRTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0NBQWdDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0EsMEJBQTBCLDBDQUEwQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEIsc0NBQXNDO0FBQ2hFO0FBQ0EsMEJBQTBCLHlEQUF5RDtBQUNuRjtBQUNBLDBCQUEwQixxREFBcUQ7QUFDL0U7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFO0FBQ0EsMEJBQTBCLGlEQUFpRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUNBQXFDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBCQUEwQixpREFBaUQ7QUFDM0U7QUFDQSwwQkFBMEIsaURBQWlEO0FBQzNFO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxtQkFBbUI7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixrRkFBa0Y7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLG9DQUFvQztBQUN0STtBQUNBO0FBQ0EscUdBQXFHLDBCQUEwQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxXQUFXO0FBQ3ZIO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLElBQUksb0NBQW9DO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSSxvQ0FBb0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU07QUFDbkY7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN3VDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtIQUErSCxLQUFLO0FBQ3BJO0FBQ0EsZ0lBQWdJLEtBQUs7QUFDckk7QUFDQSxrRkFBa0YsYUFBYTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixlQUFlO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsWUFBWTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7Ozs7Ozs7Ozs7QUNuTWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFVBQVU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7Ozs7Ozs7Ozs7QUNsR2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLHNGQUEwQjtBQUN0RCx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBOEI7QUFDOUQseUJBQXlCLG1CQUFPLENBQUMsc0dBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLGdHQUFlO0FBQzdDLDhCQUE4QixtQkFBTyxDQUFDLGdIQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5RkFBeUYsbUJBQW1CO0FBQzVHO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVSxVQUFVLFVBQVUsSUFBSSxVQUFVLElBQUksSUFBSTtBQUNoRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDLGdCQUFnQixxREFBcUQ7QUFDckUsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBc0Q7QUFDdEU7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdELGdCQUFnQixrSUFBa0k7QUFDbEosZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0Esc0dBQXNHLFFBQVEsT0FBTyxRQUFRO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdCQUFnQiwwSEFBMEg7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLHNHQUFzRyxRQUFRLE9BQU8sUUFBUTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySUFBMkksTUFBTSw2Q0FBNkMsTUFBTTtBQUNwTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hzQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqUmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QixpREFBaUQsSUFBSTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1DQUFtQyxpQkFBaUIsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxxQkFBcUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLFNBQVM7QUFDVCxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcHFCYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNsRCw0QkFBNEIsbUJBQU8sQ0FBQyw4R0FBcUI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsMEdBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOzs7Ozs7Ozs7OztBQ2pOYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLCtDQUErQztBQUMvQyxzREFBc0Q7QUFDdEQsK0NBQStDO0FBQy9DLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0Msa0VBQWtFO0FBQ2xFLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDBDQUEwQztBQUMxQywyQkFBMkIsbUJBQU8sQ0FBQywwR0FBb0M7QUFDdkUsb0JBQW9CLG1CQUFPLENBQUMsc0ZBQTBCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLDhGQUE4QjtBQUM5RDtBQUNBO0FBQ0Esa0JBQWtCLElBQUksRUFBRSxZQUFZLElBQUksbUJBQW1CO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixTQUFTO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdlFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCO0FBQzVCLHNCQUFzQixtQkFBTyxDQUFDLGdHQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qjs7Ozs7Ozs7Ozs7QUNyRGE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBK0I7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQXVCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtFQUFrRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RCxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1CQUFtQixTQUFTLEtBQUssU0FBUyxJQUFJLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOzs7Ozs7Ozs7OztBQ3hPYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLGtCQUFrQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNsRCwwQkFBMEIsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0Esd0JBQXdCO0FBQ3hCLHNCQUFzQixHQUFHLDBCQUEwQixPQUFPLGVBQWUsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7Ozs7Ozs7Ozs7O0FDN0hhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7Ozs7Ozs7Ozs7O0FDN0NhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBK0I7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQXVCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNsRCwwQkFBMEIsbUJBQU8sQ0FBQyx5R0FBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXLFVBQVUsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxhQUFhO0FBQ2pGO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtJQUFrSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrSEFBa0g7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbURBQW1ELGlDQUFpQztBQUNwRjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsaUNBQWlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5Q0FBeUMsSUFBSSx1Q0FBdUM7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiOzs7Ozs7Ozs7OztBQ3JkYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELHlCQUF5QixtQkFBTyxDQUFDLHVHQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usd0JBQXdCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7Ozs7Ozs7Ozs7QUM3RWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLDJHQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsMERBQTBELElBQUk7QUFDOUQ7QUFDQSx3RkFBd0YsR0FBRztBQUMzRjtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7Ozs7Ozs7Ozs7QUM3RmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUSxLQUFLLFdBQVcsS0FBSyxjQUFjO0FBQzNEO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBK0I7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsMkZBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsaUdBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsb0JBQW9CO0FBQzdGO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0EseUVBQXlFLG9CQUFvQix1REFBdUQsaUNBQWlDO0FBQ3JMO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7O0FDM0lhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLG1CQUFtQixtQkFBTyxDQUFDLDJGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7Ozs7Ozs7Ozs7O0FDckVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLHNCQUFzQixtQkFBTyxDQUFDLGdHQUErQjtBQUM3RCxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBMEI7QUFDdEQsd0JBQXdCLG1CQUFPLENBQUMsOEZBQThCO0FBQzlELDRCQUE0QixtQkFBTyxDQUFDLHNHQUFrQztBQUN0RSwwQkFBMEIsbUJBQU8sQ0FBQyxrR0FBZ0M7QUFDbEUsdUJBQXVCLG1CQUFPLENBQUMsNEZBQTZCO0FBQzVELDZCQUE2QixtQkFBTyxDQUFDLG9HQUEwQjtBQUMvRCxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBYTtBQUN6QyxpQ0FBaUMsbUJBQU8sQ0FBQyx3SEFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsa0JBQWtCO0FBQ3JHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7Ozs7Ozs7Ozs7QUN2TmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7Ozs7Ozs7Ozs7O0FDMURhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDhGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSx3Q0FBd0M7QUFDdkQsZUFBZSxpQkFBaUI7QUFDaEMsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE1BQU0sSUFBSSx3Q0FBd0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE1BQU0sSUFBSSx3Q0FBd0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE1BQU0sSUFBSSx3Q0FBd0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7Ozs7Ozs7Ozs7O0FDblFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxnR0FBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsc0JBQXNCLG1CQUFPLENBQUMsZ0dBQStCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLHNGQUEwQjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBdUI7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsMkhBQWdDO0FBQ3RFLDBCQUEwQixtQkFBTyxDQUFDLG1IQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCw2Q0FBNkM7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWEsSUFBSSxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDZEQUE2RDtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUksY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7Ozs7Ozs7Ozs7QUNsTWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0NBQStDLEdBQUcscUNBQXFDLEdBQUcsa0NBQWtDLEdBQUcsdUNBQXVDLEdBQUcscUNBQXFDLEdBQUcscUNBQXFDLEdBQUcsc0NBQXNDLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsa0NBQWtDLEdBQUcsa0NBQWtDLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsMkJBQTJCLEdBQUcsZ0NBQWdDLEdBQUcsbUNBQW1DLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsOEJBQThCLEdBQUcsNEJBQTRCLEdBQUcsc0NBQXNDLEdBQUcsaUNBQWlDLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsaUJBQWlCO0FBQ3ozQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7Ozs7Ozs7Ozs7QUN2S2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7Ozs7Ozs7Ozs7O0FDRmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsdUJBQXVCLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxrQkFBa0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkRBQTJEO0FBQ2hFLENBQUMsYUFBYSxjQUFjLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscURBQXFEO0FBQzFELENBQUMsVUFBVSxXQUFXLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkVBQTZFO0FBQ2xGLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkRBQTZEO0FBQ2xFLENBQUMsY0FBYyxlQUFlLGVBQWU7QUFDN0MsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1RmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDs7Ozs7Ozs7Ozs7QUNsQmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDs7Ozs7Ozs7Ozs7QUNsQmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVO0FBQzdDLG9CQUFvQixnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBb0I7QUFDaEUsYUFBYSxtQkFBTyxDQUFDLGdIQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsMEZBQW9CO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyx3SUFBMkM7QUFDaEU7Ozs7Ozs7Ozs7O0FDbERhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7Ozs7Ozs7Ozs7QUM5Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7Ozs7Ozs7Ozs7O0FDdkNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7Ozs7Ozs7OztBQ3RFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekRhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsK0NBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7Ozs7Ozs7Ozs7O0FDekVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlCQUF5QjtBQUMxRTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOzs7Ozs7Ozs7OztBQ2pDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7Ozs7Ozs7Ozs7QUNuRWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkM7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7OztBQ2hFYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyx5RUFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsSUFBSSxrQkFBa0I7QUFDdEI7QUFDQTs7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWMsZUFBZSxlQUFlO0FBQzdDOzs7Ozs7Ozs7OztBQzdCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RhLDRCQUE0Qix1Q0FBdUMsa0NBQWtDLHVDQUF1QyxlQUFlLHNCQUFzQix1QkFBdUIsRUFBRSxnQkFBZ0IsK0ZBQStGLG1EQUFtRCxFQUFFLFVBQVUsaUJBQWlCLGVBQWUsU0FBUyxLQUFLLFVBQVUsT0FBTyxpQkFBaUIsRUFBRSxzQkFBc0IsWUFBWSxPQUFPLFFBQVEsVUFBVSxTQUFTLFVBQVUsV0FBVyx5QkFBeUIsaUZBQWlGLGdCQUFnQixtREFBbUQsV0FBVyxTQUFTLDBCQUEwQixZQUFZLFdBQVcsaUJBQWlCLG9EQUFvRCxtQkFBbUIsYUFBYSxLQUFLLFdBQVcsRUFBRSx5QkFBeUIsNkJBQTZCLFFBQVEseUNBQXlDLEdBQUcsWUFBWSxRQUFRLHFDQUFxQyxFQUFFLFNBQVMscUJBQXFCLFFBQVEsMkNBQTJDLEVBQUUsU0FBUyxhQUFhLFFBQVEsMkNBQTJDLEVBQUUsU0FBUyxTQUFTLEdBQUcsUUFBUSxpQ0FBaUMsRUFBRSxTQUFTLFNBQVMsR0FBRyxRQUFRLGtDQUFrQyxFQUFFLFNBQVMsWUFBWSxlQUFlLEtBQUssV0FBVyxFQUFFLG9CQUFvQiw2Q0FBNkMsVUFBVSxTQUFTLE1BQU0sT0FBTywrQkFBK0IsRUFBRSxHQUFHLFNBQVMsUUFBUSw0QkFBNEIsTUFBTSxTQUFTLFlBQVksd0JBQXdCLGVBQWUsc0NBQXNDLEVBQUUsR0FBRyxTQUFTLEtBQUssV0FBVyxFQUFFLGlCQUFpQix3QkFBd0IsS0FBSyxPQUFPLEVBQUUsU0FBUyxNQUFNLGdCQUFnQixpQkFBaUIsU0FBUyxlQUFlLGNBQWMsSUFBSSxPQUFPLHdDQUF3Qyx5Q0FBeUMsRUFBRSxRQUFRLE1BQU0sVUFBVSxjQUFjLE1BQU0sMkJBQTJCLEVBQUUsR0FBRyxTQUFTLE9BQU8sd0JBQXdCLEVBQUUsR0FBRyxTQUFTLFFBQVEsNkJBQTZCLE1BQU0sU0FBUyxRQUFRLGlDQUFpQyxFQUFFLGVBQWUsNEJBQTRCLElBQUksaUJBQWlCLEVBQUUsV0FBVyxzQ0FBc0MsV0FBVyxlQUFlLHVDQUF1QyxpREFBaUQsZ0RBQWdELFdBQVcsdUJBQXVCLElBQUksZUFBZSxNQUFNLGtDQUFrQyxHQUFHLEtBQUssRUFBRSxhQUFhLEVBQUUsR0FBRyxRQUFRLFdBQVcsS0FBSywrQkFBK0IsTUFBTSxTQUFTLHVDQUF1QyxLQUFLLFFBQVEsa0RBQWtELGlCQUFpQixRQUFRLFVBQVUsWUFBWSxNQUFNLFlBQVksTUFBTSxZQUFZLE1BQU0sa0JBQWtCLEtBQUssT0FBTyxlQUFlLGFBQWEsaUNBQWlDLE9BQU8sTUFBTSxzQkFBc0IsUUFBUSxtQ0FBbUMsTUFBTSxvRUFBb0UsRUFBRSxLQUFLLDJDQUEyQyxLQUFLLFdBQVcsRUFBRSx5Q0FBeUMsbUNBQW1DLFlBQVksNENBQTRDLFVBQVUsY0FBYyxTQUFTLDJCQUEyQixNQUFNLEtBQUssU0FBUyxjQUFjLG1DQUFtQywwQkFBMEIsVUFBVSxXQUFXLFdBQVcsY0FBYyxTQUFTLGFBQWEsU0FBUyxjQUFjLDRCQUE0QixzQkFBc0IsY0FBYyxnQ0FBZ0Msa0JBQWtCLHFCQUFxQixjQUFjLFVBQVUsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLG1CQUFtQixFQUFFLDJHQUEyRyxxQkFBcUIsZ0JBQWdCLGVBQWUsc0NBQXNDLFdBQVcsR0FBRyxjQUFjLEVBQUUsU0FBUyxrQkFBa0IsV0FBVyxlQUFlLGVBQWUsd0VBQXdFLHNDQUFzQyxFQUFFLEdBQUcsY0FBYyxZQUFZLEVBQUUsR0FBRyxjQUFjLEdBQUcsU0FBUyxtQ0FBbUMsU0FBUyxZQUFZLEdBQUcsRUFBRSxHQUFHLFlBQVksb0JBQW9CLFNBQVMsU0FBUyxZQUFZLFlBQVksRUFBRSw2Q0FBNkMsRUFBRSxNQUFNLFlBQVksNEJBQTRCLFVBQVUsY0FBYyxXQUFXLGVBQWUsR0FBRyxpQ0FBaUMsRUFBRSwrQkFBK0IsRUFBRSw2QkFBNkIsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLE1BQU0sU0FBUyxhQUFhLG9CQUFvQiwwREFBMEQsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixPQUFPLGdEQUFnRCxJQUFJLGlEQUFpRCxJQUFJLG1EQUFtRCxpQkFBaUIscUVBQXFFLGlCQUFpQixpQkFBaUIsd0RBQXdELGlCQUFpQixxREFBcUQsY0FBYywyREFBMkQsZUFBZSxnREFBZ0QsY0FBYyxlQUFlLHNDQUFzQyxTQUFTLGlCQUFpQixrQ0FBa0MscUNBQXFDLDREQUE0RCxpQkFBaUIsa0NBQWtDLHFDQUFxQyxvRUFBb0UsaUJBQWlCLGtDQUFrQyxpQkFBaUIsc0JBQXNCLHFDQUFxQywrQkFBK0IsaUJBQWlCLHNCQUFzQixxQ0FBcUMsK0JBQStCLG1CQUFtQixzQkFBc0Isd0NBQXdDLEVBQUUsR0FBRyxFQUFFLFlBQVksZ0JBQWdCLDZGQUE2RixtQkFBbUIseUNBQXlDLGlCQUFpQixvQ0FBb0MsY0FBYyxVQUFVLCtCQUErQixrQ0FBa0MscUJBQXFCLGtCQUFrQixjQUFjLG1CQUFtQixzREFBc0QseUNBQXlDLEVBQUUsS0FBSyxlQUFlLG1CQUFtQixxQ0FBcUMsK0JBQStCLGVBQWUsbUJBQW1CLHFDQUFxQywrQkFBK0IsY0FBYyxtQkFBbUIsZ0ZBQWdGLEVBQUUsSUFBSSxxQ0FBcUMsK0JBQStCLGNBQWMsbUJBQW1CLDZFQUE2RSxFQUFFLElBQUksdUJBQXVCLGNBQWMsMkRBQTJELHFDQUFxQyxFQUFFLEtBQUssZUFBZSxtQkFBbUIscUNBQXFDLHNHQUFzRyxlQUFlLGdDQUFnQyxFQUFFLFlBQVksZUFBZSxtQkFBbUIscUNBQXFDLHdEQUF3RCxlQUFlLG1CQUFtQixxQ0FBcUMsa0RBQWtELFlBQVksR0FBRyxNQUFNLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxlQUFlLFVBQVUsYUFBYSxlQUFlLFFBQVEsMEJBQTBCLHVCQUF1QixrQkFBa0IsNENBQTRDLGdCQUFnQixxRUFBcUUsU0FBUyxxQkFBcUIsV0FBVyxTQUFTLGNBQWMsTUFBTSxxQ0FBcUMsY0FBYyxjQUFjLFdBQVcsU0FBUyxnQkFBZ0IsNkJBQTZCLE1BQU0scUJBQXFCLFVBQVUsWUFBWSxnREFBZ0QsTUFBTSwwRUFBMEUsTUFBTSxzREFBc0QsTUFBTSwrQkFBK0IsTUFBTSwySkFBMkosTUFBTSw2RUFBNkUsTUFBTSxzREFBc0QsTUFBTSwrQkFBK0IsTUFBTSxhQUFhLGVBQWUsb0VBQW9FLFFBQVEsZ0JBQWdCLGFBQWEsa0NBQWtDLE1BQU0sYUFBYSxrQ0FBa0MsTUFBTSxrQ0FBa0MsTUFBTSxrQ0FBa0MsTUFBTSw4QkFBOEIsTUFBTSxrQ0FBa0MsTUFBTSxnQ0FBZ0MsTUFBTSw4QkFBOEIsTUFBTSxjQUFjLHdRQUF3USxRQUFRLGlEQUFpRCxLQUFLLDBCQUEwQixNQUFNLG9CQUFvQixNQUFNLHVGQUF1RixRQUFRLGlCQUFpQix3RkFBd0YsS0FBSyw0QkFBNEIsS0FBSyxzREFBc0QsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyxpQ0FBaUMseUNBQXlDLHlCQUF5QixnRkFBZ0YsS0FBSyw0QkFBNEIsS0FBSyxxQ0FBcUMsS0FBSyxzQ0FBc0MsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyxnREFBZ0Qsb0NBQW9DLEtBQUssU0FBUyxrQ0FBa0MsNEJBQTRCLGVBQWUsNEZBQTRGLGlCQUFpQixrRkFBa0YsbUJBQW1CLE9BQU8sOFFBQThRLGdCQUFnQixnQkFBZ0Isa0JBQWtCLE1BQU0sa0NBQWtDLGc2QkFBZzZCLE1BQU0sd0NBQXdDLFVBQVUsS0FBSyxzVUFBc1UsK0NBQStDLGtDQUFrQywrREFBK0QsdUNBQXVDLDZHQUE2RyxjQUFjLDBCQUEwQixpQkFBaUIsZUFBZSw0QkFBNEIsc0JBQXNCLGlCQUFpQiwyR0FBMkcsa0JBQWtCLGdCQUFnQiwwQkFBMEIsWUFBWSxTQUFTLFlBQVksV0FBVyxLQUFLLFdBQVcsZUFBZSxtQkFBbUIsY0FBYyxTQUFTLEtBQUssRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLFNBQVMsbUtBQW1LLDJGQUEyRixxQ0FBcUMsWUFBWSwwQkFBMEIsd0NBQXdDLGdDQUFnQyx5QkFBeUIsU0FBUyw2QkFBNkIsT0FBTyxxQkFBcUIsUUFBUSx5QkFBeUIsRUFBRSxzRkFBc0YsRUFBRSwyRkFBMkYsc0NBQXNDLFNBQVMsWUFBWSxHQUFHLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxnQkFBZ0IsTUFBTSxJQUFJLE1BQU0sa0RBQWtELGVBQWUsc0pBQXNKLFlBQVksS0FBSyx1SEFBdUgsaUVBQWlFLGtCQUFrQixjQUFjLEVBQUUsT0FBTyw2QkFBNkIsSUFBSSwrRUFBK0Usd0VBQXdFLE1BQU0sWUFBWSw0QkFBNEIsUUFBUSxjQUFjLHdCQUF3QixpREFBaUQsTUFBTSxrREFBa0QsTUFBTSxrREFBa0QsTUFBTSxxRUFBcUUsTUFBTSw2Q0FBNkMsTUFBTSxpSEFBaUgsTUFBTSxrREFBa0QsTUFBTSxnREFBZ0QsTUFBTSxJQUFJLG9JQUFvSSxNQUFNLCtCQUErQixHQUFHLFdBQVcsV0FBVyxPQUFPLFNBQVMseURBQXlELFVBQVUsSUFBSSxTQUFTLElBQUksT0FBTyx1RkFBdUYscUZBQXFGLHlCQUF5QixJQUFJLGlEQUFpRCxNQUFNLFNBQVMsTUFBTSw4Q0FBOEMsU0FBUyxTQUFTLElBQUksT0FBTyx1RkFBdUYscUZBQXFGLHVCQUF1QixJQUFJLGlEQUFpRCxNQUFNLFlBQVksU0FBUyw4QkFBOEIsTUFBTSxZQUFZLDRCQUE0QixrQkFBa0IsU0FBUywrRUFBK0UsYUFBYSxPQUFPLE1BQU0seUJBQXlCLFNBQVMsK0JBQStCLGNBQWMsMkRBQTJELHNCQUFzQix3QkFBd0IsU0FBUyxTQUFTLDZEQUE2RCxRQUFRLEtBQUssOEJBQThCLEtBQUssbUJBQW1CLGNBQWMsaURBQWlELGdIQUFnSCxlQUFlLHdCQUF3QixlQUFlLHdCQUF3QixlQUFlLHdCQUF3QixlQUFlLHdCQUF3QixXQUFXLG9CQUFvQixlQUFlLHdCQUF3QixhQUFhLHNCQUFzQixXQUFXLG9CQUFvQixzQkFBc0I7Ozs7Ozs7Ozs7O0FDQWwvaEIsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxxRkFBdUI7O0FBRXRELG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDTkEsNkJBQWUsb0NBQVMsR0FBRyxPQUFPLGtDQUFrQyxlQUFlLHlCQUF5QixtQkFBbUIsZUFBZSxnREFBZ0Qsb0JBQW9CLGVBQWUsNkJBQTZCLEtBQUssNENBQTRDLE9BQU87QUFDdFQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RTtBQUNsQztBQUNZO0FBQ047QUFDakQ7QUFDQSxJQUFJLHVEQUFLLFNBQVMsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUNBQW1DLDBEQUFjO0FBQ2pELDZCQUE2QixzRkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsR0FBRztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0ZBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrREFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0ZBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBSSxJQUFJLFNBQUk7QUFDaEMseUJBQXlCLHVGQUF1RjtBQUNoSDtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxnREFBZ0QseUZBQXlGO0FBQ3pJLGdFQUFnRSwyQ0FBMkM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQUksSUFBSSxTQUFJO0FBQ3JDO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFJLElBQUksU0FBSTtBQUNyQztBQUNBLDhDQUE4Qyx5RUFBeUU7QUFDdkg7QUFDNkM7QUFDWTtBQUNWO0FBQ0E7QUFDVTtBQUNiO0FBQ0k7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkRBQU07QUFDeEQsc0VBQXNFLHFDQUFxQywrQ0FBK0MsdUVBQXVFLGdEQUFnRCw2QkFBNkIsd0NBQXdDLG1GQUFtRiw0RkFBNEYsZ0NBQWdDLHVCQUF1QjtBQUM1akIsMEVBQTBFLHdFQUF3RTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLGlFQUFZO0FBQ3pILGdDQUFnQztBQUNoQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtFQUFrQjtBQUNyRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixHQUFHLHFCQUFxQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNzQjtBQUN2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFJLElBQUksU0FBSTtBQUNoQyx5QkFBeUIsdUZBQXVGO0FBQ2hIO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLGdEQUFnRCx5RkFBeUY7QUFDekksZ0VBQWdFLDJDQUEyQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBSSxJQUFJLFNBQUk7QUFDckM7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQUksSUFBSSxTQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBOEM7QUFDdkU7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFJLElBQUksU0FBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixTQUFTLGdCQUFnQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDeUU7QUFDaEI7QUFDRDtBQUNWO0FBQ0E7QUFDSztBQUNmO0FBQ1U7QUFDZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkRBQU07QUFDaEQsbUVBQW1FLG1GQUFtRiw0RkFBNEYsK0JBQStCLHVCQUF1QjtBQUN4UywwRUFBMEUsd0VBQXdFO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxpRUFBWTtBQUNqSCwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQ0FBbUMsc0RBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQWU7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsd0RBQWdCO0FBQ25EO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMsNkRBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtGQUFxQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix5Q0FBeUMsa0ZBQXFDO0FBQzlFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVEQUFVO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDJCQUEyQix1REFBVTtBQUNyQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkRBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDNkI7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZUa0Q7QUFDMkI7QUFDOUI7QUFDL0M7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLDBEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUVBQW9CO0FBQzFDO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQWdCLG9CQUFvQixPQUFPO0FBQ2pFO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lFO0FBQ3RCO0FBQ2M7QUFDVjtBQUNKO0FBQ007QUFDakQsMEJBQTBCLHVEQUFLO0FBQy9CLDZCQUE2Qix1REFBSztBQUNsQztBQUNBO0FBQ0E7QUFDTyw2QkFBNkIsaUVBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5RUFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYSxJQUFJLGVBQWU7QUFDdEg7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxRQUFRO0FBQ2xIO0FBQ0EsUUFBUSwyREFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjLEVBQUUsZUFBZTtBQUNwRDtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMrQztBQUMvQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZLDJEQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFVLDRCQUE0QixhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQztBQUNuQyx5QkFBeUIsa0RBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQUksSUFBSSxTQUFJO0FBQ3JDO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFJLElBQUksU0FBSTtBQUNoQyx5QkFBeUIsdUZBQXVGO0FBQ2hIO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLGdEQUFnRCx5RkFBeUY7QUFDekksZ0VBQWdFLDJDQUEyQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBSSxJQUFJLFNBQUk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhDQUE4QztBQUN2RTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQUksSUFBSSxTQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFNBQVMsZ0JBQWdCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUN1RDtBQUNTO0FBQ1Q7QUFDWDtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBZTtBQUNuRCx3Q0FBd0Msb0VBQWUsVUFBVSxnRUFBYTtBQUM5RSw2REFBNkQsMkVBQTJFLHlEQUF5RCx1QkFBdUI7QUFDeE4saUVBQWlFLCtFQUErRSxpRUFBaUUsdUJBQXVCO0FBQ3hPLDBFQUEwRSx3RUFBd0U7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4R0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLDBCQUEwQix5RUFBaUI7QUFDM0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQztBQUM0QjtBQUM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQUksSUFBSSxTQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBOEM7QUFDdkU7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFJLElBQUksU0FBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixTQUFTLGdCQUFnQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDa0U7QUFDVjtBQUNWO0FBQ1M7QUFDcUI7QUFDdEI7QUFDVjtBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0IsdUJBQXVCLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDREQUE0RCxpRUFBWTtBQUN4RSw2QkFBNkIsb0ZBQWlCO0FBQzlDLG9DQUFvQyxvRUFBaUIsQ0FBQyxzRUFBbUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTLElBQUksaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVU7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsc0RBQVk7QUFDMUU7QUFDQTtBQUNBLGFBQWE7QUFDYiw2REFBNkQsZ0VBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0VBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1REFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyREFBVTtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBSSxJQUFJLFNBQUk7QUFDckM7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQUksSUFBSSxTQUFJO0FBQ2hDLHlCQUF5Qix1RkFBdUY7QUFDaEg7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsZ0RBQWdELHlGQUF5RjtBQUN6SSxnRUFBZ0UsMkNBQTJDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFJLElBQUksU0FBSTtBQUNyQztBQUNBLDhDQUE4Qyx5RUFBeUU7QUFDdkg7QUFDbUU7QUFDNEU7QUFDckY7QUFDRjtBQUNNO0FBQ2U7QUFDSDtBQUN2QjtBQUNGO0FBQ0k7QUFDWjtBQUNpQjtBQUNHO0FBQ2hCO0FBQ0Q7QUFDTztBQUNKO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQWU7QUFDL0Msc0NBQXNDLDBEQUFlO0FBQ3JELDZDQUE2QywwREFBZTtBQUM1RCxnREFBZ0QsMERBQWU7QUFDL0QsdURBQXVELDBEQUFlO0FBQ3RFLG9DQUFvQywwREFBZTtBQUNuRCx1Q0FBdUMsMERBQWU7QUFDdEQseURBQXlELHVFQUF1RSxpREFBaUQsdUJBQXVCO0FBQ3hNLCtEQUErRCw2RUFBNkUsNkRBQTZELHVCQUF1QjtBQUNoTyxzRUFBc0Usb0ZBQW9GLDJFQUEyRSx1QkFBdUI7QUFDNVAsb0VBQW9FLCtDQUErQztBQUNuSCwwQkFBMEIscUJBQXFCO0FBQy9DLDRCQUE0Qix5REFBeUQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBRTtBQUNqQztBQUNBLDJCQUEyQix3RUFBYTtBQUN4QywrQkFBK0IsaUVBQWdCO0FBQy9DLHFCQUFxQixRQUFRLDhEQUFHLFVBQVUsR0FBRyxnRUFBSyxJQUFJLG1FQUFRLENBQUMsd0RBQU8sNkJBQTZCLDhEQUFHO0FBQ3RHO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQixvQkFBb0Isc0NBQXNDLCtFQUErRSxpRUFBaUUsdUJBQXVCO0FBQ2xQLDJFQUEyRSwrQ0FBK0M7QUFDMUgsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZEQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLDJCQUEyQiw2Q0FBNkMsc0ZBQXNGLCtFQUErRSx1QkFBdUI7QUFDclIsNkRBQTZELDJFQUEyRSx5REFBeUQsdUJBQXVCO0FBQ3hOLGdFQUFnRSw4RUFBOEUsK0RBQStELHVCQUF1QjtBQUNwTywwRUFBMEUsd0VBQXdFO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwREFBYztBQUM1QztBQUNBLHlCQUF5QixzREFBYztBQUN2QywwQkFBMEIsc0RBQWMscUVBQXFFLGlDQUFpQztBQUM5STtBQUNBLHFDQUFxQyxnRUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRTtBQUNBLGFBQWE7QUFDYjtBQUNBLHNDQUFzQywwREFBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtEQUFrRCxTQUFTO0FBQzNELG9DQUFvQyw2REFBZTtBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IscURBQXFELFlBQVk7QUFDakU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxREFBcUQsWUFBWTtBQUNqRSxpRkFBaUYsbURBQVU7QUFDM0YsYUFBYTtBQUNiLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkRBQTJELHVEQUFZO0FBQ3ZFLDhCQUE4Qiw4REFBZ0I7QUFDOUM7QUFDQSxrQ0FBa0MsT0FBTyxFQUFFLFlBQVk7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0EsMkZBQTJGLHFFQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUMsR0FBRyxVQUFVLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyREFBVSxrQ0FBa0MsV0FBVyxXQUFXLFdBQVcsZUFBZSxZQUFZO0FBQzVIO0FBQ0EsYUFBYTtBQUNiLGlEQUFpRCxPQUFPO0FBQ3hELCtCQUErQix5REFBYTtBQUM1QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1CQUFtQixnRUFBSztBQUN4QjtBQUNBLDJCQUEyQiw2REFBRTtBQUM3QjtBQUNBLHVCQUF1QixpRUFBZ0IsaUZBQWlGLGlFQUFNO0FBQzlIO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCLGlFQUFzQjtBQUMzQztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQWMsQ0FBQyx3RUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLG9CQUFvQix5REFBeUQ7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYix5QkFBeUIseUVBQWMsQ0FBQyx3RUFBYTtBQUNyRCxnQkFBZ0IsaUVBQWdCLDBDQUEwQyxvRUFBUyxJQUFJLFlBQVk7QUFDbkcsNERBQTRELG9FQUFTO0FBQ3JFO0FBQ0EsbUNBQW1DLDZEQUFFO0FBQ3JDO0FBQ0EsK0JBQStCLHdFQUFhO0FBQzVDLHFCQUFxQixHQUFHLG1FQUFRLENBQUMsaUVBQWdCLDBCQUEwQixpRUFBZ0Isd0JBQXdCLGlFQUFnQiw2QkFBNkIsOERBQUcsSUFBSSxLQUFLO0FBQzVLLCtEQUErRCxJQUFJO0FBQ25FLHFCQUFxQixLQUFLLG9FQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2REFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpRUFBZ0I7QUFDdkQsMENBQTBDLG1FQUFRLENBQUMsaUVBQWdCLHFCQUFxQixtRUFBUSxDQUFDLGlFQUFnQjtBQUNqSCwwQ0FBMEMsb0VBQVM7QUFDbkQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZEQUFFO0FBQ2pDLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSxvQkFBb0IsOERBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzREFBUTtBQUM1QztBQUNBLGFBQWEsR0FBRyxtRUFBUSxDQUFDLHdEQUFPLDZCQUE2Qiw4REFBRztBQUNoRSwwQkFBMEIsK0RBQWdCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxLQUFLLGdCQUFnQixLQUFLO0FBQ2xHO0FBQ0EscUNBQXFDLG9FQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUssWUFBWSxLQUFLO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiLGtEQUFrRCxvRkFBaUI7QUFDbkUsdUJBQXVCLDBEQUFjO0FBQ3JDO0FBQ0EsOEJBQThCO0FBQzlCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzY0E7QUFDZ0Y7QUFDckI7QUFDTjtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNPLDhCQUE4Qiw0REFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkIsOERBQWdCO0FBQzdDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtRUFBb0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixtRUFBb0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixtRUFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUIsZ0VBQVc7QUFDOUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xQQSx5QkFBeUIsU0FBSSxJQUFJLFNBQUk7QUFDckM7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQUksSUFBSSxTQUFJO0FBQ2hDLHlCQUF5Qix1RkFBdUY7QUFDaEg7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsZ0RBQWdELHlGQUF5RjtBQUN6SSxnRUFBZ0UsMkNBQTJDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUNLO0FBQ1U7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOERBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2RUFBNEI7QUFDckUsa0VBQWtFLGdGQUFnRixtRUFBbUUsdUJBQXVCO0FBQzVPLDBFQUEwRSx3RUFBd0U7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFvQjtBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLG1FQUFvQjtBQUMxQztBQUNBO0FBQ0EsQ0FBQztBQUMyQjtBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZFO0FBQ2xCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsYUFBYSxJQUFJLDhEQUFhO0FBQzlCO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0Esa0JBQWtCLDhEQUFhO0FBQy9CO0FBQ0E7QUFDQSxDQUFDO0FBQ3FCO0FBQ3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0U7QUFDakI7QUFDSTtBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZUFBZSw4REFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFZO0FBQzVCLDhCQUE4Qix5REFBWTtBQUMxQyw0QkFBNEIseURBQVk7QUFDeEMsNkNBQTZDLHdDQUF3QyxHQUFHLGtCQUFrQixLQUFLLGVBQWUsZ0JBQWdCLGlCQUFpQixHQUFHLG1CQUFtQjtBQUNyTDtBQUNBO0FBQ0EsMENBQTBDLHFDQUFxQyxHQUFHLFVBQVUsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDZCQUE2Qiw0REFBYTtBQUMxQyxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLGtDQUFrQywyREFBWTtBQUM5QyxxREFBcUQsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL0JpZGlNYXBwZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL0JpZGlOb09wUGFyc2VyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9CaWRpU2VydmVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9Db21tYW5kUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9PdXRnb2luZ01lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvYnJvd3Nlci9Ccm93c2VyUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2NkcC9DZHBQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvY2RwL0NkcFRhcmdldC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9jZHAvQ2RwVGFyZ2V0TWFuYWdlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9jb250ZXh0L0Jyb3dzaW5nQ29udGV4dEltcGwuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvY29udGV4dC9Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvY29udGV4dC9Ccm93c2luZ0NvbnRleHRTdG9yYWdlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2lucHV0L0FjdGlvbkRpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvaW5wdXQvSW5wdXRQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvaW5wdXQvSW5wdXRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvaW5wdXQvSW5wdXRTdGF0ZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9pbnB1dC9JbnB1dFN0YXRlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9pbnB1dC9VU0tleWJvYXJkTGF5b3V0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2lucHV0L2tleVV0aWxzLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2xvZy9Mb2dNYW5hZ2VyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL2xvZy9sb2dIZWxwZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvbmV0d29yay9OZXR3b3JrUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL25ldHdvcmsvTmV0d29ya1JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvbmV0d29yay9OZXR3b3JrU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9uZXR3b3JrL05ldHdvcmtVdGlscy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9wZXJtaXNzaW9ucy9QZXJtaXNzaW9uc1Byb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvQ2hhbm5lbFByb3h5LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3NjcmlwdC9QcmVsb2FkU2NyaXB0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3NjcmlwdC9QcmVsb2FkU2NyaXB0U3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvUmVhbG0uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L1JlYWxtU3RvcmFnZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvU2NyaXB0UHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3NjcmlwdC9TaGFyZWRJZC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zY3JpcHQvV2luZG93UmVhbG0uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2NyaXB0L1dvcmtlclJlYWxtLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3Nlc3Npb24vRXZlbnRNYW5hZ2VyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9tb2R1bGVzL3Nlc3Npb24vU2Vzc2lvblByb2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL2JpZGlNYXBwZXIvbW9kdWxlcy9zZXNzaW9uL1N1YnNjcmlwdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc2Vzc2lvbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9iaWRpTWFwcGVyL21vZHVsZXMvc3RvcmFnZS9TdG9yYWdlUHJvY2Vzc29yLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvcHJvdG9jb2wvRXJyb3JSZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3Byb3RvY29sL2NkcC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3Byb3RvY29sL2Nocm9taXVtLWJpZGkuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9nZW5lcmF0ZWQvd2ViZHJpdmVyLWJpZGktcGVybWlzc2lvbnMuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9nZW5lcmF0ZWQvd2ViZHJpdmVyLWJpZGkuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9wcm90b2NvbC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0Jhc2U2NC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0RlZmF1bHRNYXAuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nocm9taXVtLWJpZGkvbGliL2Nqcy91dGlscy9EZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0Rpc3RpbmN0VmFsdWVzLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvdXRpbHMvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvdXRpbHMvR3JhcGhlbWVUb29scy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL0lkV3JhcHBlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL011dGV4LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvdXRpbHMvUHJvY2Vzc2luZ1F1ZXVlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9jaHJvbWl1bS1iaWRpL2xpYi9janMvdXRpbHMvVXJsUGF0dGVybi5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL3VuaXRDb252ZXJzaW9ucy5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvY2hyb21pdW0tYmlkaS9saWIvY2pzL3V0aWxzL3V1aWQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3VybHBhdHRlcm4tcG9seWZpbGwvZGlzdC91cmxwYXR0ZXJuLmNqcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvdXJscGF0dGVybi1wb2x5ZmlsbC9pbmRleC5janMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0Lm1qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9CaWRpT3ZlckNkcC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9Ccm93c2VyLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0Jyb3dzZXJDb250ZXh0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0NEUFNlc3Npb24uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvQ29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9EZXNlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvRGlhbG9nLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0VsZW1lbnRIYW5kbGUuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvRXhwb3NlZEZ1bmN0aW9uLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0ZyYW1lLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0hUVFBSZXF1ZXN0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL0hUVFBSZXNwb25zZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9JbnB1dC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9KU0hhbmRsZS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9QYWdlLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL1JlYWxtLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL1NlcmlhbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvVGFyZ2V0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL1dlYldvcmtlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9iaWRpLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL2NvcmUvQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9jb3JlL0Jyb3dzaW5nQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9jb3JlL05hdmlnYXRpb24uanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9SZWFsbS5qcyIsIndlYnBhY2s6Ly9hZ2FtYS13ZWJwYWNrLXRlc3QvLi9ub2RlX21vZHVsZXMvcHVwcGV0ZWVyLWNvcmUvbGliL2VzbS9wdXBwZXRlZXIvYmlkaS9jb3JlL1JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9TZXNzaW9uLmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL2NvcmUvVXNlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vYWdhbWEtd2VicGFjay10ZXN0Ly4vbm9kZV9tb2R1bGVzL3B1cHBldGVlci1jb3JlL2xpYi9lc20vcHVwcGV0ZWVyL2JpZGkvY29yZS9Vc2VyUHJvbXB0LmpzIiwid2VicGFjazovL2FnYW1hLXdlYnBhY2stdGVzdC8uL25vZGVfbW9kdWxlcy9wdXBwZXRlZXItY29yZS9saWIvZXNtL3B1cHBldGVlci9iaWRpL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0Z29pbmdNZXNzYWdlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBleHBvcnRzLkJpZGlTZXJ2ZXIgPSB2b2lkIDA7XG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGhlIGVudHJ5IHBvaW50IHRvIHRoZSBCaURpIE1hcHBlciBuYW1lc3BhY2UuXG4gKiBPdGhlciBtb2R1bGVzIHNob3VsZCBvbmx5IGFjY2VzcyBleHBvcnRzIGRlZmluZWQgaW4gdGhpcyBmaWxlLlxuICogWFhYOiBBZGQgRVNsaW50IHJ1bGUgZm9yIHRoaXMgKGh0dHBzOi8vZ2l0aHViLmNvbS9pbXBvcnQtanMvZXNsaW50LXBsdWdpbi1pbXBvcnQvYmxvYi9tYWluL2RvY3MvcnVsZXMvbm8tcmVzdHJpY3RlZC1wYXRocy5tZClcbiAqL1xudmFyIEJpZGlTZXJ2ZXJfanNfMSA9IHJlcXVpcmUoXCIuL0JpZGlTZXJ2ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaWRpU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCaWRpU2VydmVyX2pzXzEuQmlkaVNlcnZlcjsgfSB9KTtcbnZhciBFdmVudEVtaXR0ZXJfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9FdmVudEVtaXR0ZXIuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudEVtaXR0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEV2ZW50RW1pdHRlcl9qc18xLkV2ZW50RW1pdHRlcjsgfSB9KTtcbnZhciBPdXRnb2luZ01lc3NhZ2VfanNfMSA9IHJlcXVpcmUoXCIuL091dGdvaW5nTWVzc2FnZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk91dGdvaW5nTWVzc2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gT3V0Z29pbmdNZXNzYWdlX2pzXzEuT3V0Z29pbmdNZXNzYWdlOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmlkaU1hcHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaWRpTm9PcFBhcnNlciA9IHZvaWQgMDtcbmNsYXNzIEJpZGlOb09wUGFyc2VyIHtcbiAgICAvLyBCcm93c2VyIGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlUmVtb3ZlVXNlckNvbnRleHRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgIC8vIEJyb3dzaW5nIENvbnRleHQgZG9tYWluXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgcGFyc2VBY3RpdmF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VDYXB0dXJlU2NyZWVuc2hvdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VDbG9zZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlR2V0VHJlZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VIYW5kbGVVc2VyUHJvbXB0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUxvY2F0ZU5vZGVzUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZU5hdmlnYXRlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVByaW50UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVJlbG9hZFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VTZXRWaWV3cG9ydFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VUcmF2ZXJzZUhpc3RvcnlQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgIC8vIENEUCBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZUdldFNlc3Npb25QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlUmVzb2x2ZVJlYWxtUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVNlbmRDb21tYW5kUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBTY3JpcHQgZG9tYWluXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgcGFyc2VBZGRQcmVsb2FkU2NyaXB0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUNhbGxGdW5jdGlvblBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VEaXNvd25QYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlRXZhbHVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlR2V0UmVhbG1zUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVJlbW92ZVByZWxvYWRTY3JpcHRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgIC8vIElucHV0IGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlUGVyZm9ybUFjdGlvbnNQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlUmVsZWFzZUFjdGlvbnNQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlU2V0RmlsZXNQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgIC8vIE5ldHdvcmsgZG9tYWluXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgcGFyc2VBZGRJbnRlcmNlcHRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlQ29udGludWVSZXF1ZXN0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZUNvbnRpbnVlUmVzcG9uc2VQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlQ29udGludWVXaXRoQXV0aFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VGYWlsUmVxdWVzdFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VQcm92aWRlUmVzcG9uc2VQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcnNlUmVtb3ZlSW50ZXJjZXB0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBQZXJtaXNzaW9ucyBkb21haW5cbiAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICBwYXJzZVNldFBlcm1pc3Npb25zUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBTZXNzaW9uIGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlU3Vic2NyaWJlUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAvLyBTdG9yYWdlIGRvbWFpblxuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgIHBhcnNlRGVsZXRlQ29va2llc1BhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcGFyc2VHZXRDb29raWVzUGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cbiAgICBwYXJzZVNldENvb2tpZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG59XG5leHBvcnRzLkJpZGlOb09wUGFyc2VyID0gQmlkaU5vT3BQYXJzZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaWRpTm9PcFBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaWRpU2VydmVyID0gdm9pZCAwO1xuY29uc3QgRXZlbnRFbWl0dGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRXZlbnRFbWl0dGVyLmpzXCIpO1xuY29uc3QgbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbG9nLmpzXCIpO1xuY29uc3QgUHJvY2Vzc2luZ1F1ZXVlX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvUHJvY2Vzc2luZ1F1ZXVlLmpzXCIpO1xuY29uc3QgQ29tbWFuZFByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vQ29tbWFuZFByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IENkcFRhcmdldE1hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY2RwL0NkcFRhcmdldE1hbmFnZXIuanNcIik7XG5jb25zdCBCcm93c2luZ0NvbnRleHRTdG9yYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2NvbnRleHQvQnJvd3NpbmdDb250ZXh0U3RvcmFnZS5qc1wiKTtcbmNvbnN0IE5ldHdvcmtTdG9yYWdlX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL25ldHdvcmsvTmV0d29ya1N0b3JhZ2UuanNcIik7XG5jb25zdCBQcmVsb2FkU2NyaXB0U3RvcmFnZV9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zY3JpcHQvUHJlbG9hZFNjcmlwdFN0b3JhZ2UuanNcIik7XG5jb25zdCBSZWFsbVN0b3JhZ2VfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2NyaXB0L1JlYWxtU3RvcmFnZS5qc1wiKTtcbmNvbnN0IEV2ZW50TWFuYWdlcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zZXNzaW9uL0V2ZW50TWFuYWdlci5qc1wiKTtcbmNsYXNzIEJpZGlTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXIge1xuICAgICNtZXNzYWdlUXVldWU7XG4gICAgI3RyYW5zcG9ydDtcbiAgICAjY29tbWFuZFByb2Nlc3NvcjtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gbmV3IEJyb3dzaW5nQ29udGV4dFN0b3JhZ2VfanNfMS5Ccm93c2luZ0NvbnRleHRTdG9yYWdlKCk7XG4gICAgI3JlYWxtU3RvcmFnZSA9IG5ldyBSZWFsbVN0b3JhZ2VfanNfMS5SZWFsbVN0b3JhZ2UoKTtcbiAgICAjcHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSBuZXcgUHJlbG9hZFNjcmlwdFN0b3JhZ2VfanNfMS5QcmVsb2FkU2NyaXB0U3RvcmFnZSgpO1xuICAgICNsb2dnZXI7XG4gICAgI2hhbmRsZUluY29taW5nTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHZvaWQgdGhpcy4jY29tbWFuZFByb2Nlc3Nvci5wcm9jZXNzQ29tbWFuZChtZXNzYWdlKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgICNwcm9jZXNzT3V0Z29pbmdNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2VFbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZUVudHJ5Lm1lc3NhZ2U7XG4gICAgICAgIGlmIChtZXNzYWdlRW50cnkuY2hhbm5lbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZVsnY2hhbm5lbCddID0gbWVzc2FnZUVudHJ5LmNoYW5uZWw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy4jdHJhbnNwb3J0LnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgY29uc3RydWN0b3IoYmlkaVRyYW5zcG9ydCwgY2RwQ29ubmVjdGlvbiwgYnJvd3NlckNkcENsaWVudCwgc2VsZlRhcmdldElkLCBkZWZhdWx0VXNlckNvbnRleHRJZCwgb3B0aW9ucywgcGFyc2VyLCBsb2dnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLiNtZXNzYWdlUXVldWUgPSBuZXcgUHJvY2Vzc2luZ1F1ZXVlX2pzXzEuUHJvY2Vzc2luZ1F1ZXVlKHRoaXMuI3Byb2Nlc3NPdXRnb2luZ01lc3NhZ2UsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIHRoaXMuI3RyYW5zcG9ydCA9IGJpZGlUcmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuI3RyYW5zcG9ydC5zZXRPbk1lc3NhZ2UodGhpcy4jaGFuZGxlSW5jb21pbmdNZXNzYWdlKTtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcl9qc18xLkV2ZW50TWFuYWdlcih0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlKTtcbiAgICAgICAgY29uc3QgbmV0d29ya1N0b3JhZ2UgPSBuZXcgTmV0d29ya1N0b3JhZ2VfanNfMS5OZXR3b3JrU3RvcmFnZSh0aGlzLiNldmVudE1hbmFnZXIsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIGJyb3dzZXJDZHBDbGllbnQsIGxvZ2dlcik7XG4gICAgICAgIG5ldyBDZHBUYXJnZXRNYW5hZ2VyX2pzXzEuQ2RwVGFyZ2V0TWFuYWdlcihjZHBDb25uZWN0aW9uLCBicm93c2VyQ2RwQ2xpZW50LCBzZWxmVGFyZ2V0SWQsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgdGhpcy4jcmVhbG1TdG9yYWdlLCBuZXR3b3JrU3RvcmFnZSwgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIG9wdGlvbnM/LmFjY2VwdEluc2VjdXJlQ2VydHMgPz8gZmFsc2UsIGRlZmF1bHRVc2VyQ29udGV4dElkLCBvcHRpb25zPy51bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgbG9nZ2VyKTtcbiAgICAgICAgdGhpcy4jY29tbWFuZFByb2Nlc3NvciA9IG5ldyBDb21tYW5kUHJvY2Vzc29yX2pzXzEuQ29tbWFuZFByb2Nlc3NvcihjZHBDb25uZWN0aW9uLCBicm93c2VyQ2RwQ2xpZW50LCB0aGlzLiNldmVudE1hbmFnZXIsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHRoaXMuI3JlYWxtU3RvcmFnZSwgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCBwYXJzZXIsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5vbihcImV2ZW50XCIgLyogRXZlbnRNYW5hZ2VyRXZlbnRzLkV2ZW50ICovLCAoeyBtZXNzYWdlLCBldmVudCB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXRPdXRnb2luZ01lc3NhZ2UobWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY29tbWFuZFByb2Nlc3Nvci5vbihcInJlc3BvbnNlXCIgLyogQ29tbWFuZFByb2Nlc3NvckV2ZW50cy5SZXNwb25zZSAqLywgKHsgbWVzc2FnZSwgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0T3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHN0YXJ0cyBCaURpIE1hcHBlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlQW5kU3RhcnQoYmlkaVRyYW5zcG9ydCwgY2RwQ29ubmVjdGlvbiwgYnJvd3NlckNkcENsaWVudCwgc2VsZlRhcmdldElkLCBvcHRpb25zLCBwYXJzZXIsIGxvZ2dlcikge1xuICAgICAgICAvLyBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIG5vdCBleHBvc2VkIGluIFRhcmdldC5nZXRCcm93c2VyQ29udGV4dHMgYnV0IGNhblxuICAgICAgICAvLyBiZSBvYnNlcnZlZCB2aWEgVGFyZ2V0LmdldFRhcmdldHMuIFRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBicm93c2VyXG4gICAgICAgIC8vIGNvbnRleHQsIHdlIGNoZWNrIHdoaWNoIG9uZSBpcyBtZW50aW9uZWQgaW4gVGFyZ2V0LmdldFRhcmdldHMgYW5kIG5vdCBpblxuICAgICAgICAvLyBUYXJnZXQuZ2V0QnJvd3NlckNvbnRleHRzLlxuICAgICAgICBjb25zdCBbeyBicm93c2VyQ29udGV4dElkcyB9LCB7IHRhcmdldEluZm9zIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmdldEJyb3dzZXJDb250ZXh0cycpLFxuICAgICAgICAgICAgYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmdldFRhcmdldHMnKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBkZWZhdWx0VXNlckNvbnRleHRJZCA9ICdkZWZhdWx0JztcbiAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIHRhcmdldEluZm9zKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5icm93c2VyQ29udGV4dElkICYmXG4gICAgICAgICAgICAgICAgIWJyb3dzZXJDb250ZXh0SWRzLmluY2x1ZGVzKGluZm8uYnJvd3NlckNvbnRleHRJZCkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VXNlckNvbnRleHRJZCA9IGluZm8uYnJvd3NlckNvbnRleHRJZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBuZXcgQmlkaVNlcnZlcihiaWRpVHJhbnNwb3J0LCBjZHBDb25uZWN0aW9uLCBicm93c2VyQ2RwQ2xpZW50LCBzZWxmVGFyZ2V0SWQsIGRlZmF1bHRVc2VyQ29udGV4dElkLCBvcHRpb25zLCBwYXJzZXIsIGxvZ2dlcik7XG4gICAgICAgIC8vIE5lZWRlZCB0byBnZXQgZXZlbnRzIGFib3V0IG5ldyB0YXJnZXRzLlxuICAgICAgICBhd2FpdCBicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuc2V0RGlzY292ZXJUYXJnZXRzJywge1xuICAgICAgICAgICAgZGlzY292ZXI6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOZWVkZWQgdG8gYXV0b21hdGljYWxseSBhdHRhY2ggdG8gbmV3IHRhcmdldHMuXG4gICAgICAgIGF3YWl0IGJyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1RhcmdldC5zZXRBdXRvQXR0YWNoJywge1xuICAgICAgICAgICAgYXV0b0F0dGFjaDogdHJ1ZSxcbiAgICAgICAgICAgIHdhaXRGb3JEZWJ1Z2dlck9uU3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgc2VydmVyLiN0b3BMZXZlbENvbnRleHRzTG9hZGVkKCk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIEJpRGkgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBlbWl0T3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2VFbnRyeSwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy4jbWVzc2FnZVF1ZXVlLmFkZChtZXNzYWdlRW50cnksIGV2ZW50KTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuI3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cbiAgICBhc3luYyAjdG9wTGV2ZWxDb250ZXh0c0xvYWRlZCgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZVxuICAgICAgICAgICAgLmdldFRvcExldmVsQ29udGV4dHMoKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4gYy5saWZlY3ljbGVMb2FkZWQoKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmlkaVNlcnZlciA9IEJpZGlTZXJ2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaWRpU2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbW1hbmRQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRXZlbnRFbWl0dGVyLmpzXCIpO1xuY29uc3QgbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbG9nLmpzXCIpO1xuY29uc3QgQmlkaU5vT3BQYXJzZXJfanNfMSA9IHJlcXVpcmUoXCIuL0JpZGlOb09wUGFyc2VyLmpzXCIpO1xuY29uc3QgQnJvd3NlclByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9icm93c2VyL0Jyb3dzZXJQcm9jZXNzb3IuanNcIik7XG5jb25zdCBDZHBQcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY2RwL0NkcFByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IEJyb3dzaW5nQ29udGV4dFByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9jb250ZXh0L0Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IElucHV0UHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2lucHV0L0lucHV0UHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgTmV0d29ya1Byb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9uZXR3b3JrL05ldHdvcmtQcm9jZXNzb3IuanNcIik7XG5jb25zdCBQZXJtaXNzaW9uc1Byb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9wZXJtaXNzaW9ucy9QZXJtaXNzaW9uc1Byb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IFNjcmlwdFByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zY3JpcHQvU2NyaXB0UHJvY2Vzc29yLmpzXCIpO1xuY29uc3QgU2Vzc2lvblByb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zZXNzaW9uL1Nlc3Npb25Qcm9jZXNzb3IuanNcIik7XG5jb25zdCBTdG9yYWdlUHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3N0b3JhZ2UvU3RvcmFnZVByb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IE91dGdvaW5nTWVzc2FnZV9qc18xID0gcmVxdWlyZShcIi4vT3V0Z29pbmdNZXNzYWdlLmpzXCIpO1xuY2xhc3MgQ29tbWFuZFByb2Nlc3NvciBleHRlbmRzIEV2ZW50RW1pdHRlcl9qc18xLkV2ZW50RW1pdHRlciB7XG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICAjYnJvd3NlclByb2Nlc3NvcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yO1xuICAgICNjZHBQcm9jZXNzb3I7XG4gICAgI2lucHV0UHJvY2Vzc29yO1xuICAgICNuZXR3b3JrUHJvY2Vzc29yO1xuICAgICNwZXJtaXNzaW9uc1Byb2Nlc3NvcjtcbiAgICAjc2NyaXB0UHJvY2Vzc29yO1xuICAgICNzZXNzaW9uUHJvY2Vzc29yO1xuICAgICNzdG9yYWdlUHJvY2Vzc29yO1xuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICNwYXJzZXI7XG4gICAgI2xvZ2dlcjtcbiAgICBjb25zdHJ1Y3RvcihjZHBDb25uZWN0aW9uLCBicm93c2VyQ2RwQ2xpZW50LCBldmVudE1hbmFnZXIsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCBwYXJzZXIgPSBuZXcgQmlkaU5vT3BQYXJzZXJfanNfMS5CaWRpTm9PcFBhcnNlcigpLCBsb2dnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jcGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICB0aGlzLiNicm93c2VyUHJvY2Vzc29yID0gbmV3IEJyb3dzZXJQcm9jZXNzb3JfanNfMS5Ccm93c2VyUHJvY2Vzc29yKGJyb3dzZXJDZHBDbGllbnQpO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IgPSBuZXcgQnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yX2pzXzEuQnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yKGJyb3dzZXJDZHBDbGllbnQsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIGV2ZW50TWFuYWdlcik7XG4gICAgICAgIHRoaXMuI2NkcFByb2Nlc3NvciA9IG5ldyBDZHBQcm9jZXNzb3JfanNfMS5DZHBQcm9jZXNzb3IoYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgcmVhbG1TdG9yYWdlLCBjZHBDb25uZWN0aW9uLCBicm93c2VyQ2RwQ2xpZW50KTtcbiAgICAgICAgdGhpcy4jaW5wdXRQcm9jZXNzb3IgPSBuZXcgSW5wdXRQcm9jZXNzb3JfanNfMS5JbnB1dFByb2Nlc3Nvcihicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UpO1xuICAgICAgICB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yID0gbmV3IE5ldHdvcmtQcm9jZXNzb3JfanNfMS5OZXR3b3JrUHJvY2Vzc29yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlKTtcbiAgICAgICAgdGhpcy4jcGVybWlzc2lvbnNQcm9jZXNzb3IgPSBuZXcgUGVybWlzc2lvbnNQcm9jZXNzb3JfanNfMS5QZXJtaXNzaW9uc1Byb2Nlc3Nvcihicm93c2VyQ2RwQ2xpZW50KTtcbiAgICAgICAgdGhpcy4jc2NyaXB0UHJvY2Vzc29yID0gbmV3IFNjcmlwdFByb2Nlc3Nvcl9qc18xLlNjcmlwdFByb2Nlc3Nvcihicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIHByZWxvYWRTY3JpcHRTdG9yYWdlLCBsb2dnZXIpO1xuICAgICAgICB0aGlzLiNzZXNzaW9uUHJvY2Vzc29yID0gbmV3IFNlc3Npb25Qcm9jZXNzb3JfanNfMS5TZXNzaW9uUHJvY2Vzc29yKGV2ZW50TWFuYWdlciwgYnJvd3NlckNkcENsaWVudCk7XG4gICAgICAgIHRoaXMuI3N0b3JhZ2VQcm9jZXNzb3IgPSBuZXcgU3RvcmFnZVByb2Nlc3Nvcl9qc18xLlN0b3JhZ2VQcm9jZXNzb3IoYnJvd3NlckNkcENsaWVudCwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbG9nZ2VyKTtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgfVxuICAgIGFzeW5jICNwcm9jZXNzQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Nlc3Npb24uZW5kJzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBCcm93c2VyIGRvbWFpblxuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgICAgICBjYXNlICdicm93c2VyLmNsb3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlclByb2Nlc3Nvci5jbG9zZSgpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5jcmVhdGVVc2VyQ29udGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzZXJQcm9jZXNzb3IuY3JlYXRlVXNlckNvbnRleHQoY29tbWFuZC5wYXJhbXMpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5nZXRVc2VyQ29udGV4dHMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2VyUHJvY2Vzc29yLmdldFVzZXJDb250ZXh0cygpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3Nlci5yZW1vdmVVc2VyQ29udGV4dCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzZXJQcm9jZXNzb3IucmVtb3ZlVXNlckNvbnRleHQodGhpcy4jcGFyc2VyLnBhcnNlUmVtb3ZlVXNlckNvbnRleHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gQnJvd3NpbmcgQ29udGV4dCBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmFjdGl2YXRlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmFjdGl2YXRlKHRoaXMuI3BhcnNlci5wYXJzZUFjdGl2YXRlUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuY2FwdHVyZVNjcmVlbnNob3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IuY2FwdHVyZVNjcmVlbnNob3QodGhpcy4jcGFyc2VyLnBhcnNlQ2FwdHVyZVNjcmVlbnNob3RQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5jbG9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5jbG9zZSh0aGlzLiNwYXJzZXIucGFyc2VDbG9zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmNyZWF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5jcmVhdGUodGhpcy4jcGFyc2VyLnBhcnNlQ3JlYXRlUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuZ2V0VHJlZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5nZXRUcmVlKHRoaXMuI3BhcnNlci5wYXJzZUdldFRyZWVQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5oYW5kbGVVc2VyUHJvbXB0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmhhbmRsZVVzZXJQcm9tcHQodGhpcy4jcGFyc2VyLnBhcnNlSGFuZGxlVXNlclByb21wdFBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LmxvY2F0ZU5vZGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yLmxvY2F0ZU5vZGVzKHRoaXMuI3BhcnNlci5wYXJzZUxvY2F0ZU5vZGVzUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQubmF2aWdhdGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IubmF2aWdhdGUodGhpcy4jcGFyc2VyLnBhcnNlTmF2aWdhdGVQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC5wcmludCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5wcmludCh0aGlzLiNwYXJzZXIucGFyc2VQcmludFBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NpbmdDb250ZXh0LnJlbG9hZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFByb2Nlc3Nvci5yZWxvYWQodGhpcy4jcGFyc2VyLnBhcnNlUmVsb2FkUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdicm93c2luZ0NvbnRleHQuc2V0Vmlld3BvcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3Iuc2V0Vmlld3BvcnQodGhpcy4jcGFyc2VyLnBhcnNlU2V0Vmlld3BvcnRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzaW5nQ29udGV4dC50cmF2ZXJzZUhpc3RvcnknOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRQcm9jZXNzb3IudHJhdmVyc2VIaXN0b3J5KHRoaXMuI3BhcnNlci5wYXJzZVRyYXZlcnNlSGlzdG9yeVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgICAgICAgICAvLyBDRFAgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ2NkcC5nZXRTZXNzaW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jY2RwUHJvY2Vzc29yLmdldFNlc3Npb24odGhpcy4jcGFyc2VyLnBhcnNlR2V0U2Vzc2lvblBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnY2RwLnJlc29sdmVSZWFsbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NkcFByb2Nlc3Nvci5yZXNvbHZlUmVhbG0odGhpcy4jcGFyc2VyLnBhcnNlUmVzb2x2ZVJlYWxtUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdjZHAuc2VuZENvbW1hbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBQcm9jZXNzb3Iuc2VuZENvbW1hbmQodGhpcy4jcGFyc2VyLnBhcnNlU2VuZENvbW1hbmRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gSW5wdXQgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnBlcmZvcm1BY3Rpb25zJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3IucGVyZm9ybUFjdGlvbnModGhpcy4jcGFyc2VyLnBhcnNlUGVyZm9ybUFjdGlvbnNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnJlbGVhc2VBY3Rpb25zJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3IucmVsZWFzZUFjdGlvbnModGhpcy4jcGFyc2VyLnBhcnNlUmVsZWFzZUFjdGlvbnNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ2lucHV0LnNldEZpbGVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jaW5wdXRQcm9jZXNzb3Iuc2V0RmlsZXModGhpcy4jcGFyc2VyLnBhcnNlU2V0RmlsZXNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gTmV0d29yayBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5hZGRJbnRlcmNlcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmFkZEludGVyY2VwdCh0aGlzLiNwYXJzZXIucGFyc2VBZGRJbnRlcmNlcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmsuY29udGludWVSZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbmV0d29ya1Byb2Nlc3Nvci5jb250aW51ZVJlcXVlc3QodGhpcy4jcGFyc2VyLnBhcnNlQ29udGludWVSZXF1ZXN0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICduZXR3b3JrLmNvbnRpbnVlUmVzcG9uc2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmNvbnRpbnVlUmVzcG9uc2UodGhpcy4jcGFyc2VyLnBhcnNlQ29udGludWVSZXNwb25zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5jb250aW51ZVdpdGhBdXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jbmV0d29ya1Byb2Nlc3Nvci5jb250aW51ZVdpdGhBdXRoKHRoaXMuI3BhcnNlci5wYXJzZUNvbnRpbnVlV2l0aEF1dGhQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ25ldHdvcmsuZmFpbFJlcXVlc3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLmZhaWxSZXF1ZXN0KHRoaXMuI3BhcnNlci5wYXJzZUZhaWxSZXF1ZXN0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICduZXR3b3JrLnByb3ZpZGVSZXNwb25zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI25ldHdvcmtQcm9jZXNzb3IucHJvdmlkZVJlc3BvbnNlKHRoaXMuI3BhcnNlci5wYXJzZVByb3ZpZGVSZXNwb25zZVBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnbmV0d29yay5yZW1vdmVJbnRlcmNlcHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNuZXR3b3JrUHJvY2Vzc29yLnJlbW92ZUludGVyY2VwdCh0aGlzLiNwYXJzZXIucGFyc2VSZW1vdmVJbnRlcmNlcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gUGVybWlzc2lvbnMgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ3Blcm1pc3Npb25zLnNldFBlcm1pc3Npb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNwZXJtaXNzaW9uc1Byb2Nlc3Nvci5zZXRQZXJtaXNzaW9ucyh0aGlzLiNwYXJzZXIucGFyc2VTZXRQZXJtaXNzaW9uc1BhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgICAgICAgICAvLyBTY3JpcHQgZG9tYWluXG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydCBibG9jaz15ZXNcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdC5hZGRQcmVsb2FkU2NyaXB0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc2NyaXB0UHJvY2Vzc29yLmFkZFByZWxvYWRTY3JpcHQodGhpcy4jcGFyc2VyLnBhcnNlQWRkUHJlbG9hZFNjcmlwdFBhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnc2NyaXB0LmNhbGxGdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5jYWxsRnVuY3Rpb24odGhpcy4jcGFyc2VyLnBhcnNlQ2FsbEZ1bmN0aW9uUGFyYW1zKHRoaXMuI3Byb2Nlc3NUYXJnZXRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKSk7XG4gICAgICAgICAgICBjYXNlICdzY3JpcHQuZGlzb3duJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc2NyaXB0UHJvY2Vzc29yLmRpc293bih0aGlzLiNwYXJzZXIucGFyc2VEaXNvd25QYXJhbXModGhpcy4jcHJvY2Vzc1RhcmdldFBhcmFtcyhjb21tYW5kLnBhcmFtcykpKTtcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdC5ldmFsdWF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5ldmFsdWF0ZSh0aGlzLiNwYXJzZXIucGFyc2VFdmFsdWF0ZVBhcmFtcyh0aGlzLiNwcm9jZXNzVGFyZ2V0UGFyYW1zKGNvbW1hbmQucGFyYW1zKSkpO1xuICAgICAgICAgICAgY2FzZSAnc2NyaXB0LmdldFJlYWxtcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5nZXRSZWFsbXModGhpcy4jcGFyc2VyLnBhcnNlR2V0UmVhbG1zUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICBjYXNlICdzY3JpcHQucmVtb3ZlUHJlbG9hZFNjcmlwdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3NjcmlwdFByb2Nlc3Nvci5yZW1vdmVQcmVsb2FkU2NyaXB0KHRoaXMuI3BhcnNlci5wYXJzZVJlbW92ZVByZWxvYWRTY3JpcHRQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIGVuZFxuICAgICAgICAgICAgLy8gU2Vzc2lvbiBkb21haW5cbiAgICAgICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0IGJsb2NrPXllc1xuICAgICAgICAgICAgY2FzZSAnc2Vzc2lvbi5uZXcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzZXNzaW9uUHJvY2Vzc29yLmNyZWF0ZShjb21tYW5kLnBhcmFtcyk7XG4gICAgICAgICAgICBjYXNlICdzZXNzaW9uLnN0YXR1cyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Nlc3Npb25Qcm9jZXNzb3Iuc3RhdHVzKCk7XG4gICAgICAgICAgICBjYXNlICdzZXNzaW9uLnN1YnNjcmliZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3Nlc3Npb25Qcm9jZXNzb3Iuc3Vic2NyaWJlKHRoaXMuI3BhcnNlci5wYXJzZVN1YnNjcmliZVBhcmFtcyhjb21tYW5kLnBhcmFtcyksIGNvbW1hbmQuY2hhbm5lbCk7XG4gICAgICAgICAgICBjYXNlICdzZXNzaW9uLnVuc3Vic2NyaWJlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc2Vzc2lvblByb2Nlc3Nvci51bnN1YnNjcmliZSh0aGlzLiNwYXJzZXIucGFyc2VTdWJzY3JpYmVQYXJhbXMoY29tbWFuZC5wYXJhbXMpLCBjb21tYW5kLmNoYW5uZWwpO1xuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgICAgICAgICAvLyBTdG9yYWdlIGRvbWFpblxuICAgICAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnQgYmxvY2s9eWVzXG4gICAgICAgICAgICBjYXNlICdzdG9yYWdlLmRlbGV0ZUNvb2tpZXMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNzdG9yYWdlUHJvY2Vzc29yLmRlbGV0ZUNvb2tpZXModGhpcy4jcGFyc2VyLnBhcnNlRGVsZXRlQ29va2llc1BhcmFtcyhjb21tYW5kLnBhcmFtcykpO1xuICAgICAgICAgICAgY2FzZSAnc3RvcmFnZS5nZXRDb29raWVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3RvcmFnZVByb2Nlc3Nvci5nZXRDb29raWVzKHRoaXMuI3BhcnNlci5wYXJzZUdldENvb2tpZXNQYXJhbXMoY29tbWFuZC5wYXJhbXMpKTtcbiAgICAgICAgICAgIGNhc2UgJ3N0b3JhZ2Uuc2V0Q29va2llJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jc3RvcmFnZVByb2Nlc3Nvci5zZXRDb29raWUodGhpcy4jcGFyc2VyLnBhcnNlU2V0Q29va2llUGFyYW1zKGNvbW1hbmQucGFyYW1zKSk7XG4gICAgICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGtlcHQgb3V0c2lkZSB0aGUgc3dpdGNoIHN0YXRlbWVudCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyBFU0xpbnQgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayB0cmlnZ2VycyBpZiBhIG5ld1xuICAgICAgICAvLyBjb21tYW5kIGlzIGFkZGVkLlxuICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duQ29tbWFuZEV4Y2VwdGlvbihgVW5rbm93biBjb21tYW5kICcke2NvbW1hbmQubWV0aG9kfScuYCk7XG4gICAgfVxuICAgIC8vIFdvcmthcm91bmQgZm9yIGFzIHpvZC51bmlvbiBhbHdheXMgdGFrZSB0aGUgZmlyc3Qgc2NoZW1hXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJkcml2ZXItYmlkaS9pc3N1ZXMvNjM1XG4gICAgI3Byb2Nlc3NUYXJnZXRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgcGFyYW1zICYmXG4gICAgICAgICAgICAndGFyZ2V0JyBpbiBwYXJhbXMgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXJhbXMudGFyZ2V0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgcGFyYW1zLnRhcmdldCAmJlxuICAgICAgICAgICAgJ2NvbnRleHQnIGluIHBhcmFtcy50YXJnZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudGFyZ2V0WydyZWFsbSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuI3Byb2Nlc3NDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIGlkOiBjb21tYW5kLmlkLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiIC8qIENvbW1hbmRQcm9jZXNzb3JFdmVudHMuUmVzcG9uc2UgKi8sIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBPdXRnb2luZ01lc3NhZ2VfanNfMS5PdXRnb2luZ01lc3NhZ2UuY3JlYXRlUmVzb2x2ZWQocmVzcG9uc2UsIGNvbW1hbmQuY2hhbm5lbCksXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGNvbW1hbmQubWV0aG9kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgcHJvdG9jb2xfanNfMS5FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiIC8qIENvbW1hbmRQcm9jZXNzb3JFdmVudHMuUmVzcG9uc2UgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogT3V0Z29pbmdNZXNzYWdlX2pzXzEuT3V0Z29pbmdNZXNzYWdlLmNyZWF0ZVJlc29sdmVkKGUudG9FcnJvclJlc3BvbnNlKGNvbW1hbmQuaWQpLCBjb21tYW5kLmNoYW5uZWwpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogY29tbWFuZC5tZXRob2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5iaWRpLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVzcG9uc2VcIiAvKiBDb21tYW5kUHJvY2Vzc29yRXZlbnRzLlJlc3BvbnNlICovLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE91dGdvaW5nTWVzc2FnZV9qc18xLk91dGdvaW5nTWVzc2FnZS5jcmVhdGVSZXNvbHZlZChuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spLnRvRXJyb3JSZXNwb25zZShjb21tYW5kLmlkKSwgY29tbWFuZC5jaGFubmVsKSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGNvbW1hbmQubWV0aG9kLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Db21tYW5kUHJvY2Vzc29yID0gQ29tbWFuZFByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbW1hbmRQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0Z29pbmdNZXNzYWdlID0gdm9pZCAwO1xuY2xhc3MgT3V0Z29pbmdNZXNzYWdlIHtcbiAgICAjbWVzc2FnZTtcbiAgICAjY2hhbm5lbDtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjaGFubmVsID0gbnVsbCkge1xuICAgICAgICB0aGlzLiNtZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy4jY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tUHJvbWlzZShtZXNzYWdlUHJvbWlzZSwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZVByb21pc2UudGhlbigobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2luZCA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3IE91dGdvaW5nTWVzc2FnZShtZXNzYWdlLnZhbHVlLCBjaGFubmVsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUmVzb2x2ZWQobWVzc2FnZSwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgT3V0Z29pbmdNZXNzYWdlKG1lc3NhZ2UsIGNoYW5uZWwpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoYW5uZWw7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRnb2luZ01lc3NhZ2UgPSBPdXRnb2luZ01lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRnb2luZ01lc3NhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NlclByb2Nlc3NvciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jbGFzcyBCcm93c2VyUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyQ2RwQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgaXQgaXMgcHV0IGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3AuXG4gICAgICAgIC8vIFRoaXMgd2F5IHdlIHNlbmQgYmFjayB0aGUgcmVzcG9uc2UgYmVmb3JlIGNsb3NpbmcgdGhlIHRhYi5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdCcm93c2VyLmNsb3NlJyksIDApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVVzZXJDb250ZXh0KHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcHJveHlTZXJ2ZXI6IHBhcmFtc1snZ29vZzpwcm94eVNlcnZlciddID8/IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJveHlCeXBhc3NMaXN0ID0gcGFyYW1zWydnb29nOnByb3h5QnlwYXNzTGlzdCddID8/IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3h5QnlwYXNzTGlzdCkge1xuICAgICAgICAgICAgcmVxdWVzdC5wcm94eUJ5cGFzc0xpc3QgPSBwcm94eUJ5cGFzc0xpc3Quam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuY3JlYXRlQnJvd3NlckNvbnRleHQnLCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXJDb250ZXh0OiBjb250ZXh0LmJyb3dzZXJDb250ZXh0SWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVVzZXJDb250ZXh0KHBhcmFtcykge1xuICAgICAgICBjb25zdCB1c2VyQ29udGV4dCA9IHBhcmFtcy51c2VyQ29udGV4dDtcbiAgICAgICAgaWYgKHVzZXJDb250ZXh0ID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignYGRlZmF1bHRgIHVzZXIgY29udGV4dCBjYW5ub3QgYmUgcmVtb3ZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuZGlzcG9zZUJyb3dzZXJDb250ZXh0Jywge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0SWQ6IHVzZXJDb250ZXh0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46Y29udGVudC9icm93c2VyL2RldnRvb2xzL3Byb3RvY29sL3RhcmdldF9oYW5kbGVyLmNjO2w9MTQyNDtkcmM9YzY4NmU4ZjRmZDM3OTMxMjQ2OWZlMDE4ZjVjMzkwZTljOGYyMGQwZFxuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ0ZhaWxlZCB0byBmaW5kIGNvbnRleHQgd2l0aCBpZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb24oZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXNlckNvbnRleHRzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuZ2V0QnJvd3NlckNvbnRleHRzJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQ29udGV4dHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiAnZGVmYXVsdCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHQuYnJvd3NlckNvbnRleHRJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlckNvbnRleHQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJQcm9jZXNzb3IgPSBCcm93c2VyUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclByb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZHBQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY2xhc3MgQ2RwUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjcmVhbG1TdG9yYWdlO1xuICAgICNjZHBDb25uZWN0aW9uO1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgY2RwQ29ubmVjdGlvbiwgYnJvd3NlckNkcENsaWVudCkge1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlID0gcmVhbG1TdG9yYWdlO1xuICAgICAgICB0aGlzLiNjZHBDb25uZWN0aW9uID0gY2RwQ29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudCA9IGJyb3dzZXJDZHBDbGllbnQ7XG4gICAgfVxuICAgIGdldFNlc3Npb24ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBwYXJhbXMuY29udGV4dDtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KGNvbnRleHQpLmNkcFRhcmdldC5jZHBTZXNzaW9uSWQ7XG4gICAgICAgIGlmIChzZXNzaW9uSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlc3Npb246IHNlc3Npb25JZCB9O1xuICAgIH1cbiAgICByZXNvbHZlUmVhbG0ocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBwYXJhbXMucmVhbG07XG4gICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jcmVhbG1TdG9yYWdlLmdldFJlYWxtKHsgcmVhbG1JZDogY29udGV4dCB9KTtcbiAgICAgICAgaWYgKHJlYWxtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbihgQ291bGQgbm90IGZpbmQgcmVhbG0gJHtwYXJhbXMucmVhbG19YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXhlY3V0aW9uQ29udGV4dElkOiByZWFsbS5leGVjdXRpb25Db250ZXh0SWQgfTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENvbW1hbmQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHBhcmFtcy5zZXNzaW9uXG4gICAgICAgICAgICA/IHRoaXMuI2NkcENvbm5lY3Rpb24uZ2V0Q2RwQ2xpZW50KHBhcmFtcy5zZXNzaW9uKVxuICAgICAgICAgICAgOiB0aGlzLiNicm93c2VyQ2RwQ2xpZW50O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuc2VuZENvbW1hbmQocGFyYW1zLm1ldGhvZCwgcGFyYW1zLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBzZXNzaW9uOiBwYXJhbXMuc2Vzc2lvbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNkcFByb2Nlc3NvciA9IENkcFByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNkcFByb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2RwVGFyZ2V0ID0gdm9pZCAwO1xuY29uc3QgY2hyb21pdW1fYmlkaV9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL2Nocm9taXVtLWJpZGkuanNcIik7XG5jb25zdCBEZWZlcnJlZF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL0RlZmVycmVkLmpzXCIpO1xuY29uc3QgbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvbG9nLmpzXCIpO1xuY29uc3QgQnJvd3NpbmdDb250ZXh0SW1wbF9qc18xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvQnJvd3NpbmdDb250ZXh0SW1wbC5qc1wiKTtcbmNvbnN0IExvZ01hbmFnZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9sb2cvTG9nTWFuYWdlci5qc1wiKTtcbmNsYXNzIENkcFRhcmdldCB7XG4gICAgI2lkO1xuICAgICNjZHBDbGllbnQ7XG4gICAgI2Jyb3dzZXJDZHBDbGllbnQ7XG4gICAgI3JlYWxtU3RvcmFnZTtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNwcmVsb2FkU2NyaXB0U3RvcmFnZTtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjbmV0d29ya1N0b3JhZ2U7XG4gICAgI3VuYmxvY2tlZCA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgICNhY2NlcHRJbnNlY3VyZUNlcnRzO1xuICAgICNsb2dnZXI7XG4gICAgI25ldHdvcmtEb21haW5FbmFibGVkID0gZmFsc2U7XG4gICAgI2ZldGNoRG9tYWluU3RhZ2VzID0ge1xuICAgICAgICByZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgcmVzcG9uc2U6IGZhbHNlLFxuICAgICAgICBhdXRoOiBmYWxzZSxcbiAgICB9O1xuICAgIHN0YXRpYyBjcmVhdGUodGFyZ2V0SWQsIGNkcENsaWVudCwgYnJvd3NlckNkcENsaWVudCwgcmVhbG1TdG9yYWdlLCBldmVudE1hbmFnZXIsIHByZWxvYWRTY3JpcHRTdG9yYWdlLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCBuZXR3b3JrU3RvcmFnZSwgYWNjZXB0SW5zZWN1cmVDZXJ0cywgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCBjZHBUYXJnZXQgPSBuZXcgQ2RwVGFyZ2V0KHRhcmdldElkLCBjZHBDbGllbnQsIGJyb3dzZXJDZHBDbGllbnQsIGV2ZW50TWFuYWdlciwgcmVhbG1TdG9yYWdlLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbmV0d29ya1N0b3JhZ2UsIGFjY2VwdEluc2VjdXJlQ2VydHMsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpO1xuICAgICAgICBMb2dNYW5hZ2VyX2pzXzEuTG9nTWFuYWdlci5jcmVhdGUoY2RwVGFyZ2V0LCByZWFsbVN0b3JhZ2UsIGV2ZW50TWFuYWdlciwgbG9nZ2VyKTtcbiAgICAgICAgY2RwVGFyZ2V0LiNzZXRFdmVudExpc3RlbmVycygpO1xuICAgICAgICAvLyBObyBuZWVkIHRvIGF3YWl0LlxuICAgICAgICAvLyBEZWZlcnJlZCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHRhcmdldCBpcyB1bmJsb2NrZWQuXG4gICAgICAgIHZvaWQgY2RwVGFyZ2V0LiN1bmJsb2NrKCk7XG4gICAgICAgIHJldHVybiBjZHBUYXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHRhcmdldElkLCBjZHBDbGllbnQsIGJyb3dzZXJDZHBDbGllbnQsIGV2ZW50TWFuYWdlciwgcmVhbG1TdG9yYWdlLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbmV0d29ya1N0b3JhZ2UsIGFjY2VwdEluc2VjdXJlQ2VydHMsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jaWQgPSB0YXJnZXRJZDtcbiAgICAgICAgdGhpcy4jY2RwQ2xpZW50ID0gY2RwQ2xpZW50O1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UgPSByZWFsbVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlID0gcHJlbG9hZFNjcmlwdFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI25ldHdvcmtTdG9yYWdlID0gbmV0d29ya1N0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNhY2NlcHRJbnNlY3VyZUNlcnRzID0gYWNjZXB0SW5zZWN1cmVDZXJ0cztcbiAgICAgICAgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IgPSB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcjtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIGRlZmVycmVkIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gKi9cbiAgICBnZXQgdW5ibG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdW5ibG9ja2VkO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpZDtcbiAgICB9XG4gICAgZ2V0IGNkcENsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NkcENsaWVudDtcbiAgICB9XG4gICAgZ2V0IGJyb3dzZXJDZHBDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICAvKiogTmVlZGVkIGZvciBDRFAgZXNjYXBlIHBhdGguICovXG4gICAgZ2V0IGNkcFNlc3Npb25JZCgpIHtcbiAgICAgICAgLy8gU0FGRVRZIHdlIGdvdCB0aGUgY2xpZW50IGJ5IGl0J3MgaWQgZm9yIGNyZWF0aW5nXG4gICAgICAgIHJldHVybiB0aGlzLiNjZHBDbGllbnQuc2Vzc2lvbklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGFsbCB0aGUgcmVxdWlyZWQgQ0RQIGRvbWFpbnMgYW5kIHVuYmxvY2tzIHRoZSB0YXJnZXQuXG4gICAgICovXG4gICAgYXN5bmMgI3VuYmxvY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmVuYWJsZScpLFxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBiZSBzb21lIGV4aXN0aW5nIGZyYW1lcyBpbiB0aGUgdGFyZ2V0LCBpZiByZWNvbm5lY3RpbmcgdG8gYW5cbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBicm93c2VyIGluc3RhbmNlLCBlLmcuIHZpYSBQdXBwZXRlZXIuIE5lZWQgdG8gcmVzdG9yZSB0aGUgYnJvd3NpbmdcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0cyBmb3IgdGhlIGZyYW1lcyB0byBjb3JyZWN0bHkgaGFuZGxlIGZ1cnRoZXIgZXZlbnRzLCBsaWtlXG4gICAgICAgICAgICAgICAgLy8gYFJ1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWRgLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHNjaGVkdWxlIHRoaXMgdGFzayB0b2dldGhlciB3aXRoIGVuYWJsaW5nIGRvbWFpbnMgY29tbWFuZHMgdG9cbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSB0cmVlIGJlZm9yZSB0aGUgZXZlbnRzIChlLmcuIFJ1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWQpIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gY29taW5nLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL2Nocm9taXVtLWJpZGkvaXNzdWVzLzIyODJcbiAgICAgICAgICAgICAgICB0aGlzLiNjZHBDbGllbnRcbiAgICAgICAgICAgICAgICAgICAgLnNlbmRDb21tYW5kKCdQYWdlLmdldEZyYW1lVHJlZScpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmcmFtZVRyZWUpID0+IHRoaXMuI3Jlc3RvcmVGcmFtZVRyZWVTdGF0ZShmcmFtZVRyZWUuZnJhbWVUcmVlKSksXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmVuYWJsZScpLFxuICAgICAgICAgICAgICAgIHRoaXMuI2NkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5zZXRMaWZlY3ljbGVFdmVudHNFbmFibGVkJywge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC8vIFNldCBpZ25vcmUgY2VydGlmaWNhdGUgZXJyb3JzIGZvciBlYWNoIHRhcmdldC5cbiAgICAgICAgICAgICAgICB0aGlzLiNjZHBDbGllbnQuc2VuZENvbW1hbmQoJ1NlY3VyaXR5LnNldElnbm9yZUNlcnRpZmljYXRlRXJyb3JzJywge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmU6IHRoaXMuI2FjY2VwdEluc2VjdXJlQ2VydHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVOZXR3b3JrSWZOZWVkZWQoKSxcbiAgICAgICAgICAgICAgICB0aGlzLiNjZHBDbGllbnQuc2VuZENvbW1hbmQoJ1RhcmdldC5zZXRBdXRvQXR0YWNoJywge1xuICAgICAgICAgICAgICAgICAgICBhdXRvQXR0YWNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yRGVidWdnZXJPblN0YXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuI2luaXRBbmRFdmFsdWF0ZVByZWxvYWRTY3JpcHRzKCksXG4gICAgICAgICAgICAgICAgdGhpcy4jY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLnJ1bklmV2FpdGluZ0ZvckRlYnVnZ2VyJyksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ0ZhaWxlZCB0byB1bmJsb2NrIHRhcmdldCcsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbWlnaHQgaGF2ZSBiZWVuIGNsb3NlZCBiZWZvcmUgdGhlIGluaXRpYWxpemF0aW9uIGZpbmlzaGVkLlxuICAgICAgICAgICAgaWYgKCF0aGlzLiNjZHBDbGllbnQuaXNDbG9zZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3VuYmxvY2tlZC5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3VuYmxvY2tlZC5yZXNvbHZlKHtcbiAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjcmVzdG9yZUZyYW1lVHJlZVN0YXRlKGZyYW1lVHJlZSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IGZyYW1lVHJlZS5mcmFtZTtcbiAgICAgICAgaWYgKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQoZnJhbWUuaWQpID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGZyYW1lLnBhcmVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENhbiByZXN0b3JlIG9ubHkgbm90IHlldCBrbm93biBuZXN0ZWQgZnJhbWVzLiBUaGUgdG9wLWxldmVsIGZyYW1lIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHRhcmdldCBpcyBhdHRhY2hlZC5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEJyb3dzaW5nQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChmcmFtZS5wYXJlbnRJZCk7XG4gICAgICAgICAgICBCcm93c2luZ0NvbnRleHRJbXBsX2pzXzEuQnJvd3NpbmdDb250ZXh0SW1wbC5jcmVhdGUoZnJhbWUuaWQsIGZyYW1lLnBhcmVudElkLCBwYXJlbnRCcm93c2luZ0NvbnRleHQudXNlckNvbnRleHQsIHBhcmVudEJyb3dzaW5nQ29udGV4dC5jZHBUYXJnZXQsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgdGhpcy4jcmVhbG1TdG9yYWdlLCBmcmFtZS51cmwsIHVuZGVmaW5lZCwgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWVUcmVlLmNoaWxkRnJhbWVzPy5tYXAoKGZyYW1lVHJlZSkgPT4gdGhpcy4jcmVzdG9yZUZyYW1lVHJlZVN0YXRlKGZyYW1lVHJlZSkpO1xuICAgIH1cbiAgICBhc3luYyB0b2dnbGVGZXRjaElmTmVlZGVkKCkge1xuICAgICAgICBjb25zdCBzdGFnZXMgPSB0aGlzLiNuZXR3b3JrU3RvcmFnZS5nZXRJbnRlcmNlcHRpb25TdGFnZXModGhpcy50b3BMZXZlbElkKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBPbmx5IHRvZ2dsZSBpbnRlcmNlcHRpb24gd2hlbiBOZXR3b3JrIGlzIGVuYWJsZWRcbiAgICAgICAgIXRoaXMuI25ldHdvcmtEb21haW5FbmFibGVkIHx8XG4gICAgICAgICAgICAodGhpcy4jZmV0Y2hEb21haW5TdGFnZXMucmVxdWVzdCA9PT0gc3RhZ2VzLnJlcXVlc3QgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNmZXRjaERvbWFpblN0YWdlcy5yZXNwb25zZSA9PT0gc3RhZ2VzLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jZmV0Y2hEb21haW5TdGFnZXMuYXV0aCA9PT0gc3RhZ2VzLmF1dGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0dGVybnMgPSBbXTtcbiAgICAgICAgdGhpcy4jZmV0Y2hEb21haW5TdGFnZXMgPSBzdGFnZXM7XG4gICAgICAgIGlmIChzdGFnZXMucmVxdWVzdCB8fCBzdGFnZXMuYXV0aCkge1xuICAgICAgICAgICAgLy8gQ0RQIHF1aXJrIHdlIG5lZWQgcmVxdWVzdCBpbnRlcmNlcHRpb24gd2hlbiB3ZSBpbnRlcmNlcHQgYXV0aFxuICAgICAgICAgICAgcGF0dGVybnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsUGF0dGVybjogJyonLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGFnZTogJ1JlcXVlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWdlcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgcGF0dGVybnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsUGF0dGVybjogJyonLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdGFnZTogJ1Jlc3BvbnNlJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guZW5hYmxlJywge1xuICAgICAgICAgICAgICAgIHBhdHRlcm5zLFxuICAgICAgICAgICAgICAgIGhhbmRsZUF1dGhSZXF1ZXN0czogc3RhZ2VzLmF1dGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guZGlzYWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYm90aCBOZXR3b3JrIGFuZCBGZXRjaCBkb21haW5zLlxuICAgICAqL1xuICAgIGFzeW5jIHRvZ2dsZU5ldHdvcmtJZk5lZWRlZCgpIHtcbiAgICAgICAgY29uc3QgZW5hYmxlZCA9IHRoaXMuaXNTdWJzY3JpYmVkVG8oY2hyb21pdW1fYmlkaV9qc18xLkJpRGlNb2R1bGUuTmV0d29yayk7XG4gICAgICAgIGlmIChlbmFibGVkID09PSB0aGlzLiNuZXR3b3JrRG9tYWluRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI25ldHdvcmtEb21haW5FbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLiNjZHBDbGllbnQuc2VuZENvbW1hbmQoZW5hYmxlZCA/ICdOZXR3b3JrLmVuYWJsZScgOiAnTmV0d29yay5kaXNhYmxlJyksXG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVGZXRjaElmTmVlZGVkKCksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrRG9tYWluRW5hYmxlZCA9ICFlbmFibGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgICNzZXRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy4jY2RwQ2xpZW50Lm9uKCcqJywgKGV2ZW50LCBwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIC8vIFdlIG1heSBlbmNvdW50ZXIgdXNlcyBmb3IgRXZlbnRFbWl0dGVyIG90aGVyIHRoYW4gQ0RQIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIHdlIHdhbnQgdG8gc2tpcC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBgY2RwLiR7ZXZlbnR9YCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5jZHBTZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIHRoaXMuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsIHRoZSBQcm94eUNoYW5uZWxzIGZyb20gYWxsIHRoZSBwcmVsb2FkIHNjcmlwdHMgb2YgdGhlIGdpdmVuXG4gICAgICogQnJvd3NpbmdDb250ZXh0LlxuICAgICAqL1xuICAgIGdldENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2VcbiAgICAgICAgICAgIC5maW5kKClcbiAgICAgICAgICAgIC5mbGF0TWFwKChzY3JpcHQpID0+IHNjcmlwdC5jaGFubmVscyk7XG4gICAgfVxuICAgIC8qKiBMb2FkcyBhbGwgdG9wLWxldmVsIHByZWxvYWQgc2NyaXB0cy4gKi9cbiAgICBhc3luYyAjaW5pdEFuZEV2YWx1YXRlUHJlbG9hZFNjcmlwdHMoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlXG4gICAgICAgICAgICAuZmluZCh7XG4gICAgICAgICAgICAvLyBOZWVkZWQgZm9yIE9PUElGXG4gICAgICAgICAgICB0YXJnZXRJZDogdGhpcy50b3BMZXZlbElkLFxuICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoc2NyaXB0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LmluaXRJblRhcmdldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBnZXQgdG9wTGV2ZWxJZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRUb3BMZXZlbENvbnRleHRJZCh0aGlzLmlkKSA/PyB0aGlzLmlkKTtcbiAgICB9XG4gICAgaXNTdWJzY3JpYmVkVG8obW9kdWxlT3JFdmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnRNYW5hZ2VyLnN1YnNjcmlwdGlvbk1hbmFnZXIuaXNTdWJzY3JpYmVkVG8obW9kdWxlT3JFdmVudCwgdGhpcy50b3BMZXZlbElkKTtcbiAgICB9XG59XG5leHBvcnRzLkNkcFRhcmdldCA9IENkcFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNkcFRhcmdldC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2RwVGFyZ2V0TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IEJyb3dzaW5nQ29udGV4dEltcGxfanNfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L0Jyb3dzaW5nQ29udGV4dEltcGwuanNcIik7XG5jb25zdCBXb3JrZXJSZWFsbV9qc18xID0gcmVxdWlyZShcIi4uL3NjcmlwdC9Xb3JrZXJSZWFsbS5qc1wiKTtcbmNvbnN0IENkcFRhcmdldF9qc18xID0gcmVxdWlyZShcIi4vQ2RwVGFyZ2V0LmpzXCIpO1xuY29uc3QgY2RwVG9CaWRpVGFyZ2V0VHlwZXMgPSB7XG4gICAgc2VydmljZV93b3JrZXI6ICdzZXJ2aWNlLXdvcmtlcicsXG4gICAgc2hhcmVkX3dvcmtlcjogJ3NoYXJlZC13b3JrZXInLFxuICAgIHdvcmtlcjogJ2RlZGljYXRlZC13b3JrZXInLFxufTtcbmNsYXNzIENkcFRhcmdldE1hbmFnZXIge1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgICNjZHBDb25uZWN0aW9uO1xuICAgICNzZWxmVGFyZ2V0SWQ7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAjbmV0d29ya1N0b3JhZ2U7XG4gICAgI2FjY2VwdEluc2VjdXJlQ2VydHM7XG4gICAgI3ByZWxvYWRTY3JpcHRTdG9yYWdlO1xuICAgICNyZWFsbVN0b3JhZ2U7XG4gICAgI2RlZmF1bHRVc2VyQ29udGV4dElkO1xuICAgICNsb2dnZXI7XG4gICAgI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgIGNvbnN0cnVjdG9yKGNkcENvbm5lY3Rpb24sIGJyb3dzZXJDZHBDbGllbnQsIHNlbGZUYXJnZXRJZCwgZXZlbnRNYW5hZ2VyLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlLCBwcmVsb2FkU2NyaXB0U3RvcmFnZSwgYWNjZXB0SW5zZWN1cmVDZXJ0cywgZGVmYXVsdFVzZXJDb250ZXh0SWQsIHVuaGFuZGxlZFByb21wdEJlaGF2aW9yLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jYWNjZXB0SW5zZWN1cmVDZXJ0cyA9IGFjY2VwdEluc2VjdXJlQ2VydHM7XG4gICAgICAgIHRoaXMuI2NkcENvbm5lY3Rpb24gPSBjZHBDb25uZWN0aW9uO1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jc2VsZlRhcmdldElkID0gc2VsZlRhcmdldElkO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZSA9IHByZWxvYWRTY3JpcHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZSA9IG5ldHdvcmtTdG9yYWdlO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UgPSByZWFsbVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI2RlZmF1bHRVc2VyQ29udGV4dElkID0gZGVmYXVsdFVzZXJDb250ZXh0SWQ7XG4gICAgICAgIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yID0gdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy4jc2V0RXZlbnRMaXN0ZW5lcnMoYnJvd3NlckNkcENsaWVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBmb3IgZWFjaCBDRFAgc2Vzc2lvbiwgc2luY2UgdGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZVxuICAgICAqIGZvciBjcmVhdGluZyBhbmQgZGVzdHJveWluZyBhbGwgdGFyZ2V0cyBhbmQgYnJvd3NpbmcgY29udGV4dHMuXG4gICAgICovXG4gICAgI3NldEV2ZW50TGlzdGVuZXJzKGNkcENsaWVudCkge1xuICAgICAgICBjZHBDbGllbnQub24oJ1RhcmdldC5hdHRhY2hlZFRvVGFyZ2V0JywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdGhpcy4jaGFuZGxlQXR0YWNoZWRUb1RhcmdldEV2ZW50KHBhcmFtcywgY2RwQ2xpZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNkcENsaWVudC5vbignVGFyZ2V0LmRldGFjaGVkRnJvbVRhcmdldCcsIHRoaXMuI2hhbmRsZURldGFjaGVkRnJvbVRhcmdldEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICBjZHBDbGllbnQub24oJ1RhcmdldC50YXJnZXRJbmZvQ2hhbmdlZCcsIHRoaXMuI2hhbmRsZVRhcmdldEluZm9DaGFuZ2VkRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIGNkcENsaWVudC5vbignSW5zcGVjdG9yLnRhcmdldENyYXNoZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNoYW5kbGVUYXJnZXRDcmFzaGVkRXZlbnQoY2RwQ2xpZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNkcENsaWVudC5vbignUGFnZS5mcmFtZUF0dGFjaGVkJywgdGhpcy4jaGFuZGxlRnJhbWVBdHRhY2hlZEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICBjZHBDbGllbnQub24oJ1BhZ2UuZnJhbWVEZXRhY2hlZCcsIHRoaXMuI2hhbmRsZUZyYW1lRGV0YWNoZWRFdmVudC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgI2hhbmRsZUZyYW1lQXR0YWNoZWRFdmVudChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyZW50QnJvd3NpbmdDb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kQ29udGV4dChwYXJhbXMucGFyZW50RnJhbWVJZCk7XG4gICAgICAgIGlmIChwYXJlbnRCcm93c2luZ0NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgQnJvd3NpbmdDb250ZXh0SW1wbF9qc18xLkJyb3dzaW5nQ29udGV4dEltcGwuY3JlYXRlKHBhcmFtcy5mcmFtZUlkLCBwYXJhbXMucGFyZW50RnJhbWVJZCwgcGFyZW50QnJvd3NpbmdDb250ZXh0LnVzZXJDb250ZXh0LCBwYXJlbnRCcm93c2luZ0NvbnRleHQuY2RwVGFyZ2V0LCB0aGlzLiNldmVudE1hbmFnZXIsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHRoaXMuI3JlYWxtU3RvcmFnZSwgXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBkb24ndCBrbm93IHRoZSBVUkwgb2YgdGhlIGZyYW1lIHlldCwgc28gaXQgd2lsbCBiZSB1cGRhdGVkXG4gICAgICAgICAgICAvLyBsYXRlci5cbiAgICAgICAgICAgICdhYm91dDpibGFuaycsIHVuZGVmaW5lZCwgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2hhbmRsZUZyYW1lRGV0YWNoZWRFdmVudChwYXJhbXMpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBPT1BpRiBubyBuZWVkIGluIGRlbGV0aW5nIEJyb3dzaW5nQ29udGV4dC5cbiAgICAgICAgaWYgKHBhcmFtcy5yZWFzb24gPT09ICdzd2FwJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZENvbnRleHQocGFyYW1zLmZyYW1lSWQpPy5kaXNwb3NlKCk7XG4gICAgfVxuICAgICNoYW5kbGVBdHRhY2hlZFRvVGFyZ2V0RXZlbnQocGFyYW1zLCBwYXJlbnRTZXNzaW9uQ2RwQ2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2Vzc2lvbklkLCB0YXJnZXRJbmZvIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHRhcmdldENkcENsaWVudCA9IHRoaXMuI2NkcENvbm5lY3Rpb24uZ2V0Q2RwQ2xpZW50KHNlc3Npb25JZCk7XG4gICAgICAgIHN3aXRjaCAodGFyZ2V0SW5mby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwYWdlJzpcbiAgICAgICAgICAgIGNhc2UgJ2lmcmFtZSc6IHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SW5mby50YXJnZXRJZCA9PT0gdGhpcy4jc2VsZlRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjZHBUYXJnZXQgPSB0aGlzLiNjcmVhdGVDZHBUYXJnZXQodGFyZ2V0Q2RwQ2xpZW50LCB0YXJnZXRJbmZvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXliZUNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRDb250ZXh0KHRhcmdldEluZm8udGFyZ2V0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXliZUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT09QaUYuXG4gICAgICAgICAgICAgICAgICAgIG1heWJlQ29udGV4dC51cGRhdGVDZHBUYXJnZXQoY2RwVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJDb250ZXh0ID0gdGFyZ2V0SW5mby5icm93c2VyQ29udGV4dElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLmJyb3dzZXJDb250ZXh0SWQgIT09IHRoaXMuI2RlZmF1bHRVc2VyQ29udGV4dElkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldEluZm8uYnJvd3NlckNvbnRleHRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBjb250ZXh0LlxuICAgICAgICAgICAgICAgICAgICBCcm93c2luZ0NvbnRleHRJbXBsX2pzXzEuQnJvd3NpbmdDb250ZXh0SW1wbC5jcmVhdGUodGFyZ2V0SW5mby50YXJnZXRJZCwgbnVsbCwgdXNlckNvbnRleHQsIGNkcFRhcmdldCwgdGhpcy4jZXZlbnRNYW5hZ2VyLCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIFxuICAgICAgICAgICAgICAgICAgICAvLyBIYWNrOiB3aGVuIGEgbmV3IHRhcmdldCBjcmVhdGVkLCBDRFAgZW1pdHMgdGFyZ2V0SW5mb0NoYW5nZWQgd2l0aCBhbiBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvLyB1cmwsIGFuZCBuYXZpZ2F0ZXMgaXQgdG8gYWJvdXQ6YmxhbmsgbGF0ZXIuIFdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGV4aXN0aW5nIHRhcmdldCAocmVjb25uZWN0KSwgdGhlIHVybCBpcyBhbHJlYWR5IGtub3duLCBhbmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBldmVudHMgd2lsbCBub3QgYmUgZW1pdHRlZCBhbnltb3JlLiBSZXBsYWNpbmcgZW1wdHkgdXJsIHdpdGggYGFib3V0OmJsYW5rYFxuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgdG8gaGFuZGxlIGJvdGggY2FzZXMgaW4gdGhlIHNhbWUgd2F5LlxuICAgICAgICAgICAgICAgICAgICAvLyBcIjcuMy4yLjEgQ3JlYXRpbmcgYnJvd3NpbmcgY29udGV4dHNcIi5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9jdW1lbnQtc2VxdWVuY2VzLmh0bWwjY3JlYXRpbmctYnJvd3NpbmctY29udGV4dHNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY2hlY2sgd2hvIHRvIGRlYWwgd2l0aCBub24tbnVsbCBjcmVhdG9yIGFuZCBpdHMgYGNyZWF0b3JPcmlnaW5gLlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLnVybCA9PT0gJycgPyAnYWJvdXQ6YmxhbmsnIDogdGFyZ2V0SW5mby51cmwsIHRhcmdldEluZm8ub3BlbmVyRnJhbWVJZCA/PyB0YXJnZXRJbmZvLm9wZW5lcklkLCB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgdGhpcy4jbG9nZ2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2VydmljZV93b3JrZXInOlxuICAgICAgICAgICAgY2FzZSAnd29ya2VyJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jcmVhbG1TdG9yYWdlLmZpbmRSZWFsbSh7XG4gICAgICAgICAgICAgICAgICAgIGNkcFNlc3Npb25JZDogcGFyZW50U2Vzc2lvbkNkcENsaWVudC5zZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYnJvd3NpbmcgY29udGV4dCwgdGhpcyB3b3JrZXIgaXMgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgIGlmICghcmVhbG0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNkcFRhcmdldCA9IHRoaXMuI2NyZWF0ZUNkcFRhcmdldCh0YXJnZXRDZHBDbGllbnQsIHRhcmdldEluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhbmRsZVdvcmtlclRhcmdldChjZHBUb0JpZGlUYXJnZXRUeXBlc1t0YXJnZXRJbmZvLnR5cGVdLCBjZHBUYXJnZXQsIHJlYWxtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbiBDRFAsIHdlIG9ubHkgZW1pdCBzaGFyZWQgd29ya2VycyBvbiB0aGUgYnJvd3NlciBhbmQgbm90IHRoZSBzZXQgb2ZcbiAgICAgICAgICAgIC8vIGZyYW1lcyB0aGF0IHVzZSB0aGUgc2hhcmVkIHdvcmtlci4gSWYgd2UgY2hhbmdlIHRoaXMgaW4gdGhlIGZ1dHVyZSB0b1xuICAgICAgICAgICAgLy8gYmVoYXZlIGxpa2Ugc2VydmljZSB3b3JrZXJzIChlbWl0cyBvbiBib3RoIGJyb3dzZXIgYW5kIGZyYW1lIHRhcmdldHMpLFxuICAgICAgICAgICAgLy8gd2UgY2FuIHJlbW92ZSB0aGlzIGJsb2NrIGFuZCBtZXJnZSBzZXJ2aWNlIHdvcmtlcnMgd2l0aCB0aGUgYWJvdmUgb25lLlxuICAgICAgICAgICAgY2FzZSAnc2hhcmVkX3dvcmtlcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZHBUYXJnZXQgPSB0aGlzLiNjcmVhdGVDZHBUYXJnZXQodGFyZ2V0Q2RwQ2xpZW50LCB0YXJnZXRJbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNoYW5kbGVXb3JrZXJUYXJnZXQoY2RwVG9CaWRpVGFyZ2V0VHlwZXNbdGFyZ2V0SW5mby50eXBlXSwgY2RwVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV2VG9vbHMgb3Igc29tZSBvdGhlciBub3Qgc3VwcG9ydGVkIGJ5IEJpRGkgdGFyZ2V0LiBKdXN0IHJlbGVhc2VcbiAgICAgICAgLy8gZGVidWdnZXIgYW5kIGlnbm9yZSB0aGVtLlxuICAgICAgICB0YXJnZXRDZHBDbGllbnRcbiAgICAgICAgICAgIC5zZW5kQ29tbWFuZCgnUnVudGltZS5ydW5JZldhaXRpbmdGb3JEZWJ1Z2dlcicpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBwYXJlbnRTZXNzaW9uQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdUYXJnZXQuZGV0YWNoRnJvbVRhcmdldCcsIHBhcmFtcykpXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKSk7XG4gICAgfVxuICAgICNjcmVhdGVDZHBUYXJnZXQodGFyZ2V0Q2RwQ2xpZW50LCB0YXJnZXRJbmZvKSB7XG4gICAgICAgIHRoaXMuI3NldEV2ZW50TGlzdGVuZXJzKHRhcmdldENkcENsaWVudCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IENkcFRhcmdldF9qc18xLkNkcFRhcmdldC5jcmVhdGUodGFyZ2V0SW5mby50YXJnZXRJZCwgdGFyZ2V0Q2RwQ2xpZW50LCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LCB0aGlzLiNyZWFsbVN0b3JhZ2UsIHRoaXMuI2V2ZW50TWFuYWdlciwgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UsIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHRoaXMuI25ldHdvcmtTdG9yYWdlLCB0aGlzLiNhY2NlcHRJbnNlY3VyZUNlcnRzLCB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgdGhpcy4jbG9nZ2VyKTtcbiAgICAgICAgdGhpcy4jbmV0d29ya1N0b3JhZ2Uub25DZHBUYXJnZXRDcmVhdGVkKHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgICN3b3JrZXJzID0gbmV3IE1hcCgpO1xuICAgICNoYW5kbGVXb3JrZXJUYXJnZXQocmVhbG1UeXBlLCBjZHBUYXJnZXQsIG93bmVyUmVhbG0pIHtcbiAgICAgICAgY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGVjdXRpb25Db250ZXh0Q3JlYXRlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdW5pcXVlSWQsIGlkLCBvcmlnaW4gfSA9IHBhcmFtcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgd29ya2VyUmVhbG0gPSBuZXcgV29ya2VyUmVhbG1fanNfMS5Xb3JrZXJSZWFsbShjZHBUYXJnZXQuY2RwQ2xpZW50LCB0aGlzLiNldmVudE1hbmFnZXIsIGlkLCB0aGlzLiNsb2dnZXIsICgwLCBCcm93c2luZ0NvbnRleHRJbXBsX2pzXzEuc2VyaWFsaXplT3JpZ2luKShvcmlnaW4pLCBvd25lclJlYWxtID8gW293bmVyUmVhbG1dIDogW10sIHVuaXF1ZUlkLCB0aGlzLiNyZWFsbVN0b3JhZ2UsIHJlYWxtVHlwZSk7XG4gICAgICAgICAgICB0aGlzLiN3b3JrZXJzLnNldChjZHBUYXJnZXQuY2RwU2Vzc2lvbklkLCB3b3JrZXJSZWFsbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjaGFuZGxlRGV0YWNoZWRGcm9tVGFyZ2V0RXZlbnQoeyBzZXNzaW9uSWQsIHRhcmdldElkLCB9KSB7XG4gICAgICAgIGlmICh0YXJnZXRJZCkge1xuICAgICAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UuZmluZCh7IHRhcmdldElkIH0pLm1hcCgocHJlbG9hZFNjcmlwdCkgPT4ge1xuICAgICAgICAgICAgICAgIHByZWxvYWRTY3JpcHQuZGlzcG9zZSh0YXJnZXRJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kQ29udGV4dEJ5U2Vzc2lvbihzZXNzaW9uSWQpO1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dC5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy4jd29ya2Vycy5nZXQoc2Vzc2lvbklkKTtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlLmRlbGV0ZVJlYWxtcyh7XG4gICAgICAgICAgICAgICAgY2RwU2Vzc2lvbklkOiB3b3JrZXIuY2RwQ2xpZW50LnNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgICNoYW5kbGVUYXJnZXRJbmZvQ2hhbmdlZEV2ZW50KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5maW5kQ29udGV4dChwYXJhbXMudGFyZ2V0SW5mby50YXJnZXRJZCk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uVGFyZ2V0SW5mb0NoYW5nZWQocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjaGFuZGxlVGFyZ2V0Q3Jhc2hlZEV2ZW50KGNkcENsaWVudCkge1xuICAgICAgICAvLyBUaGlzIGlzIHByaW1hcmlseSB1c2VkIGZvciBzZXJ2aWNlIGFuZCBzaGFyZWQgd29ya2Vycy4gQ0RQIHRlbmRzIHRvIG5vdFxuICAgICAgICAvLyBzaWduYWwgdGhleSBjbG9zZWQgZ3JhY2VmdWxseSBhbmQgaW5zdGVhZCBzYXlzIHRoZXkgY3Jhc2hlZCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhleSBhcmUgY2xvc2VkLlxuICAgICAgICBjb25zdCByZWFsbXMgPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtcyh7XG4gICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IGNkcENsaWVudC5zZXNzaW9uSWQsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWxtIG9mIHJlYWxtcykge1xuICAgICAgICAgICAgcmVhbG0uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DZHBUYXJnZXRNYW5hZ2VyID0gQ2RwVGFyZ2V0TWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNkcFRhcmdldE1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0SW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuc2VyaWFsaXplT3JpZ2luID0gc2VyaWFsaXplT3JpZ2luO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGFzc2VydF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2Fzc2VydC5qc1wiKTtcbmNvbnN0IERlZmVycmVkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRGVmZXJyZWQuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCB1bml0Q29udmVyc2lvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91bml0Q29udmVyc2lvbnMuanNcIik7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXVpZFwiKTtcbmNvbnN0IFdpbmRvd1JlYWxtX2pzXzEgPSByZXF1aXJlKFwiLi4vc2NyaXB0L1dpbmRvd1JlYWxtLmpzXCIpO1xuY2xhc3MgQnJvd3NpbmdDb250ZXh0SW1wbCB7XG4gICAgc3RhdGljIExPR0dFUl9QUkVGSVggPSBgJHtsb2dfanNfMS5Mb2dUeXBlLmRlYnVnfTpicm93c2luZ0NvbnRleHRgO1xuICAgIC8qKiBUaGUgSUQgb2YgdGhpcyBicm93c2luZyBjb250ZXh0LiAqL1xuICAgICNpZDtcbiAgICB1c2VyQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHBhcmVudCBicm93c2luZyBjb250ZXh0LlxuICAgICAqIElmIG51bGwsIHRoaXMgaXMgYSB0b3AtbGV2ZWwgY29udGV4dC5cbiAgICAgKi9cbiAgICAjcGFyZW50SWQ7XG4gICAgLyoqIERpcmVjdCBjaGlsZHJlbiBicm93c2luZyBjb250ZXh0cy4gKi9cbiAgICAjY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI2xpZmVjeWNsZSA9IHtcbiAgICAgICAgRE9NQ29udGVudExvYWRlZDogbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKSxcbiAgICAgICAgbG9hZDogbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKSxcbiAgICB9O1xuICAgICNuYXZpZ2F0aW9uID0ge1xuICAgICAgICB3aXRoaW5Eb2N1bWVudDogbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKSxcbiAgICB9O1xuICAgICN1cmw7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjcmVhbG1TdG9yYWdlO1xuICAgICNsb2FkZXJJZDtcbiAgICAjY2RwVGFyZ2V0O1xuICAgIC8vIFRoZSBkZWZlcnJlZCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIGRlZmF1bHQgcmVhbG0gaXMgY3JlYXRlZC5cbiAgICAjZGVmYXVsdFJlYWxtRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRfanNfMS5EZWZlcnJlZCgpO1xuICAgICNsb2dnZXI7XG4gICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHByZXZpb3VzbHkgc2V0IHZpZXdwb3J0LlxuICAgICNwcmV2aW91c1ZpZXdwb3J0ID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgLy8gVGhlIFVSTCBvZiB0aGUgbmF2aWdhdGlvbiB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy4gQSB3b3JrYXJvdW5kIG9mIHRoZSBDRFBcbiAgICAvLyBsYWNraW5nIFVSTCBmb3IgdGhlIHBlbmRpbmcgbmF2aWdhdGlvbiBldmVudHMsIGUuZy4gYFBhZ2UuZnJhbWVTdGFydGVkTG9hZGluZ2AuXG4gICAgLy8gU2V0IG9uIGBQYWdlLm5hdmlnYXRlYCwgYFBhZ2UucmVsb2FkYCBjb21tYW5kcyBhbmQgb24gZGVwcmVjYXRlZCBDRFAgZXZlbnRcbiAgICAvLyBgUGFnZS5mcmFtZVNjaGVkdWxlZE5hdmlnYXRpb25gLlxuICAgICNwZW5kaW5nTmF2aWdhdGlvblVybDtcbiAgICAjdmlydHVhbE5hdmlnYXRpb25JZCA9ICgwLCB1dWlkXzEudXVpZHY0KSgpO1xuICAgICNvcmlnaW5hbE9wZW5lcjtcbiAgICAvLyBTZXQgd2hlbiB0aGUgdXNlciBwcm9tcHQgaXMgb3BlbmVkLiBSZXF1aXJlZCB0byBwcm92aWRlIHRoZSB0eXBlIGluIGNsb3NpbmcgZXZlbnQuXG4gICAgI2xhc3RVc2VyUHJvbXB0VHlwZTtcbiAgICAjdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I7XG4gICAgY29uc3RydWN0b3IoaWQsIHBhcmVudElkLCB1c2VyQ29udGV4dCwgY2RwVGFyZ2V0LCBldmVudE1hbmFnZXIsIGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSwgdXJsLCBvcmlnaW5hbE9wZW5lciwgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3IsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQgPSBjZHBUYXJnZXQ7XG4gICAgICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgICAgIHRoaXMuI3BhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgIHRoaXMudXNlckNvbnRleHQgPSB1c2VyQ29udGV4dDtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlID0gcmVhbG1TdG9yYWdlO1xuICAgICAgICB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciA9IHVuaGFuZGxlZFByb21wdEJlaGF2aW9yO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuI3VybCA9IHVybDtcbiAgICAgICAgdGhpcy4jb3JpZ2luYWxPcGVuZXIgPSBvcmlnaW5hbE9wZW5lcjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShpZCwgcGFyZW50SWQsIHVzZXJDb250ZXh0LCBjZHBUYXJnZXQsIGV2ZW50TWFuYWdlciwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgcmVhbG1TdG9yYWdlLCB1cmwsIG9yaWdpbmFsT3BlbmVyLCB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQnJvd3NpbmdDb250ZXh0SW1wbChpZCwgcGFyZW50SWQsIHVzZXJDb250ZXh0LCBjZHBUYXJnZXQsIGV2ZW50TWFuYWdlciwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgcmVhbG1TdG9yYWdlLCB1cmwsIG9yaWdpbmFsT3BlbmVyLCB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvciwgbG9nZ2VyKTtcbiAgICAgICAgY29udGV4dC4jaW5pdExpc3RlbmVycygpO1xuICAgICAgICBicm93c2luZ0NvbnRleHRTdG9yYWdlLmFkZENvbnRleHQoY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGV4dC5pc1RvcExldmVsQ29udGV4dCgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnBhcmVudC5hZGRDaGlsZChjb250ZXh0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Db250ZXh0Q3JlYXRlZCxcbiAgICAgICAgICAgIHBhcmFtczogY29udGV4dC5zZXJpYWxpemVUb0JpZGlWYWx1ZSgpLFxuICAgICAgICB9LCBjb250ZXh0LmlkKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgIC8vIGB0aW1lc3RhbXBgIGZyb20gdGhlIGV2ZW50IGlzIE1vbm90b25pY1RpbWUsIG5vdCByZWFsIHRpbWUsIHNvXG4gICAgICAgIC8vIHRoZSBiZXN0IE1hcHBlciBjYW4gZG8gaXMgdG8gc2V0IHRoZSB0aW1lc3RhbXAgdG8gdGhlIGVwb2NoIHRpbWVcbiAgICAgICAgLy8gb2YgdGhlIGV2ZW50IGFycml2ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9OZXR3b3JrLyN0eXBlLU1vbm90b25pY1RpbWVcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvY3VtZW50LXNlcXVlbmNlcy5odG1sI25hdmlnYWJsZVxuICAgICAqL1xuICAgIGdldCBuYXZpZ2FibGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xvYWRlcklkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWaXJ0dWFsIG5hdmlnYXRpb24gSUQuIFJlcXVpcmVkLCBhcyBDRFAgYGxvYWRlcklkYCBjYW5ub3QgYmUgbWFwcGVkIDE6MSB0byBhbGwgdGhlXG4gICAgICogbmF2aWdhdGlvbnMgKGUuZy4gc2FtZSBkb2N1bWVudCBuYXZpZ2F0aW9ucykuIFVwZGF0ZWQgYWZ0ZXIgZWFjaCBuYXZpZ2F0aW9uLFxuICAgICAqIGluY2x1ZGluZyBzYW1lLWRvY3VtZW50IG9uZXMuXG4gICAgICovXG4gICAgZ2V0IHZpcnR1YWxOYXZpZ2F0aW9uSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN2aXJ0dWFsTmF2aWdhdGlvbklkO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLiNkZWxldGVBbGxDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UuZGVsZXRlUmVhbG1zKHtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiB0aGlzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgICBpZiAoIXRoaXMuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuI2NoaWxkcmVuLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWlsIGFsbCBvbmdvaW5nIG5hdmlnYXRpb25zLlxuICAgICAgICB0aGlzLiNmYWlsTGlmZWN5Y2xlSWZOb3RGaW5pc2hlZCgpO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Db250ZXh0RGVzdHJveWVkLFxuICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnNlcmlhbGl6ZVRvQmlkaVZhbHVlKCksXG4gICAgICAgIH0sIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmRlbGV0ZUNvbnRleHRCeUlkKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgSUQgb2YgdGhpcyBjb250ZXh0LiAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgcGFyZW50IGNvbnRleHQgSUQuICovXG4gICAgZ2V0IHBhcmVudElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFyZW50SWQ7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGV4dC4gKi9cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dCh0aGlzLnBhcmVudElkKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIGRpcmVjdCBjaGlsZHJlbiBjb250ZXh0cy4gKi9cbiAgICBnZXQgZGlyZWN0Q2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy4jY2hpbGRyZW5dLm1hcCgoaWQpID0+IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChpZCkpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhbGwgY2hpbGRyZW4gY29udGV4dHMsIGZsYXR0ZW5lZC4gKi9cbiAgICBnZXQgYWxsQ2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5kaXJlY3RDaGlsZHJlbjtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLmNvbmNhdCguLi5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5hbGxDaGlsZHJlbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHRvcC1sZXZlbCBjb250ZXh0LlxuICAgICAqIFRoaXMgaXMgdGhlIGNhc2Ugd2hlbmV2ZXIgdGhlIHBhcmVudCBjb250ZXh0IElEIGlzIG51bGwuXG4gICAgICovXG4gICAgaXNUb3BMZXZlbENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnRJZCA9PT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGxldCB0b3BDb250ZXh0ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHRvcENvbnRleHQucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gdG9wQ29udGV4dC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcENvbnRleHQ7XG4gICAgfVxuICAgIGFkZENoaWxkKGNoaWxkSWQpIHtcbiAgICAgICAgdGhpcy4jY2hpbGRyZW4uYWRkKGNoaWxkSWQpO1xuICAgIH1cbiAgICAjZGVsZXRlQWxsQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0Q2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuZGlzcG9zZSgpKTtcbiAgICB9XG4gICAgZ2V0IGNkcFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NkcFRhcmdldDtcbiAgICB9XG4gICAgdXBkYXRlQ2RwVGFyZ2V0KGNkcFRhcmdldCkge1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQgPSBjZHBUYXJnZXQ7XG4gICAgICAgIHRoaXMuI2luaXRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3VybDtcbiAgICB9XG4gICAgYXN5bmMgbGlmZWN5Y2xlTG9hZGVkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUubG9hZDtcbiAgICB9XG4gICAgYXN5bmMgdGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LnVuYmxvY2tlZDtcbiAgICAgICAgaWYgKHJlc3VsdC5raW5kID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVTYW5kYm94KHNhbmRib3gpIHtcbiAgICAgICAgaWYgKHNhbmRib3ggPT09IHVuZGVmaW5lZCB8fCBzYW5kYm94ID09PSAnJykge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCByZWFsbSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjcmVhdGVkIGF0IHRoaXMgcG9pbnQsIHNvIHJldHVybiBhIGRlZmVycmVkLlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXliZVNhbmRib3hlcyA9IHRoaXMuI3JlYWxtU3RvcmFnZS5maW5kUmVhbG1zKHtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgc2FuZGJveCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXliZVNhbmRib3hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UuY3JlYXRlSXNvbGF0ZWRXb3JsZCcsIHtcbiAgICAgICAgICAgICAgICBmcmFtZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHdvcmxkTmFtZTogc2FuZGJveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYFJ1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWRgIHNob3VsZCBiZSBlbWl0dGVkIGJ5IHRoZSB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgY29tbWFuZCBpcyBkb25lLlxuICAgICAgICAgICAgbWF5YmVTYW5kYm94ZXMgPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtcyh7XG4gICAgICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0SWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgc2FuZGJveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkobWF5YmVTYW5kYm94ZXMubGVuZ3RoICE9PSAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIGZvciBtb3JlIHRoYW4gb25lIHNhbmRib3ggdG8gYmUgY3JlYXRlZCBkdWUgdG8gcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gZnJhbWVzLiBJbiB0aGlzIGNhc2UsIGl0J3MgYWx3YXlzIHRoZSBmaXJzdCBvbmUgKGkuZS4gdGhlIG9sZGVzdCBvbmUpXG4gICAgICAgIC8vIHRoYXQgaXMgbW9yZSByZWxldmFudCBzaW5jZSB0aGUgdXNlciBtYXkgaGF2ZSBzZXQgdGhhdCBvbmUgdXAgYWxyZWFkeVxuICAgICAgICAvLyB0aHJvdWdoIGV2YWx1YXRpb24uXG4gICAgICAgIHJldHVybiBtYXliZVNhbmRib3hlc1swXTtcbiAgICB9XG4gICAgc2VyaWFsaXplVG9CaWRpVmFsdWUobWF4RGVwdGggPSAwLCBhZGRQYXJlbnRGaWVsZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuI2lkLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLnVzZXJDb250ZXh0LFxuICAgICAgICAgICAgb3JpZ2luYWxPcGVuZXI6IHRoaXMuI29yaWdpbmFsT3BlbmVyID8/IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlbjogbWF4RGVwdGggPiAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLmRpcmVjdENoaWxkcmVuLm1hcCgoYykgPT4gYy5zZXJpYWxpemVUb0JpZGlWYWx1ZShtYXhEZXB0aCAtIDEsIGZhbHNlKSlcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAuLi4oYWRkUGFyZW50RmllbGQgPyB7IHBhcmVudDogdGhpcy4jcGFyZW50SWQgfSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25UYXJnZXRJbmZvQ2hhbmdlZChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy4jdXJsID0gcGFyYW1zLnRhcmdldEluZm8udXJsO1xuICAgIH1cbiAgICAjaW5pdExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUGFnZS5mcmFtZU5hdmlnYXRlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkICE9PSBwYXJhbXMuZnJhbWUuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiN1cmwgPSBwYXJhbXMuZnJhbWUudXJsICsgKHBhcmFtcy5mcmFtZS51cmxGcmFnbWVudCA/PyAnJyk7XG4gICAgICAgICAgICB0aGlzLiNwZW5kaW5nTmF2aWdhdGlvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIEF0IHRoZSBwb2ludCB0aGUgcGFnZSBpcyBpbml0aWFsaXplZCwgYWxsIHRoZSBuZXN0ZWQgaWZyYW1lcyBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgcGFnZSBhcmUgZGV0YWNoZWQgYW5kIHJlYWxtcyBhcmUgZGVzdHJveWVkLlxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIGZyb20gY29udGV4dC5cbiAgICAgICAgICAgIHRoaXMuI2RlbGV0ZUFsbENoaWxkcmVuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50Lm9uKCdQYWdlLm5hdmlnYXRlZFdpdGhpbkRvY3VtZW50JywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQgIT09IHBhcmFtcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBCcm93c2luZ0NvbnRleHRJbXBsLmdldFRpbWVzdGFtcCgpO1xuICAgICAgICAgICAgdGhpcy4jdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgICAgIHRoaXMuI25hdmlnYXRpb24ud2l0aGluRG9jdW1lbnQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5GcmFnbWVudE5hdmlnYXRlZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuI3VybCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgdGhpcy5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50Lm9uKCdQYWdlLmZyYW1lU3RhcnRlZExvYWRpbmcnLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCAhPT0gcGFyYW1zLmZyYW1lSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB2aXJ0dWFsIG5hdmlnYXRpb24gaWQuXG4gICAgICAgICAgICB0aGlzLiN2aXJ0dWFsTmF2aWdhdGlvbklkID0gKDAsIHV1aWRfMS51dWlkdjQpKCk7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLk5hdmlnYXRpb25TdGFydGVkLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uOiB0aGlzLiN2aXJ0dWFsTmF2aWdhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IEJyb3dzaW5nQ29udGV4dEltcGwuZ2V0VGltZXN0YW1wKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBVUkwgb2YgdGhlIG5hdmlnYXRpb24gdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuIEFsdGhvdWdoIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHlldCBrbm93biBpbiBjYXNlIG9mIHVzZXItaW5pdGlhdGVkIG5hdmlnYXRpb25zLCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlIHRoZSBVUkwgaW4gY2FzZSBvZiBCaURpLWluaXRpYXRlZCBuYXZpZ2F0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcHJvdmlkZSBwcm9wZXIgVVJMIGluIGNhc2Ugb2YgdXNlci1pbml0aWF0ZWQgbmF2aWdhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPz8gJ1VOS05PV04nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IGRvbid0IHVzZSBkZXByZWNhdGVkIGBQYWdlLmZyYW1lU2NoZWR1bGVkTmF2aWdhdGlvbmAgZXZlbnQuXG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1BhZ2UuZnJhbWVTY2hlZHVsZWROYXZpZ2F0aW9uJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaWQgIT09IHBhcmFtcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPSBwYXJhbXMudXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUGFnZS5saWZlY3ljbGVFdmVudCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkICE9PSBwYXJhbXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZG9jdW1lbnRDaGFuZ2VkKHBhcmFtcy5sb2FkZXJJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5uYW1lID09PSAnY29tbWl0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvYWRlcklkID0gcGFyYW1zLmxvYWRlcklkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG1hcHBlciBhdHRhY2hlZCB0byB0aGUgcGFnZSBsYXRlLCBpdCBtaWdodCBtaXNzIGluaXQgYW5kXG4gICAgICAgICAgICAvLyBjb21taXQgZXZlbnRzLiBJbiB0aGF0IGNhc2UsIHNhdmUgdGhlIGZpcnN0IGxvYWRlcklkIGZvciB0aGlzXG4gICAgICAgICAgICAvLyBmcmFtZUlkLlxuICAgICAgICAgICAgaWYgKCF0aGlzLiNsb2FkZXJJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvYWRlcklkID0gcGFyYW1zLmxvYWRlcklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50IGZyb20gbm90IGN1cnJlbnQgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgIGlmIChwYXJhbXMubG9hZGVySWQgIT09IHRoaXMuI2xvYWRlcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gQnJvd3NpbmdDb250ZXh0SW1wbC5nZXRUaW1lc3RhbXAoKTtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdET01Db250ZW50TG9hZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuRG9tQ29udGVudExvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiN1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbGlmZWN5Y2xlLkRPTUNvbnRlbnRMb2FkZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMuTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLiN1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbGlmZWN5Y2xlLmxvYWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1J1bnRpbWUuZXhlY3V0aW9uQ29udGV4dENyZWF0ZWQnLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGF1eERhdGEsIG5hbWUsIHVuaXF1ZUlkLCBpZCB9ID0gcGFyYW1zLmNvbnRleHQ7XG4gICAgICAgICAgICBpZiAoIWF1eERhdGEgfHwgYXV4RGF0YS5mcmFtZUlkICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9yaWdpbjtcbiAgICAgICAgICAgIGxldCBzYW5kYm94O1xuICAgICAgICAgICAgLy8gT25seSB0aGVzZSBleGVjdXRpb24gY29udGV4dHMgYXJlIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAgICAgICAgc3dpdGNoIChhdXhEYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdpc29sYXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHNhbmRib3ggPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYW5kYm94IHNob3VsZCBoYXZlIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY29udGV4dCBpdHNlbGYsIGJ1dCBpbiBDRFBcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgaGFzIGFuIGVtcHR5IG9uZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsICdVbmV4cGVjdGVkbHksIGlzb2xhdGVkIHJlYWxtIGNyZWF0ZWQgYmVmb3JlIHRoZSBkZWZhdWx0IG9uZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkLmlzRmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQucmVzdWx0Lm9yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgOiAvLyBUaGlzIGZhbGxiYWNrIGlzIG5vdCBleHBlY3RlZCB0byBiZSBldmVyIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZXJpYWxpemVPcmlnaW4ocGFyYW1zLmNvbnRleHQub3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhbG0gPSBuZXcgV2luZG93UmVhbG1fanNfMS5XaW5kb3dSZWFsbSh0aGlzLmlkLCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LCB0aGlzLiNldmVudE1hbmFnZXIsIGlkLCB0aGlzLiNsb2dnZXIsIG9yaWdpbiwgdW5pcXVlSWQsIHRoaXMuI3JlYWxtU3RvcmFnZSwgc2FuZGJveCk7XG4gICAgICAgICAgICBpZiAoYXV4RGF0YS5pc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5yZXNvbHZlKHJlYWxtKTtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIENoYW5uZWxQcm94eSBsaXN0ZW5lcnMgZm9yIGFsbCB0aGUgY2hhbm5lbHMgb2YgYWxsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZWxvYWQgc2NyaXB0cyByZWxhdGVkIHRvIHRoaXMgQnJvd3NpbmdDb250ZXh0LlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGV4dGVuZCBmb3Igbm90IGRlZmF1bHQgcmVhbG1zIGJ5IHRoZSBzYW5kYm94IG5hbWUuXG4gICAgICAgICAgICAgICAgdm9pZCBQcm9taXNlLmFsbCh0aGlzLiNjZHBUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgLmdldENoYW5uZWxzKClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5zdGFydExpc3RlbmVyRnJvbVdpbmRvdyhyZWFsbSwgdGhpcy4jZXZlbnRNYW5hZ2VyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGVjdXRpb25Db250ZXh0RGVzdHJveWVkJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkLmlzRmluaXNoZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5yZXN1bHQuZXhlY3V0aW9uQ29udGV4dElkID09PVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZXhlY3V0aW9uQ29udGV4dElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGVmYXVsdFJlYWxtRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRfanNfMS5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlLmRlbGV0ZVJlYWxtcyh7XG4gICAgICAgICAgICAgICAgY2RwU2Vzc2lvbklkOiB0aGlzLiNjZHBUYXJnZXQuY2RwU2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogcGFyYW1zLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGVjdXRpb25Db250ZXh0c0NsZWFyZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZC5yZWplY3QobmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKCdleGVjdXRpb24gY29udGV4dHMgY2xlYXJlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRSZWFsbURlZmVycmVkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZS5kZWxldGVSZWFsbXMoe1xuICAgICAgICAgICAgICAgIGNkcFNlc3Npb25JZDogdGhpcy4jY2RwVGFyZ2V0LmNkcFNlc3Npb25JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUGFnZS5qYXZhc2NyaXB0RGlhbG9nQ2xvc2VkJywgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWNjZXB0ZWQgPSBwYXJhbXMucmVzdWx0O1xuICAgICAgICAgICAgaWYgKHRoaXMuI2xhc3RVc2VyUHJvbXB0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5kZWJ1Z0Vycm9yLCAnVW5leHBlY3RlZGx5IG5vIG9wZW5pbmcgcHJvbXB0IGV2ZW50IGJlZm9yZSBjbG9zaW5nIG9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Vc2VyUHJvbXB0Q2xvc2VkLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGxhc3RVc2VyUHJvbXB0VHlwZWAgc2hvdWxkIG5ldmVyIGJlIHVuZGVmaW5lZCBoZXJlLCBzbyBmYWxsYmFjayB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBgVU5LTk9XTmAuIFRoZSBmYWxsYmFjayBpcyByZXF1aXJlZCB0byBwcmV2ZW50IHRlc3RzIGZyb20gaGFuZ2luZyB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3YWl0aW5nIGZvciB0aGUgY2xvc2luZyBldmVudC4gVGhlIGNhc3QgaXMgcmVxdWlyZWQsIGFzIHRoZSBgVU5LTk9XTmAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHN0YW5kYXJkLlxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLiNsYXN0VXNlclByb21wdFR5cGUgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICdVTktOT1dOJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlclRleHQ6IGFjY2VwdGVkICYmIHBhcmFtcy51c2VySW5wdXQgPyBwYXJhbXMudXNlcklucHV0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgIHRoaXMuI2xhc3RVc2VyUHJvbXB0VHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1BhZ2UuamF2YXNjcmlwdERpYWxvZ09wZW5pbmcnLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9tcHRUeXBlID0gQnJvd3NpbmdDb250ZXh0SW1wbC4jZ2V0UHJvbXB0VHlwZShwYXJhbXMudHlwZSk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGxhc3QgcHJvbXB0IHR5cGUgdG8gcHJvdmlkZSBpdCBpbiBjbG9zaW5nIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy4jbGFzdFVzZXJQcm9tcHRUeXBlID0gcHJvbXB0VHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdEhhbmRsZXIgPSB0aGlzLiNnZXRQcm9tcHRIYW5kbGVyKHByb21wdFR5cGUpO1xuICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcy5Vc2VyUHJvbXB0T3BlbmVkLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBwcm9tcHRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBwcm9tcHRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJhbXMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHBhcmFtcy50eXBlID09PSAncHJvbXB0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGRlZmF1bHRWYWx1ZTogcGFyYW1zLmRlZmF1bHRQcm9tcHQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIHRoaXMuaWQpO1xuICAgICAgICAgICAgc3dpdGNoIChwcm9tcHRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQmFzZWQgb24gYHVuaGFuZGxlZFByb21wdEJlaGF2aW9yYCwgY2hlY2sgaWYgdGhlIHByb21wdCBzaG91bGQgYmUgaGFuZGxlZFxuICAgICAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgKGBhY2NlcHRgLCBgZGlzbWlzc2ApIG9yIHdhaXQgZm9yIHRoZSB1c2VyIHRvIGRvIGl0LlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FjY2VwdCc6XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5oYW5kbGVVc2VyUHJvbXB0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNtaXNzJzpcbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLmhhbmRsZVVzZXJQcm9tcHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyAjZ2V0UHJvbXB0VHlwZShjZHBUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAoY2RwVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYWxlcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImFsZXJ0XCIgLyogQnJvd3NpbmdDb250ZXh0LlVzZXJQcm9tcHRUeXBlLkFsZXJ0ICovO1xuICAgICAgICAgICAgY2FzZSAnYmVmb3JldW5sb2FkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJiZWZvcmV1bmxvYWRcIiAvKiBCcm93c2luZ0NvbnRleHQuVXNlclByb21wdFR5cGUuQmVmb3JldW5sb2FkICovO1xuICAgICAgICAgICAgY2FzZSAnY29uZmlybSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29uZmlybVwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Db25maXJtICovO1xuICAgICAgICAgICAgY2FzZSAncHJvbXB0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9tcHRcIiAvKiBCcm93c2luZ0NvbnRleHQuVXNlclByb21wdFR5cGUuUHJvbXB0ICovO1xuICAgICAgICB9XG4gICAgfVxuICAgICNnZXRQcm9tcHRIYW5kbGVyKHByb21wdFR5cGUpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFByb21wdEhhbmRsZXIgPSAnZGlzbWlzcyc7XG4gICAgICAgIHN3aXRjaCAocHJvbXB0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFsZXJ0XCIgLyogQnJvd3NpbmdDb250ZXh0LlVzZXJQcm9tcHRUeXBlLkFsZXJ0ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmFsZXJ0ID8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yPy5kZWZhdWx0ID8/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9tcHRIYW5kbGVyKTtcbiAgICAgICAgICAgIGNhc2UgXCJiZWZvcmV1bmxvYWRcIiAvKiBCcm93c2luZ0NvbnRleHQuVXNlclByb21wdFR5cGUuQmVmb3JldW5sb2FkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmJlZm9yZVVubG9hZCA/P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcj8uZGVmYXVsdCA/P1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvbXB0SGFuZGxlcik7XG4gICAgICAgICAgICBjYXNlIFwiY29uZmlybVwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Db25maXJtICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmNvbmZpcm0gPz9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3I/LmRlZmF1bHQgPz9cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb21wdEhhbmRsZXIpO1xuICAgICAgICAgICAgY2FzZSBcInByb21wdFwiIC8qIEJyb3dzaW5nQ29udGV4dC5Vc2VyUHJvbXB0VHlwZS5Qcm9tcHQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcj8ucHJvbXB0ID8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VuaGFuZGxlZFByb21wdEJlaGF2aW9yPy5kZWZhdWx0ID8/XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm9tcHRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjZG9jdW1lbnRDaGFuZ2VkKGxvYWRlcklkKSB7XG4gICAgICAgIC8vIFNhbWUgZG9jdW1lbnQgbmF2aWdhdGlvbi5cbiAgICAgICAgaWYgKGxvYWRlcklkID09PSB1bmRlZmluZWQgfHwgdGhpcy4jbG9hZGVySWQgPT09IGxvYWRlcklkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jbmF2aWdhdGlvbi53aXRoaW5Eb2N1bWVudC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbi53aXRoaW5Eb2N1bWVudCA9IG5ldyBEZWZlcnJlZF9qc18xLkRlZmVycmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsb2dnZXI/LihCcm93c2luZ0NvbnRleHRJbXBsLkxPR0dFUl9QUkVGSVgsICdEb2N1bWVudCBjaGFuZ2VkIChuYXZpZ2F0ZWRXaXRoaW5Eb2N1bWVudCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXNldExpZmVjeWNsZUlmRmluaXNoZWQoKTtcbiAgICAgICAgdGhpcy4jbG9hZGVySWQgPSBsb2FkZXJJZDtcbiAgICB9XG4gICAgI3Jlc2V0TGlmZWN5Y2xlSWZGaW5pc2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKEJyb3dzaW5nQ29udGV4dEltcGwuTE9HR0VSX1BSRUZJWCwgJ0RvY3VtZW50IGNoYW5nZWQgKERPTUNvbnRlbnRMb2FkZWQpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2xpZmVjeWNsZS5sb2FkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5sb2FkID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKEJyb3dzaW5nQ29udGV4dEltcGwuTE9HR0VSX1BSRUZJWCwgJ0RvY3VtZW50IGNoYW5nZWQgKGxvYWQpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZhaWxMaWZlY3ljbGVJZk5vdEZpbmlzaGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2xpZmVjeWNsZS5ET01Db250ZW50TG9hZGVkLnJlamVjdChuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oJ25hdmlnYXRpb24gY2FuY2VsZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLiNsaWZlY3ljbGUubG9hZC5pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLiNsaWZlY3ljbGUubG9hZC5yZWplY3QobmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKCduYXZpZ2F0aW9uIGNhbmNlbGVkJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlKHVybCwgd2FpdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFVSTCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgSW52YWxpZCBVUkw6ICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgbmF2aWdhdGlvbiBVUkwgdG8gcHJvdmlkZSBpdCBpbiBgYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25TdGFydGVkYFxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogZGV0ZWN0IG5hdmlnYXRpb24gc3RhcnQgbm90IGZyb20gQ0RQLiBDaGVjayBpZlxuICAgICAgICAvLyAgYFBhZ2UuZnJhbWVSZXF1ZXN0ZWROYXZpZ2F0aW9uYCBjYW4gYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICB0aGlzLiNwZW5kaW5nTmF2aWdhdGlvblVybCA9IHVybDtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGxvYWRpbmcgZXJyb3JzLlxuICAgICAgICBjb25zdCBjZHBOYXZpZ2F0ZVJlc3VsdCA9IGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UubmF2aWdhdGUnLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBmcmFtZUlkOiB0aGlzLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNkcE5hdmlnYXRlUmVzdWx0LmVycm9yVGV4dCkge1xuICAgICAgICAgICAgLy8gSWYgbmF2aWdhdGlvbiBmYWlsZWQsIG5vIHBlbmRpbmcgbmF2aWdhdGlvbiBpcyBsZWZ0LlxuICAgICAgICAgICAgdGhpcy4jcGVuZGluZ05hdmlnYXRpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLk5hdmlnYXRpb25GYWlsZWQsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogQnJvd3NpbmdDb250ZXh0SW1wbC5nZXRUaW1lc3RhbXAoKSxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB0aGlzLmlkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbihjZHBOYXZpZ2F0ZVJlc3VsdC5lcnJvclRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RvY3VtZW50Q2hhbmdlZChjZHBOYXZpZ2F0ZVJlc3VsdC5sb2FkZXJJZCk7XG4gICAgICAgIHN3aXRjaCAod2FpdCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmFjdGl2ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5JbnRlcmFjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICAvLyBObyBgbG9hZGVySWRgIG1lYW5zIHNhbWUtZG9jdW1lbnQgbmF2aWdhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoY2RwTmF2aWdhdGVSZXN1bHQubG9hZGVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNuYXZpZ2F0aW9uLndpdGhpbkRvY3VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jbGlmZWN5Y2xlLkRPTUNvbnRlbnRMb2FkZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvbXBsZXRlXCIgLyogQnJvd3NpbmdDb250ZXh0LlJlYWRpbmVzc1N0YXRlLkNvbXBsZXRlICovOlxuICAgICAgICAgICAgICAgIC8vIE5vIGBsb2FkZXJJZGAgbWVhbnMgc2FtZS1kb2N1bWVudCBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChjZHBOYXZpZ2F0ZVJlc3VsdC5sb2FkZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI25hdmlnYXRpb24ud2l0aGluRG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUubG9hZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI3ZpcnR1YWxOYXZpZ2F0aW9uSWQsXG4gICAgICAgICAgICAvLyBVcmwgY2FuIGNoYW5nZSBkdWUgdG8gcmVkaXJlY3QgZ2V0IHRoZSBsYXRlc3Qgb25lLlxuICAgICAgICAgICAgdXJsOiB3YWl0ID09PSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLyA/IHVybCA6IHRoaXMuI3VybCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVsb2FkKGlnbm9yZUNhY2hlLCB3YWl0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpO1xuICAgICAgICB0aGlzLiNyZXNldExpZmVjeWNsZUlmRmluaXNoZWQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5yZWxvYWQnLCB7XG4gICAgICAgICAgICBpZ25vcmVDYWNoZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHN3aXRjaCAod2FpdCkge1xuICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnRlcmFjdGl2ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5JbnRlcmFjdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUuRE9NQ29udGVudExvYWRlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiIC8qIEJyb3dzaW5nQ29udGV4dC5SZWFkaW5lc3NTdGF0ZS5Db21wbGV0ZSAqLzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNsaWZlY3ljbGUubG9hZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmF2aWdhdGlvbjogdGhpcy4jdmlydHVhbE5hdmlnYXRpb25JZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNldFZpZXdwb3J0KHZpZXdwb3J0LCBkZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgIGlmICh2aWV3cG9ydCA9PT0gbnVsbCAmJiBkZXZpY2VQaXhlbFJhdGlvID09PSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdFbXVsYXRpb24uY2xlYXJEZXZpY2VNZXRyaWNzT3ZlcnJpZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGFwcGxpZWRWaWV3cG9ydDtcbiAgICAgICAgICAgICAgICBpZiAodmlld3BvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVmlld3BvcnQgPSB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2aWV3cG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVmlld3BvcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0ID0gYXBwbGllZFZpZXdwb3J0O1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0VtdWxhdGlvbi5zZXREZXZpY2VNZXRyaWNzT3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLiNwcmV2aW91c1ZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuI3ByZXZpb3VzVmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBkZXZpY2VTY2FsZUZhY3RvcjogZGV2aWNlUGl4ZWxSYXRpbyA/IGRldmljZVBpeGVsUmF0aW8gOiAwLFxuICAgICAgICAgICAgICAgICAgICBtb2JpbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkb250U2V0VmlzaWJsZVNpemU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jcnNyYy5vcmcvYy9jb250ZW50L2Jyb3dzZXIvZGV2dG9vbHMvcHJvdG9jb2wvZW11bGF0aW9uX2hhbmRsZXIuY2M7bD0yNTc7ZHJjPTJmNmVlZTg0Y2Y5OGQ0MjI3ZTdjNDE3MThkZDcxYjgyZjI2ZDkwZmZcbiAgICAgICAgICAgICAgICAnV2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgbXVzdCBiZSBwb3NpdGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKCdQcm92aWRlZCB2aWV3cG9ydCBkaW1lbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVVc2VyUHJvbXB0KGFjY2VwdCwgdXNlclRleHQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5oYW5kbGVKYXZhU2NyaXB0RGlhbG9nJywge1xuICAgICAgICAgICAgYWNjZXB0OiBhY2NlcHQgPz8gdHJ1ZSxcbiAgICAgICAgICAgIHByb21wdFRleHQ6IHVzZXJUZXh0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgYWN0aXZhdGUoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UuYnJpbmdUb0Zyb250Jyk7XG4gICAgfVxuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5zaG90KHBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oYE5vbi10b3AtbGV2ZWwgJ2NvbnRleHQnICgke3BhcmFtcy5jb250ZXh0fSkgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXRQYXJhbWV0ZXJzID0gZ2V0SW1hZ2VGb3JtYXRQYXJhbWV0ZXJzKHBhcmFtcyk7XG4gICAgICAgIC8vIFhYWDogRm9jdXMgdGhlIG9yaWdpbmFsIHRhYiBhZnRlciB0aGUgc2NyZWVuc2hvdCBpcyB0YWtlbi5cbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgc2NyZWVuc2hvdCBnZXRzIGJsb2NrZWQgdW50aWwgdGhlIGFjdGl2ZSB0YWIgZ2V0cyBmb2N1cy5cbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5icmluZ1RvRnJvbnQnKTtcbiAgICAgICAgbGV0IGNhcHR1cmVCZXlvbmRWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICBsZXQgc2NyaXB0O1xuICAgICAgICBwYXJhbXMub3JpZ2luID8/PSAndmlld3BvcnQnO1xuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5vcmlnaW4pIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IFN0cmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50LnNjcm9sbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQmV5b25kVmlld3BvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAndmlld3BvcnQnOiB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gU3RyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB2aWV3cG9ydC5wYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHZpZXdwb3J0LnBhZ2VUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFsbSA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG9yaWdpblJlc3VsdCA9IGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihzY3JpcHQsIGZhbHNlKTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkob3JpZ2luUmVzdWx0LnR5cGUgPT09ICdzdWNjZXNzJyk7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IGRlc2VyaWFsaXplRE9NUmVjdChvcmlnaW5SZXN1bHQucmVzdWx0KTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkob3JpZ2luKTtcbiAgICAgICAgbGV0IHJlY3QgPSBvcmlnaW47XG4gICAgICAgIGlmIChwYXJhbXMuY2xpcCkge1xuICAgICAgICAgICAgY29uc3QgY2xpcCA9IHBhcmFtcy5jbGlwO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5vcmlnaW4gPT09ICd2aWV3cG9ydCcgJiYgY2xpcC50eXBlID09PSAnYm94Jykge1xuICAgICAgICAgICAgICAgIC8vIEZvciB2aWV3cG9ydCBvcmlnaW4sIHRoZSBjbGlwIGlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCwgd2hpbGUgdGhlIENEUFxuICAgICAgICAgICAgICAgIC8vIHNjcmVlbnNob3QgaXMgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LiBTbyBjb3JyZWN0aW9uIGZvciB0aGUgdmlld3BvcnQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAvLyBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICBjbGlwLnggKz0gb3JpZ2luLng7XG4gICAgICAgICAgICAgICAgY2xpcC55ICs9IG9yaWdpbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdCA9IGdldEludGVyc2VjdGlvblJlY3QoYXdhaXQgdGhpcy4jcGFyc2VSZWN0KGNsaXApLCBvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWN0LndpZHRoID09PSAwIHx8IHJlY3QuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb0NhcHR1cmVTY3JlZW5FeGNlcHRpb24oYFVuYWJsZSB0byBjYXB0dXJlIHNjcmVlbnNob3Qgd2l0aCB6ZXJvIGRpbWVuc2lvbnM6IHdpZHRoPSR7cmVjdC53aWR0aH0sIGhlaWdodD0ke3JlY3QuaGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmNhcHR1cmVTY3JlZW5zaG90Jywge1xuICAgICAgICAgICAgY2xpcDogeyAuLi5yZWN0LCBzY2FsZTogMS4wIH0sXG4gICAgICAgICAgICAuLi5mb3JtYXRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY2FwdHVyZUJleW9uZFZpZXdwb3J0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHJpbnQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNkcFBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAocGFyYW1zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnByaW50QmFja2dyb3VuZCA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWFyZ2luPy5ib3R0b20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLm1hcmdpbkJvdHRvbSA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4uYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1hcmdpbj8ubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjZHBQYXJhbXMubWFyZ2luTGVmdCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4ubGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5tYXJnaW4/LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5tYXJnaW5SaWdodCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4ucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMubWFyZ2luPy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLm1hcmdpblRvcCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5tYXJnaW4udG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm9yaWVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5sYW5kc2NhcGUgPSBwYXJhbXMub3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMucGFnZT8uaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNkcFBhcmFtcy5wYXBlckhlaWdodCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5wYWdlLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5wYWdlPy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjZHBQYXJhbXMucGFwZXJXaWR0aCA9ICgwLCB1bml0Q29udmVyc2lvbnNfanNfMS5pbmNoZXNGcm9tQ20pKHBhcmFtcy5wYWdlLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLnBhZ2VSYW5nZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiBwYXJhbXMucGFnZVJhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZVBhcnRzID0gcmFuZ2Uuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VQYXJ0cy5sZW5ndGggPCAxIHx8IHJhbmdlUGFydHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgcGFnZSByYW5nZTogJHtyYW5nZX0gaXMgbm90IGEgdmFsaWQgaW50ZWdlciByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlUGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgcGFyc2VJbnRlZ2VyKHJhbmdlUGFydHNbMF0gPz8gJycpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyQm91bmQ7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JhbmdlTG93ZXJQYXJ0ID0gJycsIHJhbmdlVXBwZXJQYXJ0ID0gJyddID0gcmFuZ2VQYXJ0cztcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VMb3dlclBhcnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZCA9IHBhcnNlSW50ZWdlcihyYW5nZUxvd2VyUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVVwcGVyUGFydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZCA9IHBhcnNlSW50ZWdlcihyYW5nZVVwcGVyUGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsb3dlckJvdW5kID4gdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgcGFnZSByYW5nZTogJHtyYW5nZUxvd2VyUGFydH0gPiAke3JhbmdlVXBwZXJQYXJ0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNkcFBhcmFtcy5wYWdlUmFuZ2VzID0gcGFyYW1zLnBhZ2VSYW5nZXMuam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnNjYWxlID0gcGFyYW1zLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuc2hyaW5rVG9GaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2RwUGFyYW1zLnByZWZlckNTU1BhZ2VTaXplID0gIXBhcmFtcy5zaHJpbmtUb0ZpdDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5wcmludFRvUERGJywgY2RwUGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRWZmZWN0aXZlbHkgemVybyBkaW1lbnNpb25zLlxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09XG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgcHJpbnQgcGFyYW1ldGVyczogY29udGVudCBhcmVhIGlzIGVtcHR5Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlXG4gICAgICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyM6fjp0ZXh0PUlmJTIwY29tbWFuZCUyMHBhcmFtZXRlcnMlMjBjb250YWlucyUyMCUyMmNsaXAlMjIlM0FcbiAgICAgKi9cbiAgICBhc3luYyAjcGFyc2VSZWN0KGNsaXApIHtcbiAgICAgICAgc3dpdGNoIChjbGlwLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2JveCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogY2xpcC54LCB5OiBjbGlwLnksIHdpZHRoOiBjbGlwLndpZHRoLCBoZWlnaHQ6IGNsaXAuaGVpZ2h0IH07XG4gICAgICAgICAgICBjYXNlICdlbGVtZW50Jzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86ICMxMjEzOiBVc2UgY3VzdG9tIHNhbmRib3ggc3BlY2lmaWNhbGx5IGZvciBDaHJvbWl1bSBCaURpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuZGJveCA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FuZGJveC5jYWxsRnVuY3Rpb24oU3RyaW5nKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KSwgZmFsc2UsIHsgdHlwZTogJ3VuZGVmaW5lZCcgfSwgW2NsaXAuZWxlbWVudF0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gJ2V4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbihgRWxlbWVudCAnJHtjbGlwLmVsZW1lbnQuc2hhcmVkSWR9JyB3YXMgbm90IGZvdW5kYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC5yZXN1bHQudHlwZSA9PT0gJ2Jvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5yZXN1bHQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbihgTm9kZSAnJHtjbGlwLmVsZW1lbnQuc2hhcmVkSWR9JyBpcyBub3QgYW4gRWxlbWVudGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhbmRib3guY2FsbEZ1bmN0aW9uKFN0cmluZygoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHJlY3QueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiByZWN0LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLCBmYWxzZSwgeyB0eXBlOiAndW5kZWZpbmVkJyB9LCBbY2xpcC5lbGVtZW50XSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHJlc3VsdC50eXBlID09PSAnc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWN0ID0gZGVzZXJpYWxpemVET01SZWN0KHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVuYWJsZVRvQ2FwdHVyZVNjcmVlbkV4Y2VwdGlvbihgQ291bGQgbm90IGdldCBib3VuZGluZyBib3ggZm9yIEVsZW1lbnQgJyR7Y2xpcC5lbGVtZW50LnNoYXJlZElkfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UuY2xvc2UnKTtcbiAgICB9XG4gICAgYXN5bmMgdHJhdmVyc2VIaXN0b3J5KGRlbHRhKSB7XG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLmdldE5hdmlnYXRpb25IaXN0b3J5Jyk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuY3VycmVudEluZGV4ICsgZGVsdGFdO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hIaXN0b3J5RW50cnlFeGNlcHRpb24oYE5vIGhpc3RvcnkgZW50cnkgYXQgZGVsdGEgJHtkZWx0YX1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLiNjZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdQYWdlLm5hdmlnYXRlVG9IaXN0b3J5RW50cnknLCB7XG4gICAgICAgICAgICBlbnRyeUlkOiBlbnRyeS5pZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHRvZ2dsZU1vZHVsZXNJZk5lZWRlZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jY2RwVGFyZ2V0LnRvZ2dsZU5ldHdvcmtJZk5lZWRlZCgpO1xuICAgIH1cbiAgICBhc3luYyBsb2NhdGVOb2RlcyhwYXJhbXMpIHtcbiAgICAgICAgLy8gVE9ETzogY3JlYXRlIGEgZGVkaWNhdGVkIHNhbmRib3ggaW5zdGVhZCBvZiBgI2RlZmF1bHRSZWFsbWAuXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNsb2NhdGVOb2Rlc0J5TG9jYXRvcihhd2FpdCB0aGlzLiNkZWZhdWx0UmVhbG1EZWZlcnJlZCwgcGFyYW1zLmxvY2F0b3IsIHBhcmFtcy5zdGFydE5vZGVzID8/IFtdLCBwYXJhbXMubWF4Tm9kZUNvdW50LCBwYXJhbXMuc2VyaWFsaXphdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0TG9jYXRvckRlbGVnYXRlKHJlYWxtLCBsb2NhdG9yLCBtYXhOb2RlQ291bnQsIHN0YXJ0Tm9kZXMpIHtcbiAgICAgICAgc3dpdGNoIChsb2NhdG9yLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nzcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChjc3NTZWxlY3RvciwgbWF4Tm9kZUNvdW50LCAuLi5zdGFydE5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGVOb2Rlc1VzaW5nQ3NzID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCBpbnN0YW5jZW9mIERvY3VtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0Tm9kZXMgaW4gY3NzIHNlbGVjdG9yIHNob3VsZCBiZSBIVE1MRWxlbWVudCwgRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChjc3NTZWxlY3RvcildO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXMgPSBzdGFydE5vZGVzLmxlbmd0aCA+IDAgPyBzdGFydE5vZGVzIDogW2RvY3VtZW50LmJvZHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuZWROb2RlcyA9IHN0YXJ0Tm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChzdGFydE5vZGUpID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogc3RvcCBzZWFyY2ggZWFybHkgaWYgYG1heE5vZGVDb3VudGAgaXMgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0ZU5vZGVzVXNpbmdDc3Moc3RhcnROb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXhOb2RlQ291bnQgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJldHVybmVkTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybmVkTm9kZXMuc2xpY2UoMCwgbWF4Tm9kZUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xvY2FsVmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgY3NzU2VsZWN0b3JgXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbG9jYXRvci52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYG1heE5vZGVDb3VudGAgd2l0aCBgMGAgbWVhbnMgbm8gbGltaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdudW1iZXInLCB2YWx1ZTogbWF4Tm9kZUNvdW50ID8/IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBzdGFydE5vZGVzYFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhcnROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAneHBhdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZygoeFBhdGhTZWxlY3RvciwgbWF4Tm9kZUNvdW50LCAuLi5zdGFydE5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI2xvY2F0ZS1ub2Rlcy11c2luZy14cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZhbHVhdG9yID0gbmV3IFhQYXRoRXZhbHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZXZhbHVhdG9yLmNyZWF0ZUV4cHJlc3Npb24oeFBhdGhTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGVOb2Rlc1VzaW5nWHBhdGggPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhQYXRoUmVzdWx0ID0gZXhwcmVzc2lvbi5ldmFsdWF0ZShlbGVtZW50LCBYUGF0aFJlc3VsdC5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuZWROb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeFBhdGhSZXN1bHQuc25hcHNob3RMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLnB1c2goeFBhdGhSZXN1bHQuc25hcHNob3RJdGVtKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlcyA9IHN0YXJ0Tm9kZXMubGVuZ3RoID4gMCA/IHN0YXJ0Tm9kZXMgOiBbZG9jdW1lbnQuYm9keV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5lZE5vZGVzID0gc3RhcnROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHN0YXJ0Tm9kZSkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdG9wIHNlYXJjaCBlYXJseSBpZiBgbWF4Tm9kZUNvdW50YCBpcyByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRlTm9kZXNVc2luZ1hwYXRoKHN0YXJ0Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZsYXQoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4Tm9kZUNvdW50ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZXR1cm5lZE5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXR1cm5lZE5vZGVzLnNsaWNlKDAsIG1heE5vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNMb2NhbFZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHhQYXRoU2VsZWN0b3JgXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbG9jYXRvci52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYG1heE5vZGVDb3VudGAgd2l0aCBgMGAgbWVhbnMgbm8gbGltaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdudW1iZXInLCB2YWx1ZTogbWF4Tm9kZUNvdW50ID8/IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBzdGFydE5vZGVzYFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhcnROb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnaW5uZXJUZXh0JzpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI2xvY2F0ZS1ub2Rlcy11c2luZy1pbm5lci10ZXh0XG4gICAgICAgICAgICAgICAgaWYgKGxvY2F0b3IudmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRTZWxlY3RvckV4Y2VwdGlvbignaW5uZXJUZXh0IGxvY2F0b3IgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZygoaW5uZXJUZXh0U2VsZWN0b3IsIGZ1bGxNYXRjaCwgaWdub3JlQ2FzZSwgbWF4Tm9kZUNvdW50LCBtYXhEZXB0aCwgLi4uc3RhcnROb2RlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoVGV4dCA9IGlnbm9yZUNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGlubmVyVGV4dFNlbGVjdG9yLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyVGV4dFNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRlTm9kZXNVc2luZ0lubmVyVGV4dCA9IChub2RlLCBjdXJyZW50TWF4RGVwdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5lZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFsuLi5ub2RlLmNoaWxkcmVuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgY3VycmVudE1heERlcHRoYCBpcyBub3QgZGVjcmVtZW50ZWQgaW50ZW50aW9uYWxseSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJkcml2ZXItYmlkaS9wdWxsLzcxMy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWROb2Rlcy5wdXNoKC4uLmxvY2F0ZU5vZGVzVXNpbmdJbm5lclRleHQoY2hpbGQsIGN1cnJlbnRNYXhEZXB0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSW5uZXJUZXh0ID0gaWdub3JlQ2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVsZW1lbnQuaW5uZXJUZXh0Py50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZWxlbWVudC5pbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlSW5uZXJUZXh0LmluY2x1ZGVzKHNlYXJjaFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bGxNYXRjaCAmJiBub2RlSW5uZXJUZXh0ID09PSBzZWFyY2hUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGBub2RlSW5uZXJUZXh0LmluY2x1ZGVzKHNlYXJjaFRleHQpYCBpcyBhbHJlYWR5IGNoZWNrZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZU1hdGNoZXMgPSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2VhcmNoIGRlZXBlciBpZiBgbWF4RGVwdGhgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNYXhEZXB0aCA8PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjaGlsZCkgPT4gbG9jYXRlTm9kZXNVc2luZ0lubmVyVGV4dChjaGlsZCwgY3VycmVudE1heERlcHRoIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZsYXQoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogYG5vZGVJbm5lclRleHQuaW5jbHVkZXMoc2VhcmNoVGV4dClgIGlzIGFscmVhZHkgY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmdWxsTWF0Y2ggfHwgbm9kZUlubmVyVGV4dCA9PT0gc2VhcmNoVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkTm9kZXMucHVzaCguLi5jaGlsZE5vZGVNYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdG9wIHNlYXJjaCBlYXJseSBpZiBgbWF4Tm9kZUNvdW50YCBpcyByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5lZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN0b3Agc2VhcmNoIGVhcmx5IGlmIGBtYXhOb2RlQ291bnRgIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5vZGVzID0gc3RhcnROb2Rlcy5sZW5ndGggPiAwID8gc3RhcnROb2RlcyA6IFtkb2N1bWVudF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5lZE5vZGVzID0gc3RhcnROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHN0YXJ0Tm9kZSkgPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdG9wIHNlYXJjaCBlYXJseSBpZiBgbWF4Tm9kZUNvdW50YCBpcyByZWFjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRlTm9kZXNVc2luZ0lubmVyVGV4dChzdGFydE5vZGUsIG1heERlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmxhdCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXhOb2RlQ291bnQgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJldHVybmVkTm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybmVkTm9kZXMuc2xpY2UoMCwgbWF4Tm9kZUNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xvY2FsVmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgaW5uZXJUZXh0U2VsZWN0b3JgXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbG9jYXRvci52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGZ1bGxNYXRjaGAgd2l0aCBkZWZhdWx0IGB0cnVlYC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Jvb2xlYW4nLCB2YWx1ZTogbG9jYXRvci5tYXRjaFR5cGUgIT09ICdwYXJ0aWFsJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGlnbm9yZUNhc2VgIHdpdGggZGVmYXVsdCBgZmFsc2VgLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnYm9vbGVhbicsIHZhbHVlOiBsb2NhdG9yLmlnbm9yZUNhc2UgPT09IHRydWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBtYXhOb2RlQ291bnRgIHdpdGggYDBgIG1lYW5zIG5vIGxpbWl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IG1heE5vZGVDb3VudCA/PyAwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgbWF4RGVwdGhgIHdpdGggZGVmYXVsdCBgMTAwMGAgKHNhbWUgYXMgZGVmYXVsdCBmdWxsIHNlcmlhbGl6YXRpb24gZGVwdGgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IGxvY2F0b3IubWF4RGVwdGggPz8gMTAwMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHN0YXJ0Tm9kZXNgXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGFydE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdhY2Nlc3NpYmlsaXR5Jzoge1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jbG9jYXRlLW5vZGVzLXVzaW5nLWFjY2Vzc2liaWxpdHktYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmICghbG9jYXRvci52YWx1ZS5uYW1lICYmICFsb2NhdG9yLnZhbHVlLnJvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZFNlbGVjdG9yRXhjZXB0aW9uKCdFaXRoZXIgbmFtZSBvciByb2xlIGhhcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5leHQgdHdvIGNvbW1hbmRzIGNhdXNlIGExMXkgY2FjaGVzIGZvciB0aGUgdGFyZ2V0IHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VydmVkLiBXZSBwcm9iYWJseSBkbyBub3QgbmVlZCB0byBkaXNhYmxlIHRoZW0gaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50IGlzIHVzaW5nIGExMXkgZmVhdHVyZXMsIGJ1dCB3ZSBjb3VsZCBieSBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gQWNjZXNzaWJpbGl0eS5kaXNhYmxlLlxuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnQWNjZXNzaWJpbGl0eS5lbmFibGUnKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnQWNjZXNzaWJpbGl0eS5nZXRSb290QVhOb2RlJyksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBhd2FpdCByZWFsbS5ldmFsdWF0ZShcbiAgICAgICAgICAgICAgICAvKiBleHByZXNzaW9uPSovICcoe2dldEFjY2Vzc2libGVOYW1lLCBnZXRBY2Nlc3NpYmxlUm9sZX0pJywgXG4gICAgICAgICAgICAgICAgLyogYXdhaXRQcm9taXNlPSovIGZhbHNlLCBcInJvb3RcIiAvKiBTY3JpcHQuUmVzdWx0T3duZXJzaGlwLlJvb3QgKi8sIFxuICAgICAgICAgICAgICAgIC8qIHNlcmlhbGl6YXRpb25PcHRpb25zPSAqLyB1bmRlZmluZWQsIFxuICAgICAgICAgICAgICAgIC8qIHVzZXJBY3RpdmF0aW9uPSovIGZhbHNlLCBcbiAgICAgICAgICAgICAgICAvKiBpbmNsdWRlQ29tbWFuZExpbmVBcGk9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdzLnR5cGUgIT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYmluZGluZ3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmdzLnJlc3VsdC50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgYmluZGluZ3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChuYW1lLCByb2xlLCBiaW5kaW5ncywgbWF4Tm9kZUNvdW50LCAuLi5zdGFydE5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5lZE5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29sbGVjdChjb250ZXh0Tm9kZXMsIHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRleHROb2RlIG9mIGNvbnRleHROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3Iucm9sZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm9sZSA9IGJpbmRpbmdzLmdldEFjY2Vzc2libGVSb2xlKGNvbnRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5yb2xlICE9PSByb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGJpbmRpbmdzLmdldEFjY2Vzc2libGVOYW1lKGNvbnRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhOb2RlQ291bnQgIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLmxlbmd0aCA9PT0gbWF4Tm9kZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZE5vZGVzLnB1c2goY29udGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjb250ZXh0Tm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3QoY2hpbGROb2Rlcywgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZXMgPSBzdGFydE5vZGVzLmxlbmd0aCA+IDAgPyBzdGFydE5vZGVzIDogW2RvY3VtZW50LmJvZHldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdChzdGFydE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuZWROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0xvY2FsVmFsdWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgbmFtZWBcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ3N0cmluZycsIHZhbHVlOiBsb2NhdG9yLnZhbHVlLm5hbWUgfHwgJycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGByb2xlYFxuICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlOiAnc3RyaW5nJywgdmFsdWU6IGxvY2F0b3IudmFsdWUucm9sZSB8fCAnJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGJpbmRpbmdzYC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgaGFuZGxlOiBiaW5kaW5ncy5yZXN1bHQuaGFuZGxlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgbWF4Tm9kZUNvdW50YCB3aXRoIGAwYCBtZWFucyBubyBsaW1pdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ251bWJlcicsIHZhbHVlOiBtYXhOb2RlQ291bnQgPz8gMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHN0YXJ0Tm9kZXNgXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGFydE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2xvY2F0ZU5vZGVzQnlMb2NhdG9yKHJlYWxtLCBsb2NhdG9yLCBzdGFydE5vZGVzLCBtYXhOb2RlQ291bnQsIHNlcmlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0b3JEZWxlZ2F0ZSA9IGF3YWl0IHRoaXMuI2dldExvY2F0b3JEZWxlZ2F0ZShyZWFsbSwgbG9jYXRvciwgbWF4Tm9kZUNvdW50LCBzdGFydE5vZGVzKTtcbiAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi5zZXJpYWxpemF0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgaXMgYW4gYXJyYXkgb2Ygbm9kZXMsIHNvIG5vIG5lZWQgaW4gZGVlcGVyIEpTIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICBtYXhPYmplY3REZXB0aDogMSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbG9jYXRvclJlc3VsdCA9IGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihsb2NhdG9yRGVsZWdhdGUuZnVuY3Rpb25EZWNsYXJhdGlvbiwgZmFsc2UsIHsgdHlwZTogJ3VuZGVmaW5lZCcgfSwgbG9jYXRvckRlbGVnYXRlLmFyZ3VtZW50c0xvY2FsVmFsdWVzLCBcIm5vbmVcIiAvKiBTY3JpcHQuUmVzdWx0T3duZXJzaGlwLk5vbmUgKi8sIHNlcmlhbGl6YXRpb25PcHRpb25zKTtcbiAgICAgICAgaWYgKGxvY2F0b3JSZXN1bHQudHlwZSAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/LihCcm93c2luZ0NvbnRleHRJbXBsLkxPR0dFUl9QUkVGSVgsICdGYWlsZWQgbG9jYXRlTm9kZXNCeUxvY2F0b3InLCBsb2NhdG9yUmVzdWx0KTtcbiAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlY3QgaW52YWxpZCBzZWxlY3RvciBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHNlbGVjdG9ycy5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIENTUyBzZWxlY3Rvci5cbiAgICAgICAgICAgIGxvY2F0b3JSZXN1bHQuZXhjZXB0aW9uRGV0YWlscy50ZXh0Py5lbmRzV2l0aCgnaXMgbm90IGEgdmFsaWQgc2VsZWN0b3IuJykgfHxcbiAgICAgICAgICAgICAgICAvLyBYUGF0aCBzZWxlY3Rvci5cbiAgICAgICAgICAgICAgICBsb2NhdG9yUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMudGV4dD8uZW5kc1dpdGgoJ2lzIG5vdCBhIHZhbGlkIFhQYXRoIGV4cHJlc3Npb24uJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24oYE5vdCB2YWxpZCBzZWxlY3RvciAke3R5cGVvZiBsb2NhdG9yLnZhbHVlID09PSAnc3RyaW5nJyA/IGxvY2F0b3IudmFsdWUgOiBKU09OLnN0cmluZ2lmeShsb2NhdG9yLnZhbHVlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlY3QgaWYgdGhlIGBzdGFydE5vZGVgIGlzIG5vdCBhbiBgSFRNTEVsZW1lbnRgIGluIGNzcyBzZWxlY3Rvci5cbiAgICAgICAgICAgIGlmIChsb2NhdG9yUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMudGV4dCA9PT1cbiAgICAgICAgICAgICAgICAnRXJyb3I6IHN0YXJ0Tm9kZXMgaW4gY3NzIHNlbGVjdG9yIHNob3VsZCBiZSBIVE1MRWxlbWVudCwgRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ3N0YXJ0Tm9kZXMgaW4gY3NzIHNlbGVjdG9yIHNob3VsZCBiZSBIVE1MRWxlbWVudCwgRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGBVbmV4cGVjdGVkIGVycm9yIGluIHNlbGVjdG9yIHNjcmlwdDogJHtsb2NhdG9yUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMudGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRvclJlc3VsdC5yZXN1bHQudHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGBVbmV4cGVjdGVkIHNlbGVjdG9yIHNjcmlwdCByZXN1bHQgdHlwZTogJHtsb2NhdG9yUmVzdWx0LnJlc3VsdC50eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoZXJlIGFyZSBubyBub24tbm9kZSBlbGVtZW50cyBpbiB0aGUgcmVzdWx0LlxuICAgICAgICBjb25zdCBub2RlcyA9IGxvY2F0b3JSZXN1bHQucmVzdWx0LnZhbHVlLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Vbmtub3duRXJyb3JFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VsZWN0b3Igc2NyaXB0IHJlc3VsdCBlbGVtZW50OiAke3ZhbHVlLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBub2RlcyB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0SW1wbCA9IEJyb3dzaW5nQ29udGV4dEltcGw7XG5mdW5jdGlvbiBzZXJpYWxpemVPcmlnaW4ob3JpZ2luKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjYXNjaWktc2VyaWFsaXNhdGlvbi1vZi1hbi1vcmlnaW5cbiAgICBpZiAoWyc6Ly8nLCAnJ10uaW5jbHVkZXMob3JpZ2luKSkge1xuICAgICAgICBvcmlnaW4gPSAnbnVsbCc7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW47XG59XG5mdW5jdGlvbiBnZXRJbWFnZUZvcm1hdFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgY29uc3QgeyBxdWFsaXR5LCB0eXBlIH0gPSBwYXJhbXMuZm9ybWF0ID8/IHtcbiAgICAgICAgdHlwZTogJ2ltYWdlL3BuZycsXG4gICAgfTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW1hZ2UvcG5nJzoge1xuICAgICAgICAgICAgcmV0dXJuIHsgZm9ybWF0OiAncG5nJyB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ltYWdlL2pwZWcnOiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAgICAgICAgICAgIC4uLihxdWFsaXR5ID09PSB1bmRlZmluZWQgPyB7fSA6IHsgcXVhbGl0eTogTWF0aC5yb3VuZChxdWFsaXR5ICogMTAwKSB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW1hZ2Uvd2VicCc6IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnd2VicCcsXG4gICAgICAgICAgICAgICAgLi4uKHF1YWxpdHkgPT09IHVuZGVmaW5lZCA/IHt9IDogeyBxdWFsaXR5OiBNYXRoLnJvdW5kKHF1YWxpdHkgKiAxMDApIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEltYWdlIGZvcm1hdCAnJHt0eXBlfScgaXMgbm90IGEgc3VwcG9ydGVkIGZvcm1hdGApO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVET01SZWN0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQudHlwZSAhPT0gJ29iamVjdCcgfHwgcmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcmVzdWx0LnZhbHVlLmZpbmQoKFtrZXldKSA9PiB7XG4gICAgICAgIHJldHVybiBrZXkgPT09ICd4JztcbiAgICB9KT8uWzFdO1xuICAgIGNvbnN0IHkgPSByZXN1bHQudmFsdWUuZmluZCgoW2tleV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ3knO1xuICAgIH0pPy5bMV07XG4gICAgY29uc3QgaGVpZ2h0ID0gcmVzdWx0LnZhbHVlLmZpbmQoKFtrZXldKSA9PiB7XG4gICAgICAgIHJldHVybiBrZXkgPT09ICdoZWlnaHQnO1xuICAgIH0pPy5bMV07XG4gICAgY29uc3Qgd2lkdGggPSByZXN1bHQudmFsdWUuZmluZCgoW2tleV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGtleSA9PT0gJ3dpZHRoJztcbiAgICB9KT8uWzFdO1xuICAgIGlmICh4Py50eXBlICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICB5Py50eXBlICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBoZWlnaHQ/LnR5cGUgIT09ICdudW1iZXInIHx8XG4gICAgICAgIHdpZHRoPy50eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgudmFsdWUsXG4gICAgICAgIHk6IHkudmFsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWUsXG4gICAgfTtcbn1cbi8qKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jbm9ybWFsaXplLXJlY3QgKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QoYm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uKGJveC53aWR0aCA8IDBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHg6IGJveC54ICsgYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAtYm94LndpZHRoLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgeDogYm94LngsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGJveC53aWR0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAuLi4oYm94LmhlaWdodCA8IDBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHk6IGJveC55ICsgYm94LmhlaWdodCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IC1ib3guaGVpZ2h0LFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgeTogYm94LnksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBib3guaGVpZ2h0LFxuICAgICAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jcmVjdGFuZ2xlLWludGVyc2VjdGlvbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUmVjdChmaXJzdCwgc2Vjb25kKSB7XG4gICAgZmlyc3QgPSBub3JtYWxpemVSZWN0KGZpcnN0KTtcbiAgICBzZWNvbmQgPSBub3JtYWxpemVSZWN0KHNlY29uZCk7XG4gICAgY29uc3QgeCA9IE1hdGgubWF4KGZpcnN0LngsIHNlY29uZC54KTtcbiAgICBjb25zdCB5ID0gTWF0aC5tYXgoZmlyc3QueSwgc2Vjb25kLnkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heChNYXRoLm1pbihmaXJzdC54ICsgZmlyc3Qud2lkdGgsIHNlY29uZC54ICsgc2Vjb25kLndpZHRoKSAtIHgsIDApLFxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KE1hdGgubWluKGZpcnN0LnkgKyBmaXJzdC5oZWlnaHQsIHNlY29uZC55ICsgc2Vjb25kLmhlaWdodCkgLSB5LCAwKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VJbnRlZ2VyKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgaWYgKCEvXlswLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgSW52YWxpZCBpbnRlZ2VyOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NpbmdDb250ZXh0SW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0UHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNsYXNzIEJyb3dzaW5nQ29udGV4dFByb2Nlc3NvciB7XG4gICAgI2Jyb3dzZXJDZHBDbGllbnQ7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyQ2RwQ2xpZW50LCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCBldmVudE1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudCA9IGJyb3dzZXJDZHBDbGllbnQ7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5hZGRTdWJzY3JpYmVIb29rKHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLkNvbnRleHRDcmVhdGVkLCB0aGlzLiNvbkNvbnRleHRDcmVhdGVkU3Vic2NyaWJlSG9vay5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgZ2V0VHJlZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0Q29udGV4dHMgPSBwYXJhbXMucm9vdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0VG9wTGV2ZWxDb250ZXh0cygpXG4gICAgICAgICAgICA6IFt0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLnJvb3QpXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHRzOiByZXN1bHRDb250ZXh0cy5tYXAoKGMpID0+IGMuc2VyaWFsaXplVG9CaWRpVmFsdWUocGFyYW1zLm1heERlcHRoID8/IE51bWJlci5NQVhfVkFMVUUpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICBsZXQgcmVmZXJlbmNlQ29udGV4dDtcbiAgICAgICAgbGV0IHVzZXJDb250ZXh0ID0gJ2RlZmF1bHQnO1xuICAgICAgICBpZiAocGFyYW1zLnJlZmVyZW5jZUNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMucmVmZXJlbmNlQ29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIXJlZmVyZW5jZUNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgcmVmZXJlbmNlQ29udGV4dCBzaG91bGQgYmUgYSB0b3AtbGV2ZWwgY29udGV4dGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlckNvbnRleHQgPSByZWZlcmVuY2VDb250ZXh0LnVzZXJDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMudXNlckNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlckNvbnRleHQgPSBwYXJhbXMudXNlckNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdDb250ZXh0cyA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2VcbiAgICAgICAgICAgIC5nZXRBbGxDb250ZXh0cygpXG4gICAgICAgICAgICAuZmlsdGVyKChjb250ZXh0KSA9PiBjb250ZXh0LnVzZXJDb250ZXh0ID09PSB1c2VyQ29udGV4dCk7XG4gICAgICAgIGxldCBuZXdXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRhYlwiIC8qIEJyb3dzaW5nQ29udGV4dC5DcmVhdGVUeXBlLlRhYiAqLzpcbiAgICAgICAgICAgICAgICBuZXdXaW5kb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ3aW5kb3dcIiAvKiBCcm93c2luZ0NvbnRleHQuQ3JlYXRlVHlwZS5XaW5kb3cgKi86XG4gICAgICAgICAgICAgICAgbmV3V2luZG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4aXN0aW5nQ29udGV4dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY29udGV4dHMgaW4gdGhlIGdpdmVuIHVzZXIgY29udGV4dCwgd2UgbmVlZCB0byBzZXRcbiAgICAgICAgICAgIC8vIG5ld1dpbmRvdyB0byB0cnVlIGFzIG5ld1dpbmRvdz1mYWxzZSB3aWxsIGJlIHJlamVjdGVkLlxuICAgICAgICAgICAgbmV3V2luZG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmNyZWF0ZVRhcmdldCcsIHtcbiAgICAgICAgICAgICAgICB1cmw6ICdhYm91dDpibGFuaycsXG4gICAgICAgICAgICAgICAgbmV3V2luZG93LFxuICAgICAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0SWQ6IHVzZXJDb250ZXh0ID09PSAnZGVmYXVsdCcgPyB1bmRlZmluZWQgOiB1c2VyQ29udGV4dCxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBwYXJhbXMuYmFja2dyb3VuZCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjpjaHJvbWUvYnJvd3Nlci9kZXZ0b29scy9wcm90b2NvbC90YXJnZXRfaGFuZGxlci5jYztsPTkwO2RyYz1lODAzOTJhYzExZTQ4YTY5MWY0MzA5OTY0Y2FiODNhM2E1OWUwMWM4XG4gICAgICAgICAgICBlcnIubWVzc2FnZS5zdGFydHNXaXRoKCdGYWlsZWQgdG8gZmluZCBicm93c2VyIGNvbnRleHQgd2l0aCBpZCcpIHx8XG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vc291cmNlLmNocm9taXVtLm9yZy9jaHJvbWl1bS9jaHJvbWl1bS9zcmMvKy9tYWluOmhlYWRsZXNzL2xpYi9icm93c2VyL3Byb3RvY29sL3RhcmdldF9oYW5kbGVyLmNjO2w9NDk7ZHJjPWU4MDM5MmFjMTFlNDhhNjkxZjQzMDk5NjRjYWI4M2EzYTU5ZTAxYzhcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ2Jyb3dzZXJDb250ZXh0SWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb24oYFRoZSBjb250ZXh0ICR7dXNlckNvbnRleHR9IHdhcyBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgbmV3IHRhYiB0byBiZSBsb2FkZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIGluIHRoZVxuICAgICAgICAvLyBgYnJvd3NpbmdDb250ZXh0YCBldmVudHMsIHdoZW4gdGhlIGBicm93c2luZ0NvbnRleHQuZG9tQ29udGVudExvYWRlZGAgYW5kXG4gICAgICAgIC8vIGBicm93c2luZ0NvbnRleHQubG9hZGAgZXZlbnRzIGZyb20gdGhlIGluaXRpYWwgYGFib3V0OmJsYW5rYCBuYXZpZ2F0aW9uXG4gICAgICAgIC8vIGFyZSBlbWl0dGVkIGFmdGVyIHRoZSBuZXh0IG5hdmlnYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgICAgLy8gRGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL3dlYi1wbGF0Zm9ybS10ZXN0cy93cHQvaXNzdWVzLzM1ODQ2XG4gICAgICAgIGNvbnN0IGNvbnRleHRJZCA9IHJlc3VsdC50YXJnZXRJZDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChjb250ZXh0SWQpO1xuICAgICAgICBhd2FpdCBjb250ZXh0LmxpZmVjeWNsZUxvYWRlZCgpO1xuICAgICAgICByZXR1cm4geyBjb250ZXh0OiBjb250ZXh0LmlkIH07XG4gICAgfVxuICAgIG5hdmlnYXRlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQubmF2aWdhdGUocGFyYW1zLnVybCwgcGFyYW1zLndhaXQgPz8gXCJub25lXCIgLyogQnJvd3NpbmdDb250ZXh0LlJlYWRpbmVzc1N0YXRlLk5vbmUgKi8pO1xuICAgIH1cbiAgICByZWxvYWQocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gY29udGV4dC5yZWxvYWQocGFyYW1zLmlnbm9yZUNhY2hlID8/IGZhbHNlLCBwYXJhbXMud2FpdCA/PyBcIm5vbmVcIiAvKiBCcm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuTm9uZSAqLyk7XG4gICAgfVxuICAgIGFzeW5jIGFjdGl2YXRlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250ZXh0LmlzVG9wTGV2ZWxDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignQWN0aXZhdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiB0aGUgdG9wLWxldmVsIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBjb250ZXh0LmFjdGl2YXRlKCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgY2FwdHVyZVNjcmVlbnNob3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY29udGV4dC5jYXB0dXJlU2NyZWVuc2hvdChwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBwcmludChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBjb250ZXh0LnByaW50KHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFZpZXdwb3J0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250ZXh0LmlzVG9wTGV2ZWxDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignRW11bGF0aW5nIHZpZXdwb3J0IGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRoZSB0b3AtbGV2ZWwgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbnRleHQuc2V0Vmlld3BvcnQocGFyYW1zLnZpZXdwb3J0LCBwYXJhbXMuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgdHJhdmVyc2VIaXN0b3J5KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYE5vIGJyb3dzaW5nIGNvbnRleHQgd2l0aCBpZCAke3BhcmFtcy5jb250ZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGNvbnRleHQudHJhdmVyc2VIaXN0b3J5KHBhcmFtcy5kZWx0YSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVXNlclByb21wdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjb250ZXh0LmhhbmRsZVVzZXJQcm9tcHQocGFyYW1zLmFjY2VwdCwgcGFyYW1zLnVzZXJUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEhldXJpc3RpY2FsbHkgZGV0ZXJtaW5lIHRoZSBlcnJvclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46Y29udGVudC9icm93c2VyL2RldnRvb2xzL3Byb3RvY29sL3BhZ2VfaGFuZGxlci5jYztsPTEwODU/cT0lMjJObyUyMGRpYWxvZyUyMGlzJTIwc2hvd2luZyUyMiZzcz1jaHJvbWl1bVxuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdObyBkaWFsb2cgaXMgc2hvd2luZycpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoQWxlcnRFeGNlcHRpb24oJ05vIGRpYWxvZyBpcyBzaG93aW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250ZXh0LmlzVG9wTGV2ZWxDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgTm9uIHRvcC1sZXZlbCBicm93c2luZyBjb250ZXh0ICR7Y29udGV4dC5pZH0gY2Fubm90IGJlIGNsb3NlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGV0YWNoZWRGcm9tVGFyZ2V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25Db250ZXh0RGVzdHJveWVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXRJZCA9PT0gcGFyYW1zLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQub2ZmKCdUYXJnZXQuZGV0YWNoZWRGcm9tVGFyZ2V0Jywgb25Db250ZXh0RGVzdHJveWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NlckNkcENsaWVudC5vbignVGFyZ2V0LmRldGFjaGVkRnJvbVRhcmdldCcsIG9uQ29udGV4dERlc3Ryb3llZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucHJvbXB0VW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29udGV4dC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnVGFyZ2V0LmNsb3NlVGFyZ2V0Jywge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZDogcGFyYW1zLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgQ0RQIGNvbW1hbmQgZmluaXNoZXMgYmVmb3JlIGBkZXRhY2hlZEZyb21UYXJnZXRgIGV2ZW50LFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGFmdGVyLiBXYWl0IGZvciB0aGUgQ0RQIGNvbW1hbmQgdG8gYmUgZmluaXNoZWQsIGFuZCB0aGVuIHdhaXRcbiAgICAgICAgICAgIC8vIGZvciBgZGV0YWNoZWRGcm9tVGFyZ2V0YCBpZiBpdCBoYXNuJ3QgZW1pdHRlZC5cbiAgICAgICAgICAgIGF3YWl0IGRldGFjaGVkRnJvbVRhcmdldFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBTd2FsbG93IGVycm9yIHRoYXQgYXJpc2UgZnJvbSB0aGUgcGFnZSBiZWluZyBkZXN0cm95ZWRcbiAgICAgICAgICAgIC8vIEV4YW1wbGUgaXMgbmF2aWdhdGluZyB0byBmYXVsdHkgU1NMIGNlcnRpZmljYXRlXG4gICAgICAgICAgICBpZiAoIShlcnJvci5jb2RlID09PSAtMzIwMDAgLyogQ2RwRXJyb3JDb25zdGFudHMuR0VORVJJQ19FUlJPUiAqLyAmJlxuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPT09ICdOb3QgYXR0YWNoZWQgdG8gYW4gYWN0aXZlIHBhZ2UnKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgbG9jYXRlTm9kZXMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgY29udGV4dC5sb2NhdGVOb2RlcyhwYXJhbXMpO1xuICAgIH1cbiAgICAjb25Db250ZXh0Q3JlYXRlZFN1YnNjcmliZUhvb2soY29udGV4dElkKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoY29udGV4dElkKTtcbiAgICAgICAgY29uc3QgY29udGV4dHNUb1JlcG9ydCA9IFtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAuLi50aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoY29udGV4dElkKS5hbGxDaGlsZHJlbixcbiAgICAgICAgXTtcbiAgICAgICAgY29udGV4dHNUb1JlcG9ydC5mb3JFYWNoKChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzLkNvbnRleHRDcmVhdGVkLFxuICAgICAgICAgICAgICAgIHBhcmFtczogY29udGV4dC5zZXJpYWxpemVUb0JpZGlWYWx1ZSgpLFxuICAgICAgICAgICAgfSwgY29udGV4dC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IgPSBCcm93c2luZ0NvbnRleHRQcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2luZ0NvbnRleHRQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG4vKiogQ29udGFpbmVyIGNsYXNzIGZvciBicm93c2luZyBjb250ZXh0cy4gKi9cbmNsYXNzIEJyb3dzaW5nQ29udGV4dFN0b3JhZ2Uge1xuICAgIC8qKiBNYXAgZnJvbSBjb250ZXh0IElEIHRvIGNvbnRleHQgaW1wbGVtZW50YXRpb24uICovXG4gICAgI2NvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgIC8qKiBHZXRzIGFsbCB0b3AtbGV2ZWwgY29udGV4dHMsIGkuZS4gdGhvc2Ugd2l0aCBubyBwYXJlbnQuICovXG4gICAgZ2V0VG9wTGV2ZWxDb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsQ29udGV4dHMoKS5maWx0ZXIoKGNvbnRleHQpID0+IGNvbnRleHQuaXNUb3BMZXZlbENvbnRleHQoKSk7XG4gICAgfVxuICAgIC8qKiBHZXRzIGFsbCBjb250ZXh0cy4gKi9cbiAgICBnZXRBbGxDb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy4jY29udGV4dHMudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKiogRGVsZXRlcyB0aGUgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBJRC4gKi9cbiAgICBkZWxldGVDb250ZXh0QnlJZChpZCkge1xuICAgICAgICB0aGlzLiNjb250ZXh0cy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICAvKiogRGVsZXRlcyB0aGUgZ2l2ZW4gY29udGV4dC4gKi9cbiAgICBkZWxldGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy4jY29udGV4dHMuZGVsZXRlKGNvbnRleHQuaWQpO1xuICAgIH1cbiAgICAvKiogVHJhY2tzIHRoZSBnaXZlbiBjb250ZXh0LiAqL1xuICAgIGFkZENvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLiNjb250ZXh0cy5zZXQoY29udGV4dC5pZCwgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgd2hldGhlciB0aGVyZSBpcyBhbiBleGlzdGluZyBjb250ZXh0IHdpdGggdGhlIGdpdmVuIElELiAqL1xuICAgIGhhc0NvbnRleHQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbnRleHRzLmhhcyhpZCk7XG4gICAgfVxuICAgIC8qKiBHZXRzIHRoZSBjb250ZXh0IHdpdGggdGhlIGdpdmVuIElELCBpZiBhbnkuICovXG4gICAgZmluZENvbnRleHQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NvbnRleHRzLmdldChpZCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSB0b3AtbGV2ZWwgY29udGV4dCBJRCBvZiB0aGUgZ2l2ZW4gY29udGV4dCwgaWYgYW55LiAqL1xuICAgIGZpbmRUb3BMZXZlbENvbnRleHRJZChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heWJlQ29udGV4dCA9IHRoaXMuZmluZENvbnRleHQoaWQpO1xuICAgICAgICBjb25zdCBwYXJlbnRJZCA9IG1heWJlQ29udGV4dD8ucGFyZW50SWQgPz8gbnVsbDtcbiAgICAgICAgaWYgKHBhcmVudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRvcExldmVsQ29udGV4dElkKHBhcmVudElkKTtcbiAgICB9XG4gICAgZmluZENvbnRleHRCeVNlc3Npb24oc2Vzc2lvbklkKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29udGV4dCBvZiB0aGlzLiNjb250ZXh0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuY2RwVGFyZ2V0LmNkcFNlc3Npb25JZCA9PT0gc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBJRCwgaWYgYW55LCBvdGhlcndpc2UgdGhyb3dzLiAqL1xuICAgIGdldENvbnRleHQoaWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5maW5kQ29udGV4dChpZCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRnJhbWVFeGNlcHRpb24oYENvbnRleHQgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmVyaWZ5VG9wTGV2ZWxDb250ZXh0c0xpc3QoY29udGV4dHMpIHtcbiAgICAgICAgY29uc3QgZm91bmRDb250ZXh0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKCFjb250ZXh0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kQ29udGV4dHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0SWQgb2YgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY29udGV4dElkKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmlzVG9wTGV2ZWxDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZENvbnRleHRzLmFkZChjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgTm9uIHRvcC1sZXZlbCBjb250ZXh0ICcke2NvbnRleHRJZH0nIGdpdmVuLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZENvbnRleHRzO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IEJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2luZ0NvbnRleHRTdG9yYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjdGlvbkRpc3BhdGNoZXIgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvYXNzZXJ0LmpzXCIpO1xuY29uc3QgR3JhcGhlbWVUb29sc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL0dyYXBoZW1lVG9vbHNcIik7XG5jb25zdCBJbnB1dFNvdXJjZV9qc18xID0gcmVxdWlyZShcIi4vSW5wdXRTb3VyY2UuanNcIik7XG5jb25zdCBrZXlVdGlsc19qc18xID0gcmVxdWlyZShcIi4va2V5VXRpbHMuanNcIik7XG5jb25zdCBVU0tleWJvYXJkTGF5b3V0X2pzXzEgPSByZXF1aXJlKFwiLi9VU0tleWJvYXJkTGF5b3V0LmpzXCIpO1xuLyoqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvI2Rmbi1jZW50ZXItcG9pbnQgKi9cbmNvbnN0IENBTENVTEFURV9JTl9WSUVXX0NFTlRFUl9QVF9ERUNMID0gKChpKSA9PiB7XG4gICAgY29uc3QgdCA9IGkuZ2V0Q2xpZW50UmVjdHMoKVswXSwgZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHQueCwgdC54ICsgdC53aWR0aCkpLCBuID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIE1hdGgubWF4KHQueCwgdC54ICsgdC53aWR0aCkpLCBoID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odC55LCB0LnkgKyB0LmhlaWdodCkpLCBtID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCBNYXRoLm1heCh0LnksIHQueSArIHQuaGVpZ2h0KSk7XG4gICAgcmV0dXJuIFtlICsgKChuIC0gZSkgPj4gMSksIGggKyAoKG0gLSBoKSA+PiAxKV07XG59KS50b1N0cmluZygpO1xuY29uc3QgSVNfTUFDX0RFQ0wgPSAoKCkgPT4ge1xuICAgIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbWFjJyk7XG59KS50b1N0cmluZygpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudENlbnRlcihjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgY29uc3Qgc2FuZGJveCA9IGF3YWl0IGNvbnRleHQuZ2V0T3JDcmVhdGVTYW5kYm94KHVuZGVmaW5lZCk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FuZGJveC5jYWxsRnVuY3Rpb24oQ0FMQ1VMQVRFX0lOX1ZJRVdfQ0VOVEVSX1BUX0RFQ0wsIGZhbHNlLCB7IHR5cGU6ICd1bmRlZmluZWQnIH0sIFtlbGVtZW50XSk7XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSAnZXhjZXB0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uKGBPcmlnaW4gZWxlbWVudCAke2VsZW1lbnQuc2hhcmVkSWR9IHdhcyBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocmVzdWx0LnJlc3VsdC50eXBlID09PSAnYXJyYXknKTtcbiAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQucmVzdWx0LnZhbHVlPy5bMF0/LnR5cGUgPT09ICdudW1iZXInKTtcbiAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQucmVzdWx0LnZhbHVlPy5bMV0/LnR5cGUgPT09ICdudW1iZXInKTtcbiAgICBjb25zdCB7IHJlc3VsdDogeyB2YWx1ZTogW3sgdmFsdWU6IHggfSwgeyB2YWx1ZTogeSB9XSwgfSwgfSA9IHJlc3VsdDtcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG59XG5jbGFzcyBBY3Rpb25EaXNwYXRjaGVyIHtcbiAgICBzdGF0aWMgaXNNYWNPUyA9IGFzeW5jIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChhd2FpdCBjb250ZXh0LmdldE9yQ3JlYXRlU2FuZGJveCh1bmRlZmluZWQpKS5jYWxsRnVuY3Rpb24oSVNfTUFDX0RFQ0wsIGZhbHNlKTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocmVzdWx0LnR5cGUgIT09ICdleGNlcHRpb24nKTtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocmVzdWx0LnJlc3VsdC50eXBlID09PSAnYm9vbGVhbicpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdC52YWx1ZTtcbiAgICB9O1xuICAgICN0aWNrU3RhcnQgPSAwO1xuICAgICN0aWNrRHVyYXRpb24gPSAwO1xuICAgICNpbnB1dFN0YXRlO1xuICAgICNjb250ZXh0O1xuICAgICNpc01hY09TO1xuICAgIGNvbnN0cnVjdG9yKGlucHV0U3RhdGUsIGNvbnRleHQsIGlzTWFjT1MpIHtcbiAgICAgICAgdGhpcy4jaW5wdXRTdGF0ZSA9IGlucHV0U3RhdGU7XG4gICAgICAgIHRoaXMuI2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLiNpc01hY09TID0gaXNNYWNPUztcbiAgICB9XG4gICAgYXN5bmMgZGlzcGF0Y2hBY3Rpb25zKG9wdGlvbnNCeVRpY2spIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jaW5wdXRTdGF0ZS5xdWV1ZS5ydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb25zIG9mIG9wdGlvbnNCeVRpY2spIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRpc3BhdGNoVGlja0FjdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkaXNwYXRjaFRpY2tBY3Rpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4jdGlja1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHRoaXMuI3RpY2tEdXJhdGlvbiA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgeyBhY3Rpb24gfSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoJ2R1cmF0aW9uJyBpbiBhY3Rpb24gJiYgYWN0aW9uLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiN0aWNrRHVyYXRpb24gPSBNYXRoLm1heCh0aGlzLiN0aWNrRHVyYXRpb24sIGFjdGlvbi5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLiN0aWNrRHVyYXRpb24pKSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gSW4gdGhlb3J5IHdlIGhhdmUgdG8gd2FpdCBmb3IgZWFjaCBhY3Rpb24gdG8gaGFwcGVuLCBidXQgQ0RQIGlzIHNlcmlhbCxcbiAgICAgICAgICAgIC8vIHNvIGFzIGFuIG9wdGltaXphdGlvbiwgd2UgcXVldWUgYWxsIENEUCBjb21tYW5kcyBhdCBvbmNlIGFuZCBhd2FpdCBhbGxcbiAgICAgICAgICAgIC8vIG9mIHRoZW0uXG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuI2Rpc3BhdGNoQWN0aW9uKG9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoQWN0aW9uKHsgaWQsIGFjdGlvbiB9KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuI2lucHV0U3RhdGUuZ2V0KGlkKTtcbiAgICAgICAgY29uc3Qga2V5U3RhdGUgPSB0aGlzLiNpbnB1dFN0YXRlLmdldEdsb2JhbEtleVN0YXRlKCk7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2tleURvd24nOiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBUaGUgc291cmNlIGlzIHZhbGlkYXRlZCBiZWZvcmUuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZGlzcGF0Y2hLZXlEb3duQWN0aW9uKHNvdXJjZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLiNpbnB1dFN0YXRlLmNhbmNlbExpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdrZXlVcCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdrZXlVcCc6IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IFRoZSBzb3VyY2UgaXMgdmFsaWRhdGVkIGJlZm9yZS5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaXNwYXRjaEtleVVwQWN0aW9uKHNvdXJjZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BhdXNlJzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB3YWl0aW5nIG9uIHRoZSBpbnB1dCBzb3VyY2UuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdwb2ludGVyRG93bic6IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IFRoZSBzb3VyY2UgaXMgdmFsaWRhdGVkIGJlZm9yZS5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaXNwYXRjaFBvaW50ZXJEb3duQWN0aW9uKHNvdXJjZSwga2V5U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy4jaW5wdXRTdGF0ZS5jYW5jZWxMaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9pbnRlclVwJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BvaW50ZXJNb3ZlJzoge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlIHNvdXJjZSBpcyB2YWxpZGF0ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Rpc3BhdGNoUG9pbnRlck1vdmVBY3Rpb24oc291cmNlLCBrZXlTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3BvaW50ZXJVcCc6IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IFRoZSBzb3VyY2UgaXMgdmFsaWRhdGVkIGJlZm9yZS5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNkaXNwYXRjaFBvaW50ZXJVcEFjdGlvbihzb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2Nyb2xsJzoge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlIHNvdXJjZSBpcyB2YWxpZGF0ZWQgYmVmb3JlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Rpc3BhdGNoU2Nyb2xsQWN0aW9uKHNvdXJjZSwga2V5U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoUG9pbnRlckRvd25BY3Rpb24oc291cmNlLCBrZXlTdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgYnV0dG9uIH0gPSBhY3Rpb247XG4gICAgICAgIGlmIChzb3VyY2UucHJlc3NlZC5oYXMoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5wcmVzc2VkLmFkZChidXR0b24pO1xuICAgICAgICBjb25zdCB7IHgsIHksIHN1YnR5cGU6IHBvaW50ZXJUeXBlIH0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcHJlc3N1cmUsIHR3aXN0LCB0YW5nZW50aWFsUHJlc3N1cmUgfSA9IGFjdGlvbjtcbiAgICAgICAgY29uc3QgeyB0aWx0WCwgdGlsdFkgfSA9IGdldFRpbHQoYWN0aW9uKTtcbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgYmVnaW5zIGhlcmUgLS0tXG4gICAgICAgIGNvbnN0IHsgbW9kaWZpZXJzIH0gPSBrZXlTdGF0ZTtcbiAgICAgICAgY29uc3QgeyByYWRpdXNYLCByYWRpdXNZIH0gPSBnZXRSYWRpaSh3aWR0aCA/PyAxLCBoZWlnaHQgPz8gMSk7XG4gICAgICAgIHN3aXRjaCAocG9pbnRlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiIC8qIElucHV0LlBvaW50ZXJUeXBlLk1vdXNlICovOlxuICAgICAgICAgICAgY2FzZSBcInBlblwiIC8qIElucHV0LlBvaW50ZXJUeXBlLlBlbiAqLzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgd2lkdGggYW5kIGhlaWdodCB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlUHJlc3NlZCcsXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBnZXRDZHBCdXR0b24oYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogc291cmNlLmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrQ291bnQ6IHNvdXJjZS5zZXRDbGlja0NvdW50KGJ1dHRvbiwgbmV3IElucHV0U291cmNlX2pzXzEuUG9pbnRlclNvdXJjZS5DbGlja0NvbnRleHQoeCwgeSwgcGVyZm9ybWFuY2Uubm93KCkpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgdGlsdFgsXG4gICAgICAgICAgICAgICAgICAgIHRpbHRZLFxuICAgICAgICAgICAgICAgICAgICB0d2lzdCxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHByZXNzdXJlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRvdWNoXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi86XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaFRvdWNoRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaFN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hQb2ludHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2lzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5wb2ludGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLnJhZGl1c1ggPSByYWRpdXNYO1xuICAgICAgICBzb3VyY2UucmFkaXVzWSA9IHJhZGl1c1k7XG4gICAgICAgIHNvdXJjZS5mb3JjZSA9IHByZXNzdXJlO1xuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBlbmRzIGhlcmUgLS0tXG4gICAgfVxuICAgICNkaXNwYXRjaFBvaW50ZXJVcEFjdGlvbihzb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBidXR0b24gfSA9IGFjdGlvbjtcbiAgICAgICAgaWYgKCFzb3VyY2UucHJlc3NlZC5oYXMoYnV0dG9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5wcmVzc2VkLmRlbGV0ZShidXR0b24pO1xuICAgICAgICBjb25zdCB7IHgsIHksIGZvcmNlLCByYWRpdXNYLCByYWRpdXNZLCBzdWJ0eXBlOiBwb2ludGVyVHlwZSB9ID0gc291cmNlO1xuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGtleVN0YXRlO1xuICAgICAgICBzd2l0Y2ggKHBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibW91c2VcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Nb3VzZSAqLzpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5cIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5QZW4gKi86XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hNb3VzZUV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2VSZWxlYXNlZCcsXG4gICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBnZXRDZHBCdXR0b24oYnV0dG9uKSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogc291cmNlLmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrQ291bnQ6IHNvdXJjZS5nZXRDbGlja0NvdW50KGJ1dHRvbiksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSBcInRvdWNoXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hUb3VjaEV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hFbmQnLFxuICAgICAgICAgICAgICAgICAgICB0b3VjaFBvaW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc291cmNlLnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1ksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgZW5kcyBoZXJlIC0tLVxuICAgIH1cbiAgICBhc3luYyAjZGlzcGF0Y2hQb2ludGVyTW92ZUFjdGlvbihzb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgc3VidHlwZTogcG9pbnRlclR5cGUgfSA9IHNvdXJjZTtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBwcmVzc3VyZSwgdHdpc3QsIHRhbmdlbnRpYWxQcmVzc3VyZSwgeDogb2Zmc2V0WCwgeTogb2Zmc2V0WSwgb3JpZ2luID0gJ3ZpZXdwb3J0JywgZHVyYXRpb24gPSB0aGlzLiN0aWNrRHVyYXRpb24sIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IHsgdGlsdFgsIHRpbHRZIH0gPSBnZXRUaWx0KGFjdGlvbik7XG4gICAgICAgIGNvbnN0IHsgcmFkaXVzWCwgcmFkaXVzWSB9ID0gZ2V0UmFkaWkod2lkdGggPz8gMSwgaGVpZ2h0ID8/IDEpO1xuICAgICAgICBjb25zdCB7IHRhcmdldFgsIHRhcmdldFkgfSA9IGF3YWl0IHRoaXMuI2dldENvb3JkaW5hdGVGcm9tT3JpZ2luKG9yaWdpbiwgb2Zmc2V0WCwgb2Zmc2V0WSwgc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICBpZiAodGFyZ2V0WCA8IDAgfHwgdGFyZ2V0WSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk1vdmVUYXJnZXRPdXRPZkJvdW5kc0V4Y2VwdGlvbihgQ2Fubm90IG1vdmUgYmV5b25kIHZpZXdwb3J0ICh4OiAke3RhcmdldFh9LCB5OiAke3RhcmdldFl9KWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGR1cmF0aW9uID4gMCA/IChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuI3RpY2tTdGFydCkgLyBkdXJhdGlvbiA6IDE7XG4gICAgICAgICAgICBsYXN0ID0gcmF0aW8gPj0gMTtcbiAgICAgICAgICAgIGxldCB4O1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIHggPSB0YXJnZXRYO1xuICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgucm91bmQocmF0aW8gKiAodGFyZ2V0WCAtIHN0YXJ0WCkgKyBzdGFydFgpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKHJhdGlvICogKHRhcmdldFkgLSBzdGFydFkpICsgc3RhcnRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UueCAhPT0geCB8fCBzb3VyY2UueSAhPT0geSkge1xuICAgICAgICAgICAgICAgIC8vIC0tLSBQbGF0Zm9ybS1zcGVjaWZpYyBjb2RlIGJlZ2lucyBoZXJlIC0tLVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbW9kaWZpZXJzIH0gPSBrZXlTdGF0ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3VzZVwiIC8qIElucHV0LlBvaW50ZXJUeXBlLk1vdXNlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmRpc3BhdGNoTW91c2VFdmVudCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2VNb3ZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlja0NvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogZ2V0Q2RwQnV0dG9uKHNvdXJjZS5wcmVzc2VkLnZhbHVlcygpLm5leHQoKS52YWx1ZSA/PyA1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiBzb3VyY2UuYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YW5nZW50aWFsUHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsdFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsdFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHdpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2U6IHByZXNzdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBlblwiIC8qIElucHV0LlBvaW50ZXJUeXBlLlBlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UucHJlc3NlZC5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZU1vdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlja0NvdW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IGdldENkcEJ1dHRvbihzb3VyY2UucHJlc3NlZC52YWx1ZXMoKS5uZXh0KCkudmFsdWUgPz8gNSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHNvdXJjZS5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFuZ2VudGlhbFByZXNzdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGlsdFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR3aXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvdWNoXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi86XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnByZXNzZWQuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hUb3VjaEV2ZW50Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hNb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hQb2ludHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhbmdlbnRpYWxQcmVzc3VyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWx0WSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2lzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZTogcHJlc3N1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvdXJjZS5wb2ludGVySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgZW5kcyBoZXJlIC0tLVxuICAgICAgICAgICAgICAgIHNvdXJjZS54ID0geDtcbiAgICAgICAgICAgICAgICBzb3VyY2UueSA9IHk7XG4gICAgICAgICAgICAgICAgc291cmNlLnJhZGl1c1ggPSByYWRpdXNYO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5yYWRpdXNZID0gcmFkaXVzWTtcbiAgICAgICAgICAgICAgICBzb3VyY2UuZm9yY2UgPSBwcmVzc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoIWxhc3QpO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0Q29vcmRpbmF0ZUZyb21PcmlnaW4ob3JpZ2luLCBvZmZzZXRYLCBvZmZzZXRZLCBzdGFydFgsIHN0YXJ0WSkge1xuICAgICAgICBsZXQgdGFyZ2V0WDtcbiAgICAgICAgbGV0IHRhcmdldFk7XG4gICAgICAgIHN3aXRjaCAob3JpZ2luKSB7XG4gICAgICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgICAgICAgdGFyZ2V0WCA9IG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IG9mZnNldFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb2ludGVyJzpcbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gc3RhcnRYICsgb2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0YXJnZXRZID0gc3RhcnRZICsgb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IHBvc1gsIHk6IHBvc1kgfSA9IGF3YWl0IGdldEVsZW1lbnRDZW50ZXIodGhpcy4jY29udGV4dCwgb3JpZ2luLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogVGhlc2UgY2FuIG5ldmVyIGJlIHNwZWNpYWwgbnVtYmVycy5cbiAgICAgICAgICAgICAgICB0YXJnZXRYID0gcG9zWCArIG9mZnNldFg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0WSA9IHBvc1kgKyBvZmZzZXRZO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRhcmdldFgsIHRhcmdldFkgfTtcbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoU2Nyb2xsQWN0aW9uKF9zb3VyY2UsIGtleVN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgeyBkZWx0YVg6IHRhcmdldERlbHRhWCwgZGVsdGFZOiB0YXJnZXREZWx0YVksIHg6IG9mZnNldFgsIHk6IG9mZnNldFksIG9yaWdpbiA9ICd2aWV3cG9ydCcsIGR1cmF0aW9uID0gdGhpcy4jdGlja0R1cmF0aW9uLCB9ID0gYWN0aW9uO1xuICAgICAgICBpZiAob3JpZ2luID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbignXCJwb2ludGVyXCIgb3JpZ2luIGlzIGludmFsaWQgZm9yIHNjcm9sbGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhcmdldFgsIHRhcmdldFkgfSA9IGF3YWl0IHRoaXMuI2dldENvb3JkaW5hdGVGcm9tT3JpZ2luKG9yaWdpbiwgb2Zmc2V0WCwgb2Zmc2V0WSwgMCwgMCk7XG4gICAgICAgIGlmICh0YXJnZXRYIDwgMCB8fCB0YXJnZXRZIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTW92ZVRhcmdldE91dE9mQm91bmRzRXhjZXB0aW9uKGBDYW5ub3QgbW92ZSBiZXlvbmQgdmlld3BvcnQgKHg6ICR7dGFyZ2V0WH0sIHk6ICR7dGFyZ2V0WX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnREZWx0YVggPSAwO1xuICAgICAgICBsZXQgY3VycmVudERlbHRhWSA9IDA7XG4gICAgICAgIGxldCBsYXN0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGR1cmF0aW9uID4gMCA/IChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuI3RpY2tTdGFydCkgLyBkdXJhdGlvbiA6IDE7XG4gICAgICAgICAgICBsYXN0ID0gcmF0aW8gPj0gMTtcbiAgICAgICAgICAgIGxldCBkZWx0YVg7XG4gICAgICAgICAgICBsZXQgZGVsdGFZO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSB0YXJnZXREZWx0YVggLSBjdXJyZW50RGVsdGFYO1xuICAgICAgICAgICAgICAgIGRlbHRhWSA9IHRhcmdldERlbHRhWSAtIGN1cnJlbnREZWx0YVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSBNYXRoLnJvdW5kKHJhdGlvICogdGFyZ2V0RGVsdGFYIC0gY3VycmVudERlbHRhWCk7XG4gICAgICAgICAgICAgICAgZGVsdGFZID0gTWF0aC5yb3VuZChyYXRpbyAqIHRhcmdldERlbHRhWSAtIGN1cnJlbnREZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhWCAhPT0gMCB8fCBkZWx0YVkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0ga2V5U3RhdGU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZVdoZWVsJyxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVksXG4gICAgICAgICAgICAgICAgICAgIHg6IHRhcmdldFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRhcmdldFksXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBlbmRzIGhlcmUgLS0tXG4gICAgICAgICAgICAgICAgY3VycmVudERlbHRhWCArPSBkZWx0YVg7XG4gICAgICAgICAgICAgICAgY3VycmVudERlbHRhWSArPSBkZWx0YVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCFsYXN0KTtcbiAgICB9XG4gICAgYXN5bmMgI2Rpc3BhdGNoS2V5RG93bkFjdGlvbihzb3VyY2UsIGFjdGlvbikge1xuICAgICAgICBjb25zdCByYXdLZXkgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGlmICghKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUdyYXBoZW1lKShyYXdLZXkpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4tcHJvY2Vzcy1hLWtleS1hY3Rpb25cbiAgICAgICAgICAgIC8vIFdlYkRyaXZlciBzcGVjIGFsbG93cyBhIGdyYXBoZW1lIHRvIGJlIHVzZWQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQga2V5IHZhbHVlOiAke3Jhd0tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0dyYXBoZW1lID0gKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUNvbXBsZXhHcmFwaGVtZSkocmF3S2V5KTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGtleVV0aWxzX2pzXzEuZ2V0Tm9ybWFsaXplZEtleSkocmF3S2V5KTtcbiAgICAgICAgY29uc3QgcmVwZWF0ID0gc291cmNlLnByZXNzZWQuaGFzKGtleSk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoMCwga2V5VXRpbHNfanNfMS5nZXRLZXlDb2RlKShyYXdLZXkpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9ICgwLCBrZXlVdGlsc19qc18xLmdldEtleUxvY2F0aW9uKShyYXdLZXkpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnQWx0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NoaWZ0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ29udHJvbCc6XG4gICAgICAgICAgICAgICAgc291cmNlLmN0cmwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWV0YSc6XG4gICAgICAgICAgICAgICAgc291cmNlLm1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZS5wcmVzc2VkLmFkZChrZXkpO1xuICAgICAgICBjb25zdCB7IG1vZGlmaWVycyB9ID0gc291cmNlO1xuICAgICAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBiZWdpbnMgaGVyZSAtLS1cbiAgICAgICAgLy8gVGhlIHNwcmVhZCBpcyBhIGxpdHRsZSBoYWNrIHNvIEpTIGdpdmVzIHVzIGFuIGFycmF5IG9mIHVuaWNvZGUgY2hhcmFjdGVyc1xuICAgICAgICAvLyB0byBtZWFzdXJlLlxuICAgICAgICBjb25zdCB1bm1vZGlmaWVkVGV4dCA9IGdldEtleUV2ZW50VW5tb2RpZmllZFRleHQoa2V5LCBzb3VyY2UsIGlzR3JhcGhlbWUpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gZ2V0S2V5RXZlbnRUZXh0KGNvZGUgPz8gJycsIHNvdXJjZSkgPz8gdW5tb2RpZmllZFRleHQ7XG4gICAgICAgIGxldCBjb21tYW5kO1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbW1hbmRzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYmVjYXVzZSBDaHJvbWl1bSBkb2Vzbid0XG4gICAgICAgIC8vIGhhbmRsZSB0aGVtLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL3JlZnMvaGVhZHMvbWFpbjp0aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2VkaXRpbmcvZWRpdGluZ19iZWhhdmlvci5jYztsPTE2OTtkcmM9YjgxNDNjZjFkZmQyNDg0Mjg5MGZjZDgzMWM0ZjVkOTA5YmVmNGZjNDticHY9MDticHQ9MS5cbiAgICAgICAgaWYgKHRoaXMuI2lzTWFjT1MgJiYgc291cmNlLm1ldGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0tleUEnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gJ1NlbGVjdEFsbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0tleUMnOlxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kID0gJ0NvcHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdLZXlWJzpcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZCA9IHNvdXJjZS5zaGlmdCA/ICdQYXN0ZUFuZE1hdGNoU3R5bGUnIDogJ1Bhc3RlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnS2V5WCc6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSAnQ3V0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnS2V5Wic6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgPSBzb3VyY2Uuc2hpZnQgPyAnUmVkbycgOiAnVW5kbyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRleHQuY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnSW5wdXQuZGlzcGF0Y2hLZXlFdmVudCcsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0ZXh0ID8gJ2tleURvd24nIDogJ3Jhd0tleURvd24nLFxuICAgICAgICAgICAgICAgIHdpbmRvd3NWaXJ0dWFsS2V5Q29kZTogVVNLZXlib2FyZExheW91dF9qc18xLktleVRvS2V5Q29kZVtrZXldLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdW5tb2RpZmllZFRleHQsXG4gICAgICAgICAgICAgICAgYXV0b1JlcGVhdDogcmVwZWF0LFxuICAgICAgICAgICAgICAgIGlzU3lzdGVtS2V5OiBzb3VyY2UuYWx0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gPCAzID8gbG9jYXRpb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaXNLZXlwYWQ6IGxvY2F0aW9uID09PSAzLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgICAgICAgICBjb21tYW5kczogY29tbWFuZCA/IFtjb21tYW5kXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgICAgICAvLyBEcmFnIGNhbmNlbGxpbmcgaGFwcGVucyBvbiBlc2NhcGUuXG4gICAgICAgIGlmIChrZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5hbHQgJiZcbiAgICAgICAgICAgICAgICAoKHRoaXMuI2lzTWFjT1MgJiYgIXNvdXJjZS5jdHJsICYmICFzb3VyY2UubWV0YSkgfHwgIXRoaXMuI2lzTWFjT1MpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLiNjb250ZXh0LmNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ0lucHV0LmNhbmNlbERyYWdnaW5nJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgZW5kcyBoZXJlIC0tLVxuICAgIH1cbiAgICAjZGlzcGF0Y2hLZXlVcEFjdGlvbihzb3VyY2UsIGFjdGlvbikge1xuICAgICAgICBjb25zdCByYXdLZXkgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGlmICghKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUdyYXBoZW1lKShyYXdLZXkpKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4tcHJvY2Vzcy1hLWtleS1hY3Rpb25cbiAgICAgICAgICAgIC8vIFdlYkRyaXZlciBzcGVjIGFsbG93cyBhIGdyYXBoZW1lIHRvIGJlIHVzZWQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQga2V5IHZhbHVlOiAke3Jhd0tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0dyYXBoZW1lID0gKDAsIEdyYXBoZW1lVG9vbHNfMS5pc1NpbmdsZUNvbXBsZXhHcmFwaGVtZSkocmF3S2V5KTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIGtleVV0aWxzX2pzXzEuZ2V0Tm9ybWFsaXplZEtleSkocmF3S2V5KTtcbiAgICAgICAgaWYgKCFzb3VyY2UucHJlc3NlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoMCwga2V5VXRpbHNfanNfMS5nZXRLZXlDb2RlKShyYXdLZXkpO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9ICgwLCBrZXlVdGlsc19qc18xLmdldEtleUxvY2F0aW9uKShyYXdLZXkpO1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnQWx0JzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuYWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTaGlmdCc6XG4gICAgICAgICAgICAgICAgc291cmNlLnNoaWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDb250cm9sJzpcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3RybCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTWV0YSc6XG4gICAgICAgICAgICAgICAgc291cmNlLm1ldGEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UucHJlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IHNvdXJjZTtcbiAgICAgICAgLy8gLS0tIFBsYXRmb3JtLXNwZWNpZmljIGNvZGUgYmVnaW5zIGhlcmUgLS0tXG4gICAgICAgIC8vIFRoZSBzcHJlYWQgaXMgYSBsaXR0bGUgaGFjayBzbyBKUyBnaXZlcyB1cyBhbiBhcnJheSBvZiB1bmljb2RlIGNoYXJhY3RlcnNcbiAgICAgICAgLy8gdG8gbWVhc3VyZS5cbiAgICAgICAgY29uc3QgdW5tb2RpZmllZFRleHQgPSBnZXRLZXlFdmVudFVubW9kaWZpZWRUZXh0KGtleSwgc291cmNlLCBpc0dyYXBoZW1lKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldEtleUV2ZW50VGV4dChjb2RlID8/ICcnLCBzb3VyY2UpID8/IHVubW9kaWZpZWRUZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dC5jZHBUYXJnZXQuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdJbnB1dC5kaXNwYXRjaEtleUV2ZW50Jywge1xuICAgICAgICAgICAgdHlwZTogJ2tleVVwJyxcbiAgICAgICAgICAgIHdpbmRvd3NWaXJ0dWFsS2V5Q29kZTogVVNLZXlib2FyZExheW91dF9qc18xLktleVRvS2V5Q29kZVtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICB1bm1vZGlmaWVkVGV4dCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbiA8IDMgPyBsb2NhdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzU3lzdGVtS2V5OiBzb3VyY2UuYWx0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzS2V5cGFkOiBsb2NhdGlvbiA9PT0gMyxcbiAgICAgICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSBQbGF0Zm9ybS1zcGVjaWZpYyBjb2RlIGVuZHMgaGVyZSAtLS1cbiAgICB9XG59XG5leHBvcnRzLkFjdGlvbkRpc3BhdGNoZXIgPSBBY3Rpb25EaXNwYXRjaGVyO1xuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbm9uLWdyYXBoZW1lIGtleSB0byBlaXRoZXIgYW4gYHVuZGVmaW5lZGAgZm9yIGEgc3BlY2lhbCBrZXlzLCBvciBhIHNpbmdsZVxuICogY2hhcmFjdGVyIG1vZGlmaWVkIGJ5IHNoaWZ0IGlmIG5lZWRlZC5cbiAqL1xuY29uc3QgZ2V0S2V5RXZlbnRVbm1vZGlmaWVkVGV4dCA9IChrZXksIHNvdXJjZSwgaXNHcmFwaGVtZSkgPT4ge1xuICAgIGlmIChpc0dyYXBoZW1lKSB7XG4gICAgICAgIC8vIEdyYXBoZW1lcyBzaG91bGQgYmUgcHJlc2VudGVkIGFzIHRleHQgaW4gdGhlIENEUCBjb21tYW5kLlxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIHJldHVybiAnXFxyJztcbiAgICB9XG4gICAgLy8gSWYga2V5IGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGl0IGlzIGEgbm9ybWFsaXplZCBrZXkgdmFsdWUsIGFuZCBzaG91bGQgYmVcbiAgICAvLyBwcmVzZW50ZWQgYXMga2V5LCBub3QgdGV4dCBpbiB0aGUgQ0RQIGNvbW1hbmQuXG4gICAgcmV0dXJuIFsuLi5rZXldLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHNvdXJjZS5zaGlmdFxuICAgICAgICAgICAgPyBrZXkudG9Mb2NhbGVVcHBlckNhc2UoJ2VuLVVTJylcbiAgICAgICAgICAgIDoga2V5XG4gICAgICAgIDogdW5kZWZpbmVkO1xufTtcbmNvbnN0IGdldEtleUV2ZW50VGV4dCA9IChjb2RlLCBzb3VyY2UpID0+IHtcbiAgICBpZiAoc291cmNlLmN0cmwpIHtcbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdEaWdpdDInOlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwMCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnS2V5QSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwMSc7XG4gICAgICAgICAgICBjYXNlICdLZXlCJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDAyJztcbiAgICAgICAgICAgIGNhc2UgJ0tleUMnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDMnO1xuICAgICAgICAgICAgY2FzZSAnS2V5RCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwNCc7XG4gICAgICAgICAgICBjYXNlICdLZXlFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDA1JztcbiAgICAgICAgICAgIGNhc2UgJ0tleUYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDYnO1xuICAgICAgICAgICAgY2FzZSAnS2V5Ryc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwNyc7XG4gICAgICAgICAgICBjYXNlICdLZXlIJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDA4JztcbiAgICAgICAgICAgIGNhc2UgJ0tleUknOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MDknO1xuICAgICAgICAgICAgY2FzZSAnS2V5Sic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwQSc7XG4gICAgICAgICAgICBjYXNlICdLZXlLJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDBCJztcbiAgICAgICAgICAgIGNhc2UgJ0tleUwnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MEMnO1xuICAgICAgICAgICAgY2FzZSAnS2V5TSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgwRCc7XG4gICAgICAgICAgICBjYXNlICdLZXlOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDBFJztcbiAgICAgICAgICAgIGNhc2UgJ0tleU8nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MEYnO1xuICAgICAgICAgICAgY2FzZSAnS2V5UCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxMCc7XG4gICAgICAgICAgICBjYXNlICdLZXlRJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDExJztcbiAgICAgICAgICAgIGNhc2UgJ0tleVInOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTInO1xuICAgICAgICAgICAgY2FzZSAnS2V5Uyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxMyc7XG4gICAgICAgICAgICBjYXNlICdLZXlUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDE0JztcbiAgICAgICAgICAgIGNhc2UgJ0tleVUnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTUnO1xuICAgICAgICAgICAgY2FzZSAnS2V5Vic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxNic7XG4gICAgICAgICAgICBjYXNlICdLZXlXJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDE3JztcbiAgICAgICAgICAgIGNhc2UgJ0tleVgnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MTgnO1xuICAgICAgICAgICAgY2FzZSAnS2V5WSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxOSc7XG4gICAgICAgICAgICBjYXNlICdLZXlaJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFBJztcbiAgICAgICAgICAgIGNhc2UgJ0JyYWNrZXRMZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFCJztcbiAgICAgICAgICAgIGNhc2UgJ0JhY2tzbGFzaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXHgxQyc7XG4gICAgICAgICAgICBjYXNlICdCcmFja2V0UmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MUQnO1xuICAgICAgICAgICAgY2FzZSAnRGlnaXQ2JzpcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFx4MUUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ01pbnVzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xceDFGJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuYWx0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbmZ1bmN0aW9uIGdldENkcEJ1dHRvbihidXR0b24pIHtcbiAgICBzd2l0Y2ggKGJ1dHRvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ21pZGRsZSc7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gJ2JhY2snO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gJ2ZvcndhcmQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdub25lJztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUaWx0KGFjdGlvbikge1xuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9wb2ludGVyZXZlbnRzLyNjb252ZXJ0aW5nLWJldHdlZW4tdGlsdHgtdGlsdHktYW5kLWFsdGl0dWRlYW5nbGUtYXppbXV0aGFuZ2xlXG4gICAgY29uc3QgYWx0aXR1ZGVBbmdsZSA9IGFjdGlvbi5hbHRpdHVkZUFuZ2xlID8/IDA7XG4gICAgY29uc3QgYXppbXV0aEFuZ2xlID0gYWN0aW9uLmF6aW11dGhBbmdsZSA/PyAwO1xuICAgIGxldCB0aWx0WFJhZGlhbnMgPSAwO1xuICAgIGxldCB0aWx0WVJhZGlhbnMgPSAwO1xuICAgIGlmIChhbHRpdHVkZUFuZ2xlID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSBwZW4gaXMgaW4gdGhlIFgtWSBwbGFuZVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID09PSAwIHx8IGF6aW11dGhBbmdsZSA9PT0gMiAqIE1hdGguUEkpIHtcbiAgICAgICAgICAgIC8vIHBlbiBpcyBvbiBwb3NpdGl2ZSBYIGF4aXNcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IE1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhemltdXRoQW5nbGUgPT09IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICAvLyBwZW4gaXMgb24gcG9zaXRpdmUgWSBheGlzXG4gICAgICAgICAgICB0aWx0WVJhZGlhbnMgPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID09PSBNYXRoLlBJKSB7XG4gICAgICAgICAgICAvLyBwZW4gaXMgb24gbmVnYXRpdmUgWCBheGlzXG4gICAgICAgICAgICB0aWx0WFJhZGlhbnMgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6aW11dGhBbmdsZSA9PT0gKDMgKiBNYXRoLlBJKSAvIDIpIHtcbiAgICAgICAgICAgIC8vIHBlbiBpcyBvbiBuZWdhdGl2ZSBZIGF4aXNcbiAgICAgICAgICAgIHRpbHRZUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gMCAmJiBhemltdXRoQW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgdGlsdFhSYWRpYW5zID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICB0aWx0WVJhZGlhbnMgPSBNYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gTWF0aC5QSSAvIDIgJiYgYXppbXV0aEFuZ2xlIDwgTWF0aC5QSSkge1xuICAgICAgICAgICAgdGlsdFhSYWRpYW5zID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgICAgdGlsdFlSYWRpYW5zID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF6aW11dGhBbmdsZSA+IE1hdGguUEkgJiYgYXppbXV0aEFuZ2xlIDwgKDMgKiBNYXRoLlBJKSAvIDIpIHtcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIHRpbHRZUmFkaWFucyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXppbXV0aEFuZ2xlID4gKDMgKiBNYXRoLlBJKSAvIDIgJiYgYXppbXV0aEFuZ2xlIDwgMiAqIE1hdGguUEkpIHtcbiAgICAgICAgICAgIHRpbHRYUmFkaWFucyA9IE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgdGlsdFlSYWRpYW5zID0gLU1hdGguUEkgLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRpdHVkZUFuZ2xlICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IHRhbkFsdCA9IE1hdGgudGFuKGFsdGl0dWRlQW5nbGUpO1xuICAgICAgICB0aWx0WFJhZGlhbnMgPSBNYXRoLmF0YW4oTWF0aC5jb3MoYXppbXV0aEFuZ2xlKSAvIHRhbkFsdCk7XG4gICAgICAgIHRpbHRZUmFkaWFucyA9IE1hdGguYXRhbihNYXRoLnNpbihhemltdXRoQW5nbGUpIC8gdGFuQWx0KTtcbiAgICB9XG4gICAgY29uc3QgZmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aWx0WDogTWF0aC5yb3VuZCh0aWx0WFJhZGlhbnMgKiBmYWN0b3IpLFxuICAgICAgICB0aWx0WTogTWF0aC5yb3VuZCh0aWx0WVJhZGlhbnMgKiBmYWN0b3IpLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRSYWRpaSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFkaXVzWDogd2lkdGggPyB3aWR0aCAvIDIgOiAwLjUsXG4gICAgICAgIHJhZGl1c1k6IGhlaWdodCA/IGhlaWdodCAvIDIgOiAwLjUsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbkRpc3BhdGNoZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0UHJvY2Vzc29yID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBBY3Rpb25EaXNwYXRjaGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvQWN0aW9uRGlzcGF0Y2hlci5qc1wiKTtcbmNvbnN0IElucHV0U3RhdGVNYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vaW5wdXQvSW5wdXRTdGF0ZU1hbmFnZXIuanNcIik7XG5jbGFzcyBJbnB1dFByb2Nlc3NvciB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI3JlYWxtU3RvcmFnZTtcbiAgICAjaW5wdXRTdGF0ZU1hbmFnZXIgPSBuZXcgSW5wdXRTdGF0ZU1hbmFnZXJfanNfMS5JbnB1dFN0YXRlTWFuYWdlcigpO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIHJlYWxtU3RvcmFnZSkge1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlID0gcmVhbG1TdG9yYWdlO1xuICAgIH1cbiAgICBhc3luYyBwZXJmb3JtQWN0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGlucHV0U3RhdGUgPSB0aGlzLiNpbnB1dFN0YXRlTWFuYWdlci5nZXQoY29udGV4dC50b3ApO1xuICAgICAgICBjb25zdCBhY3Rpb25zQnlUaWNrID0gdGhpcy4jZ2V0QWN0aW9uc0J5VGljayhwYXJhbXMsIGlucHV0U3RhdGUpO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gbmV3IEFjdGlvbkRpc3BhdGNoZXJfanNfMS5BY3Rpb25EaXNwYXRjaGVyKGlucHV0U3RhdGUsIGNvbnRleHQsIGF3YWl0IEFjdGlvbkRpc3BhdGNoZXJfanNfMS5BY3Rpb25EaXNwYXRjaGVyLmlzTWFjT1MoY29udGV4dCkuY2F0Y2goKCkgPT4gZmFsc2UpKTtcbiAgICAgICAgYXdhaXQgZGlzcGF0Y2hlci5kaXNwYXRjaEFjdGlvbnMoYWN0aW9uc0J5VGljayk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgcmVsZWFzZUFjdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQocGFyYW1zLmNvbnRleHQpO1xuICAgICAgICBjb25zdCB0b3BDb250ZXh0ID0gY29udGV4dC50b3A7XG4gICAgICAgIGNvbnN0IGlucHV0U3RhdGUgPSB0aGlzLiNpbnB1dFN0YXRlTWFuYWdlci5nZXQodG9wQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBuZXcgQWN0aW9uRGlzcGF0Y2hlcl9qc18xLkFjdGlvbkRpc3BhdGNoZXIoaW5wdXRTdGF0ZSwgY29udGV4dCwgYXdhaXQgQWN0aW9uRGlzcGF0Y2hlcl9qc18xLkFjdGlvbkRpc3BhdGNoZXIuaXNNYWNPUyhjb250ZXh0KS5jYXRjaCgoKSA9PiBmYWxzZSkpO1xuICAgICAgICBhd2FpdCBkaXNwYXRjaGVyLmRpc3BhdGNoVGlja0FjdGlvbnMoaW5wdXRTdGF0ZS5jYW5jZWxMaXN0LnJldmVyc2UoKSk7XG4gICAgICAgIHRoaXMuI2lucHV0U3RhdGVNYW5hZ2VyLmRlbGV0ZSh0b3BDb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBzZXRGaWxlcyhwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChwYXJhbXMuY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gYXdhaXQgY29udGV4dC5nZXRPckNyZWF0ZVNhbmRib3godW5kZWZpbmVkKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihTdHJpbmcoZnVuY3Rpb24gZ2V0RmlsZXMoZmlsZUxpc3RMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBFcnJvckNvZGUuRWxlbWVudCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCAvKiBFcnJvckNvZGUuTm9kZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEVycm9yQ29kZS5UeXBlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMyAvKiBFcnJvckNvZGUuRGlzYWJsZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWxlTGlzdExlbmd0aCA+IDEgJiYgIXRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQgLyogRXJyb3JDb2RlLk11bHRpcGxlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KSwgZmFsc2UsIHBhcmFtcy5lbGVtZW50LCBbeyB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IHBhcmFtcy5maWxlcy5sZW5ndGggfV0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaE5vZGVFeGNlcHRpb24oYENvdWxkIG5vdCBmaW5kIGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShyZXN1bHQudHlwZSA9PT0gJ3N1Y2Nlc3MnKTtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0LnJlc3VsdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBFcnJvckNvZGUuTm9kZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uKGBDb3VsZCBub3QgZmluZCBlbGVtZW50ICR7cGFyYW1zLmVsZW1lbnQuc2hhcmVkSWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBFcnJvckNvZGUuRWxlbWVudCAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbihgRWxlbWVudCAke3BhcmFtcy5lbGVtZW50LnNoYXJlZElkfSBpcyBub3QgYSBpbnB1dGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogRXJyb3JDb2RlLlR5cGUgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5hYmxlVG9TZXRGaWxlSW5wdXRFeGNlcHRpb24oYElucHV0IGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH0gaXMgbm90IGEgZmlsZSB0eXBlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBFcnJvckNvZGUuRGlzYWJsZWQgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5hYmxlVG9TZXRGaWxlSW5wdXRFeGNlcHRpb24oYElucHV0IGVsZW1lbnQgJHtwYXJhbXMuZWxlbWVudC5zaGFyZWRJZH0gaXMgZGlzYWJsZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIEVycm9yQ29kZS5NdWx0aXBsZSAqLzoge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbihgQ2Fubm90IHNldCBtdWx0aXBsZSBmaWxlcyBvbiBhIG5vbi1tdWx0aXBsZSBpbnB1dCBlbGVtZW50YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgemVyby1sZW5ndGggYXJyYXkgaXMgYSBzcGVjaWFsIGNhc2UsIGl0IHNlZW1zIHRoYXRcbiAgICAgICAgICogRE9NLnNldEZpbGVJbnB1dEZpbGVzIGRvZXMgbm90IGFjdHVhbGx5IHVwZGF0ZSB0aGUgZmlsZXMgaW4gdGhhdCBjYXNlLCBzb1xuICAgICAgICAgKiB0aGUgc29sdXRpb24gaXMgdG8gZXZhbCB0aGUgZWxlbWVudCB2YWx1ZSB0byBhIG5ldyBGaWxlTGlzdCBkaXJlY3RseS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwYXJhbXMuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBYWFg6IFRoZXNlIGV2ZW50cyBzaG91bGQgY29udmVydGVkIHRvIHRydXN0ZWQgZXZlbnRzLiBQZXJoYXBzIGRvIHRoaXNcbiAgICAgICAgICAgIC8vIGluIGBET00uc2V0RmlsZUlucHV0RmlsZXNgP1xuICAgICAgICAgICAgYXdhaXQgcmVhbG0uY2FsbEZ1bmN0aW9uKFN0cmluZyhmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2FuY2VsJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRGF0YVRyYW5zZmVyKCkuZmlsZXM7XG4gICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGZvciB0aGlzIGNhc2UgYmVjYXVzZSBpdCBzaG91bGQgYmVoYXZlIGFraW4gdG8gYSB1c2VyIGFjdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY29tcG9zZWQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9KSwgZmFsc2UsIHBhcmFtcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXIgZ29hbCBoZXJlIGlzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgaW5wdXQgZWxlbWVudCBmaWxlcyBhbmQgZ2V0IHRoZWlyXG4gICAgICAgIC8vIGZpbGUgcGF0aHMuXG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFsbS5jYWxsRnVuY3Rpb24oU3RyaW5nKGZ1bmN0aW9uIGdldEZpbGVzKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXM/Lml0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgfSksIGZhbHNlLCBwYXJhbXMuZWxlbWVudCwgW3sgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwIH1dLCBcInJvb3RcIiAvKiBTY3JpcHQuUmVzdWx0T3duZXJzaGlwLlJvb3QgKi8pO1xuICAgICAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocmVzdWx0LnR5cGUgPT09ICdzdWNjZXNzJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC50eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBoYW5kbGUgfSA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShoYW5kbGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGggfSA9IGF3YWl0IHJlYWxtLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRE9NLmdldEZpbGVJbmZvJywge1xuICAgICAgICAgICAgICAgIG9iamVjdElkOiBoYW5kbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBoYW5kbGUuXG4gICAgICAgICAgICB2b2lkIHJlYWxtLmRpc293bihoYW5kbGUpLmNhdGNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aHMuc29ydCgpO1xuICAgICAgICAvLyBXZSBjcmVhdGUgYSBuZXcgYXJyYXkgc28gd2UgcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBmaWxlcy5cbiAgICAgICAgY29uc3Qgc29ydGVkRmlsZXMgPSBbLi4ucGFyYW1zLmZpbGVzXS5zb3J0KCk7XG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggIT09IHBhcmFtcy5maWxlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHNvcnRlZEZpbGVzLnNvbWUoKHBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhzW2luZGV4XSAhPT0gcGF0aDtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9iamVjdElkIH0gPSBhd2FpdCByZWFsbS5kZXNlcmlhbGl6ZUZvckNkcChwYXJhbXMuZWxlbWVudCk7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbm5vdCB0aHJvdyBzaW5jZSB0aGlzIHdhcyBqdXN0IHVzZWQgaW4gYGNhbGxGdW5jdGlvbmAgYWJvdmUuXG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShvYmplY3RJZCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWxtLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRE9NLnNldEZpbGVJbnB1dEZpbGVzJywge1xuICAgICAgICAgICAgICAgIGZpbGVzOiBwYXJhbXMuZmlsZXMsXG4gICAgICAgICAgICAgICAgb2JqZWN0SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFhYWDogV2Ugc2hvdWxkIGRpc3BhdGNoIGEgdHJ1c3RlZCBldmVudC5cbiAgICAgICAgICAgIGF3YWl0IHJlYWxtLmNhbGxGdW5jdGlvbihTdHJpbmcoZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjYW5jZWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSksIGZhbHNlLCBwYXJhbXMuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAjZ2V0QWN0aW9uc0J5VGljayhwYXJhbXMsIGlucHV0U3RhdGUpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uc0J5VGljayA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBwYXJhbXMuYWN0aW9ucykge1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyXCIgLyogU291cmNlVHlwZS5Qb2ludGVyICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5wYXJhbWV0ZXJzID8/PSB7IHBvaW50ZXJUeXBlOiBcIm1vdXNlXCIgLyogSW5wdXQuUG9pbnRlclR5cGUuTW91c2UgKi8gfTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnBhcmFtZXRlcnMucG9pbnRlclR5cGUgPz89IFwibW91c2VcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Nb3VzZSAqLztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gaW5wdXRTdGF0ZS5nZXRPckNyZWF0ZShhY3Rpb24uaWQsIFwicG9pbnRlclwiIC8qIFNvdXJjZVR5cGUuUG9pbnRlciAqLywgYWN0aW9uLnBhcmFtZXRlcnMucG9pbnRlclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnN1YnR5cGUgIT09IGFjdGlvbi5wYXJhbWV0ZXJzLnBvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEV4cGVjdGVkIGlucHV0IHNvdXJjZSAke2FjdGlvbi5pZH0gdG8gYmUgJHtzb3VyY2Uuc3VidHlwZX07IGdvdCAke2FjdGlvbi5wYXJhbWV0ZXJzLnBvaW50ZXJUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRTdGF0ZS5nZXRPckNyZWF0ZShhY3Rpb24uaWQsIGFjdGlvbi50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhY3Rpb24uYWN0aW9ucy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgaWQ6IGFjdGlvbi5pZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGl0ZW0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uc0J5VGljay5sZW5ndGggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0J5VGljay5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWN0aW9uc0J5VGlja1tpXS5wdXNoKGFjdGlvbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25zQnlUaWNrO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRQcm9jZXNzb3IgPSBJbnB1dFByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0UHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldoZWVsU291cmNlID0gZXhwb3J0cy5Qb2ludGVyU291cmNlID0gZXhwb3J0cy5LZXlTb3VyY2UgPSBleHBvcnRzLk5vbmVTb3VyY2UgPSB2b2lkIDA7XG5jbGFzcyBOb25lU291cmNlIHtcbiAgICB0eXBlID0gXCJub25lXCIgLyogU291cmNlVHlwZS5Ob25lICovO1xufVxuZXhwb3J0cy5Ob25lU291cmNlID0gTm9uZVNvdXJjZTtcbmNsYXNzIEtleVNvdXJjZSB7XG4gICAgdHlwZSA9IFwia2V5XCIgLyogU291cmNlVHlwZS5LZXkgKi87XG4gICAgcHJlc3NlZCA9IG5ldyBTZXQoKTtcbiAgICAvLyBUaGlzIGlzIGEgYml0ZmllbGQgdGhhdCBtYXRjaGVzIHRoZSBtb2RpZmllcnMgcGFyYW1ldGVyIG9mXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0lucHV0LyNtZXRob2QtZGlzcGF0Y2hLZXlFdmVudFxuICAgICNtb2RpZmllcnMgPSAwO1xuICAgIGdldCBtb2RpZmllcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtb2RpZmllcnM7XG4gICAgfVxuICAgIGdldCBhbHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jbW9kaWZpZXJzICYgMSkgPT09IDE7XG4gICAgfVxuICAgIHNldCBhbHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDEpO1xuICAgIH1cbiAgICBnZXQgY3RybCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNtb2RpZmllcnMgJiAyKSA9PT0gMjtcbiAgICB9XG4gICAgc2V0IGN0cmwodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDIpO1xuICAgIH1cbiAgICBnZXQgbWV0YSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNtb2RpZmllcnMgJiA0KSA9PT0gNDtcbiAgICB9XG4gICAgc2V0IG1ldGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jc2V0TW9kaWZpZXIodmFsdWUsIDQpO1xuICAgIH1cbiAgICBnZXQgc2hpZnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jbW9kaWZpZXJzICYgOCkgPT09IDg7XG4gICAgfVxuICAgIHNldCBzaGlmdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNzZXRNb2RpZmllcih2YWx1ZSwgOCk7XG4gICAgfVxuICAgICNzZXRNb2RpZmllcih2YWx1ZSwgYml0KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4jbW9kaWZpZXJzIHw9IGJpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI21vZGlmaWVycyAmPSB+Yml0O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXlTb3VyY2UgPSBLZXlTb3VyY2U7XG5jbGFzcyBQb2ludGVyU291cmNlIHtcbiAgICB0eXBlID0gXCJwb2ludGVyXCIgLyogU291cmNlVHlwZS5Qb2ludGVyICovO1xuICAgIHN1YnR5cGU7XG4gICAgcG9pbnRlcklkO1xuICAgIHByZXNzZWQgPSBuZXcgU2V0KCk7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gICAgcmFkaXVzWDtcbiAgICByYWRpdXNZO1xuICAgIGZvcmNlO1xuICAgIGNvbnN0cnVjdG9yKGlkLCBzdWJ0eXBlKSB7XG4gICAgICAgIHRoaXMucG9pbnRlcklkID0gaWQ7XG4gICAgICAgIHRoaXMuc3VidHlwZSA9IHN1YnR5cGU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBiaXRmaWVsZCB0aGF0IG1hdGNoZXMgdGhlIGJ1dHRvbnMgcGFyYW1ldGVyIG9mXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0lucHV0LyNtZXRob2QtZGlzcGF0Y2hNb3VzZUV2ZW50XG4gICAgZ2V0IGJ1dHRvbnMoKSB7XG4gICAgICAgIGxldCBidXR0b25zID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5wcmVzc2VkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyB8PSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgfD0gNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBidXR0b25zIHw9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyB8PSA4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgfD0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidXR0b25zO1xuICAgIH1cbiAgICAvLyAtLS0gUGxhdGZvcm0tc3BlY2lmaWMgY29kZSBzdGFydHMgaGVyZSAtLS1cbiAgICAvLyBJbnB1dC5kaXNwYXRjaE1vdXNlRXZlbnQgZG9lc24ndCBrbm93IHRoZSBjb25jZXB0IG9mIGRvdWJsZSBjbGljaywgc28gd2VcbiAgICAvLyBuZWVkIHRvIGNyZWF0ZSB0aGUgbG9naWMsIHNpbWlsYXIgdG8gaG93IGl0J3MgZG9uZSBmb3IgT1NlczpcbiAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvcmVmcy9oZWFkcy9tYWluOnVpL2V2ZW50cy9ldmVudC5jYztsPTQ3OVxuICAgIHN0YXRpYyBDbGlja0NvbnRleHQgPSBjbGFzcyBDbGlja0NvbnRleHQge1xuICAgICAgICBzdGF0aWMgI0RPVUJMRV9DTElDS19USU1FX01TID0gNTAwO1xuICAgICAgICBzdGF0aWMgI01BWF9ET1VCTEVfQ0xJQ0tfUkFESVVTID0gMjtcbiAgICAgICAgY291bnQgPSAwO1xuICAgICAgICAjeDtcbiAgICAgICAgI3k7XG4gICAgICAgICN0aW1lO1xuICAgICAgICBjb25zdHJ1Y3Rvcih4LCB5LCB0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLiN4ID0geDtcbiAgICAgICAgICAgIHRoaXMuI3kgPSB5O1xuICAgICAgICAgICAgdGhpcy4jdGltZSA9IHRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGFyZShjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVGhlIGNsaWNrIG5lZWRzIHRvIGJlIHdpdGhpbiBhIGNlcnRhaW4gYW1vdW50IG9mIG1zLlxuICAgICAgICAgICAgY29udGV4dC4jdGltZSAtIHRoaXMuI3RpbWUgPiBDbGlja0NvbnRleHQuI0RPVUJMRV9DTElDS19USU1FX01TIHx8XG4gICAgICAgICAgICAgICAgLy8gVGhlIGNsaWNrIG5lZWRzIHRvIGJlIHdpdGhpbiBhIGNlcnRhaW4gc3F1YXJlIHJhZGl1cy5cbiAgICAgICAgICAgICAgICBNYXRoLmFicyhjb250ZXh0LiN4IC0gdGhpcy4jeCkgPlxuICAgICAgICAgICAgICAgICAgICBDbGlja0NvbnRleHQuI01BWF9ET1VCTEVfQ0xJQ0tfUkFESVVTIHx8XG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoY29udGV4dC4jeSAtIHRoaXMuI3kpID4gQ2xpY2tDb250ZXh0LiNNQVhfRE9VQkxFX0NMSUNLX1JBRElVUyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgICNjbGlja0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgIHNldENsaWNrQ291bnQoYnV0dG9uLCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdG9yZWRDb250ZXh0ID0gdGhpcy4jY2xpY2tDb250ZXh0cy5nZXQoYnV0dG9uKTtcbiAgICAgICAgaWYgKCFzdG9yZWRDb250ZXh0IHx8IHN0b3JlZENvbnRleHQuY29tcGFyZShjb250ZXh0KSkge1xuICAgICAgICAgICAgc3RvcmVkQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgKytzdG9yZWRDb250ZXh0LmNvdW50O1xuICAgICAgICB0aGlzLiNjbGlja0NvbnRleHRzLnNldChidXR0b24sIHN0b3JlZENvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RvcmVkQ29udGV4dC5jb3VudDtcbiAgICB9XG4gICAgZ2V0Q2xpY2tDb3VudChidXR0b24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NsaWNrQ29udGV4dHMuZ2V0KGJ1dHRvbik/LmNvdW50ID8/IDA7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2ludGVyU291cmNlID0gUG9pbnRlclNvdXJjZTtcbmNsYXNzIFdoZWVsU291cmNlIHtcbiAgICB0eXBlID0gXCJ3aGVlbFwiIC8qIFNvdXJjZVR5cGUuV2hlZWwgKi87XG59XG5leHBvcnRzLldoZWVsU291cmNlID0gV2hlZWxTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFNvdXJjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnB1dFN0YXRlID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IE11dGV4X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvTXV0ZXguanNcIik7XG5jb25zdCBJbnB1dFNvdXJjZV9qc18xID0gcmVxdWlyZShcIi4vSW5wdXRTb3VyY2UuanNcIik7XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjYW5jZWxMaXN0ID0gW107XG4gICAgI3NvdXJjZXMgPSBuZXcgTWFwKCk7XG4gICAgI211dGV4ID0gbmV3IE11dGV4X2pzXzEuTXV0ZXgoKTtcbiAgICBnZXRPckNyZWF0ZShpZCwgdHlwZSwgc3VidHlwZSkge1xuICAgICAgICBsZXQgc291cmNlID0gdGhpcy4jc291cmNlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBTb3VyY2VUeXBlLk5vbmUgKi86XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBJbnB1dFNvdXJjZV9qc18xLk5vbmVTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImtleVwiIC8qIFNvdXJjZVR5cGUuS2V5ICovOlxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgSW5wdXRTb3VyY2VfanNfMS5LZXlTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJcIiAvKiBTb3VyY2VUeXBlLlBvaW50ZXIgKi86IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXJJZCA9IHN1YnR5cGUgPT09IFwibW91c2VcIiAvKiBJbnB1dC5Qb2ludGVyVHlwZS5Nb3VzZSAqLyA/IDAgOiAyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVySWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFssIHNvdXJjZV0gb2YgdGhpcy4jc291cmNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS50eXBlID09PSBcInBvaW50ZXJcIiAvKiBTb3VyY2VUeXBlLlBvaW50ZXIgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVySWRzLmFkZChzb3VyY2UucG9pbnRlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9pbnRlcklkcy5oYXMocG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwb2ludGVySWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbmV3IElucHV0U291cmNlX2pzXzEuUG9pbnRlclNvdXJjZShwb2ludGVySWQsIHN1YnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIndoZWVsXCIgLyogU291cmNlVHlwZS5XaGVlbCAqLzpcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gbmV3IElucHV0U291cmNlX2pzXzEuV2hlZWxTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBFeHBlY3RlZCBcIiR7XCJub25lXCIgLyogU291cmNlVHlwZS5Ob25lICovfVwiLCBcIiR7XCJrZXlcIiAvKiBTb3VyY2VUeXBlLktleSAqL31cIiwgXCIke1wicG9pbnRlclwiIC8qIFNvdXJjZVR5cGUuUG9pbnRlciAqL31cIiwgb3IgXCIke1wid2hlZWxcIiAvKiBTb3VyY2VUeXBlLldoZWVsICovfVwiLiBGb3VuZCB1bmtub3duIHNvdXJjZSB0eXBlICR7dHlwZX0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNzb3VyY2VzLnNldChpZCwgc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYElucHV0IHNvdXJjZSB0eXBlIG9mICR7aWR9IGlzICR7c291cmNlLnR5cGV9LCBidXQgcmVjZWl2ZWQgJHt0eXBlfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBnZXQoaWQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy4jc291cmNlcy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5rbm93bkVycm9yRXhjZXB0aW9uKGBJbnRlcm5hbCBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBnZXRHbG9iYWxLZXlTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgSW5wdXRTb3VyY2VfanNfMS5LZXlTb3VyY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBbLCBzb3VyY2VdIG9mIHRoaXMuI3NvdXJjZXMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudHlwZSAhPT0gXCJrZXlcIiAvKiBTb3VyY2VUeXBlLktleSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVzc2VkIG9mIHNvdXJjZS5wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJlc3NlZC5hZGQocHJlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS5hbHQgfHw9IHNvdXJjZS5hbHQ7XG4gICAgICAgICAgICBzdGF0ZS5jdHJsIHx8PSBzb3VyY2UuY3RybDtcbiAgICAgICAgICAgIHN0YXRlLm1ldGEgfHw9IHNvdXJjZS5tZXRhO1xuICAgICAgICAgICAgc3RhdGUuc2hpZnQgfHw9IHNvdXJjZS5zaGlmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGdldCBxdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI211dGV4O1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRTdGF0ZSA9IElucHV0U3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dFN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0U3RhdGVNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvYXNzZXJ0LmpzXCIpO1xuY29uc3QgSW5wdXRTdGF0ZV9qc18xID0gcmVxdWlyZShcIi4vSW5wdXRTdGF0ZS5qc1wiKTtcbi8vIFdlIHVzZSBhIHdlYWsgbWFwIGhlcmUgYXMgc3BlY2lmaWVkIGhlcmU6XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViZHJpdmVyLyNkZm4tYnJvd3NpbmctY29udGV4dC1pbnB1dC1zdGF0ZS1tYXBcbmNsYXNzIElucHV0U3RhdGVNYW5hZ2VyIGV4dGVuZHMgV2Vha01hcCB7XG4gICAgZ2V0KGNvbnRleHQpIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkoY29udGV4dC5pc1RvcExldmVsQ29udGV4dCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29udGV4dCwgbmV3IElucHV0U3RhdGVfanNfMS5JbnB1dFN0YXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoY29udGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnB1dFN0YXRlTWFuYWdlciA9IElucHV0U3RhdGVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5wdXRTdGF0ZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5VG9LZXlDb2RlID0gdm9pZCAwO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgb25jZSBodHRwczovL2NycmV2LmNvbS9jLzQ1NDgyOTAgaXMgc3RhYmx5IGluIENocm9taXVtLlxuLy8gYElucHV0LmRpc3BhdGNoS2V5Ym9hcmRFdmVudGAgd2lsbCBhdXRvbWF0aWNhbGx5IGhhbmRsZSB0aGVzZSBjb252ZXJzaW9ucy5cbmV4cG9ydHMuS2V5VG9LZXlDb2RlID0ge1xuICAgICcwJzogNDgsXG4gICAgJzEnOiA0OSxcbiAgICAnMic6IDUwLFxuICAgICczJzogNTEsXG4gICAgJzQnOiA1MixcbiAgICAnNSc6IDUzLFxuICAgICc2JzogNTQsXG4gICAgJzcnOiA1NSxcbiAgICAnOCc6IDU2LFxuICAgICc5JzogNTcsXG4gICAgQWJvcnQ6IDMsXG4gICAgSGVscDogNixcbiAgICBCYWNrc3BhY2U6IDgsXG4gICAgVGFiOiA5LFxuICAgIE51bXBhZDU6IDEyLFxuICAgIE51bXBhZEVudGVyOiAxMyxcbiAgICBFbnRlcjogMTMsXG4gICAgJ1xcXFxyJzogMTMsXG4gICAgJ1xcXFxuJzogMTMsXG4gICAgU2hpZnRMZWZ0OiAxNixcbiAgICBTaGlmdFJpZ2h0OiAxNixcbiAgICBDb250cm9sTGVmdDogMTcsXG4gICAgQ29udHJvbFJpZ2h0OiAxNyxcbiAgICBBbHRMZWZ0OiAxOCxcbiAgICBBbHRSaWdodDogMTgsXG4gICAgUGF1c2U6IDE5LFxuICAgIENhcHNMb2NrOiAyMCxcbiAgICBFc2NhcGU6IDI3LFxuICAgIENvbnZlcnQ6IDI4LFxuICAgIE5vbkNvbnZlcnQ6IDI5LFxuICAgIFNwYWNlOiAzMixcbiAgICBOdW1wYWQ5OiAzMyxcbiAgICBQYWdlVXA6IDMzLFxuICAgIE51bXBhZDM6IDM0LFxuICAgIFBhZ2VEb3duOiAzNCxcbiAgICBFbmQ6IDM1LFxuICAgIE51bXBhZDE6IDM1LFxuICAgIEhvbWU6IDM2LFxuICAgIE51bXBhZDc6IDM2LFxuICAgIEFycm93TGVmdDogMzcsXG4gICAgTnVtcGFkNDogMzcsXG4gICAgTnVtcGFkODogMzgsXG4gICAgQXJyb3dVcDogMzgsXG4gICAgQXJyb3dSaWdodDogMzksXG4gICAgTnVtcGFkNjogMzksXG4gICAgTnVtcGFkMjogNDAsXG4gICAgQXJyb3dEb3duOiA0MCxcbiAgICBTZWxlY3Q6IDQxLFxuICAgIE9wZW46IDQzLFxuICAgIFByaW50U2NyZWVuOiA0NCxcbiAgICBJbnNlcnQ6IDQ1LFxuICAgIE51bXBhZDA6IDQ1LFxuICAgIERlbGV0ZTogNDYsXG4gICAgTnVtcGFkRGVjaW1hbDogNDYsXG4gICAgRGlnaXQwOiA0OCxcbiAgICBEaWdpdDE6IDQ5LFxuICAgIERpZ2l0MjogNTAsXG4gICAgRGlnaXQzOiA1MSxcbiAgICBEaWdpdDQ6IDUyLFxuICAgIERpZ2l0NTogNTMsXG4gICAgRGlnaXQ2OiA1NCxcbiAgICBEaWdpdDc6IDU1LFxuICAgIERpZ2l0ODogNTYsXG4gICAgRGlnaXQ5OiA1NyxcbiAgICBLZXlBOiA2NSxcbiAgICBLZXlCOiA2NixcbiAgICBLZXlDOiA2NyxcbiAgICBLZXlEOiA2OCxcbiAgICBLZXlFOiA2OSxcbiAgICBLZXlGOiA3MCxcbiAgICBLZXlHOiA3MSxcbiAgICBLZXlIOiA3MixcbiAgICBLZXlJOiA3MyxcbiAgICBLZXlKOiA3NCxcbiAgICBLZXlLOiA3NSxcbiAgICBLZXlMOiA3NixcbiAgICBLZXlNOiA3NyxcbiAgICBLZXlOOiA3OCxcbiAgICBLZXlPOiA3OSxcbiAgICBLZXlQOiA4MCxcbiAgICBLZXlROiA4MSxcbiAgICBLZXlSOiA4MixcbiAgICBLZXlTOiA4MyxcbiAgICBLZXlUOiA4NCxcbiAgICBLZXlVOiA4NSxcbiAgICBLZXlWOiA4NixcbiAgICBLZXlXOiA4NyxcbiAgICBLZXlYOiA4OCxcbiAgICBLZXlZOiA4OSxcbiAgICBLZXlaOiA5MCxcbiAgICBNZXRhTGVmdDogOTEsXG4gICAgTWV0YVJpZ2h0OiA5MixcbiAgICBDb250ZXh0TWVudTogOTMsXG4gICAgTnVtcGFkTXVsdGlwbHk6IDEwNixcbiAgICBOdW1wYWRBZGQ6IDEwNyxcbiAgICBOdW1wYWRTdWJ0cmFjdDogMTA5LFxuICAgIE51bXBhZERpdmlkZTogMTExLFxuICAgIEYxOiAxMTIsXG4gICAgRjI6IDExMyxcbiAgICBGMzogMTE0LFxuICAgIEY0OiAxMTUsXG4gICAgRjU6IDExNixcbiAgICBGNjogMTE3LFxuICAgIEY3OiAxMTgsXG4gICAgRjg6IDExOSxcbiAgICBGOTogMTIwLFxuICAgIEYxMDogMTIxLFxuICAgIEYxMTogMTIyLFxuICAgIEYxMjogMTIzLFxuICAgIEYxMzogMTI0LFxuICAgIEYxNDogMTI1LFxuICAgIEYxNTogMTI2LFxuICAgIEYxNjogMTI3LFxuICAgIEYxNzogMTI4LFxuICAgIEYxODogMTI5LFxuICAgIEYxOTogMTMwLFxuICAgIEYyMDogMTMxLFxuICAgIEYyMTogMTMyLFxuICAgIEYyMjogMTMzLFxuICAgIEYyMzogMTM0LFxuICAgIEYyNDogMTM1LFxuICAgIE51bUxvY2s6IDE0NCxcbiAgICBTY3JvbGxMb2NrOiAxNDUsXG4gICAgQXVkaW9Wb2x1bWVNdXRlOiAxNzMsXG4gICAgQXVkaW9Wb2x1bWVEb3duOiAxNzQsXG4gICAgQXVkaW9Wb2x1bWVVcDogMTc1LFxuICAgIE1lZGlhVHJhY2tOZXh0OiAxNzYsXG4gICAgTWVkaWFUcmFja1ByZXZpb3VzOiAxNzcsXG4gICAgTWVkaWFTdG9wOiAxNzgsXG4gICAgTWVkaWFQbGF5UGF1c2U6IDE3OSxcbiAgICBTZW1pY29sb246IDE4NixcbiAgICBFcXVhbDogMTg3LFxuICAgIE51bXBhZEVxdWFsOiAxODcsXG4gICAgQ29tbWE6IDE4OCxcbiAgICBNaW51czogMTg5LFxuICAgIFBlcmlvZDogMTkwLFxuICAgIFNsYXNoOiAxOTEsXG4gICAgQmFja3F1b3RlOiAxOTIsXG4gICAgQnJhY2tldExlZnQ6IDIxOSxcbiAgICBCYWNrc2xhc2g6IDIyMCxcbiAgICBCcmFja2V0UmlnaHQ6IDIyMSxcbiAgICBRdW90ZTogMjIyLFxuICAgIEFsdEdyYXBoOiAyMjUsXG4gICAgUHJvcHM6IDI0NyxcbiAgICBDYW5jZWw6IDMsXG4gICAgQ2xlYXI6IDEyLFxuICAgIFNoaWZ0OiAxNixcbiAgICBDb250cm9sOiAxNyxcbiAgICBBbHQ6IDE4LFxuICAgIEFjY2VwdDogMzAsXG4gICAgTW9kZUNoYW5nZTogMzEsXG4gICAgJyAnOiAzMixcbiAgICBQcmludDogNDIsXG4gICAgRXhlY3V0ZTogNDMsXG4gICAgJ1xcXFx1MDAwMCc6IDQ2LFxuICAgIGE6IDY1LFxuICAgIGI6IDY2LFxuICAgIGM6IDY3LFxuICAgIGQ6IDY4LFxuICAgIGU6IDY5LFxuICAgIGY6IDcwLFxuICAgIGc6IDcxLFxuICAgIGg6IDcyLFxuICAgIGk6IDczLFxuICAgIGo6IDc0LFxuICAgIGs6IDc1LFxuICAgIGw6IDc2LFxuICAgIG06IDc3LFxuICAgIG46IDc4LFxuICAgIG86IDc5LFxuICAgIHA6IDgwLFxuICAgIHE6IDgxLFxuICAgIHI6IDgyLFxuICAgIHM6IDgzLFxuICAgIHQ6IDg0LFxuICAgIHU6IDg1LFxuICAgIHY6IDg2LFxuICAgIHc6IDg3LFxuICAgIHg6IDg4LFxuICAgIHk6IDg5LFxuICAgIHo6IDkwLFxuICAgIE1ldGE6IDkxLFxuICAgICcqJzogMTA2LFxuICAgICcrJzogMTA3LFxuICAgICctJzogMTA5LFxuICAgICcvJzogMTExLFxuICAgICc7JzogMTg2LFxuICAgICc9JzogMTg3LFxuICAgICcsJzogMTg4LFxuICAgICcuJzogMTkwLFxuICAgICdgJzogMTkyLFxuICAgICdbJzogMjE5LFxuICAgICdcXFxcXFxcXCc6IDIyMCxcbiAgICAnXSc6IDIyMSxcbiAgICBcIidcIjogMjIyLFxuICAgIEF0dG46IDI0NixcbiAgICBDclNlbDogMjQ3LFxuICAgIEV4U2VsOiAyNDgsXG4gICAgRXJhc2VFb2Y6IDI0OSxcbiAgICBQbGF5OiAyNTAsXG4gICAgWm9vbU91dDogMjUxLFxuICAgICcpJzogNDgsXG4gICAgJyEnOiA0OSxcbiAgICAnQCc6IDUwLFxuICAgICcjJzogNTEsXG4gICAgJDogNTIsXG4gICAgJyUnOiA1MyxcbiAgICAnXic6IDU0LFxuICAgICcmJzogNTUsXG4gICAgJygnOiA1NyxcbiAgICBBOiA2NSxcbiAgICBCOiA2NixcbiAgICBDOiA2NyxcbiAgICBEOiA2OCxcbiAgICBFOiA2OSxcbiAgICBGOiA3MCxcbiAgICBHOiA3MSxcbiAgICBIOiA3MixcbiAgICBJOiA3MyxcbiAgICBKOiA3NCxcbiAgICBLOiA3NSxcbiAgICBMOiA3NixcbiAgICBNOiA3NyxcbiAgICBOOiA3OCxcbiAgICBPOiA3OSxcbiAgICBQOiA4MCxcbiAgICBROiA4MSxcbiAgICBSOiA4MixcbiAgICBTOiA4MyxcbiAgICBUOiA4NCxcbiAgICBVOiA4NSxcbiAgICBWOiA4NixcbiAgICBXOiA4NyxcbiAgICBYOiA4OCxcbiAgICBZOiA4OSxcbiAgICBaOiA5MCxcbiAgICAnOic6IDE4NixcbiAgICAnPCc6IDE4OCxcbiAgICBfOiAxODksXG4gICAgJz4nOiAxOTAsXG4gICAgJz8nOiAxOTEsXG4gICAgJ34nOiAxOTIsXG4gICAgJ3snOiAyMTksXG4gICAgJ3wnOiAyMjAsXG4gICAgJ30nOiAyMjEsXG4gICAgJ1wiJzogMjIyLFxuICAgIENhbWVyYTogNDQsXG4gICAgRW5kQ2FsbDogOTUsXG4gICAgVm9sdW1lRG93bjogMTgyLFxuICAgIFZvbHVtZVVwOiAxODMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VVNLZXlib2FyZExheW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROb3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZEtleTtcbmV4cG9ydHMuZ2V0S2V5Q29kZSA9IGdldEtleUNvZGU7XG5leHBvcnRzLmdldEtleUxvY2F0aW9uID0gZ2V0S2V5TG9jYXRpb247XG4vKipcbiAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQga2V5IHZhbHVlIGZvciBhIGdpdmVuIGtleSBhY2NvcmRpbmcgdG8gdGhlIHRhYmxlOlxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci8jZGZuLW5vcm1hbGl6ZWQta2V5LXZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRLZXkodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDAnOlxuICAgICAgICAgICAgcmV0dXJuICdVbmlkZW50aWZpZWQnO1xuICAgICAgICBjYXNlICdcXHVFMDAxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ2FuY2VsJztcbiAgICAgICAgY2FzZSAnXFx1RTAwMic6XG4gICAgICAgICAgICByZXR1cm4gJ0hlbHAnO1xuICAgICAgICBjYXNlICdcXHVFMDAzJzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3NwYWNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAwNCc6XG4gICAgICAgICAgICByZXR1cm4gJ1RhYic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDUnOlxuICAgICAgICAgICAgcmV0dXJuICdDbGVhcic7XG4gICAgICAgIC8vIFNwZWNpZmljYXRpb24gZGVjbGFyZXMgdGhlICdcXHVFMDA2JyB0byBiZSBgUmV0dXJuYCwgYnV0IGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAgICAgICAgLy8gQ2hyb21lLCBzbyBmYWxsIGJhY2sgdG8gYEVudGVyYCwgd2hpY2ggYWxpZ25zIHdpdGggV1BULlxuICAgICAgICBjYXNlICdcXHVFMDA2JzpcbiAgICAgICAgY2FzZSAnXFx1RTAwNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0VudGVyJztcbiAgICAgICAgY2FzZSAnXFx1RTAwOCc6XG4gICAgICAgICAgICByZXR1cm4gJ1NoaWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0NvbnRyb2wnO1xuICAgICAgICBjYXNlICdcXHVFMDBBJzpcbiAgICAgICAgICAgIHJldHVybiAnQWx0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwQic6XG4gICAgICAgICAgICByZXR1cm4gJ1BhdXNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQyc6XG4gICAgICAgICAgICByZXR1cm4gJ0VzY2FwZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEQnOlxuICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgY2FzZSAnXFx1RTAwRSc6XG4gICAgICAgICAgICByZXR1cm4gJ1BhZ2VVcCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEYnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlRG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTAnOlxuICAgICAgICAgICAgcmV0dXJuICdFbmQnO1xuICAgICAgICBjYXNlICdcXHVFMDExJzpcbiAgICAgICAgICAgIHJldHVybiAnSG9tZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTInOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd0xlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDEzJzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dVcCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTQnOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd1JpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93RG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTYnOlxuICAgICAgICAgICAgcmV0dXJuICdJbnNlcnQnO1xuICAgICAgICBjYXNlICdcXHVFMDE3JzpcbiAgICAgICAgICAgIHJldHVybiAnRGVsZXRlJztcbiAgICAgICAgY2FzZSAnXFx1RTAxOCc6XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICBjYXNlICdcXHVFMDE5JzpcbiAgICAgICAgICAgIHJldHVybiAnPSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMUEnOlxuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQic6XG4gICAgICAgICAgICByZXR1cm4gJzEnO1xuICAgICAgICBjYXNlICdcXHVFMDFDJzpcbiAgICAgICAgICAgIHJldHVybiAnMic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMUQnOlxuICAgICAgICAgICAgcmV0dXJuICczJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRSc6XG4gICAgICAgICAgICByZXR1cm4gJzQnO1xuICAgICAgICBjYXNlICdcXHVFMDFGJzpcbiAgICAgICAgICAgIHJldHVybiAnNSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjAnOlxuICAgICAgICAgICAgcmV0dXJuICc2JztcbiAgICAgICAgY2FzZSAnXFx1RTAyMSc6XG4gICAgICAgICAgICByZXR1cm4gJzcnO1xuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgICAgIHJldHVybiAnOCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjMnOlxuICAgICAgICAgICAgcmV0dXJuICc5JztcbiAgICAgICAgY2FzZSAnXFx1RTAyNCc6XG4gICAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgICAgIHJldHVybiAnKyc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjYnOlxuICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgY2FzZSAnXFx1RTAyNyc6XG4gICAgICAgICAgICByZXR1cm4gJy0nO1xuICAgICAgICBjYXNlICdcXHVFMDI4JzpcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjknOlxuICAgICAgICAgICAgcmV0dXJuICcvJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMic6XG4gICAgICAgICAgICByZXR1cm4gJ0YyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0YzJztcbiAgICAgICAgY2FzZSAnXFx1RTAzNCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y0JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y1JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNic6XG4gICAgICAgICAgICByZXR1cm4gJ0Y2JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y3JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y4JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y5JztcbiAgICAgICAgY2FzZSAnXFx1RTAzQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxMCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwM0InOlxuICAgICAgICAgICAgcmV0dXJuICdGMTEnO1xuICAgICAgICBjYXNlICdcXHVFMDNDJzpcbiAgICAgICAgICAgIHJldHVybiAnRjEyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzRCc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGEnO1xuICAgICAgICBjYXNlICdcXHVFMDQwJzpcbiAgICAgICAgICAgIHJldHVybiAnWmVua2FrdUhhbmtha3UnO1xuICAgICAgICBjYXNlICdcXHVFMDUwJzpcbiAgICAgICAgICAgIHJldHVybiAnU2hpZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTInOlxuICAgICAgICAgICAgcmV0dXJuICdBbHQnO1xuICAgICAgICBjYXNlICdcXHVFMDUzJzpcbiAgICAgICAgICAgIHJldHVybiAnTWV0YSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTQnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlVXAnO1xuICAgICAgICBjYXNlICdcXHVFMDU1JzpcbiAgICAgICAgICAgIHJldHVybiAnUGFnZURvd24nO1xuICAgICAgICBjYXNlICdcXHVFMDU2JzpcbiAgICAgICAgICAgIHJldHVybiAnRW5kJztcbiAgICAgICAgY2FzZSAnXFx1RTA1Nyc6XG4gICAgICAgICAgICByZXR1cm4gJ0hvbWUnO1xuICAgICAgICBjYXNlICdcXHVFMDU4JzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dMZWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93VXAnO1xuICAgICAgICBjYXNlICdcXHVFMDVBJzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dSaWdodCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwNUInOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd0Rvd24nO1xuICAgICAgICBjYXNlICdcXHVFMDVDJzpcbiAgICAgICAgICAgIHJldHVybiAnSW5zZXJ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1RCc6XG4gICAgICAgICAgICByZXR1cm4gJ0RlbGV0ZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXkgY29kZSBmb3IgYSBnaXZlbiBrZXkgYWNjb3JkaW5nIHRvIHRoZSB0YWJsZTpcbiAqIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXIvI2Rmbi1zaGlmdGVkLWNoYXJhY3RlclxuICovXG5mdW5jdGlvbiBnZXRLZXlDb2RlKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2AnOlxuICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3F1b3RlJztcbiAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgcmV0dXJuICdCYWNrc2xhc2gnO1xuICAgICAgICBjYXNlICdcXHVFMDAzJzpcbiAgICAgICAgICAgIHJldHVybiAnQmFja3NwYWNlJztcbiAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgcmV0dXJuICdCcmFja2V0TGVmdCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHJldHVybiAnQnJhY2tldFJpZ2h0JztcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuICdDb21tYSc7XG4gICAgICAgIGNhc2UgJzAnOlxuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQwJztcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDEnO1xuICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0Mic7XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQzJztcbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDQnO1xuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0NSc7XG4gICAgICAgIGNhc2UgJzYnOlxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQ2JztcbiAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdEaWdpdDcnO1xuICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICByZXR1cm4gJ0RpZ2l0OCc7XG4gICAgICAgIGNhc2UgJzknOlxuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgIHJldHVybiAnRGlnaXQ5JztcbiAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgcmV0dXJuICdFcXVhbCc7XG4gICAgICAgIC8vIFRoZSBzcGVjIGRlY2xhcmVzIHRoZSAnPCcgdG8gYmUgYEludGxCYWNrc2xhc2hgIGFzIHdlbGwsIGJ1dCBpdCBpcyBhbHJlYWR5IGNvdmVyZWRcbiAgICAgICAgLy8gaW4gdGhlIGBDb21tYWAgYWJvdmUuXG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdJbnRsQmFja3NsYXNoJztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlBJztcbiAgICAgICAgY2FzZSAnYic6XG4gICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlCJztcbiAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlDJztcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlEJztcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlFJztcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgIGNhc2UgJ0YnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlGJztcbiAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlHJztcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlIJztcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlJJztcbiAgICAgICAgY2FzZSAnaic6XG4gICAgICAgIGNhc2UgJ0onOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlKJztcbiAgICAgICAgY2FzZSAnayc6XG4gICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlLJztcbiAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlMJztcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlNJztcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlOJztcbiAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgIGNhc2UgJ08nOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlPJztcbiAgICAgICAgY2FzZSAncCc6XG4gICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlQJztcbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlRJztcbiAgICAgICAgY2FzZSAncic6XG4gICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlSJztcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlTJztcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlUJztcbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlVJztcbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlWJztcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlXJztcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlYJztcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlZJztcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgcmV0dXJuICdLZXlaJztcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgcmV0dXJuICdNaW51cyc7XG4gICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgcmV0dXJuICdQZXJpb2QnO1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ1F1b3RlJztcbiAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdTZW1pY29sb24nO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICByZXR1cm4gJ1NsYXNoJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0FsdExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUyJzpcbiAgICAgICAgICAgIHJldHVybiAnQWx0UmlnaHQnO1xuICAgICAgICBjYXNlICdcXHVFMDA5JzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgICAgIHJldHVybiAnQ29udHJvbFJpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAwNic6XG4gICAgICAgICAgICByZXR1cm4gJ0VudGVyJztcbiAgICAgICAgY2FzZSAnXFx1RTAwQic6XG4gICAgICAgICAgICByZXR1cm4gJ1BhdXNlJztcbiAgICAgICAgY2FzZSAnXFx1RTAzRCc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGFMZWZ0JztcbiAgICAgICAgY2FzZSAnXFx1RTA1Myc6XG4gICAgICAgICAgICByZXR1cm4gJ01ldGFSaWdodCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDgnOlxuICAgICAgICAgICAgcmV0dXJuICdTaGlmdExlZnQnO1xuICAgICAgICBjYXNlICdcXHVFMDUwJzpcbiAgICAgICAgICAgIHJldHVybiAnU2hpZnRSaWdodCc7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXHVFMDBEJzpcbiAgICAgICAgICAgIHJldHVybiAnU3BhY2UnO1xuICAgICAgICBjYXNlICdcXHVFMDA0JzpcbiAgICAgICAgICAgIHJldHVybiAnVGFiJztcbiAgICAgICAgY2FzZSAnXFx1RTAxNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0RlbGV0ZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTAnOlxuICAgICAgICAgICAgcmV0dXJuICdFbmQnO1xuICAgICAgICBjYXNlICdcXHVFMDAyJzpcbiAgICAgICAgICAgIHJldHVybiAnSGVscCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTEnOlxuICAgICAgICAgICAgcmV0dXJuICdIb21lJztcbiAgICAgICAgY2FzZSAnXFx1RTAxNic6XG4gICAgICAgICAgICByZXR1cm4gJ0luc2VydCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEYnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlRG93bic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMEUnOlxuICAgICAgICAgICAgcmV0dXJuICdQYWdlVXAnO1xuICAgICAgICBjYXNlICdcXHVFMDE1JzpcbiAgICAgICAgICAgIHJldHVybiAnQXJyb3dEb3duJztcbiAgICAgICAgY2FzZSAnXFx1RTAxMic6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93TGVmdCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMTQnOlxuICAgICAgICAgICAgcmV0dXJuICdBcnJvd1JpZ2h0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Fycm93VXAnO1xuICAgICAgICBjYXNlICdcXHVFMDBDJzpcbiAgICAgICAgICAgIHJldHVybiAnRXNjYXBlJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMic6XG4gICAgICAgICAgICByZXR1cm4gJ0YyJztcbiAgICAgICAgY2FzZSAnXFx1RTAzMyc6XG4gICAgICAgICAgICByZXR1cm4gJ0YzJztcbiAgICAgICAgY2FzZSAnXFx1RTAzNCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y0JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y1JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNic6XG4gICAgICAgICAgICByZXR1cm4gJ0Y2JztcbiAgICAgICAgY2FzZSAnXFx1RTAzNyc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y3JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOCc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y4JztcbiAgICAgICAgY2FzZSAnXFx1RTAzOSc6XG4gICAgICAgICAgICByZXR1cm4gJ0Y5JztcbiAgICAgICAgY2FzZSAnXFx1RTAzQSc6XG4gICAgICAgICAgICByZXR1cm4gJ0YxMCc7XG4gICAgICAgIGNhc2UgJ1xcdUUwM0InOlxuICAgICAgICAgICAgcmV0dXJuICdGMTEnO1xuICAgICAgICBjYXNlICdcXHVFMDNDJzpcbiAgICAgICAgICAgIHJldHVybiAnRjEyJztcbiAgICAgICAgY2FzZSAnXFx1RTAxOSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZEVxdWFsJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUMnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQwJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTYnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQxJztcbiAgICAgICAgY2FzZSAnXFx1RTAxQyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUInOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQyJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTUnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQzJztcbiAgICAgICAgY2FzZSAnXFx1RTAxRSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTgnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWQ0JztcbiAgICAgICAgY2FzZSAnXFx1RTAxRic6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDUnO1xuICAgICAgICBjYXNlICdcXHVFMDIwJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1QSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDYnO1xuICAgICAgICBjYXNlICdcXHVFMDIxJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Nyc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDcnO1xuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDgnO1xuICAgICAgICBjYXNlICdcXHVFMDIzJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1NCc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZDknO1xuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgICAgIHJldHVybiAnTnVtcGFkQWRkJztcbiAgICAgICAgY2FzZSAnXFx1RTAyNic6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZENvbW1hJztcbiAgICAgICAgY2FzZSAnXFx1RTAyOCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUQnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWREZWNpbWFsJztcbiAgICAgICAgY2FzZSAnXFx1RTAyOSc6XG4gICAgICAgICAgICByZXR1cm4gJ051bXBhZERpdmlkZSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDcnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRFbnRlcic7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjQnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRNdWx0aXBseSc7XG4gICAgICAgIGNhc2UgJ1xcdUUwMjcnOlxuICAgICAgICAgICAgcmV0dXJuICdOdW1wYWRTdWJ0cmFjdCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUga2V5IGFjY29yZGluZyB0byB0aGUgdGFibGU6XG4gKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLyNkZm4ta2V5LWxvY2F0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldEtleUxvY2F0aW9uKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ1xcdUUwMDcnOlxuICAgICAgICBjYXNlICdcXHVFMDA4JzpcbiAgICAgICAgY2FzZSAnXFx1RTAwOSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMEEnOlxuICAgICAgICBjYXNlICdcXHVFMDNEJzpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlICdcXHVFMDE5JzpcbiAgICAgICAgY2FzZSAnXFx1RTAxQSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMUInOlxuICAgICAgICBjYXNlICdcXHVFMDFDJzpcbiAgICAgICAgY2FzZSAnXFx1RTAxRCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMUUnOlxuICAgICAgICBjYXNlICdcXHVFMDFGJzpcbiAgICAgICAgY2FzZSAnXFx1RTAyMCc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjEnOlxuICAgICAgICBjYXNlICdcXHVFMDIyJzpcbiAgICAgICAgY2FzZSAnXFx1RTAyMyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjQnOlxuICAgICAgICBjYXNlICdcXHVFMDI1JzpcbiAgICAgICAgY2FzZSAnXFx1RTAyNic6XG4gICAgICAgIGNhc2UgJ1xcdUUwMjcnOlxuICAgICAgICBjYXNlICdcXHVFMDI4JzpcbiAgICAgICAgY2FzZSAnXFx1RTAyOSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTQnOlxuICAgICAgICBjYXNlICdcXHVFMDU1JzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Nic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTcnOlxuICAgICAgICBjYXNlICdcXHVFMDU4JzpcbiAgICAgICAgY2FzZSAnXFx1RTA1OSc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUEnOlxuICAgICAgICBjYXNlICdcXHVFMDVCJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Qyc6XG4gICAgICAgIGNhc2UgJ1xcdUUwNUQnOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgJ1xcdUUwNTAnOlxuICAgICAgICBjYXNlICdcXHVFMDUxJzpcbiAgICAgICAgY2FzZSAnXFx1RTA1Mic6XG4gICAgICAgIGNhc2UgJ1xcdUUwNTMnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlVdGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nTWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCBsb2dIZWxwZXJfanNfMSA9IHJlcXVpcmUoXCIuL2xvZ0hlbHBlci5qc1wiKTtcbi8qKiBDb252ZXJ0cyBDRFAgU3RhY2tUcmFjZSBvYmplY3QgdG8gQmlEaSBTdGFja1RyYWNlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGdldEJpZGlTdGFja1RyYWNlKGNkcFN0YWNrVHJhY2UpIHtcbiAgICBjb25zdCBzdGFja0ZyYW1lcyA9IGNkcFN0YWNrVHJhY2U/LmNhbGxGcmFtZXMubWFwKChjYWxsRnJhbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY2FsbEZyYW1lLmNvbHVtbk51bWJlcixcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogY2FsbEZyYW1lLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGNhbGxGcmFtZS5saW5lTnVtYmVyLFxuICAgICAgICAgICAgdXJsOiBjYWxsRnJhbWUudXJsLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBzdGFja0ZyYW1lcyA/IHsgY2FsbEZyYW1lczogc3RhY2tGcmFtZXMgfSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldExvZ0xldmVsKGNvbnNvbGVBcGlUeXBlKSB7XG4gICAgaWYgKFtcImVycm9yXCIgLyogTG9nLkxldmVsLkVycm9yICovLCAnYXNzZXJ0J10uaW5jbHVkZXMoY29uc29sZUFwaVR5cGUpKSB7XG4gICAgICAgIHJldHVybiBcImVycm9yXCIgLyogTG9nLkxldmVsLkVycm9yICovO1xuICAgIH1cbiAgICBpZiAoW1wiZGVidWdcIiAvKiBMb2cuTGV2ZWwuRGVidWcgKi8sICd0cmFjZSddLmluY2x1ZGVzKGNvbnNvbGVBcGlUeXBlKSkge1xuICAgICAgICByZXR1cm4gXCJkZWJ1Z1wiIC8qIExvZy5MZXZlbC5EZWJ1ZyAqLztcbiAgICB9XG4gICAgaWYgKFtcIndhcm5cIiAvKiBMb2cuTGV2ZWwuV2FybiAqLywgJ3dhcm5pbmcnXS5pbmNsdWRlcyhjb25zb2xlQXBpVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwid2FyblwiIC8qIExvZy5MZXZlbC5XYXJuICovO1xuICAgIH1cbiAgICByZXR1cm4gXCJpbmZvXCIgLyogTG9nLkxldmVsLkluZm8gKi87XG59XG5jbGFzcyBMb2dNYW5hZ2VyIHtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNyZWFsbVN0b3JhZ2U7XG4gICAgI2NkcFRhcmdldDtcbiAgICAjbG9nZ2VyO1xuICAgIGNvbnN0cnVjdG9yKGNkcFRhcmdldCwgcmVhbG1TdG9yYWdlLCBldmVudE1hbmFnZXIsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNjZHBUYXJnZXQgPSBjZHBUYXJnZXQ7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZSA9IHJlYWxtU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLiNsb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY2RwVGFyZ2V0LCByZWFsbVN0b3JhZ2UsIGV2ZW50TWFuYWdlciwgbG9nZ2VyKSB7XG4gICAgICAgIGNvbnN0IGxvZ01hbmFnZXIgPSBuZXcgTG9nTWFuYWdlcihjZHBUYXJnZXQsIHJlYWxtU3RvcmFnZSwgZXZlbnRNYW5hZ2VyLCBsb2dnZXIpO1xuICAgICAgICBsb2dNYW5hZ2VyLiNpbml0aWFsaXplRW50cnlBZGRlZEV2ZW50TGlzdGVuZXIoKTtcbiAgICAgICAgcmV0dXJuIGxvZ01hbmFnZXI7XG4gICAgfVxuICAgICNpbml0aWFsaXplRW50cnlBZGRlZEV2ZW50TGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuI2NkcFRhcmdldC5jZHBDbGllbnQub24oJ1J1bnRpbWUuY29uc29sZUFQSUNhbGxlZCcsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHJlYWxtIGJ5IGBjZHBTZXNzaW9uSWRgIGFuZCBgZXhlY3V0aW9uQ29udGV4dElkYCxcbiAgICAgICAgICAgIC8vIGlmIHByb3ZpZGVkLlxuICAgICAgICAgICAgY29uc3QgcmVhbG0gPSB0aGlzLiNyZWFsbVN0b3JhZ2UuZmluZFJlYWxtKHtcbiAgICAgICAgICAgICAgICBjZHBTZXNzaW9uSWQ6IHRoaXMuI2NkcFRhcmdldC5jZHBTZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiBwYXJhbXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIG5vdCBhdHRhY2hlZCB0byBhbnkgcmVhbG0uXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5jZHAsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJnc1Byb21pc2UgPSByZWFsbSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUocGFyYW1zLmFyZ3MpXG4gICAgICAgICAgICAgICAgOiAvLyBQcm9wZXJseSBzZXJpYWxpemUgYXJndW1lbnRzIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwYXJhbXMuYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxtLnNlcmlhbGl6ZUNkcE9iamVjdChhcmcsIFwibm9uZVwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnJvd3NpbmdDb250ZXh0IG9mIHJlYWxtLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyUHJvbWlzZUV2ZW50KGFyZ3NQcm9taXNlLnRoZW4oKGFyZ3MpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzLkxvZ0VudHJ5QWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogZ2V0TG9nTGV2ZWwocGFyYW1zLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcmVhbG0uc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICgwLCBsb2dIZWxwZXJfanNfMS5nZXRSZW1vdGVWYWx1ZXNUZXh0KShhcmdzLCB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQocGFyYW1zLnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZTogZ2V0QmlkaVN0YWNrVHJhY2UocGFyYW1zLnN0YWNrVHJhY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb25zb2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zb2xlIG1ldGhvZCBpcyBgd2FybmAsIG5vdCBgd2FybmluZ2AuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwYXJhbXMudHlwZSA9PT0gJ3dhcm5pbmcnID8gJ3dhcm4nIDogcGFyYW1zLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksIChlcnJvcikgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSkpLCBicm93c2luZ0NvbnRleHQuaWQsIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkxvZy5FdmVudE5hbWVzLkxvZ0VudHJ5QWRkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudC5vbignUnVudGltZS5leGNlcHRpb25UaHJvd24nLCAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZmluZCByZWFsbSBieSBgY2RwU2Vzc2lvbklkYCBhbmQgYGV4ZWN1dGlvbkNvbnRleHRJZGAsXG4gICAgICAgICAgICAvLyBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jcmVhbG1TdG9yYWdlLmZpbmRSZWFsbSh7XG4gICAgICAgICAgICAgICAgY2RwU2Vzc2lvbklkOiB0aGlzLiNjZHBUYXJnZXQuY2RwU2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogcGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIG5vdCBhdHRhY2hlZCB0byBhbnkgcmVhbG0uXG4gICAgICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5jZHAsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2luZ0NvbnRleHQgb2YgcmVhbG0uYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJQcm9taXNlRXZlbnQoTG9nTWFuYWdlci4jZ2V0RXhjZXB0aW9uVGV4dChwYXJhbXMsIHJlYWxtKS50aGVuKCh0ZXh0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiAnc3VjY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Mb2cuRXZlbnROYW1lcy5Mb2dFbnRyeUFkZGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IFwiZXJyb3JcIiAvKiBMb2cuTGV2ZWwuRXJyb3IgKi8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZWFsbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQocGFyYW1zLnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZTogZ2V0QmlkaVN0YWNrVHJhY2UocGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuc3RhY2tUcmFjZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KSksIGJyb3dzaW5nQ29udGV4dC5pZCwgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTG9nLkV2ZW50TmFtZXMuTG9nRW50cnlBZGRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnkgdGhlIGJlc3QgdG8gZ2V0IHRoZSBleGNlcHRpb24gdGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgI2dldEV4Y2VwdGlvblRleHQocGFyYW1zLCByZWFsbSkge1xuICAgICAgICBpZiAoIXBhcmFtcy5leGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5leGNlcHRpb25EZXRhaWxzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYWxtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMuZXhjZXB0aW9uRGV0YWlscy5leGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCByZWFsbS5zdHJpbmdpZnlPYmplY3QocGFyYW1zLmV4Y2VwdGlvbkRldGFpbHMuZXhjZXB0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkxvZ01hbmFnZXIgPSBMb2dNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2dNZXNzYWdlRm9ybWF0dGVyID0gbG9nTWVzc2FnZUZvcm1hdHRlcjtcbmV4cG9ydHMuZ2V0UmVtb3RlVmFsdWVzVGV4dCA9IGdldFJlbW90ZVZhbHVlc1RleHQ7XG5jb25zdCBhc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9hc3NlcnQuanNcIik7XG5jb25zdCBzcGVjaWZpZXJzID0gWyclcycsICclZCcsICclaScsICclZicsICclbycsICclTycsICclYyddO1xuZnVuY3Rpb24gaXNGb3JtYXRTcGVjaWZpZXIoc3RyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllcnMuc29tZSgoc3BlYykgPT4gc3RyLmluY2x1ZGVzKHNwZWMpKTtcbn1cbi8qKlxuICogQHBhcmFtIGFyZ3MgaW5wdXQgcmVtb3RlIHZhbHVlcyB0byBiZSBmb3JtYXQgcHJpbnRlZFxuICogQHJldHVybiBwYXJzZWQgdGV4dCBvZiB0aGUgcmVtb3RlIHZhbHVlcyBpbiBzcGVjaWZpYyBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbG9nTWVzc2FnZUZvcm1hdHRlcihhcmdzKSB7XG4gICAgbGV0IG91dHB1dCA9ICcnO1xuICAgIGNvbnN0IGFyZ0Zvcm1hdCA9IGFyZ3NbMF0udmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBhcmdWYWx1ZXMgPSBhcmdzLnNsaWNlKDEsIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdG9rZW5zID0gYXJnRm9ybWF0LnNwbGl0KG5ldyBSZWdFeHAoc3BlY2lmaWVycy5tYXAoKHNwZWMpID0+IGAoJHtzcGVjfSlgKS5qb2luKCd8JyksICdnJykpO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuID09PSAnJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRm9ybWF0U3BlY2lmaWVyKHRva2VuKSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnVmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAvLyByYWlzZSBhbiBleGNlcHRpb24gd2hlbiBsZXNzIHZhbHVlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KShhcmcsIGBMZXNzIHZhbHVlIGlzIHByb3ZpZGVkOiBcIiR7Z2V0UmVtb3RlVmFsdWVzVGV4dChhcmdzLCBmYWxzZSl9XCJgKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gJyVzJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJyVkJyB8fCB0b2tlbiA9PT0gJyVpJykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyZy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gcGFyc2VJbnQoYXJnLnZhbHVlLnRvU3RyaW5nKCksIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSAnTmFOJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gJyVmJykge1xuICAgICAgICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgICAgICAgICAgYXJnLnR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyZy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gcGFyc2VGbG9hdChhcmcudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ05hTic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gJW8sICVPLCAlY1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSB0b0pzb24oYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCArPSB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByYWlzZSBhbiBleGNlcHRpb24gd2hlbiBtb3JlIHZhbHVlIGlzIHByb3ZpZGVkXG4gICAgaWYgKGFyZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9yZSB2YWx1ZSBpcyBwcm92aWRlZDogXCIke2dldFJlbW90ZVZhbHVlc1RleHQoYXJncywgZmFsc2UpfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIEBwYXJhbSBhcmcgaW5wdXQgcmVtb3RlIHZhbHVlIHRvIGJlIHBhcnNlZFxuICogQHJldHVybiBwYXJzZWQgdGV4dCBvZiB0aGUgcmVtb3RlIHZhbHVlXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJudW1iZXJcIiwgXCJ2YWx1ZVwiOiAxfVxuICogb3V0cHV0OiAxXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcImFiY1wifVxuICogb3V0cHV0OiBcImFiY1wiXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgIFwidmFsdWVcIjogW1tcImlkXCIsIHtcInR5cGVcIjogXCJudW1iZXJcIiwgXCJ2YWx1ZVwiOiAxfV1dfVxuICogb3V0cHV0OiAne1wiaWRcIjogMX0nXG4gKlxuICogaW5wdXQ6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJ2YWx1ZVwiOiBbW1wiZm9udC1zaXplXCIsIHtcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJ2YWx1ZVwiOiBcIjIwcHhcIn1dXX1cbiAqIG91dHB1dDogJ3tcImZvbnQtc2l6ZVwiOiBcIjIwcHhcIn0nXG4gKi9cbmZ1bmN0aW9uIHRvSnNvbihhcmcpIHtcbiAgICAvLyBhcmcgdHlwZSB2YWxpZGF0aW9uXG4gICAgaWYgKGFyZy50eXBlICE9PSAnYXJyYXknICYmXG4gICAgICAgIGFyZy50eXBlICE9PSAnYmlnaW50JyAmJlxuICAgICAgICBhcmcudHlwZSAhPT0gJ2RhdGUnICYmXG4gICAgICAgIGFyZy50eXBlICE9PSAnbnVtYmVyJyAmJlxuICAgICAgICBhcmcudHlwZSAhPT0gJ29iamVjdCcgJiZcbiAgICAgICAgYXJnLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgcmV0dXJuIGAke2FyZy52YWx1ZS50b1N0cmluZygpfW5gO1xuICAgIH1cbiAgICBpZiAoYXJnLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhcmcudmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKFsnZGF0ZScsICdzdHJpbmcnXS5pbmNsdWRlcyhhcmcudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZy52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGB7JHthcmcudmFsdWVcbiAgICAgICAgICAgIC5tYXAoKHBhaXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeShwYWlyWzBdKX06JHt0b0pzb24ocGFpclsxXSl9YDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyl9fWA7XG4gICAgfVxuICAgIGlmIChhcmcudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICByZXR1cm4gYFske2FyZy52YWx1ZT8ubWFwKCh2YWwpID0+IHRvSnNvbih2YWwpKS5qb2luKCcsJykgPz8gJyd9XWA7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICB0aHJvdyBFcnJvcihgSW52YWxpZCB2YWx1ZSB0eXBlOiAke2FyZ31gKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0Zyb21BcmcoYXJnKSB7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duKGFyZywgJ3ZhbHVlJykpIHtcbiAgICAgICAgcmV0dXJuIGFyZy50eXBlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhhcmcudmFsdWUpO1xuICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgICAgcmV0dXJuIGAvJHthcmcudmFsdWUucGF0dGVybn0vJHthcmcudmFsdWUuZmxhZ3MgPz8gJyd9YDtcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYXJnLnZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgcmV0dXJuIGBPYmplY3QoJHthcmcudmFsdWU/Lmxlbmd0aCA/PyAnJ30pYDtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIGBBcnJheSgke2FyZy52YWx1ZT8ubGVuZ3RoID8/ICcnfSlgO1xuICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgcmV0dXJuIGBNYXAoJHthcmcudmFsdWU/Lmxlbmd0aH0pYDtcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIHJldHVybiBgU2V0KCR7YXJnLnZhbHVlPy5sZW5ndGh9KWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYXJnLnR5cGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmVtb3RlVmFsdWVzVGV4dChhcmdzLCBmb3JtYXRUZXh0KSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1swXTtcbiAgICBpZiAoIWFyZykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIGlmIGFyZ3NbMF0gaXMgYSBmb3JtYXQgc3BlY2lmaWVyLCBmb3JtYXQgdGhlIGFyZ3MgYXMgb3V0cHV0XG4gICAgaWYgKGFyZy50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBpc0Zvcm1hdFNwZWNpZmllcihhcmcudmFsdWUudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgZm9ybWF0VGV4dCkge1xuICAgICAgICByZXR1cm4gbG9nTWVzc2FnZUZvcm1hdHRlcihhcmdzKTtcbiAgICB9XG4gICAgLy8gaWYgYXJnc1swXSBpcyBub3QgYSBmb3JtYXQgc3BlY2lmaWVyLCBqdXN0IGpvaW4gdGhlIGFyZ3Mgd2l0aCBcXHUwMDIwICh1bmljb2RlICdTUEFDRScpXG4gICAgcmV0dXJuIGFyZ3NcbiAgICAgICAgLm1hcCgoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQXJnKGFyZyk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJ1xcdTAwMjAnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ0hlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZXR3b3JrUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbi8qKiBEaXNwYXRjaGVzIE5ldHdvcmsgZG9tYWluIGNvbW1hbmRzLiAqL1xuY2xhc3MgTmV0d29ya1Byb2Nlc3NvciB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI25ldHdvcmtTdG9yYWdlO1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UsIG5ldHdvcmtTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZSA9IG5ldHdvcmtTdG9yYWdlO1xuICAgIH1cbiAgICBhc3luYyBhZGRJbnRlcmNlcHQocGFyYW1zKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UudmVyaWZ5VG9wTGV2ZWxDb250ZXh0c0xpc3QocGFyYW1zLmNvbnRleHRzKTtcbiAgICAgICAgY29uc3QgdXJsUGF0dGVybnMgPSBwYXJhbXMudXJsUGF0dGVybnMgPz8gW107XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybFBhdHRlcm5zID0gTmV0d29ya1Byb2Nlc3Nvci5wYXJzZVVybFBhdHRlcm5zKHVybFBhdHRlcm5zKTtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0ID0gdGhpcy4jbmV0d29ya1N0b3JhZ2UuYWRkSW50ZXJjZXB0KHtcbiAgICAgICAgICAgIHVybFBhdHRlcm5zOiBwYXJzZWRVcmxQYXR0ZXJucyxcbiAgICAgICAgICAgIHBoYXNlczogcGFyYW1zLnBoYXNlcyxcbiAgICAgICAgICAgIGNvbnRleHRzOiBwYXJhbXMuY29udGV4dHMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldEFsbENvbnRleHRzKCkubWFwKChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5jZHBUYXJnZXQudG9nZ2xlRmV0Y2hJZk5lZWRlZCgpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcmNlcHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGNvbnRpbnVlUmVxdWVzdChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy51cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgTmV0d29ya1Byb2Nlc3Nvci5wYXJzZVVybFN0cmluZyhwYXJhbXMudXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIU5ldHdvcmtQcm9jZXNzb3IuaXNNZXRob2RWYWxpZChwYXJhbXMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgTWV0aG9kICcke3BhcmFtcy5tZXRob2R9JyBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICAgICAgTmV0d29ya1Byb2Nlc3Nvci52YWxpZGF0ZUhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLiNnZXRCbG9ja2VkUmVxdWVzdE9yRmFpbChwYXJhbXMucmVxdWVzdCwgW1xuICAgICAgICAgICAgXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi8sXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBUT0RPOiBTZXQgLyBleHBhbmQuXG4gICAgICAgIC8vIDsgU3RlcCA5LiBjb29raWVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LmNvbnRpbnVlUmVxdWVzdChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgTmV0d29ya1Byb2Nlc3Nvci53cmFwSW50ZXJjZXB0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgY29udGludWVSZXNwb25zZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnZhbGlkYXRlSGVhZGVycyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuI2dldEJsb2NrZWRSZXF1ZXN0T3JGYWlsKHBhcmFtcy5yZXF1ZXN0LCBbXG4gICAgICAgICAgICBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovLFxuICAgICAgICAgICAgXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLyxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIFRPRE86IFNldCAvIGV4cGFuZC5cbiAgICAgICAgLy8gOyBTdGVwIDEwLiBjb29raWVzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LmNvbnRpbnVlUmVzcG9uc2UocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IE5ldHdvcmtQcm9jZXNzb3Iud3JhcEludGVyY2VwdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIGNvbnRpbnVlV2l0aEF1dGgocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtJZCA9IHBhcmFtcy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jZ2V0QmxvY2tlZFJlcXVlc3RPckZhaWwobmV0d29ya0lkLCBbXG4gICAgICAgICAgICBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovLFxuICAgICAgICBdKTtcbiAgICAgICAgYXdhaXQgcmVxdWVzdC5jb250aW51ZVdpdGhBdXRoKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgZmFpbFJlcXVlc3QoeyByZXF1ZXN0OiBuZXR3b3JrSWQsIH0pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuI2dldFJlcXVlc3RPckZhaWwobmV0d29ya0lkKTtcbiAgICAgICAgaWYgKHJlcXVlc3QuaW50ZXJjZXB0UGhhc2UgPT09IFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgUmVxdWVzdCAnJHtuZXR3b3JrSWR9JyBpbiAnYXV0aFJlcXVpcmVkJyBwaGFzZSBjYW5ub3QgYmUgZmFpbGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXF1ZXN0LmludGVyY2VwdFBoYXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hSZXF1ZXN0RXhjZXB0aW9uKGBObyBibG9ja2VkIHJlcXVlc3QgZm91bmQgZm9yIG5ldHdvcmsgaWQgJyR7bmV0d29ya0lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXF1ZXN0LmZhaWxSZXF1ZXN0KCdGYWlsZWQnKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBhc3luYyBwcm92aWRlUmVzcG9uc2UocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICAgICAgTmV0d29ya1Byb2Nlc3Nvci52YWxpZGF0ZUhlYWRlcnMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFNldCAvIGV4cGFuZC5cbiAgICAgICAgLy8gOyBTdGVwIDEwLiBjb29raWVzXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLiNnZXRCbG9ja2VkUmVxdWVzdE9yRmFpbChwYXJhbXMucmVxdWVzdCwgW1xuICAgICAgICAgICAgXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQmVmb3JlUmVxdWVzdFNlbnQgKi8sXG4gICAgICAgICAgICBcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovLFxuICAgICAgICAgICAgXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCByZXF1ZXN0LnByb3ZpZGVSZXNwb25zZShwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgTmV0d29ya1Byb2Nlc3Nvci53cmFwSW50ZXJjZXB0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlSW50ZXJjZXB0KHBhcmFtcykge1xuICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZS5yZW1vdmVJbnRlcmNlcHQocGFyYW1zLmludGVyY2VwdCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0QWxsQ29udGV4dHMoKS5tYXAoKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmNkcFRhcmdldC50b2dnbGVGZXRjaElmTmVlZGVkKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAjZ2V0UmVxdWVzdE9yRmFpbChpZCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jbmV0d29ya1N0b3JhZ2UuZ2V0UmVxdWVzdEJ5SWQoaWQpO1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFJlcXVlc3RFeGNlcHRpb24oYE5ldHdvcmsgcmVxdWVzdCB3aXRoIElEICcke2lkfScgZG9lc24ndCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAjZ2V0QmxvY2tlZFJlcXVlc3RPckZhaWwoaWQsIHBoYXNlcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy4jZ2V0UmVxdWVzdE9yRmFpbChpZCk7XG4gICAgICAgIGlmICghcmVxdWVzdC5pbnRlcmNlcHRQaGFzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoUmVxdWVzdEV4Y2VwdGlvbihgTm8gYmxvY2tlZCByZXF1ZXN0IGZvdW5kIGZvciBuZXR3b3JrIGlkICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdC5pbnRlcmNlcHRQaGFzZSAmJiAhcGhhc2VzLmluY2x1ZGVzKHJlcXVlc3QuaW50ZXJjZXB0UGhhc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEJsb2NrZWQgcmVxdWVzdCBmb3IgbmV0d29yayBpZCAnJHtpZH0nIGlzIGluICcke3JlcXVlc3QuaW50ZXJjZXB0UGhhc2V9JyBwaGFzZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaGVhZGVyLXZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIudmFsdWUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZSA9IGhlYWRlci52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlclZhbHVlID0gYXRvYihoZWFkZXIudmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlclZhbHVlICE9PSBoZWFkZXJWYWx1ZS50cmltKCkgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZS5pbmNsdWRlcygnXFxuJykgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXJWYWx1ZS5pbmNsdWRlcygnXFwwJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEhlYWRlciB2YWx1ZSAnJHtoZWFkZXJWYWx1ZX0nIGlzIG5vdCBhY2NlcHRhYmxlIHZhbHVlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzTWV0aG9kVmFsaWQobWV0aG9kKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjbWV0aG9kLm92ZXJ2aWV3XG4gICAgICAgIHJldHVybiAvXlshIyQlJicqK1xcLS5eX2B8fmEtekEtWlxcZF0rJC8udGVzdChtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBwYXJzZSB0aGUgZ2l2ZW4gdXJsLlxuICAgICAqIFRocm93cyBhbiBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gaWYgdGhlIHVybCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVVybFN0cmluZyh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYEludmFsaWQgVVJMICcke3VybH0nOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZVVybFBhdHRlcm5zKHVybFBhdHRlcm5zKSB7XG4gICAgICAgIHJldHVybiB1cmxQYXR0ZXJucy5tYXAoKHVybFBhdHRlcm4pID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodXJsUGF0dGVybi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBOZXR3b3JrUHJvY2Vzc29yLnBhcnNlVXJsU3RyaW5nKHVybFBhdHRlcm4ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmxQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdwYXR0ZXJuJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcGFyYW1zIHNpZ25pZmllcyBpbnRlcmNlcHQgYWxsXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxQYXR0ZXJuLnByb3RvY29sID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4uaG9zdG5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wb3J0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5zZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybFBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucHJvdG9jb2wgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5wcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybFBhdHRlcm4ucHJvdG9jb2wubWF0Y2goL15bYS16QS1aKy0uXSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0ZvcmJpZGRlbiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4uaG9zdG5hbWUgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5ob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wb3J0ID0gdW5lc2NhcGVVUkxQYXR0ZXJuKHVybFBhdHRlcm4ucG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybFBhdHRlcm4ucGF0aG5hbWUgPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wYXRobmFtZVswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wYXRobmFtZSA9IGAvJHt1cmxQYXR0ZXJuLnBhdGhuYW1lfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wYXRobmFtZS5pbmNsdWRlcygnIycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5wYXRobmFtZS5pbmNsdWRlcygnPycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdGb3JiaWRkZW4gY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFBhdHRlcm4ucGF0aG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxQYXR0ZXJuLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsUGF0dGVybi5zZWFyY2ggPSB1bmVzY2FwZVVSTFBhdHRlcm4odXJsUGF0dGVybi5zZWFyY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uc2VhcmNoWzBdICE9PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxQYXR0ZXJuLnNlYXJjaCA9IGA/JHt1cmxQYXR0ZXJuLnNlYXJjaH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uc2VhcmNoLmluY2x1ZGVzKCcjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0ZvcmJpZGRlbiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucHJvdG9jb2wgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYFVSTCBwYXR0ZXJuIG11c3Qgc3BlY2lmeSBhIHByb3RvY29sYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4uaG9zdG5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYFVSTCBwYXR0ZXJuIG11c3Qgc3BlY2lmeSBhIGhvc3RuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1cmxQYXR0ZXJuLmhvc3RuYW1lPy5sZW5ndGggPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5wcm90b2NvbD8ubWF0Y2goL15maWxlL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBVUkwgcGF0dGVybiBwcm90b2NvbCBjYW5ub3QgYmUgJ2ZpbGUnYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsUGF0dGVybi5ob3N0bmFtZT8uaW5jbHVkZXMoJzonKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVVJMIHBhdHRlcm4gaG9zdG5hbWUgbXVzdCBub3QgY29udGFpbiBhIGNvbG9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybFBhdHRlcm4ucG9ydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVVJMIHBhdHRlcm4gbXVzdCBzcGVjaWZ5IGEgcG9ydGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVVJMUGF0dGVybih1cmxQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyB3cmFwSW50ZXJjZXB0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46Y29udGVudC9icm93c2VyL2RldnRvb2xzL3Byb3RvY29sL2ZldGNoX2hhbmRsZXIuY2M7bD0xNjlcbiAgICAgICAgaWYgKGVycm9yPy5tZXNzYWdlLmluY2x1ZGVzKCdJbnZhbGlkIGhlYWRlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtQcm9jZXNzb3IgPSBOZXR3b3JrUHJvY2Vzc29yO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyN1bmVzY2FwZS11cmwtcGF0dGVyblxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVVSTFBhdHRlcm4ocGF0dGVybikge1xuICAgIGNvbnN0IGZvcmJpZGRlbiA9IG5ldyBTZXQoWycoJywgJyknLCAnKicsICd7JywgJ30nXSk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgcGF0dGVybikge1xuICAgICAgICBpZiAoIWlzRXNjYXBlZCkge1xuICAgICAgICAgICAgaWYgKGZvcmJpZGRlbi5oYXMoYykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oJ0ZvcmJpZGRlbiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYztcbiAgICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXR3b3JrUHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmtSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGFzc2VydF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2Fzc2VydC5qc1wiKTtcbmNvbnN0IERlZmVycmVkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRGVmZXJyZWQuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCBOZXR3b3JrVXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtVdGlscy5qc1wiKTtcbmNvbnN0IFJFQUxNX1JFR0VYID0gLyg/PD1yZWFsbT1cIikuKig/PVwiKS87XG4vKiogQWJzdHJhY3RzIG9uZSBpbmRpdmlkdWFsIG5ldHdvcmsgcmVxdWVzdC4gKi9cbmNsYXNzIE5ldHdvcmtSZXF1ZXN0IHtcbiAgICBzdGF0aWMgdW5rbm93blBhcmFtZXRlciA9ICdVTktOT1dOJztcbiAgICAvKipcbiAgICAgKiBFYWNoIG5ldHdvcmsgcmVxdWVzdCBoYXMgYW4gYXNzb2NpYXRlZCByZXF1ZXN0IGlkLCB3aGljaCBpcyBhIHN0cmluZ1xuICAgICAqIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIHRoYXQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFRoZSBpZGVudGlmaWVyIGZvciBhIHJlcXVlc3QgcmVzdWx0aW5nIGZyb20gYSByZWRpcmVjdCBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gICAgICogcmVxdWVzdCB0aGF0IGluaXRpYXRlZCBpdC5cbiAgICAgKi9cbiAgICAjaWQ7XG4gICAgI2ZldGNoSWQ7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBuZXR3b3JrIGludGVyY2VwdCBwaGFzZSwgaWYgdGhlIHJlcXVlc3QgaXMgY3VycmVudGx5IGJsb2NrZWQuXG4gICAgICogVW5kZWZpbmVkIG5lY2Vzc2FyaWx5IGltcGxpZXMgdGhhdCB0aGUgcmVxdWVzdCBpcyBub3QgYmxvY2tlZC5cbiAgICAgKi9cbiAgICAjaW50ZXJjZXB0UGhhc2U7XG4gICAgI3NlcnZlZEZyb21DYWNoZSA9IGZhbHNlO1xuICAgICNyZWRpcmVjdENvdW50O1xuICAgICNyZXF1ZXN0ID0ge307XG4gICAgI3JlcXVlc3RPdmVycmlkZXM7XG4gICAgI3Jlc3BvbnNlID0ge307XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjbmV0d29ya1N0b3JhZ2U7XG4gICAgI2NkcFRhcmdldDtcbiAgICAjbG9nZ2VyO1xuICAgICNlbWl0dGVkRXZlbnRzID0ge1xuICAgICAgICBbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLkF1dGhSZXF1aXJlZF06IGZhbHNlLFxuICAgICAgICBbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLkJlZm9yZVJlcXVlc3RTZW50XTogZmFsc2UsXG4gICAgICAgIFtwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuRmV0Y2hFcnJvcl06IGZhbHNlLFxuICAgICAgICBbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLlJlc3BvbnNlQ29tcGxldGVkXTogZmFsc2UsXG4gICAgICAgIFtwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuUmVzcG9uc2VTdGFydGVkXTogZmFsc2UsXG4gICAgfTtcbiAgICB3YWl0TmV4dFBoYXNlID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICBjb25zdHJ1Y3RvcihpZCwgZXZlbnRNYW5hZ2VyLCBuZXR3b3JrU3RvcmFnZSwgY2RwVGFyZ2V0LCByZWRpcmVjdENvdW50ID0gMCwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuI2lkID0gaWQ7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICAgICAgdGhpcy4jbmV0d29ya1N0b3JhZ2UgPSBuZXR3b3JrU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jY2RwVGFyZ2V0ID0gY2RwVGFyZ2V0O1xuICAgICAgICB0aGlzLiNyZWRpcmVjdENvdW50ID0gcmVkaXJlY3RDb3VudDtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpZDtcbiAgICB9XG4gICAgZ2V0IGZldGNoSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZXRjaElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIGJsb2NrZWQgcmV0dXJucyB0aGUgcGhhc2UgZm9yIGl0XG4gICAgICovXG4gICAgZ2V0IGludGVyY2VwdFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJjZXB0UGhhc2U7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy4jcmVxdWVzdC5pbmZvPy5yZXF1ZXN0LnVybEZyYWdtZW50ID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LnBhdXNlZD8ucmVxdWVzdC51cmxGcmFnbWVudCA/P1xuICAgICAgICAgICAgJyc7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuI3Jlc3BvbnNlLmluZm8/LnVybCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UucGF1c2VkPy5yZXF1ZXN0LnVybCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdE92ZXJyaWRlcz8udXJsID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmF1dGg/LnJlcXVlc3QudXJsID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmluZm8/LnJlcXVlc3QudXJsID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LnBhdXNlZD8ucmVxdWVzdC51cmwgPz9cbiAgICAgICAgICAgIE5ldHdvcmtSZXF1ZXN0LnVua25vd25QYXJhbWV0ZXI7XG4gICAgICAgIHJldHVybiBgJHt1cmx9JHtmcmFnbWVudH1gO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3JlcXVlc3RPdmVycmlkZXM/Lm1ldGhvZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5pbmZvPy5yZXF1ZXN0Lm1ldGhvZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQ/LnJlcXVlc3QubWV0aG9kID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmF1dGg/LnJlcXVlc3QubWV0aG9kID8/XG4gICAgICAgICAgICB0aGlzLiNyZXNwb25zZS5wYXVzZWQ/LnJlcXVlc3QubWV0aG9kID8/XG4gICAgICAgICAgICBOZXR3b3JrUmVxdWVzdC51bmtub3duUGFyYW1ldGVyKTtcbiAgICB9XG4gICAgZ2V0IHJlZGlyZWN0Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWRpcmVjdENvdW50O1xuICAgIH1cbiAgICBnZXQgY2RwVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2RwVGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgY2RwQ2xpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2RwVGFyZ2V0LmNkcENsaWVudDtcbiAgICB9XG4gICAgaXNSZWRpcmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy4jcmVxdWVzdC5pbmZvKTtcbiAgICB9XG4gICAgaXNEYXRhVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwuc3RhcnRzV2l0aCgnZGF0YTonKTtcbiAgICB9XG4gICAgI3BoYXNlQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy53YWl0TmV4dFBoYXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy53YWl0TmV4dFBoYXNlID0gbmV3IERlZmVycmVkX2pzXzEuRGVmZXJyZWQoKTtcbiAgICB9XG4gICAgI2ludGVyY2VwdHNJblBoYXNlKHBoYXNlKSB7XG4gICAgICAgIGlmICghdGhpcy4jY2RwVGFyZ2V0LmlzU3Vic2NyaWJlZFRvKGBuZXR3b3JrLiR7cGhhc2V9YCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcmtTdG9yYWdlLmdldEludGVyY2VwdHNGb3JQaGFzZSh0aGlzLCBwaGFzZSk7XG4gICAgfVxuICAgICNpc0Jsb2NrZWRJblBoYXNlKHBoYXNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbnRlcmNlcHRzSW5QaGFzZShwaGFzZSkuc2l6ZSA+IDA7XG4gICAgfVxuICAgIGhhbmRsZVJlZGlyZWN0KGV2ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IHVzZSBldmVudC5yZWRpcmVjdFJlc3BvbnNlO1xuICAgICAgICAvLyBUZW1wb3Jhcnkgd29ya2Fyb3VuZCB0byBlbWl0IFJlc3BvbnNlQ29tcGxldGVkIGV2ZW50IGZvciByZWRpcmVjdHNcbiAgICAgICAgdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI3Jlc3BvbnNlLmluZm8gPSBldmVudC5yZWRpcmVjdFJlc3BvbnNlO1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSh7XG4gICAgICAgICAgICB3YXNSZWRpcmVjdGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgI2VtaXRFdmVudHNJZlJlYWR5KG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0RXh0cmFJbmZvQ29tcGxldGVkID0gXG4gICAgICAgIC8vIEZsdXNoIHJlZGlyZWN0c1xuICAgICAgICBvcHRpb25zLndhc1JlZGlyZWN0ZWQgfHxcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzRmFpbGVkIHx8XG4gICAgICAgICAgICB0aGlzLmlzRGF0YVVybCgpIHx8XG4gICAgICAgICAgICBCb29sZWFuKHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvKSB8fFxuICAgICAgICAgICAgLy8gUmVxdWVzdHMgZnJvbSBjYWNoZSBkb24ndCBoYXZlIGV4dHJhIGluZm9cbiAgICAgICAgICAgIHRoaXMuI3NlcnZlZEZyb21DYWNoZSB8fFxuICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZXJlIGlzIG5vIGV4dHJhIGluZm8gYW5kIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgLy8gaXMgdGhlIG9ubHkgcGxhY2Ugd2UgY2FuIGZpbmQgb3V0XG4gICAgICAgICAgICBCb29sZWFuKHRoaXMuI3Jlc3BvbnNlLmluZm8gJiYgIXRoaXMuI3Jlc3BvbnNlLmhhc0V4dHJhSW5mbyk7XG4gICAgICAgIGNvbnN0IG5vSW50ZXJjZXB0aW9uRXhwZWN0ZWQgPSBcbiAgICAgICAgLy8gV2UgY2FuJ3QgaW50ZXJjZXB0IGRhdGEgdXJscyBmcm9tIENEUFxuICAgICAgICB0aGlzLmlzRGF0YVVybCgpIHx8XG4gICAgICAgICAgICAvLyBDYWNoZWQgcmVxdWVzdHMgbmV2ZXIgaGl0IHRoZSBuZXR3b3JrXG4gICAgICAgICAgICB0aGlzLiNzZXJ2ZWRGcm9tQ2FjaGU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJbnRlcmNlcHRpb25FeHBlY3RlZCA9ICFub0ludGVyY2VwdGlvbkV4cGVjdGVkICYmXG4gICAgICAgICAgICB0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEludGVyY2VwdGlvbkNvbXBsZXRlZCA9ICFyZXF1ZXN0SW50ZXJjZXB0aW9uRXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIChyZXF1ZXN0SW50ZXJjZXB0aW9uRXhwZWN0ZWQgJiYgQm9vbGVhbih0aGlzLiNyZXF1ZXN0LnBhdXNlZCkpO1xuICAgICAgICBpZiAoQm9vbGVhbih0aGlzLiNyZXF1ZXN0LmluZm8pICYmXG4gICAgICAgICAgICAocmVxdWVzdEludGVyY2VwdGlvbkV4cGVjdGVkXG4gICAgICAgICAgICAgICAgPyByZXF1ZXN0SW50ZXJjZXB0aW9uQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgOiByZXF1ZXN0RXh0cmFJbmZvQ29tcGxldGVkKSkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdEV2ZW50KHRoaXMuI2dldEJlZm9yZVJlcXVlc3RFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZUV4dHJhSW5mb0NvbXBsZXRlZCA9IEJvb2xlYW4odGhpcy4jcmVzcG9uc2UuZXh0cmFJbmZvKSB8fFxuICAgICAgICAgICAgLy8gUmVzcG9uc2UgZnJvbSBjYWNoZSBkb24ndCBoYXZlIGV4dHJhIGluZm9cbiAgICAgICAgICAgIHRoaXMuI3NlcnZlZEZyb21DYWNoZSB8fFxuICAgICAgICAgICAgLy8gRG9uJ3QgZXhwZWN0IGV4dHJhIGluZm8gaWYgdGhlIGZsYWcgaXMgZmFsc2VcbiAgICAgICAgICAgIEJvb2xlYW4odGhpcy4jcmVzcG9uc2UuaW5mbyAmJiAhdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRpb25FeHBlY3RlZCA9ICFub0ludGVyY2VwdGlvbkV4cGVjdGVkICYmXG4gICAgICAgICAgICB0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwicmVzcG9uc2VTdGFydGVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5SZXNwb25zZVN0YXJ0ZWQgKi8pO1xuICAgICAgICBpZiAodGhpcy4jcmVzcG9uc2UuaW5mbyB8fFxuICAgICAgICAgICAgKHJlc3BvbnNlSW50ZXJjZXB0aW9uRXhwZWN0ZWQgJiYgQm9vbGVhbih0aGlzLiNyZXNwb25zZS5wYXVzZWQpKSkge1xuICAgICAgICAgICAgdGhpcy4jZW1pdEV2ZW50KHRoaXMuI2dldFJlc3BvbnNlU3RhcnRlZEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSW50ZXJjZXB0aW9uQ29tcGxldGVkID0gIXJlc3BvbnNlSW50ZXJjZXB0aW9uRXhwZWN0ZWQgfHxcbiAgICAgICAgICAgIChyZXNwb25zZUludGVyY2VwdGlvbkV4cGVjdGVkICYmIEJvb2xlYW4odGhpcy4jcmVzcG9uc2UucGF1c2VkKSk7XG4gICAgICAgIGlmIChCb29sZWFuKHRoaXMuI3Jlc3BvbnNlLmluZm8pICYmXG4gICAgICAgICAgICByZXNwb25zZUV4dHJhSW5mb0NvbXBsZXRlZCAmJlxuICAgICAgICAgICAgcmVzcG9uc2VJbnRlcmNlcHRpb25Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXRFdmVudCh0aGlzLiNnZXRSZXNwb25zZVJlY2VpdmVkRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLiNuZXR3b3JrU3RvcmFnZS5kZWxldGVSZXF1ZXN0KHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVxdWVzdFdpbGxCZVNlbnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLiNyZXF1ZXN0LmluZm8gPSBldmVudDtcbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50c0lmUmVhZHkoKTtcbiAgICB9XG4gICAgb25SZXF1ZXN0V2lsbEJlU2VudEV4dHJhSW5mb0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvID0gZXZlbnQ7XG4gICAgICAgIHRoaXMuI2VtaXRFdmVudHNJZlJlYWR5KCk7XG4gICAgfVxuICAgIG9uUmVzcG9uc2VSZWNlaXZlZEV4dHJhSW5mb0V2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5zdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgICAgICAgZXZlbnQuc3RhdHVzQ29kZSA8PSAzOTkgJiZcbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QuaW5mbyAmJlxuICAgICAgICAgICAgZXZlbnQuaGVhZGVyc1snbG9jYXRpb24nXSA9PT0gdGhpcy4jcmVxdWVzdC5pbmZvLnJlcXVlc3QudXJsKSB7XG4gICAgICAgICAgICAvLyBXZSByZWNlaXZlZCB0aGUgUmVzcG9uc2UgRXh0cmEgaW5mbyBmb3IgdGhlIHJlZGlyZWN0XG4gICAgICAgICAgICAvLyBUb28gbGF0ZSBzbyB3ZSBuZWVkIHRvIHNraXAgaXQgYXMgaXQgd2lsbFxuICAgICAgICAgICAgLy8gZmlyZSB3cm9uZ2x5IGZvciB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZXNwb25zZS5leHRyYUluZm8gPSBldmVudDtcbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50c0lmUmVhZHkoKTtcbiAgICB9XG4gICAgb25SZXNwb25zZVJlY2VpdmVkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy4jcmVzcG9uc2UuaGFzRXh0cmFJbmZvID0gZXZlbnQuaGFzRXh0cmFJbmZvO1xuICAgICAgICB0aGlzLiNyZXNwb25zZS5pbmZvID0gZXZlbnQucmVzcG9uc2U7XG4gICAgICAgIHRoaXMuI2VtaXRFdmVudHNJZlJlYWR5KCk7XG4gICAgfVxuICAgIG9uU2VydmVkRnJvbUNhY2hlKCkge1xuICAgICAgICB0aGlzLiNzZXJ2ZWRGcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSgpO1xuICAgIH1cbiAgICBvbkxvYWRpbmdGYWlsZWRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSh7XG4gICAgICAgICAgICBoYXNGYWlsZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNlbWl0RXZlbnQoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5GZXRjaEVycm9yLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoKSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBldmVudC5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC90b3QvRmV0Y2gvI21ldGhvZC1mYWlsUmVxdWVzdCAqL1xuICAgIGFzeW5jIGZhaWxSZXF1ZXN0KGVycm9yUmVhc29uKSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI2ZldGNoSWQsICdOZXR3b3JrIEludGVyY2VwdGlvbiBub3Qgc2V0LXVwLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guZmFpbFJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICBlcnJvclJlYXNvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ludGVyY2VwdFBoYXNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvblJlcXVlc3RQYXVzZWQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy4jZmV0Y2hJZCA9IGV2ZW50LnJlcXVlc3RJZDtcbiAgICAgICAgLy8gQ0RQIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9GZXRjaC8jZXZlbnQtcmVxdWVzdFBhdXNlZFxuICAgICAgICBpZiAoZXZlbnQucmVzcG9uc2VTdGF0dXNDb2RlIHx8IGV2ZW50LnJlc3BvbnNlRXJyb3JSZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmxvY2tlZEluUGhhc2UoXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLykgJiZcbiAgICAgICAgICAgICAgICAvLyBDRFAgbWF5IGVtaXQgbXVsdGlwbGUgZXZlbnRzIGZvciBhIHNpbmdsZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgIXRoaXMuI2VtaXR0ZWRFdmVudHNbcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLlJlc3BvbnNlU3RhcnRlZF0gJiZcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBhbGwgcmVzcG9uc2UgdGhhdCBoYXZlIG5vdCBlbmFibGVkIE5ldHdvcmsgZG9tYWluXG4gICAgICAgICAgICAgICAgdGhpcy4jZmV0Y2hJZCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ludGVyY2VwdFBoYXNlID0gXCJyZXNwb25zZVN0YXJ0ZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLlJlc3BvbnNlU3RhcnRlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy4jY29udGludWVSZXNwb25zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5wYXVzZWQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0Jsb2NrZWRJblBoYXNlKFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovKSAmJlxuICAgICAgICAgICAgICAgIC8vIENEUCBtYXkgZW1pdCBtdWx0aXBsZSBldmVudHMgZm9yIGEgc2luZ2xlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAhdGhpcy4jZW1pdHRlZEV2ZW50c1twcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQmVmb3JlUmVxdWVzdFNlbnRdICYmXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgYWxsIHJlcXVlc3RzIHRoYXQgaGF2ZSBub3QgZW5hYmxlZCBOZXR3b3JrIGRvbWFpblxuICAgICAgICAgICAgICAgIHRoaXMuI2ZldGNoSWQgIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLiNjb250aW51ZVJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNlbWl0RXZlbnRzSWZSZWFkeSgpO1xuICAgIH1cbiAgICBvbkF1dGhSZXF1aXJlZChldmVudCkge1xuICAgICAgICB0aGlzLiNmZXRjaElkID0gZXZlbnQucmVxdWVzdElkO1xuICAgICAgICB0aGlzLiNyZXF1ZXN0LmF1dGggPSBldmVudDtcbiAgICAgICAgaWYgKHRoaXMuI2lzQmxvY2tlZEluUGhhc2UoXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLykgJiZcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIGFsbCBhdXRoIHJlcXVlc3RzIHRoYXQgaGF2ZSBub3QgZW5hYmxlZCBOZXR3b3JrIGRvbWFpblxuICAgICAgICAgICAgdGhpcy4jZmV0Y2hJZCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy4jaW50ZXJjZXB0UGhhc2UgPSBcImF1dGhSZXF1aXJlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuQXV0aFJlcXVpcmVkICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm9pZCB0aGlzLiNjb250aW51ZVdpdGhBdXRoKHtcbiAgICAgICAgICAgICAgICByZXNwb25zZTogJ0RlZmF1bHQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZW1pdEV2ZW50KCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuQXV0aFJlcXVpcmVkLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoXCJhdXRoUmVxdWlyZWRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkF1dGhSZXF1aXJlZCAqLyksXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB0aGlzLiNnZXRSZXNwb25zZUV2ZW50UGFyYW1zKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQHNlZSBodHRwczovL2Nocm9tZWRldnRvb2xzLmdpdGh1Yi5pby9kZXZ0b29scy1wcm90b2NvbC90b3QvRmV0Y2gvI21ldGhvZC1jb250aW51ZVJlcXVlc3QgKi9cbiAgICBhc3luYyBjb250aW51ZVJlcXVlc3Qob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jZHBGZXRjaEhlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzKShvdmVycmlkZXMuaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHBvc3REYXRhID0gZ2V0Q2RwQm9keUZyb21CaURpQnl0ZXNWYWx1ZShvdmVycmlkZXMuYm9keSk7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NvbnRpbnVlUmVxdWVzdCh7XG4gICAgICAgICAgICB1cmw6IG92ZXJyaWRlcy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG92ZXJyaWRlcy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcG9zdERhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPOiBTdG9yZSBwb3N0RGF0YSdzIHNpemUgb25seVxuICAgICAgICB0aGlzLiNyZXF1ZXN0T3ZlcnJpZGVzID0ge1xuICAgICAgICAgICAgdXJsOiBvdmVycmlkZXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvdmVycmlkZXMubWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVyczogb3ZlcnJpZGVzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5U2l6ZTogZ2V0U2l6ZUZyb21CaURpQnl0ZXNWYWx1ZShvdmVycmlkZXMuYm9keSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jICNjb250aW51ZVJlcXVlc3Qob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jZmV0Y2hJZCwgJ05ldHdvcmsgSW50ZXJjZXB0aW9uIG5vdCBzZXQtdXAuJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdGZXRjaC5jb250aW51ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMuI2ZldGNoSWQsXG4gICAgICAgICAgICB1cmw6IG92ZXJyaWRlcy51cmwsXG4gICAgICAgICAgICBtZXRob2Q6IG92ZXJyaWRlcy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiBvdmVycmlkZXMuaGVhZGVycyxcbiAgICAgICAgICAgIHBvc3REYXRhOiBvdmVycmlkZXMucG9zdERhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIEBzZWUgaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0ZldGNoLyNtZXRob2QtY29udGludWVSZXNwb25zZSAqL1xuICAgIGFzeW5jIGNvbnRpbnVlUmVzcG9uc2Uob3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0UGhhc2UgPT09IFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdE5leHRQaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGludWVXaXRoQXV0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ1Byb3ZpZGVDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogb3ZlcnJpZGVzLmNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IG92ZXJyaWRlcy5jcmVkZW50aWFscy5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBgUHJvdmlkZUNyZWRlbnRpYWxzYFxuICAgICAgICAgICAgICAgIC8vIEFzIGBEZWZhdWx0YCBtYXkgY2FuY2VsIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ1Byb3ZpZGVDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2ludGVyY2VwdFBoYXNlID09PSBcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSAoMCwgTmV0d29ya1V0aWxzX2pzXzEuY2RwRmV0Y2hIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycykob3ZlcnJpZGVzLmhlYWRlcnMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jY29udGludWVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb2RlOiBvdmVycmlkZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZVBocmFzZTogb3ZlcnJpZGVzLnJlYXNvblBocmFzZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAjY29udGludWVSZXNwb25zZSh7IHJlc3BvbnNlQ29kZSwgcmVzcG9uc2VQaHJhc2UsIHJlc3BvbnNlSGVhZGVycywgfSA9IHt9KSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI2ZldGNoSWQsICdOZXR3b3JrIEludGVyY2VwdGlvbiBub3Qgc2V0LXVwLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guY29udGludWVSZXNwb25zZScsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy4jZmV0Y2hJZCxcbiAgICAgICAgICAgIHJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgIHJlc3BvbnNlUGhyYXNlLFxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jaW50ZXJjZXB0UGhhc2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKiBAc2VlIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9GZXRjaC8jbWV0aG9kLWNvbnRpbnVlV2l0aEF1dGggKi9cbiAgICBhc3luYyBjb250aW51ZVdpdGhBdXRoKGF1dGhDaGFsbGVuZ2UpIHtcbiAgICAgICAgbGV0IHVzZXJuYW1lO1xuICAgICAgICBsZXQgcGFzc3dvcmQ7XG4gICAgICAgIGlmIChhdXRoQ2hhbGxlbmdlLmFjdGlvbiA9PT0gJ3Byb3ZpZGVDcmVkZW50aWFscycpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlZGVudGlhbHMgfSA9IGF1dGhDaGFsbGVuZ2U7XG4gICAgICAgICAgICB1c2VybmFtZSA9IGNyZWRlbnRpYWxzLnVzZXJuYW1lO1xuICAgICAgICAgICAgcGFzc3dvcmQgPSBjcmVkZW50aWFscy5wYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jZHBBdXRoQ2hhbGxlbmdlUmVzcG9uc2VGcm9tQmlkaUF1dGhDb250aW51ZVdpdGhBdXRoQWN0aW9uKShhdXRoQ2hhbGxlbmdlLmFjdGlvbik7XG4gICAgICAgIGF3YWl0IHRoaXMuI2NvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB1c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBzZWUgaHR0cHM6Ly9jaHJvbWVkZXZ0b29scy5naXRodWIuaW8vZGV2dG9vbHMtcHJvdG9jb2wvdG90L0ZldGNoLyNtZXRob2QtcHJvdmlkZVJlc3BvbnNlICovXG4gICAgYXN5bmMgcHJvdmlkZVJlc3BvbnNlKG92ZXJyaWRlcykge1xuICAgICAgICAoMCwgYXNzZXJ0X2pzXzEuYXNzZXJ0KSh0aGlzLiNmZXRjaElkLCAnTmV0d29yayBJbnRlcmNlcHRpb24gbm90IHNldC11cC4nKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHRocm91Z2ggaWYgdGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBpblxuICAgICAgICAvLyBBdXRoUmVxdWlyZWQgcGhhc2VcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJjZXB0UGhhc2UgPT09IFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIGBQcm92aWRlQ3JlZGVudGlhbHNgXG4gICAgICAgICAgICAvLyBBcyBgRGVmYXVsdGAgbWF5IGNhbmNlbCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiAnUHJvdmlkZUNyZWRlbnRpYWxzJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG1vZGlmeSB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8ganVzdCBjb250aW51ZSB0aGUgcmVxdWVzdFxuICAgICAgICBpZiAoIW92ZXJyaWRlcy5ib2R5ICYmICFvdmVycmlkZXMuaGVhZGVycykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NvbnRpbnVlUmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IFN0ZXAgNlxuICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI2NvbW1hbmQtbmV0d29yay1jb250aW51ZVJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jZHBGZXRjaEhlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzKShvdmVycmlkZXMuaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQ29kZSA9IG92ZXJyaWRlcy5zdGF0dXNDb2RlID8/IHRoaXMuc3RhdHVzQ29kZSA/PyAyMDA7XG4gICAgICAgIGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdGZXRjaC5mdWxmaWxsUmVxdWVzdCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy4jZmV0Y2hJZCxcbiAgICAgICAgICAgIHJlc3BvbnNlQ29kZSxcbiAgICAgICAgICAgIHJlc3BvbnNlUGhyYXNlOiBvdmVycmlkZXMucmVhc29uUGhyYXNlLFxuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZ2V0Q2RwQm9keUZyb21CaURpQnl0ZXNWYWx1ZShvdmVycmlkZXMuYm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRQaGFzZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0ICNjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3Jlc3BvbnNlLnBhdXNlZD8uZnJhbWVJZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5pbmZvPy5mcmFtZUlkID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LnBhdXNlZD8uZnJhbWVJZCA/P1xuICAgICAgICAgICAgdGhpcy4jcmVxdWVzdC5hdXRoPy5mcmFtZUlkID8/XG4gICAgICAgICAgICBudWxsKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIEhUVFAgc3RhdHVzIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdCBpZiBhbnkuICovXG4gICAgZ2V0IHN0YXR1c0NvZGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jcmVzcG9uc2UucGF1c2VkPy5yZXNwb25zZVN0YXR1c0NvZGUgPz9cbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLmV4dHJhSW5mbz8uc3RhdHVzQ29kZSA/P1xuICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UuaW5mbz8uc3RhdHVzKTtcbiAgICB9XG4gICAgYXN5bmMgI2NvbnRpbnVlV2l0aEF1dGgoYXV0aENoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI2ZldGNoSWQsICdOZXR3b3JrIEludGVyY2VwdGlvbiBub3Qgc2V0LXVwLicpO1xuICAgICAgICBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRmV0Y2guY29udGludWVXaXRoQXV0aCcsIHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogdGhpcy4jZmV0Y2hJZCxcbiAgICAgICAgICAgIGF1dGhDaGFsbGVuZ2VSZXNwb25zZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI2ludGVyY2VwdFBoYXNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAjZW1pdEV2ZW50KGdldEV2ZW50KSB7XG4gICAgICAgIGxldCBldmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50ID0gZ2V0RXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNpc0lnbm9yZWRFdmVudCgpIHx8XG4gICAgICAgICAgICAodGhpcy4jZW1pdHRlZEV2ZW50c1tldmVudC5tZXRob2RdICYmXG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRoaXMgZXZlbnQgY2FuIGJlIGVtaXR0ZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICBldmVudC5tZXRob2QgIT09IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5BdXRoUmVxdWlyZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcGhhc2VDaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuI2VtaXR0ZWRFdmVudHNbZXZlbnQubWV0aG9kXSA9IHRydWU7XG4gICAgICAgIHRoaXMuI2V2ZW50TWFuYWdlci5yZWdpc3RlckV2ZW50KE9iamVjdC5hc3NpZ24oZXZlbnQsIHtcbiAgICAgICAgICAgIHR5cGU6ICdldmVudCcsXG4gICAgICAgIH0pLCB0aGlzLiNjb250ZXh0KTtcbiAgICB9XG4gICAgI2dldEJhc2VFdmVudFBhcmFtcyhwaGFzZSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRQcm9wcyA9IHtcbiAgICAgICAgICAgIGlzQmxvY2tlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tlZEJ5ID0gdGhpcy4jaW50ZXJjZXB0c0luUGhhc2UocGhhc2UpO1xuICAgICAgICAgICAgaW50ZXJjZXB0UHJvcHMuaXNCbG9ja2VkID0gYmxvY2tlZEJ5LnNpemUgPiAwO1xuICAgICAgICAgICAgaWYgKGludGVyY2VwdFByb3BzLmlzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIGludGVyY2VwdFByb3BzLmludGVyY2VwdHMgPSBbLi4uYmxvY2tlZEJ5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dDogdGhpcy4jY29udGV4dCxcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHRoaXMuI2dldE5hdmlnYXRpb25JZCgpLFxuICAgICAgICAgICAgcmVkaXJlY3RDb3VudDogdGhpcy4jcmVkaXJlY3RDb3VudCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IHRoaXMuI2dldFJlcXVlc3REYXRhKCksXG4gICAgICAgICAgICAvLyBUaW1lc3RhbXAgc2hvdWxkIGJlIGluIG1pbGxpc2Vjb25kcywgd2hpbGUgQ0RQIHByb3ZpZGVzIGl0IGluIHNlY29uZHMuXG4gICAgICAgICAgICB0aW1lc3RhbXA6IE1hdGgucm91bmQoKHRoaXMuI3JlcXVlc3QuaW5mbz8ud2FsbFRpbWUgPz8gMCkgKiAxMDAwKSxcbiAgICAgICAgICAgIC8vIENvbnRhaW5zIGlzQmxvY2tlZCBhbmQgaW50ZXJjZXB0c1xuICAgICAgICAgICAgLi4uaW50ZXJjZXB0UHJvcHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgICNnZXRSZXNwb25zZUV2ZW50UGFyYW1zKCkge1xuICAgICAgICAvLyBDaHJvbWl1bSBzZW5kcyB3cm9uZyBleHRyYUluZm8gZXZlbnRzIGZvciByZXNwb25zZXMgc2VydmVkIGZyb20gY2FjaGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHVwcGV0ZWVyL3B1cHBldGVlci9pc3N1ZXMvOTk2NSBhbmRcbiAgICAgICAgLy8gaHR0cHM6Ly9jcmJ1Zy5jb20vMTM0MDM5OC5cbiAgICAgICAgaWYgKHRoaXMuI3Jlc3BvbnNlLmluZm8/LmZyb21EaXNrQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLmV4dHJhSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gW1xuICAgICAgICAgICAgLi4uKDAsIE5ldHdvcmtVdGlsc19qc18xLmJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVycykodGhpcy4jcmVzcG9uc2UuaW5mbz8uaGVhZGVycyksXG4gICAgICAgICAgICAuLi4oMCwgTmV0d29ya1V0aWxzX2pzXzEuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzKSh0aGlzLiNyZXNwb25zZS5leHRyYUluZm8/LmhlYWRlcnMpLFxuICAgICAgICAgICAgLy8gVE9ETzogVmVyaWZ5IGhvdyB0byBkZWR1cGUgdGhlc2VcbiAgICAgICAgICAgIC8vIC4uLmJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVyc0VudHJpZXMoXG4gICAgICAgICAgICAvLyAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZD8ucmVzcG9uc2VIZWFkZXJzXG4gICAgICAgICAgICAvLyApLFxuICAgICAgICBdO1xuICAgICAgICAvLyBUT0RPOiBnZXQgaGVhZGVycyBmcm9tIEZldGNoLnJlcXVlc3RQYXVzZWRcbiAgICAgICAgY29uc3QgYXV0aENoYWxsZW5nZXMgPSB0aGlzLiNhdXRoQ2hhbGxlbmdlcyh0aGlzLiNyZXNwb25zZS5pbmZvPy5oZWFkZXJzID8/IHt9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBwcm90b2NvbDogdGhpcy4jcmVzcG9uc2UuaW5mbz8ucHJvdG9jb2wgPz8gJycsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzQ29kZSA/PyAtMSwgLy8gVE9ETzogVGhyb3cgYW4gZXhjZXB0aW9uIG9yIHVzZSBzb21lIG90aGVyIHN0YXR1cyBjb2RlP1xuICAgICAgICAgICAgc3RhdHVzVGV4dDogdGhpcy4jcmVzcG9uc2UuaW5mbz8uc3RhdHVzVGV4dCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZD8ucmVzcG9uc2VTdGF0dXNUZXh0IHx8XG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBmcm9tQ2FjaGU6IHRoaXMuI3Jlc3BvbnNlLmluZm8/LmZyb21EaXNrQ2FjaGUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLiNyZXNwb25zZS5pbmZvPy5mcm9tUHJlZmV0Y2hDYWNoZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuI3NlcnZlZEZyb21DYWNoZSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBtaW1lVHlwZTogdGhpcy4jcmVzcG9uc2UuaW5mbz8ubWltZVR5cGUgfHwgJycsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB0aGlzLiNyZXNwb25zZS5pbmZvPy5lbmNvZGVkRGF0YUxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgaGVhZGVyc1NpemU6ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jb21wdXRlSGVhZGVyc1NpemUpKGhlYWRlcnMpLFxuICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgZnJvbSBzcGVjLlxuICAgICAgICAgICAgYm9keVNpemU6IDAsXG4gICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgcmVtb3ZpbmcgZnJvbSBzcGVjLlxuICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uKGF1dGhDaGFsbGVuZ2VzID8geyBhdXRoQ2hhbGxlbmdlcyB9IDoge30pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjZ2V0TmF2aWdhdGlvbklkKCkge1xuICAgICAgICAvLyBIZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBuYXZpZ2F0aW9uIHJlcXVlc3QsIGFuZCBpZiBub3QgcmV0dXJuIG51bGwuXG4gICAgICAgIGlmICghdGhpcy4jcmVxdWVzdC5pbmZvIHx8XG4gICAgICAgICAgICAhdGhpcy4jcmVxdWVzdC5pbmZvLmxvYWRlcklkIHx8XG4gICAgICAgICAgICAvLyBXaGVuIHdlIG5hdmlnYXRlIGFsbCBDRFAgbmV0d29yayBldmVudHMgaGF2ZSBgbG9hZGVySWRgXG4gICAgICAgICAgICAvLyBDRFAncyBgbG9hZGVySWRgIGFuZCBgcmVxdWVzdElkYCBtYXRjaCB3aGVuXG4gICAgICAgICAgICAvLyB0aGF0IHJlcXVlc3QgdHJpZ2dlcmVkIHRoZSBsb2FkaW5nXG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmluZm8ubG9hZGVySWQgIT09IHRoaXMuI3JlcXVlc3QuaW5mby5yZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB2aXJ0dWFsIG5hdmlnYXRpb24gSUQgZnJvbSB0aGUgYnJvd3NpbmcgY29udGV4dC5cbiAgICAgICAgcmV0dXJuIHRoaXMuI25ldHdvcmtTdG9yYWdlLmdldFZpcnR1YWxOYXZpZ2F0aW9uSWQodGhpcy4jcmVxdWVzdD8uaW5mbz8uZnJhbWVJZCk7XG4gICAgfVxuICAgICNnZXRSZXF1ZXN0RGF0YSgpIHtcbiAgICAgICAgY29uc3QgY29va2llcyA9IHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvXG4gICAgICAgICAgICA/IE5ldHdvcmtSZXF1ZXN0LiNnZXRDb29raWVzKHRoaXMuI3JlcXVlc3QuZXh0cmFJbmZvLmFzc29jaWF0ZWRDb29raWVzKVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuI3JlcXVlc3RPdmVycmlkZXM/LmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB0aGlzLiNyZXF1ZXN0T3ZlcnJpZGVzLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gW1xuICAgICAgICAgICAgICAgIC4uLigwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnMpKHRoaXMuI3JlcXVlc3QuaW5mbz8ucmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgICAgICAuLi4oMCwgTmV0d29ya1V0aWxzX2pzXzEuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzKSh0aGlzLiNyZXF1ZXN0LmV4dHJhSW5mbz8uaGVhZGVycyksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBib2R5U2l6ZSA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy4jcmVxdWVzdE92ZXJyaWRlcz8uYm9keVNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBib2R5U2l6ZSA9IHRoaXMuI3JlcXVlc3RPdmVycmlkZXMuYm9keVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5U2l6ZSA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpQm9keVNpemVGcm9tQ2RwUG9zdERhdGFFbnRyaWVzKSh0aGlzLiNyZXF1ZXN0LmluZm8/LnJlcXVlc3QucG9zdERhdGFFbnRyaWVzID8/IFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdDogdGhpcy4jaWQsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBjb29raWVzLFxuICAgICAgICAgICAgaGVhZGVyc1NpemU6ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5jb21wdXRlSGVhZGVyc1NpemUpKGhlYWRlcnMpLFxuICAgICAgICAgICAgYm9keVNpemUsXG4gICAgICAgICAgICB0aW1pbmdzOiB0aGlzLiNnZXRUaW1pbmdzKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFRPRE86IGltcGxlbWVudC5cbiAgICAjZ2V0VGltaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpbWVPcmlnaW46IDAsXG4gICAgICAgICAgICByZXF1ZXN0VGltZTogMCxcbiAgICAgICAgICAgIHJlZGlyZWN0U3RhcnQ6IDAsXG4gICAgICAgICAgICByZWRpcmVjdEVuZDogMCxcbiAgICAgICAgICAgIGZldGNoU3RhcnQ6IDAsXG4gICAgICAgICAgICBkbnNTdGFydDogMCxcbiAgICAgICAgICAgIGRuc0VuZDogMCxcbiAgICAgICAgICAgIGNvbm5lY3RTdGFydDogMCxcbiAgICAgICAgICAgIGNvbm5lY3RFbmQ6IDAsXG4gICAgICAgICAgICB0bHNTdGFydDogMCxcbiAgICAgICAgICAgIHJlcXVlc3RTdGFydDogMCxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RhcnQ6IDAsXG4gICAgICAgICAgICByZXNwb25zZUVuZDogMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2dldEJlZm9yZVJlcXVlc3RFdmVudCgpIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jcmVxdWVzdC5pbmZvLCAnUmVxdWVzdFdpbGxCZVNlbnRFdmVudCBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2Q6IHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcy5CZWZvcmVSZXF1ZXN0U2VudCxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuI2dldEJhc2VFdmVudFBhcmFtcyhcImJlZm9yZVJlcXVlc3RTZW50XCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5CZWZvcmVSZXF1ZXN0U2VudCAqLyksXG4gICAgICAgICAgICAgICAgaW5pdGlhdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5ldHdvcmtSZXF1ZXN0LiNnZXRJbml0aWF0b3JUeXBlKHRoaXMuI3JlcXVlc3QuaW5mby5pbml0aWF0b3IudHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogdGhpcy4jcmVxdWVzdC5pbmZvLmluaXRpYXRvci5jb2x1bW5OdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IHRoaXMuI3JlcXVlc3QuaW5mby5pbml0aWF0b3IubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tUcmFjZTogdGhpcy4jcmVxdWVzdC5pbmZvLmluaXRpYXRvci5zdGFjayxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy4jcmVxdWVzdC5pbmZvLmluaXRpYXRvci5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgICNnZXRSZXNwb25zZVN0YXJ0ZWRFdmVudCgpIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jcmVxdWVzdC5pbmZvLCAnUmVxdWVzdFdpbGxCZVNlbnRFdmVudCBpcyBub3Qgc2V0Jyk7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKFxuICAgICAgICAvLyBUaGUgcmVzcG9uc2UgcGF1c2VkIGNvbWVzIGJlZm9yZSBhbnkgZGF0YSBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICAgIHRoaXMuI3Jlc3BvbnNlLnBhdXNlZCB8fCB0aGlzLiNyZXNwb25zZS5pbmZvLCAnUmVzcG9uc2VSZWNlaXZlZEV2ZW50IGlzIG5vdCBzZXQnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTmV0d29yay5FdmVudE5hbWVzLlJlc3BvbnNlU3RhcnRlZCxcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuI2dldEJhc2VFdmVudFBhcmFtcyhcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogdGhpcy4jZ2V0UmVzcG9uc2VFdmVudFBhcmFtcygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2dldFJlc3BvbnNlUmVjZWl2ZWRFdmVudCgpIHtcbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkodGhpcy4jcmVxdWVzdC5pbmZvLCAnUmVxdWVzdFdpbGxCZVNlbnRFdmVudCBpcyBub3Qgc2V0Jyk7XG4gICAgICAgICgwLCBhc3NlcnRfanNfMS5hc3NlcnQpKHRoaXMuI3Jlc3BvbnNlLmluZm8sICdSZXNwb25zZVJlY2VpdmVkRXZlbnQgaXMgbm90IHNldCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMuUmVzcG9uc2VDb21wbGV0ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLiNnZXRCYXNlRXZlbnRQYXJhbXMoKSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogdGhpcy4jZ2V0UmVzcG9uc2VFdmVudFBhcmFtcygpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI2lzSWdub3JlZEV2ZW50KCkge1xuICAgICAgICBjb25zdCBmYXZpY29uVXJsID0gJy9mYXZpY29uLmljbyc7XG4gICAgICAgIHJldHVybiAodGhpcy4jcmVxdWVzdC5wYXVzZWQ/LnJlcXVlc3QudXJsLmVuZHNXaXRoKGZhdmljb25VcmwpID8/XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmluZm8/LnJlcXVlc3QudXJsLmVuZHNXaXRoKGZhdmljb25VcmwpID8/XG4gICAgICAgICAgICBmYWxzZSk7XG4gICAgfVxuICAgICNhdXRoQ2hhbGxlbmdlcyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICghKHRoaXMuc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHRoaXMuc3RhdHVzQ29kZSA9PT0gNDA3KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJOYW1lID0gdGhpcy5zdGF0dXNDb2RlID09PSA0MDEgPyAnV1dXLUF1dGhlbnRpY2F0ZScgOiAnUHJveHktQXV0aGVudGljYXRlJztcbiAgICAgICAgY29uc3QgYXV0aENoYWxsZW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGVhZGVyLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IERvIGEgcHJvcGVyIG1hdGNoIGJhc2VkIG9uIGh0dHBzOi8vaHR0cHdnLm9yZy9zcGVjcy9yZmM5MTEwLmh0bWwjY3JlZGVudGlhbHNcbiAgICAgICAgICAgIC8vIE9yIHZlcmlmeSB0aGlzIHdvcmtzXG4gICAgICAgICAgICBpZiAoaGVhZGVyLmxvY2FsZUNvbXBhcmUoaGVhZGVyTmFtZSwgdW5kZWZpbmVkLCB7IHNlbnNpdGl2aXR5OiAnYmFzZScgfSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhdXRoQ2hhbGxlbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lOiB2YWx1ZS5zcGxpdCgnICcpLmF0KDApID8/ICcnLFxuICAgICAgICAgICAgICAgICAgICByZWFsbTogdmFsdWUubWF0Y2goUkVBTE1fUkVHRVgpPy5hdCgwKSA/PyAnJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aENoYWxsZW5nZXM7XG4gICAgfVxuICAgIHN0YXRpYyAjZ2V0SW5pdGlhdG9yVHlwZShpbml0aWF0b3JUeXBlKSB7XG4gICAgICAgIHN3aXRjaCAoaW5pdGlhdG9yVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncGFyc2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjcmlwdCc6XG4gICAgICAgICAgICBjYXNlICdwcmVmbGlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWF0b3JUeXBlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgI2dldENvb2tpZXMoYXNzb2NpYXRlZENvb2tpZXMpIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0ZWRDb29raWVzXG4gICAgICAgICAgICAuZmlsdGVyKCh7IGJsb2NrZWRSZWFzb25zIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShibG9ja2VkUmVhc29ucykgfHwgYmxvY2tlZFJlYXNvbnMubGVuZ3RoID09PSAwO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoeyBjb29raWUgfSkgPT4gKDAsIE5ldHdvcmtVdGlsc19qc18xLmNkcFRvQmlEaUNvb2tpZSkoY29va2llKSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXR3b3JrUmVxdWVzdCA9IE5ldHdvcmtSZXF1ZXN0O1xuZnVuY3Rpb24gZ2V0Q2RwQm9keUZyb21CaURpQnl0ZXNWYWx1ZShib2R5KSB7XG4gICAgbGV0IHBhcnNlZEJvZHk7XG4gICAgaWYgKGJvZHk/LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlZEJvZHkgPSBidG9hKGJvZHkudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChib2R5Py50eXBlID09PSAnYmFzZTY0Jykge1xuICAgICAgICBwYXJzZWRCb2R5ID0gYm9keS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEJvZHk7XG59XG5mdW5jdGlvbiBnZXRTaXplRnJvbUJpRGlCeXRlc1ZhbHVlKGJvZHkpIHtcbiAgICBpZiAoYm9keT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJvZHkudmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChib2R5Py50eXBlID09PSAnYmFzZTY0Jykge1xuICAgICAgICByZXR1cm4gYXRvYihib2R5LnZhbHVlKS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya1JlcXVlc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5ldHdvcmtTdG9yYWdlID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91dWlkLmpzXCIpO1xuY29uc3QgTmV0d29ya1JlcXVlc3RfanNfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtSZXF1ZXN0LmpzXCIpO1xuY29uc3QgTmV0d29ya1V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrVXRpbHMuanNcIik7XG4vKiogU3RvcmVzIG5ldHdvcmsgYW5kIGludGVyY2VwdCBtYXBzLiAqL1xuY2xhc3MgTmV0d29ya1N0b3JhZ2Uge1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICNldmVudE1hbmFnZXI7XG4gICAgI2xvZ2dlcjtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBmcm9tIG5ldHdvcmsgcmVxdWVzdCBJRCB0byBOZXR3b3JrIFJlcXVlc3Qgb2JqZWN0cy5cbiAgICAgKiBOZWVkZWQgYXMgbG9uZyBhcyBpbmZvcm1hdGlvbiBhYm91dCByZXF1ZXN0cyBjb21lcyBmcm9tIGRpZmZlcmVudCBldmVudHMuXG4gICAgICovXG4gICAgI3JlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgIC8qKiBBIG1hcCBmcm9tIGludGVyY2VwdCBJRCB0byB0cmFjayBhY3RpdmUgbmV0d29yayBpbnRlcmNlcHRzLiAqL1xuICAgICNpbnRlcmNlcHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgYnJvd3NlckNsaWVudCwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIGJyb3dzZXJDbGllbnQub24oJ1RhcmdldC5kZXRhY2hlZEZyb21UYXJnZXQnLCAoeyBzZXNzaW9uSWQgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlUmVxdWVzdE1hcChzZXNzaW9uSWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXR3b3JrIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gSUQsIGlmIGFueS5cbiAgICAgKiBPdGhlcndpc2UsIGNyZWF0ZXMgYSBuZXcgbmV0d29yayByZXF1ZXN0IHdpdGggdGhlIGdpdmVuIElEIGFuZCBjZHAgdGFyZ2V0LlxuICAgICAqL1xuICAgICNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KGlkLCBjZHBUYXJnZXQsIHJlZGlyZWN0Q291bnQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmdldFJlcXVlc3RCeUlkKGlkKTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QgPSBuZXcgTmV0d29ya1JlcXVlc3RfanNfMS5OZXR3b3JrUmVxdWVzdChpZCwgdGhpcy4jZXZlbnRNYW5hZ2VyLCB0aGlzLCBjZHBUYXJnZXQsIHJlZGlyZWN0Q291bnQsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIHRoaXMuYWRkUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuICAgIG9uQ2RwVGFyZ2V0Q3JlYXRlZChjZHBUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgY2RwQ2xpZW50ID0gY2RwVGFyZ2V0LmNkcENsaWVudDtcbiAgICAgICAgLy8gVE9ETzogV3JhcCBpbnRvIG9iamVjdFxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ05ldHdvcmsucmVxdWVzdFdpbGxCZVNlbnQnLFxuICAgICAgICAgICAgICAgIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuZ2V0UmVxdWVzdEJ5SWQocGFyYW1zLnJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0ICYmIHJlcXVlc3QuaXNSZWRpcmVjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhhbmRsZVJlZGlyZWN0KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVJlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCwgcmVxdWVzdC5yZWRpcmVjdENvdW50ICsgMSkub25SZXF1ZXN0V2lsbEJlU2VudEV2ZW50KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCkub25SZXF1ZXN0V2lsbEJlU2VudEV2ZW50KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnTmV0d29yay5yZXF1ZXN0V2lsbEJlU2VudEV4dHJhSW5mbycsXG4gICAgICAgICAgICAgICAgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCkub25SZXF1ZXN0V2lsbEJlU2VudEV4dHJhSW5mb0V2ZW50KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ05ldHdvcmsucmVzcG9uc2VSZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCkub25SZXNwb25zZVJlY2VpdmVkRXZlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnTmV0d29yay5yZXNwb25zZVJlY2VpdmVkRXh0cmFJbmZvJyxcbiAgICAgICAgICAgICAgICAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QocGFyYW1zLnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vblJlc3BvbnNlUmVjZWl2ZWRFeHRyYUluZm9FdmVudChwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdOZXR3b3JrLnJlcXVlc3RTZXJ2ZWRGcm9tQ2FjaGUnLFxuICAgICAgICAgICAgICAgIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZ2V0T3JDcmVhdGVOZXR3b3JrUmVxdWVzdChwYXJhbXMucmVxdWVzdElkLCBjZHBUYXJnZXQpLm9uU2VydmVkRnJvbUNhY2hlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ05ldHdvcmsubG9hZGluZ0ZhaWxlZCcsXG4gICAgICAgICAgICAgICAgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KHBhcmFtcy5yZXF1ZXN0SWQsIGNkcFRhcmdldCkub25Mb2FkaW5nRmFpbGVkRXZlbnQocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnRmV0Y2gucmVxdWVzdFBhdXNlZCcsXG4gICAgICAgICAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2dldE9yQ3JlYXRlTmV0d29ya1JlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgIC8vIENEUCBxdWlyayBpZiB0aGUgTmV0d29yayBkb21haW4gaXMgbm90IHByZXNlbnQgdGhpcyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQubmV0d29ya0lkID8/IGV2ZW50LnJlcXVlc3RJZCwgY2RwVGFyZ2V0KS5vblJlcXVlc3RQYXVzZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdGZXRjaC5hdXRoUmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZ2V0UmVxdWVzdEJ5RmV0Y2hJZChldmVudC5yZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLiNnZXRPckNyZWF0ZU5ldHdvcmtSZXF1ZXN0KGV2ZW50LnJlcXVlc3RJZCwgY2RwVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uQXV0aFJlcXVpcmVkKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBbZXZlbnQsIGxpc3RlbmVyXSBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGNkcENsaWVudC5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEludGVyY2VwdGlvblN0YWdlcyhicm93c2luZ0NvbnRleHRJZCkge1xuICAgICAgICBjb25zdCBzdGFnZXMgPSB7XG4gICAgICAgICAgICByZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dGg6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGludGVyY2VwdCBvZiB0aGlzLiNpbnRlcmNlcHRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJjZXB0LmNvbnRleHRzICYmXG4gICAgICAgICAgICAgICAgIWludGVyY2VwdC5jb250ZXh0cy5pbmNsdWRlcyhicm93c2luZ0NvbnRleHRJZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWdlcy5yZXF1ZXN0IHx8PSBpbnRlcmNlcHQucGhhc2VzLmluY2x1ZGVzKFwiYmVmb3JlUmVxdWVzdFNlbnRcIiAvKiBOZXR3b3JrLkludGVyY2VwdFBoYXNlLkJlZm9yZVJlcXVlc3RTZW50ICovKTtcbiAgICAgICAgICAgIHN0YWdlcy5yZXNwb25zZSB8fD0gaW50ZXJjZXB0LnBoYXNlcy5pbmNsdWRlcyhcInJlc3BvbnNlU3RhcnRlZFwiIC8qIE5ldHdvcmsuSW50ZXJjZXB0UGhhc2UuUmVzcG9uc2VTdGFydGVkICovKTtcbiAgICAgICAgICAgIHN0YWdlcy5hdXRoIHx8PSBpbnRlcmNlcHQucGhhc2VzLmluY2x1ZGVzKFwiYXV0aFJlcXVpcmVkXCIgLyogTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFnZXM7XG4gICAgfVxuICAgIGdldEludGVyY2VwdHNGb3JQaGFzZShyZXF1ZXN0LCBwaGFzZSkge1xuICAgICAgICBpZiAocmVxdWVzdC51cmwgPT09IE5ldHdvcmtSZXF1ZXN0X2pzXzEuTmV0d29ya1JlcXVlc3QudW5rbm93blBhcmFtZXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmNlcHRzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnRlcmNlcHRJZCwgaW50ZXJjZXB0XSBvZiB0aGlzLiNpbnRlcmNlcHRzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFpbnRlcmNlcHQucGhhc2VzLmluY2x1ZGVzKHBoYXNlKSB8fFxuICAgICAgICAgICAgICAgIChpbnRlcmNlcHQuY29udGV4dHMgJiZcbiAgICAgICAgICAgICAgICAgICAgIWludGVyY2VwdC5jb250ZXh0cy5pbmNsdWRlcyhyZXF1ZXN0LmNkcFRhcmdldC50b3BMZXZlbElkKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcmNlcHQudXJsUGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJjZXB0cy5hZGQoaW50ZXJjZXB0SWQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGludGVyY2VwdC51cmxQYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgTmV0d29ya1V0aWxzX2pzXzEubWF0Y2hVcmxQYXR0ZXJuKShwYXR0ZXJuLCByZXF1ZXN0LnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJjZXB0cy5hZGQoaW50ZXJjZXB0SWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyY2VwdHM7XG4gICAgfVxuICAgIGRpc3Bvc2VSZXF1ZXN0TWFwKHNlc3Npb25JZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy4jcmVxdWVzdHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmNkcENsaWVudC5zZXNzaW9uSWQgPT09IHNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiBlbnRyeSB0byB0aGUgaW50ZXJjZXB0IG1hcC5cbiAgICAgKiBVUkwgcGF0dGVybnMgYXJlIGFzc3VtZWQgdG8gYmUgcGFyc2VkLlxuICAgICAqXG4gICAgICogQHJldHVybiBUaGUgaW50ZXJjZXB0IElELlxuICAgICAqL1xuICAgIGFkZEludGVyY2VwdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRJZCA9ICgwLCB1dWlkX2pzXzEudXVpZHY0KSgpO1xuICAgICAgICB0aGlzLiNpbnRlcmNlcHRzLnNldChpbnRlcmNlcHRJZCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gaW50ZXJjZXB0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGludGVyY2VwdCBmcm9tIHRoZSBpbnRlcmNlcHQgbWFwLlxuICAgICAqIFRocm93cyBOb1N1Y2hJbnRlcmNlcHRFeGNlcHRpb24gaWYgdGhlIGludGVyY2VwdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICByZW1vdmVJbnRlcmNlcHQoaW50ZXJjZXB0KSB7XG4gICAgICAgIGlmICghdGhpcy4jaW50ZXJjZXB0cy5oYXMoaW50ZXJjZXB0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoSW50ZXJjZXB0RXhjZXB0aW9uKGBJbnRlcmNlcHQgJyR7aW50ZXJjZXB0fScgZG9lcyBub3QgZXhpc3QuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaW50ZXJjZXB0cy5kZWxldGUoaW50ZXJjZXB0KTtcbiAgICB9XG4gICAgZ2V0UmVxdWVzdEJ5SWQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3RzLmdldChpZCk7XG4gICAgfVxuICAgIGdldFJlcXVlc3RCeUZldGNoSWQoZmV0Y2hJZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgdGhpcy4jcmVxdWVzdHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmZldGNoSWQgPT09IGZldGNoSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkZFJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICB0aGlzLiNyZXF1ZXN0cy5zZXQocmVxdWVzdC5pZCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIGRlbGV0ZVJlcXVlc3QoaWQpIHtcbiAgICAgICAgdGhpcy4jcmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlydHVhbCBuYXZpZ2F0aW9uIElEIGZvciB0aGUgZ2l2ZW4gbmF2aWdhYmxlIElELlxuICAgICAqL1xuICAgIGdldFZpcnR1YWxOYXZpZ2F0aW9uSWQoY29udGV4dElkKSB7XG4gICAgICAgIGlmIChjb250ZXh0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRDb250ZXh0KGNvbnRleHRJZClcbiAgICAgICAgICAgID8udmlydHVhbE5hdmlnYXRpb25JZCA/PyBudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLk5ldHdvcmtTdG9yYWdlID0gTmV0d29ya1N0b3JhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXR3b3JrU3RvcmFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlSGVhZGVyc1NpemUgPSBjb21wdXRlSGVhZGVyc1NpemU7XG5leHBvcnRzLmJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVycyA9IGJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVycztcbmV4cG9ydHMuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzRW50cmllcyA9IGJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBOZXR3b3JrSGVhZGVyc0VudHJpZXM7XG5leHBvcnRzLmNkcE5ldHdvcmtIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycyA9IGNkcE5ldHdvcmtIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycztcbmV4cG9ydHMuYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcEZldGNoSGVhZGVycyA9IGJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBGZXRjaEhlYWRlcnM7XG5leHBvcnRzLmNkcEZldGNoSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnMgPSBjZHBGZXRjaEhlYWRlcnNGcm9tQmlkaU5ldHdvcmtIZWFkZXJzO1xuZXhwb3J0cy5jZHBBdXRoQ2hhbGxlbmdlUmVzcG9uc2VGcm9tQmlkaUF1dGhDb250aW51ZVdpdGhBdXRoQWN0aW9uID0gY2RwQXV0aENoYWxsZW5nZVJlc3BvbnNlRnJvbUJpZGlBdXRoQ29udGludWVXaXRoQXV0aEFjdGlvbjtcbmV4cG9ydHMuY2RwVG9CaURpQ29va2llID0gY2RwVG9CaURpQ29va2llO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZUJ5dGVWYWx1ZSA9IGRlc2VyaWFsaXplQnl0ZVZhbHVlO1xuZXhwb3J0cy5iaWRpVG9DZHBDb29raWUgPSBiaWRpVG9DZHBDb29raWU7XG5leHBvcnRzLnNhbWVTaXRlQmlEaVRvQ2RwID0gc2FtZVNpdGVCaURpVG9DZHA7XG5leHBvcnRzLmlzU3BlY2lhbFNjaGVtZSA9IGlzU3BlY2lhbFNjaGVtZTtcbmV4cG9ydHMubWF0Y2hVcmxQYXR0ZXJuID0gbWF0Y2hVcmxQYXR0ZXJuO1xuZXhwb3J0cy5iaWRpQm9keVNpemVGcm9tQ2RwUG9zdERhdGFFbnRyaWVzID0gYmlkaUJvZHlTaXplRnJvbUNkcFBvc3REYXRhRW50cmllcztcbmNvbnN0IEVycm9yUmVzcG9uc2VfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9FcnJvclJlc3BvbnNlLmpzXCIpO1xuY29uc3QgQmFzZTY0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvQmFzZTY0LmpzXCIpO1xuY29uc3QgVXJsUGF0dGVybl9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL1VybFBhdHRlcm4uanNcIik7XG5mdW5jdGlvbiBjb21wdXRlSGVhZGVyc1NpemUoaGVhZGVycykge1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gaGVhZGVycy5yZWR1Y2UoKGFjYywgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBgJHthY2N9JHtoZWFkZXIubmFtZX06ICR7aGVhZGVyLnZhbHVlLnZhbHVlfVxcclxcbmA7XG4gICAgfSwgJycpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVxdWVzdEhlYWRlcnMpLmxlbmd0aDtcbn1cbi8qKiBDb252ZXJ0cyBmcm9tIENEUCBOZXR3b3JrIGRvbWFpbiBoZWFkZXJzIHRvIEJpRGkgbmV0d29yayBoZWFkZXJzLiAqL1xuZnVuY3Rpb24gYmlkaU5ldHdvcmtIZWFkZXJzRnJvbUNkcE5ldHdvcmtIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vKiogQ29udmVydHMgZnJvbSBDRFAgRmV0Y2ggZG9tYWluIGhlYWRlcnMgdG8gQmlEaSBuZXR3b3JrIGhlYWRlcnMuICovXG5mdW5jdGlvbiBiaWRpTmV0d29ya0hlYWRlcnNGcm9tQ2RwTmV0d29ya0hlYWRlcnNFbnRyaWVzKGhlYWRlcnMpIHtcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycy5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLyoqIENvbnZlcnRzIGZyb20gQmlkaSBuZXR3b3JrIGhlYWRlcnMgdG8gQ0RQIE5ldHdvcmsgZG9tYWluIGhlYWRlcnMuICovXG5mdW5jdGlvbiBjZHBOZXR3b3JrSGVhZGVyc0Zyb21CaWRpTmV0d29ya0hlYWRlcnMoaGVhZGVycykge1xuICAgIGlmIChoZWFkZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKChyZXN1bHQsIGhlYWRlcikgPT4ge1xuICAgICAgICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBiZXR3ZWVuIHN0cmluZyBhbmQgYnl0ZXM/XG4gICAgICAgIHJlc3VsdFtoZWFkZXIubmFtZV0gPSBoZWFkZXIudmFsdWUudmFsdWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufVxuLyoqIENvbnZlcnRzIGZyb20gQ0RQIEZldGNoIGRvbWFpbiBoZWFkZXIgZW50cmllcyB0byBCaWRpIG5ldHdvcmsgaGVhZGVycy4gKi9cbmZ1bmN0aW9uIGJpZGlOZXR3b3JrSGVhZGVyc0Zyb21DZHBGZXRjaEhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG59XG4vKiogQ29udmVydHMgZnJvbSBCaWRpIG5ldHdvcmsgaGVhZGVycyB0byBDRFAgRmV0Y2ggZG9tYWluIGhlYWRlciBlbnRyaWVzLiAqL1xuZnVuY3Rpb24gY2RwRmV0Y2hIZWFkZXJzRnJvbUJpZGlOZXR3b3JrSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycy5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLnZhbHVlLFxuICAgIH0pKTtcbn1cbi8qKiBDb252ZXJ0cyBmcm9tIEJpZGkgYXV0aCBhY3Rpb24gdG8gQ0RQIGF1dGggY2hhbGxlbmdlIHJlc3BvbnNlLiAqL1xuZnVuY3Rpb24gY2RwQXV0aENoYWxsZW5nZVJlc3BvbnNlRnJvbUJpZGlBdXRoQ29udGludWVXaXRoQXV0aEFjdGlvbihhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgIHJldHVybiAnRGVmYXVsdCc7XG4gICAgICAgIGNhc2UgJ2NhbmNlbCc6XG4gICAgICAgICAgICByZXR1cm4gJ0NhbmNlbEF1dGgnO1xuICAgICAgICBjYXNlICdwcm92aWRlQ3JlZGVudGlhbHMnOlxuICAgICAgICAgICAgcmV0dXJuICdQcm92aWRlQ3JlZGVudGlhbHMnO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgZnJvbSBDRFAgTmV0d29yayBkb21haW4gY29va2llIHRvIEJpRGkgbmV0d29yayBjb29raWUuXG4gKiAqIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9OZXR3b3JrLyN0eXBlLUNvb2tpZVxuICogKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViZHJpdmVyLWJpZGkvI3R5cGUtbmV0d29yay1Db29raWVcbiAqL1xuZnVuY3Rpb24gY2RwVG9CaURpQ29va2llKGNvb2tpZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogY29va2llLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogY29va2llLnZhbHVlIH0sXG4gICAgICAgIGRvbWFpbjogY29va2llLmRvbWFpbixcbiAgICAgICAgcGF0aDogY29va2llLnBhdGgsXG4gICAgICAgIHNpemU6IGNvb2tpZS5zaXplLFxuICAgICAgICBodHRwT25seTogY29va2llLmh0dHBPbmx5LFxuICAgICAgICBzZWN1cmU6IGNvb2tpZS5zZWN1cmUsXG4gICAgICAgIHNhbWVTaXRlOiBjb29raWUuc2FtZVNpdGUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBcIm5vbmVcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLk5vbmUgKi9cbiAgICAgICAgICAgIDogc2FtZVNpdGVDZHBUb0JpRGkoY29va2llLnNhbWVTaXRlKSxcbiAgICAgICAgLi4uKGNvb2tpZS5leHBpcmVzID49IDAgPyB7IGV4cGlyeTogY29va2llLmV4cGlyZXMgfSA6IHVuZGVmaW5lZCksXG4gICAgfTtcbiAgICAvLyBFeHRlbmRpbmcgd2l0aCBDRFAtc3BlY2lmaWMgcHJvcGVydGllcyB3aXRoIGBnb29nOmAgcHJlZml4LlxuICAgIHJlc3VsdFtgZ29vZzpzZXNzaW9uYF0gPSBjb29raWUuc2Vzc2lvbjtcbiAgICByZXN1bHRbYGdvb2c6cHJpb3JpdHlgXSA9IGNvb2tpZS5wcmlvcml0eTtcbiAgICByZXN1bHRbYGdvb2c6c2FtZVBhcnR5YF0gPSBjb29raWUuc2FtZVBhcnR5O1xuICAgIHJlc3VsdFtgZ29vZzpzb3VyY2VTY2hlbWVgXSA9IGNvb2tpZS5zb3VyY2VTY2hlbWU7XG4gICAgcmVzdWx0W2Bnb29nOnNvdXJjZVBvcnRgXSA9IGNvb2tpZS5zb3VyY2VQb3J0O1xuICAgIGlmIChjb29raWUucGFydGl0aW9uS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0W2Bnb29nOnBhcnRpdGlvbktleWBdID0gY29va2llLnBhcnRpdGlvbktleTtcbiAgICB9XG4gICAgaWYgKGNvb2tpZS5wYXJ0aXRpb25LZXlPcGFxdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHRbYGdvb2c6cGFydGl0aW9uS2V5T3BhcXVlYF0gPSBjb29raWUucGFydGl0aW9uS2V5T3BhcXVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgYnl0ZSB2YWx1ZSB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7TmV0d29yay5CeXRlc1ZhbHVlfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUJ5dGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAnYmFzZTY0Jykge1xuICAgICAgICByZXR1cm4gKDAsIEJhc2U2NF9qc18xLmJhc2U2NFRvU3RyaW5nKSh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydHMgZnJvbSBCaURpIHNldCBuZXR3b3JrIGNvb2tpZSBwYXJhbXMgdG8gQ0RQIE5ldHdvcmsgZG9tYWluIGNvb2tpZS5cbiAqICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyN0eXBlLW5ldHdvcmstQ29va2llXG4gKiAqIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL3RvdC9OZXR3b3JrLyN0eXBlLUNvb2tpZVBhcmFtXG4gKi9cbmZ1bmN0aW9uIGJpZGlUb0NkcENvb2tpZShwYXJhbXMsIHBhcnRpdGlvbktleSkge1xuICAgIGNvbnN0IGRlc2VyaWFsaXplZFZhbHVlID0gZGVzZXJpYWxpemVCeXRlVmFsdWUocGFyYW1zLmNvb2tpZS52YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBwYXJhbXMuY29va2llLm5hbWUsXG4gICAgICAgIHZhbHVlOiBkZXNlcmlhbGl6ZWRWYWx1ZSxcbiAgICAgICAgZG9tYWluOiBwYXJhbXMuY29va2llLmRvbWFpbixcbiAgICAgICAgcGF0aDogcGFyYW1zLmNvb2tpZS5wYXRoID8/ICcvJyxcbiAgICAgICAgc2VjdXJlOiBwYXJhbXMuY29va2llLnNlY3VyZSA/PyBmYWxzZSxcbiAgICAgICAgaHR0cE9ubHk6IHBhcmFtcy5jb29raWUuaHR0cE9ubHkgPz8gZmFsc2UsXG4gICAgICAgIC4uLihwYXJ0aXRpb25LZXkuc291cmNlT3JpZ2luICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgcGFydGl0aW9uS2V5OiB7XG4gICAgICAgICAgICAgICAgaGFzQ3Jvc3NTaXRlQW5jZXN0b3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIENEUCdzIGBwYXJ0aXRpb25LZXkudG9wTGV2ZWxTaXRlYCBpcyB0aGUgQmlEaSdzIGBwYXJ0aXRpb24uc291cmNlT3JpZ2luYC5cbiAgICAgICAgICAgICAgICB0b3BMZXZlbFNpdGU6IHBhcnRpdGlvbktleS5zb3VyY2VPcmlnaW4sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHBhcmFtcy5jb29raWUuZXhwaXJ5ICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgZXhwaXJlczogcGFyYW1zLmNvb2tpZS5leHBpcnksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocGFyYW1zLmNvb2tpZS5zYW1lU2l0ZSAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgICAgIHNhbWVTaXRlOiBzYW1lU2l0ZUJpRGlUb0NkcChwYXJhbXMuY29va2llLnNhbWVTaXRlKSxcbiAgICAgICAgfSksXG4gICAgfTtcbiAgICAvLyBFeHRlbmRpbmcgd2l0aCBDRFAtc3BlY2lmaWMgcHJvcGVydGllcyB3aXRoIGBnb29nOmAgcHJlZml4LlxuICAgIGlmIChwYXJhbXMuY29va2llW2Bnb29nOnVybGBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnVybCA9IHBhcmFtcy5jb29raWVbYGdvb2c6dXJsYF07XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY29va2llW2Bnb29nOnByaW9yaXR5YF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQucHJpb3JpdHkgPSBwYXJhbXMuY29va2llW2Bnb29nOnByaW9yaXR5YF07XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY29va2llW2Bnb29nOnNhbWVQYXJ0eWBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnNhbWVQYXJ0eSA9IHBhcmFtcy5jb29raWVbYGdvb2c6c2FtZVBhcnR5YF07XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY29va2llW2Bnb29nOnNvdXJjZVNjaGVtZWBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LnNvdXJjZVNjaGVtZSA9IHBhcmFtcy5jb29raWVbYGdvb2c6c291cmNlU2NoZW1lYF07XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY29va2llW2Bnb29nOnNvdXJjZVBvcnRgXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5zb3VyY2VQb3J0ID0gcGFyYW1zLmNvb2tpZVtgZ29vZzpzb3VyY2VQb3J0YF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzYW1lU2l0ZUNkcFRvQmlEaShzYW1lU2l0ZSkge1xuICAgIHN3aXRjaCAoc2FtZVNpdGUpIHtcbiAgICAgICAgY2FzZSAnU3RyaWN0JzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmljdFwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuU3RyaWN0ICovO1xuICAgICAgICBjYXNlICdOb25lJzpcbiAgICAgICAgICAgIHJldHVybiBcIm5vbmVcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLk5vbmUgKi87XG4gICAgICAgIGNhc2UgJ0xheCc6XG4gICAgICAgICAgICByZXR1cm4gXCJsYXhcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLkxheCAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIGBMYXhgOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2FydGljbGVzL3NhbWVzaXRlLWNvb2tpZXMtZXhwbGFpbmVkI3NhbWVzaXRlbGF4X2J5X2RlZmF1bHRcbiAgICAgICAgICAgIHJldHVybiBcImxheFwiIC8qIE5ldHdvcmsuU2FtZVNpdGUuTGF4ICovO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVTaXRlQmlEaVRvQ2RwKHNhbWVTaXRlKSB7XG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgICBjYXNlIFwic3RyaWN0XCIgLyogTmV0d29yay5TYW1lU2l0ZS5TdHJpY3QgKi86XG4gICAgICAgICAgICByZXR1cm4gJ1N0cmljdCc7XG4gICAgICAgIGNhc2UgXCJsYXhcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLkxheCAqLzpcbiAgICAgICAgICAgIHJldHVybiAnTGF4JztcbiAgICAgICAgY2FzZSBcIm5vbmVcIiAvKiBOZXR3b3JrLlNhbWVTaXRlLk5vbmUgKi86XG4gICAgICAgICAgICByZXR1cm4gJ05vbmUnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3JSZXNwb25zZV9qc18xLkludmFsaWRBcmd1bWVudEV4Y2VwdGlvbihgVW5rbm93biAnc2FtZVNpdGUnIHZhbHVlICR7c2FtZVNpdGV9YCk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJvdG9jb2wgaXMgc3BlY2lhbC5cbiAqIFNwZWNpYWwgcHJvdG9jb2xzIGFyZSB0aG9zZSB0aGF0IGhhdmUgYSBkZWZhdWx0IHBvcnQuXG4gKlxuICogRXhhbXBsZSBpbnB1dHM6ICdodHRwJywgJ2h0dHA6J1xuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzcGVjaWFsLXNjaGVtZVxuICovXG5mdW5jdGlvbiBpc1NwZWNpYWxTY2hlbWUocHJvdG9jb2wpIHtcbiAgICByZXR1cm4gWydmdHAnLCAnZmlsZScsICdodHRwJywgJ2h0dHBzJywgJ3dzJywgJ3dzcyddLmluY2x1ZGVzKHByb3RvY29sLnJlcGxhY2UoLzokLywgJycpKTtcbn1cbi8qKiBNYXRjaGVzIHRoZSBnaXZlbiBVUkxQYXR0ZXJuIGFnYWluc3QgdGhlIGdpdmVuIFVSTC4gKi9cbmZ1bmN0aW9uIG1hdGNoVXJsUGF0dGVybih1cmxQYXR0ZXJuLCB1cmwpIHtcbiAgICBzd2l0Y2ggKHVybFBhdHRlcm4udHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFVybFBhdHRlcm5fanNfMS5VUkxQYXR0ZXJuKHVybFBhdHRlcm4ucGF0dGVybik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVybFBhdHRlcm5fanNfMS5VUkxQYXR0ZXJuKHtcbiAgICAgICAgICAgICAgICBwcm90b2NvbDogcGF0dGVybi5wcm90b2NvbCxcbiAgICAgICAgICAgICAgICBob3N0bmFtZTogcGF0dGVybi5ob3N0bmFtZSxcbiAgICAgICAgICAgICAgICBwb3J0OiBwYXR0ZXJuLnBvcnQsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWU6IHBhdHRlcm4ucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBwYXR0ZXJuLnNlYXJjaCxcbiAgICAgICAgICAgIH0pLnRlc3QodXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdwYXR0ZXJuJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXJsUGF0dGVybl9qc18xLlVSTFBhdHRlcm4odXJsUGF0dGVybikudGVzdCh1cmwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJpZGlCb2R5U2l6ZUZyb21DZHBQb3N0RGF0YUVudHJpZXMoZW50cmllcykge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgc2l6ZSArPSBhdG9iKGVudHJ5LmJ5dGVzID8/ICcnKS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya1V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25zUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNsYXNzIFBlcm1pc3Npb25zUHJvY2Vzc29yIHtcbiAgICAjYnJvd3NlckNkcENsaWVudDtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyQ2RwQ2xpZW50KSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICBhc3luYyBzZXRQZXJtaXNzaW9ucyhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDb250ZXh0SWQgPSBwYXJhbXNbJ2dvb2c6dXNlckNvbnRleHQnXSB8fFxuICAgICAgICAgICAgICAgIHBhcmFtcy51c2VyQ29udGV4dDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ0Jyb3dzZXIuc2V0UGVybWlzc2lvbicsIHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IHBhcmFtcy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdXNlckNvbnRleHRJZCAmJiB1c2VyQ29udGV4dElkICE9PSAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICAgICAgPyB1c2VyQ29udGV4dElkXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb246IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLmRlc2NyaXB0b3IubmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldHRpbmc6IHBhcmFtcy5zdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgICBgUGVybWlzc2lvbiBjYW4ndCBiZSBncmFudGVkIHRvIG9wYXF1ZSBvcmlnaW5zLmApIHtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc3VjY2VzcyBpZiB0aGUgb3JpZ2luIGlzIG5vdCB2YWxpZCAoZG9lcyBub3QgbWF0Y2ggYW55XG4gICAgICAgICAgICAgICAgLy8gZXhpc3Rpbmcgb3JpZ2lucykuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuZXhwb3J0cy5QZXJtaXNzaW9uc1Byb2Nlc3NvciA9IFBlcm1pc3Npb25zUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVybWlzc2lvbnNQcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbFByb3h5ID0gdm9pZCAwO1xuY29uc3QgcHJvdG9jb2xfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9wcm90b2NvbC9wcm90b2NvbC5qc1wiKTtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL2xvZy5qc1wiKTtcbmNvbnN0IHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91dWlkLmpzXCIpO1xuLyoqXG4gKiBVc2VkIHRvIHNlbmQgbWVzc2FnZXMgZnJvbSByZWFsbSB0byBCaURpIHVzZXIuXG4gKi9cbmNsYXNzIENoYW5uZWxQcm94eSB7XG4gICAgI3Byb3BlcnRpZXM7XG4gICAgI2lkID0gKDAsIHV1aWRfanNfMS51dWlkdjQpKCk7XG4gICAgI2xvZ2dlcjtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jcHJvcGVydGllcyA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoYW5uZWwgcHJveHkgaW4gdGhlIGdpdmVuIHJlYWxtLCBpbml0aWFsaXNlcyBsaXN0ZW5lciBhbmRcbiAgICAgKiByZXR1cm5zIGEgaGFuZGxlIHRvIGBzZW5kTWVzc2FnZWAgZGVsZWdhdGUuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdChyZWFsbSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxIYW5kbGUgPSBhd2FpdCBDaGFubmVsUHJveHkuI2NyZWF0ZUFuZEdldEhhbmRsZUluUmVhbG0ocmVhbG0pO1xuICAgICAgICBjb25zdCBzZW5kTWVzc2FnZUhhbmRsZSA9IGF3YWl0IENoYW5uZWxQcm94eS4jY3JlYXRlU2VuZE1lc3NhZ2VIYW5kbGUocmVhbG0sIGNoYW5uZWxIYW5kbGUpO1xuICAgICAgICB2b2lkIHRoaXMuI3N0YXJ0TGlzdGVuZXIocmVhbG0sIGNoYW5uZWxIYW5kbGUsIGV2ZW50TWFuYWdlcik7XG4gICAgICAgIHJldHVybiBzZW5kTWVzc2FnZUhhbmRsZTtcbiAgICB9XG4gICAgLyoqIEdldHMgYSBDaGFubmVsUHJveHkgZnJvbSB3aW5kb3cgYW5kIHJldHVybnMgaXRzIGhhbmRsZS4gKi9cbiAgICBhc3luYyBzdGFydExpc3RlbmVyRnJvbVdpbmRvdyhyZWFsbSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsSGFuZGxlID0gYXdhaXQgdGhpcy4jZ2V0SGFuZGxlRnJvbVdpbmRvdyhyZWFsbSk7XG4gICAgICAgICAgICB2b2lkIHRoaXMuI3N0YXJ0TGlzdGVuZXIocmVhbG0sIGNoYW5uZWxIYW5kbGUsIGV2ZW50TWFuYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0aW9uIHN0cmluZyB3aGljaCBjcmVhdGVzIGEgQ2hhbm5lbFByb3h5IG9iamVjdCBvbiB0aGUgY2xpZW50IHNpZGUuXG4gICAgICovXG4gICAgc3RhdGljICNjcmVhdGVDaGFubmVsUHJveHlFdmFsU3RyKCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0ciA9IFN0cmluZygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbGV0IHF1ZXVlTm9uRW1wdHlSZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBwcm9taXNlLCB3aGljaCBpcyByZXNvbHZlZCBhcyBzb29uIGFzIGEgbWVzc2FnZSBvY2N1cnNcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgcXVldWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYXN5bmMgZ2V0TWVzc2FnZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25NZXNzYWdlID0gcXVldWUubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTm9uRW1wdHlSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25NZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlcyB0aGUgcGVuZGluZyBwcm9taXNlIGlmIG5lZWRlZC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZU5vbkVtcHR5UmVzb2x2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTm9uRW1wdHlSZXNvbHZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVOb25FbXB0eVJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGAoJHtmdW5jdGlvblN0cn0pKClgO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIENoYW5uZWxQcm94eSBpbiB0aGUgZ2l2ZW4gcmVhbG0uICovXG4gICAgc3RhdGljIGFzeW5jICNjcmVhdGVBbmRHZXRIYW5kbGVJblJlYWxtKHJlYWxtKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNoYW5uZWxIYW5kbGVSZXN1bHQgPSBhd2FpdCByZWFsbS5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuZXZhbHVhdGUnLCB7XG4gICAgICAgICAgICBleHByZXNzaW9uOiB0aGlzLiNjcmVhdGVDaGFubmVsUHJveHlFdmFsU3RyKCksXG4gICAgICAgICAgICBjb250ZXh0SWQ6IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJpZE9ubHlcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5JZE9ubHkgKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNyZWF0ZUNoYW5uZWxIYW5kbGVSZXN1bHQuZXhjZXB0aW9uRGV0YWlscyB8fFxuICAgICAgICAgICAgY3JlYXRlQ2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGNoYW5uZWxgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKiBHZXRzIGEgaGFuZGxlIHRvIGBzZW5kTWVzc2FnZWAgZGVsZWdhdGUgZnJvbSB0aGUgQ2hhbm5lbFByb3h5IGhhbmRsZS4gKi9cbiAgICBzdGF0aWMgYXN5bmMgI2NyZWF0ZVNlbmRNZXNzYWdlSGFuZGxlKHJlYWxtLCBjaGFubmVsSGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHNlbmRNZXNzYWdlQXJnUmVzdWx0ID0gYXdhaXQgcmVhbG0uY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChjaGFubmVsSGFuZGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxIYW5kbGUuc2VuZE1lc3NhZ2U7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogW3sgb2JqZWN0SWQ6IGNoYW5uZWxIYW5kbGUgfV0sXG4gICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJpZE9ubHlcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5JZE9ubHkgKi8sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4Y2VwdGlvbkRldGFpbHMuXG4gICAgICAgIHJldHVybiBzZW5kTWVzc2FnZUFyZ1Jlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKiBTdGFydHMgbGlzdGVuaW5nIGZvciB0aGUgY2hhbm5lbCBldmVudHMgb2YgdGhlIHByb3ZpZGVkIENoYW5uZWxQcm94eS4gKi9cbiAgICBhc3luYyAjc3RhcnRMaXN0ZW5lcihyZWFsbSwgY2hhbm5lbEhhbmRsZSwgZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBJbmZpbml0ZUxvb3BKU1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCByZWFsbS5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuY2FsbEZ1bmN0aW9uT24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZyhhc3luYyAoY2hhbm5lbEhhbmRsZSkgPT4gYXdhaXQgY2hhbm5lbEhhbmRsZS5nZXRNZXNzYWdlKCkpLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RJZDogY2hhbm5lbEhhbmRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiByZWFsbS5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGg6IHRoaXMuI3Byb3BlcnRpZXMuc2VyaWFsaXphdGlvbk9wdGlvbnM/Lm1heE9iamVjdERlcHRoID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWVzc2FnZS5leGNlcHRpb25EZXRhaWxzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzaW5nQ29udGV4dCBvZiByZWFsbS5hc3NvY2lhdGVkQnJvd3NpbmdDb250ZXh0cykge1xuICAgICAgICAgICAgICAgICAgICBldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogdGhpcy4jcHJvcGVydGllcy5jaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlYWxtLmNkcFRvQmlkaVZhbHVlKG1lc3NhZ2UsIHRoaXMuI3Byb3BlcnRpZXMub3duZXJzaGlwID8/IFwibm9uZVwiIC8qIFNjcmlwdC5SZXN1bHRPd25lcnNoaXAuTm9uZSAqLyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZWFsbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBicm93c2luZ0NvbnRleHQuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVycm9yIGlzIHRocm93biwgdGhlbiB0aGUgY2hhbm5lbCBpcyBwZXJtYW5lbnRseSBicm9rZW4sIHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gZXhpdCB0aGUgbG9vcC5cbiAgICAgICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgaGFuZGxlIG9mIENoYW5uZWxQcm94eSBmcm9tIHdpbmRvdydzIHByb3BlcnR5IHdoaWNoIHdhcyBzZXQgdGhlcmVcbiAgICAgKiBieSBgZ2V0RXZhbEluV2luZG93U3RyYC4gSWYgd2luZG93IHByb3BlcnR5IGlzIG5vdCBzZXQgeWV0LCBzZXRzIGEgcHJvbWlzZVxuICAgICAqIHJlc29sdmVyIHRvIHRoZSB3aW5kb3cgcHJvcGVydHksIHNvIHRoYXQgYGdldEV2YWxJbldpbmRvd1N0cmAgY2FuIHJlc29sdmVcbiAgICAgKiB0aGUgcHJvbWlzZSBsYXRlciBvbiB3aXRoIHRoZSBjaGFubmVsLlxuICAgICAqIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgYGdldEV2YWxJbldpbmRvd1N0cmAgY2FuIGJlIGNhbGxlZCBiZWZvcmUgb3JcbiAgICAgKiBhZnRlciB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyAjZ2V0SGFuZGxlRnJvbVdpbmRvdyhyZWFsbSkge1xuICAgICAgICBjb25zdCBjaGFubmVsSGFuZGxlUmVzdWx0ID0gYXdhaXQgcmVhbG0uY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHcgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKHdbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGNoYW5uZWxQcm94eSBpcyBub3QgY3JlYXRlZCB5ZXQuIENyZWF0ZSBhIHByb21pc2UsIHB1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2ZXIgdG8gd2luZG93IHByb3BlcnR5IGFuZCByZXR1cm4gdGhlIHByb21pc2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIGBnZXRFdmFsSW5XaW5kb3dTdHJgIHdpbGwgcmVzb2x2ZSB0aGUgcHJvbWlzZSBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAod1tpZF0gPSByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBjaGFubmVsUHJveHkgaXMgYWxyZWFkeSBjcmVhdGVkIGJ5IGBnZXRFdmFsSW5XaW5kb3dTdHJgIGFuZFxuICAgICAgICAgICAgICAgIC8vIGlzIHNldCBpbnRvIHdpbmRvdyBwcm9wZXJ0eS4gUmV0dXJuIGl0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxQcm94eSA9IHdbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3W2lkXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbFByb3h5O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhcmd1bWVudHM6IFt7IHZhbHVlOiB0aGlzLiNpZCB9XSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogcmVhbG0uZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgYXdhaXRQcm9taXNlOiB0cnVlLFxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImlkT25seVwiIC8qIFByb3RvY29sLlJ1bnRpbWUuU2VyaWFsaXphdGlvbk9wdGlvbnNTZXJpYWxpemF0aW9uLklkT25seSAqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbm5lbEhhbmRsZVJlc3VsdC5leGNlcHRpb25EZXRhaWxzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGNoYW5uZWxIYW5kbGVSZXN1bHQucmVzdWx0Lm9iamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hhbm5lbEhhbmRsZSBub3QgZm91bmQgaW4gd2luZG93W1wiJHt0aGlzLiNpZH1cIl1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbEhhbmRsZVJlc3VsdC5yZXN1bHQub2JqZWN0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyB0byBiZSBldmFsdWF0ZWQgdG8gY3JlYXRlIGEgUHJveHlDaGFubmVsIGFuZCBwdXQgaXQgdG8gd2luZG93LlxuICAgICAqIFJldHVybnMgdGhlIGRlbGVnYXRlIGBzZW5kTWVzc2FnZWAuIFVzZWQgdG8gcHJvdmlkZSBhbiBhcmd1bWVudCBmb3IgcHJlbG9hZFxuICAgICAqIHNjcmlwdC4gRG9lcyB0aGUgZm9sbG93aW5nOlxuICAgICAqIDEuIENyZWF0ZXMgYSBDaGFubmVsUHJveHkuXG4gICAgICogMi4gUHV0cyB0aGUgQ2hhbm5lbFByb3h5IHRvIHdpbmRvd1snJHt0aGlzLiNpZH0nXSBvciByZXNvbHZlcyB0aGUgcHJvbWlzZVxuICAgICAqICAgIGJ5IGNhbGxpbmcgZGVsZWdhdGUgc3RvcmVkIGluIHdpbmRvd1snJHt0aGlzLiNpZH0nXS5cbiAgICAgKiAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAjZ2V0SGFuZGxlRnJvbVdpbmRvd2AgY2FuIGJlIGNhbGxlZCBiZWZvcmUgb3JcbiAgICAgKiAgICBhZnRlciB0aGlzIG1ldGhvZC5cbiAgICAgKiAzLiBSZXR1cm5zIHRoZSBkZWxlZ2F0ZSBgc2VuZE1lc3NhZ2VgIG9mIHRoZSBjcmVhdGVkIENoYW5uZWxQcm94eS5cbiAgICAgKi9cbiAgICBnZXRFdmFsSW5XaW5kb3dTdHIoKSB7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gU3RyaW5nKChpZCwgY2hhbm5lbFByb3h5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gd2luZG93O1xuICAgICAgICAgICAgaWYgKHdbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBgI2dldEhhbmRsZUZyb21XaW5kb3dgIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQsIGFuZCB3aWxsIGdldCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFubmVsUHJveHkgbGF0ZXIuXG4gICAgICAgICAgICAgICAgd1tpZF0gPSBjaGFubmVsUHJveHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBgI2dldEhhbmRsZUZyb21XaW5kb3dgIGlzIGFscmVhZHkgc2V0IGEgZGVsZWdhdGUgdG8gd2luZG93IHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHdhaXRpbmcgZm9yIGl0IHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjaGFubmVsUHJveHkuXG4gICAgICAgICAgICAgICAgd1tpZF0oY2hhbm5lbFByb3h5KTtcbiAgICAgICAgICAgICAgICBkZWxldGUgd1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbFByb3h5LnNlbmRNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFByb3h5RXZhbCA9IENoYW5uZWxQcm94eS4jY3JlYXRlQ2hhbm5lbFByb3h5RXZhbFN0cigpO1xuICAgICAgICByZXR1cm4gYCgke2RlbGVnYXRlfSkoJyR7dGhpcy4jaWR9Jywke2NoYW5uZWxQcm94eUV2YWx9KWA7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsUHJveHkgPSBDaGFubmVsUHJveHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaGFubmVsUHJveHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlbG9hZFNjcmlwdCA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91dWlkLmpzXCIpO1xuY29uc3QgQ2hhbm5lbFByb3h5X2pzXzEgPSByZXF1aXJlKFwiLi9DaGFubmVsUHJveHkuanNcIik7XG4vKipcbiAqIEJpRGkgSURzIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBhbmQgYXJlIHVuaXF1ZSB3aXRoaW4gY29udGV4dHMuXG4gKlxuICogQ0RQIHByZWxvYWQgc2NyaXB0IElEcyBhcmUgZ2VuZXJhdGVkIGJ5IHRoZSBjbGllbnQgYW5kIGFyZSB1bmlxdWVcbiAqIHdpdGhpbiBzZXNzaW9ucy5cbiAqXG4gKiBUaGUgbWFwcGluZyBiZXR3ZWVuIEJpRGkgYW5kIENEUCBwcmVsb2FkIHNjcmlwdCBJRHMgaXMgMTptYW55LlxuICogQmlEaSBJRHMgYXJlIG5lZWRlZCBieSB0aGUgbWFwcGVyIHRvIGtlZXAgdHJhY2sgb2YgcG90ZW50aWFsIG11bHRpcGxlIENEUCBJRHNcbiAqIGluIHRoZSBjbGllbnQuXG4gKi9cbmNsYXNzIFByZWxvYWRTY3JpcHQge1xuICAgIC8qKiBCaURpIElELCBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBVVUlELiAqL1xuICAgICNpZCA9ICgwLCB1dWlkX2pzXzEudXVpZHY0KSgpO1xuICAgIC8qKiBDRFAgcHJlbG9hZCBzY3JpcHRzLiAqL1xuICAgICNjZHBQcmVsb2FkU2NyaXB0cyA9IFtdO1xuICAgIC8qKiBUaGUgc2NyaXB0IGl0c2VsZiwgaW4gYSBmb3JtYXQgZXhwZWN0ZWQgYnkgdGhlIHNwZWMgaS5lLiBhIGZ1bmN0aW9uLiAqL1xuICAgICNmdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgIC8qKiBUYXJnZXRzLCBpbiB3aGljaCB0aGUgcHJlbG9hZCBzY3JpcHQgaXMgaW5pdGlhbGl6ZWQuICovXG4gICAgI3RhcmdldElkcyA9IG5ldyBTZXQoKTtcbiAgICAvKiogQ2hhbm5lbHMgdG8gYmUgYWRkZWQgYXMgYXJndW1lbnRzIHRvIGZ1bmN0aW9uRGVjbGFyYXRpb24uICovXG4gICAgI2NoYW5uZWxzO1xuICAgIC8qKiBUaGUgc2NyaXB0IHNhbmRib3ggLyB3b3JsZCBuYW1lLiAqL1xuICAgICNzYW5kYm94O1xuICAgIC8qKiBUaGUgYnJvd3NpbmcgY29udGV4dHMgdG8gZXhlY3V0ZSB0aGUgcHJlbG9hZCBzY3JpcHRzIGluLCBpZiBhbnkuICovXG4gICAgI2NvbnRleHRzO1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0SWRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdGFyZ2V0SWRzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNjaGFubmVscyA9XG4gICAgICAgICAgICBwYXJhbXMuYXJndW1lbnRzPy5tYXAoKGEpID0+IG5ldyBDaGFubmVsUHJveHlfanNfMS5DaGFubmVsUHJveHkoYS52YWx1ZSwgbG9nZ2VyKSkgPz8gW107XG4gICAgICAgIHRoaXMuI2Z1bmN0aW9uRGVjbGFyYXRpb24gPSBwYXJhbXMuZnVuY3Rpb25EZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy4jc2FuZGJveCA9IHBhcmFtcy5zYW5kYm94O1xuICAgICAgICB0aGlzLiNjb250ZXh0cyA9IHBhcmFtcy5jb250ZXh0cztcbiAgICB9XG4gICAgLyoqIENoYW5uZWxzIG9mIHRoZSBwcmVsb2FkIHNjcmlwdC4gKi9cbiAgICBnZXQgY2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGFubmVscztcbiAgICB9XG4gICAgLyoqIENvbnRleHRzIG9mIHRoZSBwcmVsb2FkIHNjcmlwdCwgaWYgYW55ICovXG4gICAgZ2V0IGNvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29udGV4dHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyB0byBiZSBldmFsdWF0ZWQuIFdyYXBzIHVzZXItcHJvdmlkZWQgZnVuY3Rpb24gc28gdGhhdCB0aGUgZm9sbG93aW5nXG4gICAgICogc3RlcHMgYXJlIHJ1bjpcbiAgICAgKiAxLiBDcmVhdGUgY2hhbm5lbHMuXG4gICAgICogMi4gU3RvcmUgdGhlIGNyZWF0ZWQgY2hhbm5lbHMgaW4gd2luZG93LlxuICAgICAqIDMuIENhbGwgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBjaGFubmVscyBhcyBhcmd1bWVudHMuXG4gICAgICovXG4gICAgI2dldEV2YWx1YXRlU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBjaGFubmVsc0FyZ1N0ciA9IGBbJHt0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAubWFwKChjKSA9PiBjLmdldEV2YWxJbldpbmRvd1N0cigpKVxuICAgICAgICAgICAgLmpvaW4oJywgJyl9XWA7XG4gICAgICAgIHJldHVybiBgKCgpPT57KCR7dGhpcy4jZnVuY3Rpb25EZWNsYXJhdGlvbn0pKC4uLiR7Y2hhbm5lbHNBcmdTdHJ9KX0pKClgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzY3JpcHQgdG8gdGhlIGdpdmVuIENEUCB0YXJnZXRzIGJ5IGNhbGxpbmcgdGhlXG4gICAgICogYFBhZ2UuYWRkU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnRgIGNvbW1hbmQuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdEluVGFyZ2V0cyhjZHBUYXJnZXRzLCBydW5JbW1lZGlhdGVseSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChBcnJheS5mcm9tKGNkcFRhcmdldHMpLm1hcCgoY2RwVGFyZ2V0KSA9PiB0aGlzLmluaXRJblRhcmdldChjZHBUYXJnZXQsIHJ1bkltbWVkaWF0ZWx5KSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBzY3JpcHQgdG8gdGhlIGdpdmVuIENEUCB0YXJnZXQgYnkgY2FsbGluZyB0aGVcbiAgICAgKiBgUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudGAgY29tbWFuZC5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0SW5UYXJnZXQoY2RwVGFyZ2V0LCBydW5JbW1lZGlhdGVseSkge1xuICAgICAgICBjb25zdCBhZGRDZHBQcmVsb2FkU2NyaXB0UmVzdWx0ID0gYXdhaXQgY2RwVGFyZ2V0LmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUGFnZS5hZGRTY3JpcHRUb0V2YWx1YXRlT25OZXdEb2N1bWVudCcsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy4jZ2V0RXZhbHVhdGVTdHJpbmcoKSxcbiAgICAgICAgICAgIHdvcmxkTmFtZTogdGhpcy4jc2FuZGJveCxcbiAgICAgICAgICAgIHJ1bkltbWVkaWF0ZWx5LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGNkcFRhcmdldCxcbiAgICAgICAgICAgIHByZWxvYWRTY3JpcHRJZDogYWRkQ2RwUHJlbG9hZFNjcmlwdFJlc3VsdC5pZGVudGlmaWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jdGFyZ2V0SWRzLmFkZChjZHBUYXJnZXQuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoaXMgc2NyaXB0IGZyb20gYWxsIENEUCB0YXJnZXRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZSgpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMubWFwKGFzeW5jIChjZHBQcmVsb2FkU2NyaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwVGFyZ2V0ID0gY2RwUHJlbG9hZFNjcmlwdC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwUHJlbG9hZFNjcmlwdElkID0gY2RwUHJlbG9hZFNjcmlwdC5wcmVsb2FkU2NyaXB0SWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNkcFRhcmdldC5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1BhZ2UucmVtb3ZlU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGNkcFByZWxvYWRTY3JpcHRJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIGNkcCB0YXJnZXQgZnJvbSB0aGUgbGlzdCBvZiBjZHAgcHJlbG9hZCBzY3JpcHRzLiAqL1xuICAgIGRpc3Bvc2UoY2RwVGFyZ2V0SWQpIHtcbiAgICAgICAgdGhpcy4jY2RwUHJlbG9hZFNjcmlwdHMgPSB0aGlzLiNjZHBQcmVsb2FkU2NyaXB0cy5maWx0ZXIoKGNkcFByZWxvYWRTY3JpcHQpID0+IGNkcFByZWxvYWRTY3JpcHQudGFyZ2V0Py5pZCAhPT0gY2RwVGFyZ2V0SWQpO1xuICAgICAgICB0aGlzLiN0YXJnZXRJZHMuZGVsZXRlKGNkcFRhcmdldElkKTtcbiAgICB9XG59XG5leHBvcnRzLlByZWxvYWRTY3JpcHQgPSBQcmVsb2FkU2NyaXB0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlbG9hZFNjcmlwdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSB2b2lkIDA7XG4vKipcbiAqIENvbnRhaW5lciBjbGFzcyBmb3IgcHJlbG9hZCBzY3JpcHRzLlxuICovXG5jbGFzcyBQcmVsb2FkU2NyaXB0U3RvcmFnZSB7XG4gICAgLyoqIFRyYWNrcyBhbGwgQmlEaSBwcmVsb2FkIHNjcmlwdHMuICAqL1xuICAgICNzY3JpcHRzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBlbnRyaWVzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIGZpbHRlciAoT1IgbG9naWMpLlxuICAgICAqL1xuICAgIGZpbmQoZmlsdGVyKSB7XG4gICAgICAgIGlmICghZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuI3NjcmlwdHNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4udGhpcy4jc2NyaXB0c10uZmlsdGVyKChzY3JpcHQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuaWQgIT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIuaWQgPT09IHNjcmlwdC5pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci50YXJnZXRJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2NyaXB0LnRhcmdldElkcy5oYXMoZmlsdGVyLnRhcmdldElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci5nbG9iYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIC8vIEdsb2JhbCBzY3JpcHRzIGhhdmUgbm8gY29udGV4dHNcbiAgICAgICAgICAgICAgICAoKGZpbHRlci5nbG9iYWwgJiYgc2NyaXB0LmNvbnRleHRzID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vbiBnbG9iYWwgc2NyaXB0cyBhbHdheXMgaGF2ZSBjb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAoIWZpbHRlci5nbG9iYWwgJiYgc2NyaXB0LmNvbnRleHRzICE9PSB1bmRlZmluZWQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkKHByZWxvYWRTY3JpcHQpIHtcbiAgICAgICAgdGhpcy4jc2NyaXB0cy5hZGQocHJlbG9hZFNjcmlwdCk7XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFsbCBCaURpIHByZWxvYWQgc2NyaXB0IGVudHJpZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIHJlbW92ZShmaWx0ZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcmVsb2FkU2NyaXB0IG9mIHRoaXMuZmluZChmaWx0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLiNzY3JpcHRzLmRlbGV0ZShwcmVsb2FkU2NyaXB0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSBQcmVsb2FkU2NyaXB0U3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByZWxvYWRTY3JpcHRTdG9yYWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWFsbSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBsb2dfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9sb2cuanNcIik7XG5jb25zdCB1dWlkX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXVpZC5qc1wiKTtcbmNvbnN0IENoYW5uZWxQcm94eV9qc18xID0gcmVxdWlyZShcIi4vQ2hhbm5lbFByb3h5LmpzXCIpO1xuY2xhc3MgUmVhbG0ge1xuICAgICNjZHBDbGllbnQ7XG4gICAgI2V2ZW50TWFuYWdlcjtcbiAgICAjZXhlY3V0aW9uQ29udGV4dElkO1xuICAgICNsb2dnZXI7XG4gICAgI29yaWdpbjtcbiAgICAjcmVhbG1JZDtcbiAgICAjcmVhbG1TdG9yYWdlO1xuICAgIGNvbnN0cnVjdG9yKGNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBleGVjdXRpb25Db250ZXh0SWQsIGxvZ2dlciwgb3JpZ2luLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy4jY2RwQ2xpZW50ID0gY2RwQ2xpZW50O1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI2V4ZWN1dGlvbkNvbnRleHRJZCA9IGV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLiNvcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMuI3JlYWxtSWQgPSByZWFsbUlkO1xuICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2UgPSByZWFsbVN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZS5hZGRSZWFsbSh0aGlzKTtcbiAgICB9XG4gICAgY2RwVG9CaWRpVmFsdWUoY2RwVmFsdWUsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICBjb25zdCBiaWRpVmFsdWUgPSB0aGlzLnNlcmlhbGl6ZUZvckJpRGkoY2RwVmFsdWUucmVzdWx0LmRlZXBTZXJpYWxpemVkVmFsdWUsIG5ldyBNYXAoKSk7XG4gICAgICAgIGlmIChjZHBWYWx1ZS5yZXN1bHQub2JqZWN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdElkID0gY2RwVmFsdWUucmVzdWx0Lm9iamVjdElkO1xuICAgICAgICAgICAgaWYgKHJlc3VsdE93bmVyc2hpcCA9PT0gXCJyb290XCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Sb290ICovKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIEJpRGkgdmFsdWUgd2l0aCBgaGFuZGxlYCBiYXNlZCBvbiByZXF1aXJlZCBgcmVzdWx0T3duZXJzaGlwYFxuICAgICAgICAgICAgICAgIC8vIGFuZCAgQ0RQIHJlc3BvbnNlIGJ1dCBub3Qgb24gdGhlIGFjdHVhbCBCaURpIHR5cGUuXG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlLmhhbmRsZSA9IG9iamVjdElkO1xuICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIGFsbCB0aGUgaGFuZGxlcyBzZW50IHRvIGNsaWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFsbVN0b3JhZ2Uua25vd25IYW5kbGVzVG9SZWFsbU1hcC5zZXQob2JqZWN0SWQsIHRoaXMucmVhbG1JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGF3YWl0IGZvciB0aGUgb2JqZWN0IHRvIGJlIHJlbGVhc2VkLlxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy4jcmVsZWFzZU9iamVjdChvYmplY3RJZCkuY2F0Y2goKGVycm9yKSA9PiB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnRXJyb3IsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpZGlWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsaWVzIG9uIHRoZSBDRFAgdG8gaW1wbGVtZW50IHByb3BlciBCaURpIHNlcmlhbGl6YXRpb24sIGV4Y2VwdDpcbiAgICAgKiAqIENEUCBpbnRlZ2VyIHByb3BlcnR5IGBiYWNrZW5kTm9kZUlkYCBpcyByZXBsYWNlZCB3aXRoIGBzaGFyZWRJZGAgb2ZcbiAgICAgKiBge2RvY3VtZW50SWR9X2VsZW1lbnRfe2JhY2tlbmROb2RlSWR9YDtcbiAgICAgKiAqIENEUCBpbnRlZ2VyIHByb3BlcnR5IGB3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2VgIGlzIHJlcGxhY2VkIHdpdGggVVVJRCBgaW50ZXJuYWxJZGBcbiAgICAgKiB1c2luZyB1bmlxdWUtcGVyIHNlcmlhbGl6YXRpb24gYGludGVybmFsSWRNYXBgLlxuICAgICAqICogQ0RQIHR5cGUgYHBsYXRmb3Jtb2JqZWN0YCBpcyByZXBsYWNlZCB3aXRoIGBvYmplY3RgLlxuICAgICAqIEBwYXJhbSBkZWVwU2VyaWFsaXplZFZhbHVlIC0gQ0RQIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCB0byBCaURpLlxuICAgICAqIEBwYXJhbSBpbnRlcm5hbElkTWFwIC0gTWFwIGZyb20gQ0RQIGludGVnZXIgYHdlYWtMb2NhbE9iamVjdFJlZmVyZW5jZWAgdG8gQmlEaSBVVUlEXG4gICAgICogYGludGVybmFsSWRgLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZUZvckJpRGkoZGVlcFNlcmlhbGl6ZWRWYWx1ZSwgaW50ZXJuYWxJZE1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihkZWVwU2VyaWFsaXplZFZhbHVlLCAnd2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHdlYWtMb2NhbE9iamVjdFJlZmVyZW5jZSA9IGRlZXBTZXJpYWxpemVkVmFsdWUud2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlO1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbElkTWFwLmhhcyh3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxJZE1hcC5zZXQod2Vha0xvY2FsT2JqZWN0UmVmZXJlbmNlLCAoMCwgdXVpZF9qc18xLnV1aWR2NCkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWVwU2VyaWFsaXplZFZhbHVlLmludGVybmFsSWQgPSBpbnRlcm5hbElkTWFwLmdldCh3ZWFrTG9jYWxPYmplY3RSZWZlcmVuY2UpO1xuICAgICAgICAgICAgZGVsZXRlIGRlZXBTZXJpYWxpemVkVmFsdWVbJ3dlYWtMb2NhbE9iamVjdFJlZmVyZW5jZSddO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYXRmb3JtIG9iamVjdCBpcyBhIHNwZWNpYWwgY2FzZS4gSXQgc2hvdWxkIGhhdmUgb25seSBge3R5cGU6IG9iamVjdH1gXG4gICAgICAgIC8vIHdpdGhvdXQgYHZhbHVlYCBmaWVsZC5cbiAgICAgICAgaWYgKGRlZXBTZXJpYWxpemVkVmFsdWUudHlwZSA9PT0gJ3BsYXRmb3Jtb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29iamVjdCcgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaWRpVmFsdWUgPSBkZWVwU2VyaWFsaXplZFZhbHVlLnZhbHVlO1xuICAgICAgICBpZiAoYmlkaVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWVwU2VyaWFsaXplZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHVwZGF0ZSB0aGUgbmVzdGVkIHZhbHVlcy5cbiAgICAgICAgaWYgKFsnYXJyYXknLCAnc2V0JywgJ2h0bWxjb2xsZWN0aW9uJywgJ25vZGVsaXN0J10uaW5jbHVkZXMoZGVlcFNlcmlhbGl6ZWRWYWx1ZS50eXBlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGJpZGlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJpZGlWYWx1ZVtpXSA9IHRoaXMuc2VyaWFsaXplRm9yQmlEaShiaWRpVmFsdWVbaV0sIGludGVybmFsSWRNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChbJ29iamVjdCcsICdtYXAnXS5pbmNsdWRlcyhkZWVwU2VyaWFsaXplZFZhbHVlLnR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gYmlkaVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlW2ldID0gW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZvckJpRGkoYmlkaVZhbHVlW2ldWzBdLCBpbnRlcm5hbElkTWFwKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGb3JCaURpKGJpZGlWYWx1ZVtpXVsxXSwgaW50ZXJuYWxJZE1hcCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVlcFNlcmlhbGl6ZWRWYWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJlYWxtSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWFsbUlkO1xuICAgIH1cbiAgICBnZXQgZXhlY3V0aW9uQ29udGV4dElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXhlY3V0aW9uQ29udGV4dElkO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3JpZ2luO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IGNkcENsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NkcENsaWVudDtcbiAgICB9XG4gICAgZ2V0IGJhc2VJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGV2YWx1YXRlKGV4cHJlc3Npb24sIGF3YWl0UHJvbWlzZSwgcmVzdWx0T3duZXJzaGlwID0gXCJub25lXCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Ob25lICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHt9LCB1c2VyQWN0aXZhdGlvbiA9IGZhbHNlLCBpbmNsdWRlQ29tbWFuZExpbmVBcGkgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjZHBFdmFsdWF0ZVJlc3VsdCA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmV2YWx1YXRlJywge1xuICAgICAgICAgICAgY29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgICAgICBhd2FpdFByb21pc2UsXG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9uczogUmVhbG0uI2dldFNlcmlhbGl6YXRpb25PcHRpb25zKFwiZGVlcFwiIC8qIFByb3RvY29sLlJ1bnRpbWUuU2VyaWFsaXphdGlvbk9wdGlvbnNTZXJpYWxpemF0aW9uLkRlZXAgKi8sIHNlcmlhbGl6YXRpb25PcHRpb25zKSxcbiAgICAgICAgICAgIHVzZXJHZXN0dXJlOiB1c2VyQWN0aXZhdGlvbixcbiAgICAgICAgICAgIGluY2x1ZGVDb21tYW5kTGluZUFQSTogaW5jbHVkZUNvbW1hbmRMaW5lQXBpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNkcEV2YWx1YXRlUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNnZXRFeGNlcHRpb25SZXN1bHQoY2RwRXZhbHVhdGVSZXN1bHQuZXhjZXB0aW9uRGV0YWlscywgMCwgcmVzdWx0T3duZXJzaGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBFdmFsdWF0ZVJlc3VsdCwgcmVzdWx0T3duZXJzaGlwKSxcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgI3JlZ2lzdGVyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNzb2NpYXRlZEJyb3dzaW5nQ29udGV4dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIucmVnaXN0ZXJFdmVudChldmVudCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJyb3dzaW5nQ29udGV4dCBvZiB0aGlzLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZXZlbnRNYW5hZ2VyLnJlZ2lzdGVyRXZlbnQoZXZlbnQsIGJyb3dzaW5nQ29udGV4dC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy4jcmVnaXN0ZXJFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnZXZlbnQnLFxuICAgICAgICAgICAgbWV0aG9kOiBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5SZWFsbUNyZWF0ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMucmVhbG1JbmZvLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIGdpdmVuIENEUCBvYmplY3QgaW50byBCaURpLCBrZWVwaW5nIHJlZmVyZW5jZXMgaW4gdGhlXG4gICAgICogdGFyZ2V0J3MgYGdsb2JhbFRoaXNgLlxuICAgICAqL1xuICAgIGFzeW5jIHNlcmlhbGl6ZUNkcE9iamVjdChjZHBSZW1vdGVPYmplY3QsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICBjb25zdCBhcmd1bWVudCA9IFJlYWxtLiNjZHBSZW1vdGVPYmplY3RUb0NhbGxBcmd1bWVudChjZHBSZW1vdGVPYmplY3QpO1xuICAgICAgICBjb25zdCBjZHBWYWx1ZSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChyZW1vdGVPYmplY3QpID0+IHJlbW90ZU9iamVjdCksXG4gICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgYXJndW1lbnRzOiBbYXJndW1lbnRdLFxuICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uOiBcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBWYWx1ZSwgcmVzdWx0T3duZXJzaGlwKTtcbiAgICB9XG4gICAgc3RhdGljICNjZHBSZW1vdGVPYmplY3RUb0NhbGxBcmd1bWVudChjZHBSZW1vdGVPYmplY3QpIHtcbiAgICAgICAgaWYgKGNkcFJlbW90ZU9iamVjdC5vYmplY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogY2RwUmVtb3RlT2JqZWN0Lm9iamVjdElkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNkcFJlbW90ZU9iamVjdC51bnNlcmlhbGl6YWJsZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6IGNkcFJlbW90ZU9iamVjdC51bnNlcmlhbGl6YWJsZVZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNkcFJlbW90ZU9iamVjdC52YWx1ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBjYWxsaW5nIGB0b1N0cmluZygpYCBvbiB0aGUgb2JqZWN0IHZhbHVlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0cmluZ2lmeU9iamVjdChjZHBSZW1vdGVPYmplY3QpIHtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKChyZW1vdGVPYmplY3QpID0+IFN0cmluZyhyZW1vdGVPYmplY3QpKSxcbiAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogZmFsc2UsXG4gICAgICAgICAgICBhcmd1bWVudHM6IFtjZHBSZW1vdGVPYmplY3RdLFxuICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICBhc3luYyAjZmxhdHRlbktleVZhbHVlUGFpcnMobWFwcGluZ0xvY2FsVmFsdWUpIHtcbiAgICAgICAgY29uc3Qga2V5VmFsdWVBcnJheSA9IGF3YWl0IFByb21pc2UuYWxsKG1hcHBpbmdMb2NhbFZhbHVlLm1hcChhc3luYyAoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBsZXQga2V5QXJnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGlzIGEgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGtleUFyZyA9IHsgdmFsdWU6IGtleSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IGlzIGEgc2VyaWFsaXplZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBrZXlBcmcgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplRm9yQ2RwKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFyZyA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlBcmcsIHZhbHVlQXJnXTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ga2V5VmFsdWVBcnJheS5mbGF0KCk7XG4gICAgfVxuICAgIGFzeW5jICNmbGF0dGVuVmFsdWVMaXN0KGxpc3RMb2NhbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChsaXN0TG9jYWxWYWx1ZS5tYXAoKGxvY2FsVmFsdWUpID0+IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAobG9jYWxWYWx1ZSkpKTtcbiAgICB9XG4gICAgYXN5bmMgI3NlcmlhbGl6ZUNkcEV4Y2VwdGlvbkRldGFpbHMoY2RwRXhjZXB0aW9uRGV0YWlscywgbGluZU9mZnNldCwgcmVzdWx0T3duZXJzaGlwKSB7XG4gICAgICAgIGNvbnN0IGNhbGxGcmFtZXMgPSBjZHBFeGNlcHRpb25EZXRhaWxzLnN0YWNrVHJhY2U/LmNhbGxGcmFtZXMubWFwKChmcmFtZSkgPT4gKHtcbiAgICAgICAgICAgIHVybDogZnJhbWUudXJsLFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmcmFtZS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBmcmFtZS5saW5lTnVtYmVyIC0gbGluZU9mZnNldCxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogZnJhbWUuY29sdW1uTnVtYmVyLFxuICAgICAgICB9KSkgPz8gW107XG4gICAgICAgIC8vIEV4Y2VwdGlvbiBzaG91bGQgYWx3YXlzIGJlIHRoZXJlLlxuICAgICAgICBjb25zdCBleGNlcHRpb24gPSBjZHBFeGNlcHRpb25EZXRhaWxzLmV4Y2VwdGlvbjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogYXdhaXQgdGhpcy5zZXJpYWxpemVDZHBPYmplY3QoZXhjZXB0aW9uLCByZXN1bHRPd25lcnNoaXApLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjZHBFeGNlcHRpb25EZXRhaWxzLmNvbHVtbk51bWJlcixcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGNkcEV4Y2VwdGlvbkRldGFpbHMubGluZU51bWJlciAtIGxpbmVPZmZzZXQsXG4gICAgICAgICAgICBzdGFja1RyYWNlOiB7XG4gICAgICAgICAgICAgICAgY2FsbEZyYW1lcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZXh0OiAoYXdhaXQgdGhpcy5zdHJpbmdpZnlPYmplY3QoZXhjZXB0aW9uKSkgfHwgY2RwRXhjZXB0aW9uRGV0YWlscy50ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBjYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgYXdhaXRQcm9taXNlLCB0aGlzTG9jYWxWYWx1ZSA9IHtcbiAgICAgICAgdHlwZTogJ3VuZGVmaW5lZCcsXG4gICAgfSwgYXJndW1lbnRzTG9jYWxWYWx1ZXMgPSBbXSwgcmVzdWx0T3duZXJzaGlwID0gXCJub25lXCIgLyogU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Ob25lICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHt9LCB1c2VyQWN0aXZhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGNhbGxGdW5jdGlvbkFuZFNlcmlhbGl6ZVNjcmlwdCA9IGAoLi4uYXJncykgPT4ge1xuICAgICAgZnVuY3Rpb24gY2FsbEZ1bmN0aW9uKGYsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkVGhpcyA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkQXJncyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KGRlc2VyaWFsaXplZFRoaXMsIGRlc2VyaWFsaXplZEFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGxGdW5jdGlvbigoXG4gICAgICAgICR7ZnVuY3Rpb25EZWNsYXJhdGlvbn1cbiAgICAgICksIGFyZ3MpO1xuICAgIH1gO1xuICAgICAgICBjb25zdCB0aGlzQW5kQXJndW1lbnRzTGlzdCA9IFtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGVzZXJpYWxpemVGb3JDZHAodGhpc0xvY2FsVmFsdWUpLFxuICAgICAgICAgICAgLi4uKGF3YWl0IFByb21pc2UuYWxsKGFyZ3VtZW50c0xvY2FsVmFsdWVzLm1hcChhc3luYyAoYXJndW1lbnRMb2NhbFZhbHVlKSA9PiBhd2FpdCB0aGlzLmRlc2VyaWFsaXplRm9yQ2RwKGFyZ3VtZW50TG9jYWxWYWx1ZSkpKSksXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjZHBDYWxsRnVuY3Rpb25SZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjZHBDYWxsRnVuY3Rpb25SZXN1bHQgPSBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUnVudGltZS5jYWxsRnVuY3Rpb25PbicsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBjYWxsRnVuY3Rpb25BbmRTZXJpYWxpemVTY3JpcHQsXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogdGhpc0FuZEFyZ3VtZW50c0xpc3QsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnM6IFJlYWxtLiNnZXRTZXJpYWxpemF0aW9uT3B0aW9ucyhcImRlZXBcIiAvKiBQcm90b2NvbC5SdW50aW1lLlNlcmlhbGl6YXRpb25PcHRpb25zU2VyaWFsaXphdGlvbi5EZWVwICovLCBzZXJpYWxpemF0aW9uT3B0aW9ucyksXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgICAgICB1c2VyR2VzdHVyZTogdXNlckFjdGl2YXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlcm1pbmUgaWYgdGhlIHByb2JsZW0gaXMgaW4gdGhlIGFyZ3VtZW50LlxuICAgICAgICAgICAgLy8gVGhlIGNoZWNrIGNhbiBiZSBkb25lIG9uIHRoZSBgZGVzZXJpYWxpemF0aW9uYCBzdGVwLCBidXQgdGhpcyBhcHByb2FjaFxuICAgICAgICAgICAgLy8gaGVscHMgdG8gc2F2ZSByb3VuZC10cmlwcy5cbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAtMzIwMDAgLyogQ2RwRXJyb3JDb25zdGFudHMuR0VORVJJQ19FUlJPUiAqLyAmJlxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIG9iamVjdCB3aXRoIGdpdmVuIGlkJyxcbiAgICAgICAgICAgICAgICAgICAgJ0FyZ3VtZW50IHNob3VsZCBiZWxvbmcgdG8gdGhlIHNhbWUgSmF2YVNjcmlwdCB3b3JsZCBhcyB0YXJnZXQgb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgcmVtb3RlIG9iamVjdCBpZCcsXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaEhhbmRsZUV4Y2VwdGlvbignSGFuZGxlIHdhcyBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2RwQ2FsbEZ1bmN0aW9uUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNnZXRFeGNlcHRpb25SZXN1bHQoY2RwQ2FsbEZ1bmN0aW9uUmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMsIDEsIHJlc3VsdE93bmVyc2hpcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHJlc3VsdDogdGhpcy5jZHBUb0JpZGlWYWx1ZShjZHBDYWxsRnVuY3Rpb25SZXN1bHQsIHJlc3VsdE93bmVyc2hpcCksXG4gICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbUlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZUZvckNkcChsb2NhbFZhbHVlKSB7XG4gICAgICAgIGlmICgnaGFuZGxlJyBpbiBsb2NhbFZhbHVlICYmIGxvY2FsVmFsdWUuaGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogbG9jYWxWYWx1ZS5oYW5kbGUgfTtcbiAgICAgICAgICAgIC8vIFdlIHRyaWVkIHRvIGZpbmQgYSBoYW5kbGUgdmFsdWUgYnV0IGZhaWxlZFxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBleGhhdXN0aXZlIHN3aXRjaCBvbiBgbG9jYWxWYWx1ZS50eXBlYFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdoYW5kbGUnIGluIGxvY2FsVmFsdWUgfHwgJ3NoYXJlZElkJyBpbiBsb2NhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5Ob1N1Y2hIYW5kbGVFeGNlcHRpb24oJ0hhbmRsZSB3YXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobG9jYWxWYWx1ZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICd1bmRlZmluZWQnIH07XG4gICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1bnNlcmlhbGl6YWJsZVZhbHVlOiAnbnVsbCcgfTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGxvY2FsVmFsdWUudmFsdWUgfTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsVmFsdWUudmFsdWUgPT09ICdOYU4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICdOYU4nIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvY2FsVmFsdWUudmFsdWUgPT09ICctMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJy0wJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2NhbFZhbHVlLnZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHVuc2VyaWFsaXphYmxlVmFsdWU6ICdJbmZpbml0eScgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxWYWx1ZS52YWx1ZSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdW5zZXJpYWxpemFibGVWYWx1ZTogJy1JbmZpbml0eScgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxvY2FsVmFsdWUudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBCb29sZWFuKGxvY2FsVmFsdWUudmFsdWUpIH07XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHVuc2VyaWFsaXphYmxlVmFsdWU6IGBCaWdJbnQoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlKX0pYCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGVWYWx1ZTogYG5ldyBEYXRlKERhdGUucGFyc2UoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlKX0pKWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZXJpYWxpemFibGVWYWx1ZTogYG5ldyBSZWdFeHAoJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlLnBhdHRlcm4pfSwgJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlLnZhbHVlLmZsYWdzKX0pYCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbWFwJzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IElmIG5vbmUgb2YgdGhlIG5lc3RlZCBrZXlzIGFuZCB2YWx1ZXMgaGFzIGEgcmVtb3RlXG4gICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlLCBzZXJpYWxpemUgdG8gYHVuc2VyaWFsaXphYmxlVmFsdWVgIHdpdGhvdXQgQ0RQIHJvdW5kdHJpcC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlWYWx1ZUFycmF5ID0gYXdhaXQgdGhpcy4jZmxhdHRlbktleVZhbHVlUGFpcnMobG9jYWxWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYXJnc1tpXSwgYXJnc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0UHJvbWlzZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czoga2V5VmFsdWVBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuQnlWYWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHRJZDogdGhpcy5leGVjdXRpb25Db250ZXh0SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjMzc1KTogUmVsZWFzZSBgcmVzdWx0Lm9iamVjdElkYCBhZnRlciB1c2luZy5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogcmVzdWx0Lm9iamVjdElkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgbm9uZSBvZiB0aGUgbmVzdGVkIGtleXMgYW5kIHZhbHVlcyBoYXMgYSByZW1vdGVcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UsIHNlcmlhbGl6ZSB0byBgdW5zZXJpYWxpemFibGVWYWx1ZWAgd2l0aG91dCBDRFAgcm91bmR0cmlwLlxuICAgICAgICAgICAgICAgIGNvbnN0IGtleVZhbHVlQXJyYXkgPSBhd2FpdCB0aGlzLiNmbGF0dGVuS2V5VmFsdWVQYWlycyhsb2NhbFZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gYXdhaXQgdGhpcy5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUuY2FsbEZ1bmN0aW9uT24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb246IFN0cmluZygoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZXkgc2hvdWxkIGJlIGVpdGhlciBgc3RyaW5nYCwgYG51bWJlcmAsIG9yIGBzeW1ib2xgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGtleVZhbHVlQXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHRoaXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IFJlbGVhc2UgYHJlc3VsdC5vYmplY3RJZGAgYWZ0ZXIgdXNpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IHJlc3VsdC5vYmplY3RJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgbm9uZSBvZiB0aGUgbmVzdGVkIGl0ZW1zIGhhcyBhIHJlbW90ZSByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIHRvIGB1bnNlcmlhbGl6YWJsZVZhbHVlYCB3aXRob3V0IENEUCByb3VuZHRyaXAuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGF3YWl0IHRoaXMuI2ZsYXR0ZW5WYWx1ZUxpc3QobG9jYWxWYWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuY2RwQ2xpZW50LnNlbmRDb21tYW5kKCdSdW50aW1lLmNhbGxGdW5jdGlvbk9uJywge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uOiBTdHJpbmcoKC4uLmFyZ3MpID0+IGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdFByb21pc2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkJ5VmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHRoaXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IFJlbGVhc2UgYHJlc3VsdC5vYmplY3RJZGAgYWZ0ZXIgdXNpbmcuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb2JqZWN0SWQ6IHJlc3VsdC5vYmplY3RJZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2V0Jzoge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIG5vbmUgb2YgdGhlIG5lc3RlZCBpdGVtcyBoYXMgYSByZW1vdGUgcmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSB0byBgdW5zZXJpYWxpemFibGVWYWx1ZWAgd2l0aG91dCBDRFAgcm91bmR0cmlwLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhd2FpdCB0aGlzLiNmbGF0dGVuVmFsdWVMaXN0KGxvY2FsVmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnUnVudGltZS5jYWxsRnVuY3Rpb25PbicsIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbjogU3RyaW5nKCguLi5hcmdzKSA9PiBuZXcgU2V0KGFyZ3MpKSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5CeVZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKCMzNzUpOiBSZWxlYXNlIGByZXN1bHQub2JqZWN0SWRgIGFmdGVyIHVzaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG9iamVjdElkOiByZXN1bHQub2JqZWN0SWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbFByb3h5ID0gbmV3IENoYW5uZWxQcm94eV9qc18xLkNoYW5uZWxQcm94eShsb2NhbFZhbHVlLnZhbHVlLCB0aGlzLiNsb2dnZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxQcm94eVNlbmRNZXNzYWdlSGFuZGxlID0gYXdhaXQgY2hhbm5lbFByb3h5LmluaXQodGhpcywgdGhpcy4jZXZlbnRNYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvYmplY3RJZDogY2hhbm5lbFByb3h5U2VuZE1lc3NhZ2VIYW5kbGUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IERpc3Bvc2Ugb2YgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBvdXRzaWRlIHRvIGhhbmRsZSB1bmtub3duIHR5cGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgJHtKU09OLnN0cmluZ2lmeShsb2NhbFZhbHVlKX0gaXMgbm90IGRlc2VyaWFsaXphYmxlLmApO1xuICAgIH1cbiAgICBhc3luYyAjZ2V0RXhjZXB0aW9uUmVzdWx0KGV4Y2VwdGlvbkRldGFpbHMsIGxpbmVPZmZzZXQsIHJlc3VsdE93bmVyc2hpcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXhjZXB0aW9uRGV0YWlsczogYXdhaXQgdGhpcy4jc2VyaWFsaXplQ2RwRXhjZXB0aW9uRGV0YWlscyhleGNlcHRpb25EZXRhaWxzLCBsaW5lT2Zmc2V0LCByZXN1bHRPd25lcnNoaXApLFxuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIHR5cGU6ICdleGNlcHRpb24nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgI2dldFNlcmlhbGl6YXRpb25PcHRpb25zKHNlcmlhbGl6YXRpb24sIHNlcmlhbGl6YXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJpYWxpemF0aW9uLFxuICAgICAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IFJlYWxtLiNnZXRBZGRpdGlvbmFsU2VyaWFsaXphdGlvblBhcmFtZXRlcnMoc2VyaWFsaXphdGlvbk9wdGlvbnMpLFxuICAgICAgICAgICAgLi4uUmVhbG0uI2dldE1heE9iamVjdERlcHRoKHNlcmlhbGl6YXRpb25PcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljICNnZXRBZGRpdGlvbmFsU2VyaWFsaXphdGlvblBhcmFtZXRlcnMoc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHNlcmlhbGl6YXRpb25PcHRpb25zLm1heERvbURlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzWydtYXhOb2RlRGVwdGgnXSA9XG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnMubWF4RG9tRGVwdGggPT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgPyAxMDAwXG4gICAgICAgICAgICAgICAgICAgIDogc2VyaWFsaXphdGlvbk9wdGlvbnMubWF4RG9tRGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcmlhbGl6YXRpb25PcHRpb25zLmluY2x1ZGVTaGFkb3dUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzWydpbmNsdWRlU2hhZG93VHJlZSddID1cbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9ucy5pbmNsdWRlU2hhZG93VHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkaXRpb25hbFBhcmFtZXRlcnM7XG4gICAgfVxuICAgIHN0YXRpYyAjZ2V0TWF4T2JqZWN0RGVwdGgoc2VyaWFsaXphdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoID09PSBudWxsXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHsgbWF4RGVwdGg6IHNlcmlhbGl6YXRpb25PcHRpb25zLm1heE9iamVjdERlcHRoIH07XG4gICAgfVxuICAgIGFzeW5jICNyZWxlYXNlT2JqZWN0KGhhbmRsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jZHBDbGllbnQuc2VuZENvbW1hbmQoJ1J1bnRpbWUucmVsZWFzZU9iamVjdCcsIHtcbiAgICAgICAgICAgICAgICBvYmplY3RJZDogaGFuZGxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBIZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBwcm9ibGVtIGlzIGluIHRoZSB1bmtub3duIGhhbmRsZXIuXG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9yIGlmIHNvLlxuICAgICAgICAgICAgaWYgKCEoZXJyb3IuY29kZSA9PT0gLTMyMDAwIC8qIENkcEVycm9yQ29uc3RhbnRzLkdFTkVSSUNfRVJST1IgKi8gJiZcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCByZW1vdGUgb2JqZWN0IGlkJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkaXNvd24oaGFuZGxlKSB7XG4gICAgICAgIC8vIERpc293bmluZyBhbiBvYmplY3QgZnJvbSBkaWZmZXJlbnQgcmVhbG0gZG9lcyBub3RoaW5nLlxuICAgICAgICBpZiAodGhpcy4jcmVhbG1TdG9yYWdlLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZ2V0KGhhbmRsZSkgIT09IHRoaXMucmVhbG1JZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuI3JlbGVhc2VPYmplY3QoaGFuZGxlKTtcbiAgICAgICAgdGhpcy4jcmVhbG1TdG9yYWdlLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZGVsZXRlKGhhbmRsZSk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuI3JlZ2lzdGVyRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2V2ZW50JyxcbiAgICAgICAgICAgIG1ldGhvZDogcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuU2NyaXB0LkV2ZW50TmFtZXMuUmVhbG1EZXN0cm95ZWQsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICByZWFsbTogdGhpcy5yZWFsbUlkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SZWFsbSA9IFJlYWxtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbG0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWxtU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBXaW5kb3dSZWFsbV9qc18xID0gcmVxdWlyZShcIi4vV2luZG93UmVhbG0uanNcIik7XG4vKiogQ29udGFpbmVyIGNsYXNzIGZvciBicm93c2luZyByZWFsbXMuICovXG5jbGFzcyBSZWFsbVN0b3JhZ2Uge1xuICAgIC8qKiBUcmFja3MgaGFuZGxlcyBhbmQgdGhlaXIgcmVhbG1zIHNlbnQgdG8gdGhlIGNsaWVudC4gKi9cbiAgICAja25vd25IYW5kbGVzVG9SZWFsbU1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogTWFwIGZyb20gcmVhbG0gSUQgdG8gUmVhbG0uICovXG4gICAgI3JlYWxtTWFwID0gbmV3IE1hcCgpO1xuICAgIGdldCBrbm93bkhhbmRsZXNUb1JlYWxtTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4ja25vd25IYW5kbGVzVG9SZWFsbU1hcDtcbiAgICB9XG4gICAgYWRkUmVhbG0ocmVhbG0pIHtcbiAgICAgICAgdGhpcy4jcmVhbG1NYXAuc2V0KHJlYWxtLnJlYWxtSWQsIHJlYWxtKTtcbiAgICB9XG4gICAgLyoqIEZpbmRzIGFsbCByZWFsbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIGZpbmRSZWFsbXMoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI3JlYWxtTWFwLnZhbHVlcygpKS5maWx0ZXIoKHJlYWxtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnJlYWxtSWQgIT09IHVuZGVmaW5lZCAmJiBmaWx0ZXIucmVhbG1JZCAhPT0gcmVhbG0ucmVhbG1JZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIuYnJvd3NpbmdDb250ZXh0SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICFyZWFsbS5hc3NvY2lhdGVkQnJvd3NpbmdDb250ZXh0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChicm93c2luZ0NvbnRleHQpID0+IGJyb3dzaW5nQ29udGV4dC5pZClcbiAgICAgICAgICAgICAgICAgICAgLmluY2x1ZGVzKGZpbHRlci5icm93c2luZ0NvbnRleHRJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnNhbmRib3ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICghKHJlYWxtIGluc3RhbmNlb2YgV2luZG93UmVhbG1fanNfMS5XaW5kb3dSZWFsbSkgfHwgZmlsdGVyLnNhbmRib3ggIT09IHJlYWxtLnNhbmRib3gpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci5leGVjdXRpb25Db250ZXh0SWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGZpbHRlci5leGVjdXRpb25Db250ZXh0SWQgIT09IHJlYWxtLmV4ZWN1dGlvbkNvbnRleHRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIub3JpZ2luICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyLm9yaWdpbiAhPT0gcmVhbG0ub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbHRlci50eXBlICE9PSB1bmRlZmluZWQgJiYgZmlsdGVyLnR5cGUgIT09IHJlYWxtLnJlYWxtVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXIuY2RwU2Vzc2lvbklkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBmaWx0ZXIuY2RwU2Vzc2lvbklkICE9PSByZWFsbS5jZHBDbGllbnQuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5kUmVhbG0oZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IG1heWJlUmVhbG1zID0gdGhpcy5maW5kUmVhbG1zKGZpbHRlcik7XG4gICAgICAgIGlmIChtYXliZVJlYWxtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUmVhbG1zWzBdO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgb25seSByZWFsbSB0aGF0IG1hdGNoZXMgdGhlIGdpdmVuIGZpbHRlciwgaWYgYW55LCBvdGhlcndpc2UgdGhyb3dzLiAqL1xuICAgIGdldFJlYWxtKGZpbHRlcikge1xuICAgICAgICBjb25zdCBtYXliZVJlYWxtID0gdGhpcy5maW5kUmVhbG0oZmlsdGVyKTtcbiAgICAgICAgaWYgKG1heWJlUmVhbG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoRnJhbWVFeGNlcHRpb24oYFJlYWxtICR7SlNPTi5zdHJpbmdpZnkoZmlsdGVyKX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heWJlUmVhbG07XG4gICAgfVxuICAgIC8qKiBEZWxldGVzIGFsbCByZWFsbXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmlsdGVyLiAqL1xuICAgIGRlbGV0ZVJlYWxtcyhmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5maW5kUmVhbG1zKGZpbHRlcikubWFwKChyZWFsbSkgPT4ge1xuICAgICAgICAgICAgcmVhbG0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy4jcmVhbG1NYXAuZGVsZXRlKHJlYWxtLnJlYWxtSWQpO1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZW50cmllcygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKFssIHJdKSA9PiByID09PSByZWFsbS5yZWFsbUlkKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtoYW5kbGVdKSA9PiB0aGlzLmtub3duSGFuZGxlc1RvUmVhbG1NYXAuZGVsZXRlKGhhbmRsZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWxtU3RvcmFnZSA9IFJlYWxtU3RvcmFnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlYWxtU3RvcmFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TY3JpcHRQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgUHJlbG9hZFNjcmlwdF9qc18xID0gcmVxdWlyZShcIi4vUHJlbG9hZFNjcmlwdC5qc1wiKTtcbmNsYXNzIFNjcmlwdFByb2Nlc3NvciB7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgI3JlYWxtU3RvcmFnZTtcbiAgICAjcHJlbG9hZFNjcmlwdFN0b3JhZ2U7XG4gICAgI2xvZ2dlcjtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHRTdG9yYWdlLCByZWFsbVN0b3JhZ2UsIHByZWxvYWRTY3JpcHRTdG9yYWdlLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZSA9IGJyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgICAgIHRoaXMuI3JlYWxtU3RvcmFnZSA9IHJlYWxtU3RvcmFnZTtcbiAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UgPSBwcmVsb2FkU2NyaXB0U3RvcmFnZTtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICBhc3luYyBhZGRQcmVsb2FkU2NyaXB0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBjb250ZXh0cyA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UudmVyaWZ5VG9wTGV2ZWxDb250ZXh0c0xpc3QocGFyYW1zLmNvbnRleHRzKTtcbiAgICAgICAgY29uc3QgcHJlbG9hZFNjcmlwdCA9IG5ldyBQcmVsb2FkU2NyaXB0X2pzXzEuUHJlbG9hZFNjcmlwdChwYXJhbXMsIHRoaXMuI2xvZ2dlcik7XG4gICAgICAgIHRoaXMuI3ByZWxvYWRTY3JpcHRTdG9yYWdlLmFkZChwcmVsb2FkU2NyaXB0KTtcbiAgICAgICAgY29uc3QgY2RwVGFyZ2V0cyA9IGNvbnRleHRzLnNpemUgPT09IDBcbiAgICAgICAgICAgID8gbmV3IFNldCh0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlXG4gICAgICAgICAgICAgICAgLmdldFRvcExldmVsQ29udGV4dHMoKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbnRleHQpID0+IGNvbnRleHQuY2RwVGFyZ2V0KSlcbiAgICAgICAgICAgIDogbmV3IFNldChbLi4uY29udGV4dHMudmFsdWVzKCldLm1hcCgoY29udGV4dCkgPT4gY29udGV4dC5jZHBUYXJnZXQpKTtcbiAgICAgICAgYXdhaXQgcHJlbG9hZFNjcmlwdC5pbml0SW5UYXJnZXRzKGNkcFRhcmdldHMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjcmlwdDogcHJlbG9hZFNjcmlwdC5pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVtb3ZlUHJlbG9hZFNjcmlwdChwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBzY3JpcHQ6IGlkIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHNjcmlwdHMgPSB0aGlzLiNwcmVsb2FkU2NyaXB0U3RvcmFnZS5maW5kKHsgaWQgfSk7XG4gICAgICAgIGlmIChzY3JpcHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoU2NyaXB0RXhjZXB0aW9uKGBObyBwcmVsb2FkIHNjcmlwdCB3aXRoIGlkICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzY3JpcHRzLm1hcCgoc2NyaXB0KSA9PiBzY3JpcHQucmVtb3ZlKCkpKTtcbiAgICAgICAgdGhpcy4jcHJlbG9hZFNjcmlwdFN0b3JhZ2UucmVtb3ZlKHsgaWQgfSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbEZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICBjb25zdCByZWFsbSA9IGF3YWl0IHRoaXMuI2dldFJlYWxtKHBhcmFtcy50YXJnZXQpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVhbG0uY2FsbEZ1bmN0aW9uKHBhcmFtcy5mdW5jdGlvbkRlY2xhcmF0aW9uLCBwYXJhbXMuYXdhaXRQcm9taXNlLCBwYXJhbXMudGhpcywgcGFyYW1zLmFyZ3VtZW50cywgcGFyYW1zLnJlc3VsdE93bmVyc2hpcCwgcGFyYW1zLnNlcmlhbGl6YXRpb25PcHRpb25zLCBwYXJhbXMudXNlckFjdGl2YXRpb24pO1xuICAgIH1cbiAgICBhc3luYyBldmFsdWF0ZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVhbG0gPSBhd2FpdCB0aGlzLiNnZXRSZWFsbShwYXJhbXMudGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlYWxtLmV2YWx1YXRlKHBhcmFtcy5leHByZXNzaW9uLCBwYXJhbXMuYXdhaXRQcm9taXNlLCBwYXJhbXMucmVzdWx0T3duZXJzaGlwLCBwYXJhbXMuc2VyaWFsaXphdGlvbk9wdGlvbnMsIHBhcmFtcy51c2VyQWN0aXZhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIGRpc293bihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVhbG0gPSBhd2FpdCB0aGlzLiNnZXRSZWFsbShwYXJhbXMudGFyZ2V0KTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocGFyYW1zLmhhbmRsZXMubWFwKGFzeW5jIChoYW5kbGUpID0+IGF3YWl0IHJlYWxtLmRpc293bihoYW5kbGUpKSk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZ2V0UmVhbG1zKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmNvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjb250ZXh0IGlzIGtub3duLlxuICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHBhcmFtcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFsbXMgPSB0aGlzLiNyZWFsbVN0b3JhZ2VcbiAgICAgICAgICAgIC5maW5kUmVhbG1zKHtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dElkOiBwYXJhbXMuY29udGV4dCxcbiAgICAgICAgICAgIHR5cGU6IHBhcmFtcy50eXBlLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgocmVhbG0pID0+IHJlYWxtLnJlYWxtSW5mbyk7XG4gICAgICAgIHJldHVybiB7IHJlYWxtcyB9O1xuICAgIH1cbiAgICBhc3luYyAjZ2V0UmVhbG0odGFyZ2V0KSB7XG4gICAgICAgIGlmICgnY29udGV4dCcgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRDb250ZXh0KHRhcmdldC5jb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb250ZXh0LmdldE9yQ3JlYXRlU2FuZGJveCh0YXJnZXQuc2FuZGJveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxtU3RvcmFnZS5nZXRSZWFsbSh7XG4gICAgICAgICAgICByZWFsbUlkOiB0YXJnZXQucmVhbG0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NyaXB0UHJvY2Vzc29yID0gU2NyaXB0UHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NyaXB0UHJvY2Vzc29yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U2hhcmVkSWQgPSBnZXRTaGFyZWRJZDtcbmV4cG9ydHMucGFyc2VTaGFyZWRJZCA9IHBhcnNlU2hhcmVkSWQ7XG5jb25zdCBTSEFSRURfSURfRElWSURFUiA9ICdfZWxlbWVudF8nO1xuZnVuY3Rpb24gZ2V0U2hhcmVkSWQoZnJhbWVJZCwgZG9jdW1lbnRJZCwgYmFja2VuZE5vZGVJZCkge1xuICAgIHJldHVybiBgZi4ke2ZyYW1lSWR9LmQuJHtkb2N1bWVudElkfS5lLiR7YmFja2VuZE5vZGVJZH1gO1xufVxuZnVuY3Rpb24gcGFyc2VMZWdhY3lTaGFyZWRJZChzaGFyZWRJZCkge1xuICAgIGNvbnN0IG1hdGNoID0gc2hhcmVkSWQubWF0Y2gobmV3IFJlZ0V4cChgKC4qKSR7U0hBUkVEX0lEX0RJVklERVJ9KC4qKWApKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIC8vIFNoYXJlZElkIGlzIGluY29ycmVjdGx5IGZvcm1hdHRlZC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRvY3VtZW50SWQgPSBtYXRjaFsxXTtcbiAgICBjb25zdCBlbGVtZW50SWQgPSBtYXRjaFsyXTtcbiAgICBpZiAoZG9jdW1lbnRJZCA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBiYWNrZW5kTm9kZUlkID0gcGFyc2VJbnQoZWxlbWVudElkID8/ICcnKTtcbiAgICBpZiAoaXNOYU4oYmFja2VuZE5vZGVJZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2hhcmVkSWQoc2hhcmVkSWQpIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgbGVnYWN5IGNoZWNrIG9uY2UgQ2hyb21lRHJpdmVyIHByb3ZpZGVzIHNoYXJlZElkIGluIHRoZSBuZXcgZm9ybWF0LlxuICAgIGNvbnN0IGxlZ2FjeUZvcm1hdHRlZFNoYXJlZElkID0gcGFyc2VMZWdhY3lTaGFyZWRJZChzaGFyZWRJZCk7XG4gICAgaWYgKGxlZ2FjeUZvcm1hdHRlZFNoYXJlZElkICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IC4uLmxlZ2FjeUZvcm1hdHRlZFNoYXJlZElkLCBmcmFtZUlkOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBzaGFyZWRJZC5tYXRjaCgvZlxcLiguKilcXC5kXFwuKC4qKVxcLmVcXC4oWzAtOV0qKS8pO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgLy8gU2hhcmVkSWQgaXMgaW5jb3JyZWN0bHkgZm9ybWF0dGVkLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZnJhbWVJZCA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IGRvY3VtZW50SWQgPSBtYXRjaFsyXTtcbiAgICBjb25zdCBlbGVtZW50SWQgPSBtYXRjaFszXTtcbiAgICBpZiAoZnJhbWVJZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGRvY3VtZW50SWQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBlbGVtZW50SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYmFja2VuZE5vZGVJZCA9IHBhcnNlSW50KGVsZW1lbnRJZCA/PyAnJyk7XG4gICAgaWYgKGlzTmFOKGJhY2tlbmROb2RlSWQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFtZUlkLFxuICAgICAgICBkb2N1bWVudElkLFxuICAgICAgICBiYWNrZW5kTm9kZUlkLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaGFyZWRJZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XaW5kb3dSZWFsbSA9IHZvaWQgMDtcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBSZWFsbV9qc18xID0gcmVxdWlyZShcIi4vUmVhbG0uanNcIik7XG5jb25zdCBTaGFyZWRJZF9qc18xID0gcmVxdWlyZShcIi4vU2hhcmVkSWQuanNcIik7XG5jbGFzcyBXaW5kb3dSZWFsbSBleHRlbmRzIFJlYWxtX2pzXzEuUmVhbG0ge1xuICAgICNicm93c2luZ0NvbnRleHRJZDtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICBzYW5kYm94O1xuICAgIGNvbnN0cnVjdG9yKGJyb3dzaW5nQ29udGV4dElkLCBicm93c2luZ0NvbnRleHRTdG9yYWdlLCBjZHBDbGllbnQsIGV2ZW50TWFuYWdlciwgZXhlY3V0aW9uQ29udGV4dElkLCBsb2dnZXIsIG9yaWdpbiwgcmVhbG1JZCwgcmVhbG1TdG9yYWdlLCBzYW5kYm94KSB7XG4gICAgICAgIHN1cGVyKGNkcENsaWVudCwgZXZlbnRNYW5hZ2VyLCBleGVjdXRpb25Db250ZXh0SWQsIGxvZ2dlciwgb3JpZ2luLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UpO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRJZCA9IGJyb3dzaW5nQ29udGV4dElkO1xuICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlID0gYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICAgICAgdGhpcy5zYW5kYm94ID0gc2FuZGJveDtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgICNnZXRCcm93c2luZ0NvbnRleHRJZChuYXZpZ2FibGVJZCkge1xuICAgICAgICBjb25zdCBtYXliZUJyb3dzaW5nQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2VcbiAgICAgICAgICAgIC5nZXRBbGxDb250ZXh0cygpXG4gICAgICAgICAgICAuZmluZCgoY29udGV4dCkgPT4gY29udGV4dC5uYXZpZ2FibGVJZCA9PT0gbmF2aWdhYmxlSWQpO1xuICAgICAgICByZXR1cm4gbWF5YmVCcm93c2luZ0NvbnRleHQ/LmlkID8/ICdVTktOT1dOJztcbiAgICB9XG4gICAgZ2V0IGJyb3dzaW5nQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dCh0aGlzLiNicm93c2luZ0NvbnRleHRJZCk7XG4gICAgfVxuICAgIGdldCBhc3NvY2lhdGVkQnJvd3NpbmdDb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmJyb3dzaW5nQ29udGV4dF07XG4gICAgfVxuICAgIGdldCByZWFsbVR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnd2luZG93JztcbiAgICB9XG4gICAgZ2V0IHJlYWxtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuYmFzZUluZm8sXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnJlYWxtVHlwZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuI2Jyb3dzaW5nQ29udGV4dElkLFxuICAgICAgICAgICAgc2FuZGJveDogdGhpcy5zYW5kYm94LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVhbG06IHRoaXMucmVhbG1JZCxcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuYnJvd3NpbmdDb250ZXh0LmlkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXJpYWxpemVGb3JCaURpKGRlZXBTZXJpYWxpemVkVmFsdWUsIGludGVybmFsSWRNYXApIHtcbiAgICAgICAgY29uc3QgYmlkaVZhbHVlID0gZGVlcFNlcmlhbGl6ZWRWYWx1ZS52YWx1ZTtcbiAgICAgICAgaWYgKGRlZXBTZXJpYWxpemVkVmFsdWUudHlwZSA9PT0gJ25vZGUnICYmIGJpZGlWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093bihiaWRpVmFsdWUsICdiYWNrZW5kTm9kZUlkJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmF2aWdhYmxlSWQgPSB0aGlzLmJyb3dzaW5nQ29udGV4dC5uYXZpZ2FibGVJZCA/PyAnVU5LTk9XTic7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oYmlkaVZhbHVlLCAnbG9hZGVySWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgbG9hZGVySWRgIHNob3VsZCBiZSBhbHdheXMgdGhlcmUgYWZ0ZXIgfjIwMjQtMDMtMDUsIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jcnJldi5jb20vYy81MTE2MjQwIHJlYWNoZXMgc3RhYmxlLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhlIGNoZWNrIGFmdGVyIHRoZSBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2FibGVJZCA9IGJpZGlWYWx1ZS5sb2FkZXJJZDtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJpZGlWYWx1ZVsnbG9hZGVySWQnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVlcFNlcmlhbGl6ZWRWYWx1ZS5zaGFyZWRJZCA9XG4gICAgICAgICAgICAgICAgICAgICgwLCBTaGFyZWRJZF9qc18xLmdldFNoYXJlZElkKSh0aGlzLiNnZXRCcm93c2luZ0NvbnRleHRJZChuYXZpZ2FibGVJZCksIG5hdmlnYWJsZUlkLCBiaWRpVmFsdWUuYmFja2VuZE5vZGVJZCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJpZGlWYWx1ZVsnYmFja2VuZE5vZGVJZCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oYmlkaVZhbHVlLCAnY2hpbGRyZW4nKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBiaWRpVmFsdWUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYmlkaVZhbHVlLmNoaWxkcmVuW2ldID0gdGhpcy5zZXJpYWxpemVGb3JCaURpKGJpZGlWYWx1ZS5jaGlsZHJlbltpXSwgaW50ZXJuYWxJZE1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd24oYmlkaVZhbHVlLCAnc2hhZG93Um9vdCcpICYmXG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlLnNoYWRvd1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBiaWRpVmFsdWUuc2hhZG93Um9vdCA9IHRoaXMuc2VyaWFsaXplRm9yQmlEaShiaWRpVmFsdWUuc2hhZG93Um9vdCwgaW50ZXJuYWxJZE1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgbmFtZXNwYWNlVVJJYCBjYW4gYmUgaXMgZWl0aGVyIGBudWxsYCBvciBub24tZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgaWYgKGJpZGlWYWx1ZS5uYW1lc3BhY2VVUkkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgYmlkaVZhbHVlLm5hbWVzcGFjZVVSSSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnNlcmlhbGl6ZUZvckJpRGkoZGVlcFNlcmlhbGl6ZWRWYWx1ZSwgaW50ZXJuYWxJZE1hcCk7XG4gICAgfVxuICAgIGFzeW5jIGRlc2VyaWFsaXplRm9yQ2RwKGxvY2FsVmFsdWUpIHtcbiAgICAgICAgaWYgKCdzaGFyZWRJZCcgaW4gbG9jYWxWYWx1ZSAmJiBsb2NhbFZhbHVlLnNoYXJlZElkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTaGFyZWRJZCA9ICgwLCBTaGFyZWRJZF9qc18xLnBhcnNlU2hhcmVkSWQpKGxvY2FsVmFsdWUuc2hhcmVkSWQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZFNoYXJlZElkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoTm9kZUV4Y2VwdGlvbihgU2hhcmVkSWQgXCIke2xvY2FsVmFsdWUuc2hhcmVkSWR9XCIgd2FzIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnRJZCwgYmFja2VuZE5vZGVJZCB9ID0gcGFyc2VkU2hhcmVkSWQ7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgcHJvcGVyIHZhbGlkYXRpb24gaWYgdGhlIGVsZW1lbnQgaXMgYWNjZXNzaWJsZSBmcm9tIHRoZSBjdXJyZW50IHJlYWxtLlxuICAgICAgICAgICAgaWYgKHRoaXMuYnJvd3NpbmdDb250ZXh0Lm5hdmlnYWJsZUlkICE9PSBkb2N1bWVudElkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoTm9kZUV4Y2VwdGlvbihgU2hhcmVkSWQgXCIke2xvY2FsVmFsdWUuc2hhcmVkSWR9XCIgYmVsb25ncyB0byBkaWZmZXJlbnQgZG9jdW1lbnQuIEN1cnJlbnQgZG9jdW1lbnQgaXMgJHt0aGlzLmJyb3dzaW5nQ29udGV4dC5uYXZpZ2FibGVJZH0uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb2JqZWN0IH0gPSBhd2FpdCB0aGlzLmNkcENsaWVudC5zZW5kQ29tbWFuZCgnRE9NLnJlc29sdmVOb2RlJywge1xuICAgICAgICAgICAgICAgICAgICBiYWNrZW5kTm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Db250ZXh0SWQ6IHRoaXMuZXhlY3V0aW9uQ29udGV4dElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oIzM3NSk6IFJlbGVhc2UgYG9iai5vYmplY3Qub2JqZWN0SWRgIGFmdGVyIHVzaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiB7IG9iamVjdElkOiBvYmplY3Qub2JqZWN0SWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlY3QgXCJubyBzdWNoIG5vZGVcIiBleGNlcHRpb24uIEJhc2VkIG9uIHRoZSAgc3BlY2lmaWNcbiAgICAgICAgICAgICAgICAvLyBDRFAgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IC0zMjAwMCAvKiBDZHBFcnJvckNvbnN0YW50cy5HRU5FUklDX0VSUk9SICovICYmXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPT09ICdObyBub2RlIHdpdGggZ2l2ZW4gaWQgZm91bmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaE5vZGVFeGNlcHRpb24oYFNoYXJlZElkIFwiJHtsb2NhbFZhbHVlLnNoYXJlZElkfVwiIHdhcyBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLlVua25vd25FcnJvckV4Y2VwdGlvbihlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplRm9yQ2RwKGxvY2FsVmFsdWUpO1xuICAgIH1cbiAgICBhc3luYyBldmFsdWF0ZShleHByZXNzaW9uLCBhd2FpdFByb21pc2UsIHJlc3VsdE93bmVyc2hpcCwgc2VyaWFsaXphdGlvbk9wdGlvbnMsIHVzZXJBY3RpdmF0aW9uLCBpbmNsdWRlQ29tbWFuZExpbmVBcGkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZVxuICAgICAgICAgICAgLmdldENvbnRleHQodGhpcy4jYnJvd3NpbmdDb250ZXh0SWQpXG4gICAgICAgICAgICAudGFyZ2V0VW5ibG9ja2VkT3JUaHJvdygpO1xuICAgICAgICByZXR1cm4gYXdhaXQgc3VwZXIuZXZhbHVhdGUoZXhwcmVzc2lvbiwgYXdhaXRQcm9taXNlLCByZXN1bHRPd25lcnNoaXAsIHNlcmlhbGl6YXRpb25PcHRpb25zLCB1c2VyQWN0aXZhdGlvbiwgaW5jbHVkZUNvbW1hbmRMaW5lQXBpKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbEZ1bmN0aW9uKGZ1bmN0aW9uRGVjbGFyYXRpb24sIGF3YWl0UHJvbWlzZSwgdGhpc0xvY2FsVmFsdWUsIGFyZ3VtZW50c0xvY2FsVmFsdWVzLCByZXN1bHRPd25lcnNoaXAsIHNlcmlhbGl6YXRpb25PcHRpb25zLCB1c2VyQWN0aXZhdGlvbikge1xuICAgICAgICBhd2FpdCB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlXG4gICAgICAgICAgICAuZ2V0Q29udGV4dCh0aGlzLiNicm93c2luZ0NvbnRleHRJZClcbiAgICAgICAgICAgIC50YXJnZXRVbmJsb2NrZWRPclRocm93KCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5jYWxsRnVuY3Rpb24oZnVuY3Rpb25EZWNsYXJhdGlvbiwgYXdhaXRQcm9taXNlLCB0aGlzTG9jYWxWYWx1ZSwgYXJndW1lbnRzTG9jYWxWYWx1ZXMsIHJlc3VsdE93bmVyc2hpcCwgc2VyaWFsaXphdGlvbk9wdGlvbnMsIHVzZXJBY3RpdmF0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLldpbmRvd1JlYWxtID0gV2luZG93UmVhbG07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaW5kb3dSZWFsbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Xb3JrZXJSZWFsbSA9IHZvaWQgMDtcbmNvbnN0IFJlYWxtX2pzXzEgPSByZXF1aXJlKFwiLi9SZWFsbS5qc1wiKTtcbmNsYXNzIFdvcmtlclJlYWxtIGV4dGVuZHMgUmVhbG1fanNfMS5SZWFsbSB7XG4gICAgI3JlYWxtVHlwZTtcbiAgICAjb3duZXJSZWFsbXM7XG4gICAgY29uc3RydWN0b3IoY2RwQ2xpZW50LCBldmVudE1hbmFnZXIsIGV4ZWN1dGlvbkNvbnRleHRJZCwgbG9nZ2VyLCBvcmlnaW4sIG93bmVyUmVhbG1zLCByZWFsbUlkLCByZWFsbVN0b3JhZ2UsIHJlYWxtVHlwZSkge1xuICAgICAgICBzdXBlcihjZHBDbGllbnQsIGV2ZW50TWFuYWdlciwgZXhlY3V0aW9uQ29udGV4dElkLCBsb2dnZXIsIG9yaWdpbiwgcmVhbG1JZCwgcmVhbG1TdG9yYWdlKTtcbiAgICAgICAgdGhpcy4jb3duZXJSZWFsbXMgPSBvd25lclJlYWxtcztcbiAgICAgICAgdGhpcy4jcmVhbG1UeXBlID0gcmVhbG1UeXBlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgZ2V0IGFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jb3duZXJSZWFsbXMuZmxhdE1hcCgocmVhbG0pID0+IHJlYWxtLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzKTtcbiAgICB9XG4gICAgZ2V0IHJlYWxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxtVHlwZTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlYWxtOiB0aGlzLnJlYWxtSWQsXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIFB1cHBldGVlciBhYmxlIHRvIHRyYWNrIHdvcmtlcnMuXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgYWZ0ZXIgUHVwcGV0ZWVyIHRyYWNrcyB3b3JrZXJzIGJ5IG93bmVycyBhbmQgdXNlIHRoZSBiYXNlIHZlcnNpb24uXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmFzc29jaWF0ZWRCcm93c2luZ0NvbnRleHRzWzBdPy5pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHJlYWxtSW5mbygpIHtcbiAgICAgICAgY29uc3Qgb3duZXJzID0gdGhpcy4jb3duZXJSZWFsbXMubWFwKChyZWFsbSkgPT4gcmVhbG0ucmVhbG1JZCk7XG4gICAgICAgIGNvbnN0IHsgcmVhbG1UeXBlIH0gPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHJlYWxtVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGVkaWNhdGVkLXdvcmtlcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9IG93bmVyc1swXTtcbiAgICAgICAgICAgICAgICBpZiAob3duZXIgPT09IHVuZGVmaW5lZCB8fCBvd25lcnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVkaWNhdGVkIHdvcmtlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgb3duZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5iYXNlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVhbG1UeXBlLFxuICAgICAgICAgICAgICAgICAgICBvd25lcnM6IFtvd25lcl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NlcnZpY2Utd29ya2VyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NoYXJlZC13b3JrZXInOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5iYXNlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogcmVhbG1UeXBlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLldvcmtlclJlYWxtID0gV29ya2VyUmVhbG07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Xb3JrZXJSZWFsbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgQnVmZmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvQnVmZmVyLmpzXCIpO1xuY29uc3QgRGVmYXVsdE1hcF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL0RlZmF1bHRNYXAuanNcIik7XG5jb25zdCBEaXN0aW5jdFZhbHVlc19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL0Rpc3RpbmN0VmFsdWVzLmpzXCIpO1xuY29uc3QgRXZlbnRFbWl0dGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvRXZlbnRFbWl0dGVyLmpzXCIpO1xuY29uc3QgSWRXcmFwcGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvSWRXcmFwcGVyLmpzXCIpO1xuY29uc3QgT3V0Z29pbmdNZXNzYWdlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vT3V0Z29pbmdNZXNzYWdlLmpzXCIpO1xuY29uc3QgZXZlbnRzX2pzXzEgPSByZXF1aXJlKFwiLi9ldmVudHMuanNcIik7XG5jb25zdCBTdWJzY3JpcHRpb25NYW5hZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi9TdWJzY3JpcHRpb25NYW5hZ2VyLmpzXCIpO1xuY2xhc3MgRXZlbnRXcmFwcGVyIHtcbiAgICAjaWRXcmFwcGVyID0gbmV3IElkV3JhcHBlcl9qc18xLklkV3JhcHBlcigpO1xuICAgICNjb250ZXh0SWQ7XG4gICAgI2V2ZW50O1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50LCBjb250ZXh0SWQpIHtcbiAgICAgICAgdGhpcy4jZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy4jY29udGV4dElkID0gY29udGV4dElkO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpZFdyYXBwZXIuaWQ7XG4gICAgfVxuICAgIGdldCBjb250ZXh0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb250ZXh0SWQ7XG4gICAgfVxuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50O1xuICAgIH1cbn1cbi8qKlxuICogTWFwcyBldmVudCBuYW1lIHRvIGEgZGVzaXJlZCBidWZmZXIgbGVuZ3RoLlxuICovXG5jb25zdCBldmVudEJ1ZmZlckxlbmd0aCA9IG5ldyBNYXAoW1twcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Mb2cuRXZlbnROYW1lcy5Mb2dFbnRyeUFkZGVkLCAxMDBdXSk7XG5jbGFzcyBFdmVudE1hbmFnZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXJfanNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIE1hcHMgZXZlbnQgbmFtZSB0byBhIHNldCBvZiBjb250ZXh0cyB3aGVyZSB0aGlzIGV2ZW50IGFscmVhZHkgaGFwcGVuZWQuXG4gICAgICogTmVlZGVkIGZvciBnZXR0aW5nIGJ1ZmZlcmVkIGV2ZW50cyBmcm9tIGFsbCB0aGUgY29udGV4dHMgaW4gY2FzZSBvZlxuICAgICAqIHN1YnNjcmlwdGluZyB0byBhbGwgY29udGV4dHMuXG4gICAgICovXG4gICAgI2V2ZW50VG9Db250ZXh0c01hcCA9IG5ldyBEZWZhdWx0TWFwX2pzXzEuRGVmYXVsdE1hcCgoKSA9PiBuZXcgU2V0KCkpO1xuICAgIC8qKlxuICAgICAqIE1hcHMgYGV2ZW50TmFtZWAgKyBgYnJvd3NpbmdDb250ZXh0YCB0byBidWZmZXIuIFVzZWQgdG8gZ2V0IGJ1ZmZlcmVkIGV2ZW50c1xuICAgICAqIGR1cmluZyBzdWJzY3JpcHRpb24uIENoYW5uZWwtYWdub3N0aWMuXG4gICAgICovXG4gICAgI2V2ZW50QnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBNYXBzIGBldmVudE5hbWVgICsgYGJyb3dzaW5nQ29udGV4dGAgKyBgY2hhbm5lbGAgdG8gbGFzdCBzZW50IGV2ZW50IGlkLlxuICAgICAqIFVzZWQgdG8gYXZvaWQgc2VuZGluZyBkdXBsaWNhdGVkIGV2ZW50cyB3aGVuIHVzZXJcbiAgICAgKiBzdWJzY3JpYmVzIC0+IHVuc3Vic2NyaWJlcyAtPiBzdWJzY3JpYmVzLlxuICAgICAqL1xuICAgICNsYXN0TWVzc2FnZVNlbnQgPSBuZXcgTWFwKCk7XG4gICAgI3N1YnNjcmlwdGlvbk1hbmFnZXI7XG4gICAgI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2U7XG4gICAgLyoqXG4gICAgICogTWFwIG9mIGV2ZW50IG5hbWUgdG8gaG9va3MgdG8gYmUgY2FsbGVkIHdoZW4gY2xpZW50IGlzIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuICAgICAqL1xuICAgICNzdWJzY3JpYmVIb29rcztcbiAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHRTdG9yYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNzdWJzY3JpcHRpb25NYW5hZ2VyID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXJfanNfMS5TdWJzY3JpcHRpb25NYW5hZ2VyKGJyb3dzaW5nQ29udGV4dFN0b3JhZ2UpO1xuICAgICAgICB0aGlzLiNzdWJzY3JpYmVIb29rcyA9IG5ldyBEZWZhdWx0TWFwX2pzXzEuRGVmYXVsdE1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICAgIGdldCBzdWJzY3JpcHRpb25NYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc3Vic2NyaXB0aW9uTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb25zaXN0ZW50IGtleSB0byBiZSB1c2VkIHRvIGFjY2VzcyB2YWx1ZSBtYXBzLlxuICAgICAqL1xuICAgIHN0YXRpYyAjZ2V0TWFwS2V5KGV2ZW50TmFtZSwgYnJvd3NpbmdDb250ZXh0LCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IGV2ZW50TmFtZSwgYnJvd3NpbmdDb250ZXh0LCBjaGFubmVsIH0pO1xuICAgIH1cbiAgICBhZGRTdWJzY3JpYmVIb29rKGV2ZW50LCBob29rKSB7XG4gICAgICAgIHRoaXMuI3N1YnNjcmliZUhvb2tzLmdldChldmVudCkucHVzaChob29rKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFdmVudChldmVudCwgY29udGV4dElkKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQcm9taXNlRXZlbnQoUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIGtpbmQ6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIHZhbHVlOiBldmVudCxcbiAgICAgICAgfSksIGNvbnRleHRJZCwgZXZlbnQubWV0aG9kKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJQcm9taXNlRXZlbnQoZXZlbnQsIGNvbnRleHRJZCwgZXZlbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50V3JhcHBlciA9IG5ldyBFdmVudFdyYXBwZXIoZXZlbnQsIGNvbnRleHRJZCk7XG4gICAgICAgIGNvbnN0IHNvcnRlZENoYW5uZWxzID0gdGhpcy4jc3Vic2NyaXB0aW9uTWFuYWdlci5nZXRDaGFubmVsc1N1YnNjcmliZWRUb0V2ZW50KGV2ZW50TmFtZSwgY29udGV4dElkKTtcbiAgICAgICAgdGhpcy4jYnVmZmVyRXZlbnQoZXZlbnRXcmFwcGVyLCBldmVudE5hbWUpO1xuICAgICAgICAvLyBTZW5kIGV2ZW50cyB0byBjaGFubmVscyBpbiB0aGUgc3Vic2NyaXB0aW9uIHByaW9yaXR5LlxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2Ygc29ydGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImV2ZW50XCIgLyogRXZlbnRNYW5hZ2VyRXZlbnRzLkV2ZW50ICovLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogT3V0Z29pbmdNZXNzYWdlX2pzXzEuT3V0Z29pbmdNZXNzYWdlLmNyZWF0ZUZyb21Qcm9taXNlKGV2ZW50LCBjaGFubmVsKSxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRXZlbnRTZW50KGV2ZW50V3JhcHBlciwgY2hhbm5lbCwgZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUoZXZlbnROYW1lcywgY29udGV4dElkcywgY2hhbm5lbCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZXZlbnROYW1lcykge1xuICAgICAgICAgICAgKDAsIGV2ZW50c19qc18xLmFzc2VydFN1cHBvcnRlZEV2ZW50KShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiBhbGwgdGhlIGNvbnRleHRzIGFyZSBrbm93bi5cbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0SWQgb2YgY29udGV4dElkcykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFzc2VydCB0aGUgY29udGV4dCBpcyBrbm93bi4gVGhyb3cgZXhjZXB0aW9uIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoY29udGV4dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBMaXN0IG9mIHRoZSBzdWJzY3JpcHRpb24gaXRlbXMgdGhhdCB3ZXJlIGFjdHVhbGx5IGFkZGVkLiBFYWNoIGNvbnRhaW5zIGEgc3BlY2lmaWNcbiAgICAgICAgLy8gZXZlbnQgYW5kIGNvbnRleHQuIE5vIGRvbWFpbiBldmVudCAobGlrZSBcIm5ldHdvcmtcIikgb3IgZ2xvYmFsIGNvbnRleHQgc3Vic2NyaXB0aW9uXG4gICAgICAgIC8vIChsaWtlIG51bGwpIGFyZSBpbmNsdWRlZC5cbiAgICAgICAgY29uc3QgYWRkZWRTdWJzY3JpcHRpb25JdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBldmVudE5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRleHRJZCBvZiBjb250ZXh0SWRzKSB7XG4gICAgICAgICAgICAgICAgYWRkZWRTdWJzY3JpcHRpb25JdGVtcy5wdXNoKC4uLnRoaXMuI3N1YnNjcmlwdGlvbk1hbmFnZXIuc3Vic2NyaWJlKGV2ZW50TmFtZSwgY29udGV4dElkLCBjaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBldmVudFdyYXBwZXIgb2YgdGhpcy4jZ2V0QnVmZmVyZWRFdmVudHMoZXZlbnROYW1lLCBjb250ZXh0SWQsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgZXZlbnRzIGlzIGltcG9ydGFudC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiAvKiBFdmVudE1hbmFnZXJFdmVudHMuRXZlbnQgKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IE91dGdvaW5nTWVzc2FnZV9qc18xLk91dGdvaW5nTWVzc2FnZS5jcmVhdGVGcm9tUHJvbWlzZShldmVudFdyYXBwZXIuZXZlbnQsIGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI21hcmtFdmVudFNlbnQoZXZlbnRXcmFwcGVyLCBjaGFubmVsLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5ldyBzdWJzY3JpcHRpb24gaXRlbXMgYW5kIGNhbGwgaG9va3MgaWYgYW55LiBUaGVyZSBjYW4gYmVcbiAgICAgICAgLy8gZHVwbGljYXRlcywgZS5nLiB3aGVuIHN1YnNjcmliaW5nIHRvIHRoZSB3aG9sZSBkb21haW4gYW5kIHNvbWUgc3BlY2lmaWMgZXZlbnQgaW5cbiAgICAgICAgLy8gdGhlIHNhbWUgdGltZSAoXCJuZXR3b3JrXCIsIFwibmV0d29yay5yZXNwb25zZUNvbXBsZXRlZFwiKS4gYGRpc3RpbmN0VmFsdWVzYCBndWFyYW50ZWVzXG4gICAgICAgIC8vIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHBhaXIgZXZlbnQgKyBjb250ZXh0LlxuICAgICAgICAoMCwgRGlzdGluY3RWYWx1ZXNfanNfMS5kaXN0aW5jdFZhbHVlcykoYWRkZWRTdWJzY3JpcHRpb25JdGVtcykuZm9yRWFjaCgoeyBjb250ZXh0SWQsIGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuI3N1YnNjcmliZUhvb2tzLmdldChldmVudCkuZm9yRWFjaCgoaG9vaykgPT4gaG9vayhjb250ZXh0SWQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlTW9kdWxlc0lmTmVlZGVkKCk7XG4gICAgfVxuICAgIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50TmFtZXMsIGNvbnRleHRJZHMsIGNoYW5uZWwpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgICAgICgwLCBldmVudHNfanNfMS5hc3NlcnRTdXBwb3J0ZWRFdmVudCkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc3Vic2NyaXB0aW9uTWFuYWdlci51bnN1YnNjcmliZUFsbChldmVudE5hbWVzLCBjb250ZXh0SWRzLCBjaGFubmVsKTtcbiAgICAgICAgYXdhaXQgdGhpcy50b2dnbGVNb2R1bGVzSWZOZWVkZWQoKTtcbiAgICB9XG4gICAgYXN5bmMgdG9nZ2xlTW9kdWxlc0lmTmVlZGVkKCkge1xuICAgICAgICAvLyBUT0RPKDEpOiBPbmx5IHVwZGF0ZSBjaGFuZ2VkIHN1YnNjcmliZXJzXG4gICAgICAgIC8vIFRPRE8oMik6IEVuYWJsZSBmb3IgV29ya2VyIFRhcmdldHNcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5nZXRBbGxDb250ZXh0cygpLm1hcChhc3luYyAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNvbnRleHQudG9nZ2xlTW9kdWxlc0lmTmVlZGVkKCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGJ1ZmZlci1hYmxlLCBwdXQgaXQgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICAjYnVmZmVyRXZlbnQoZXZlbnRXcmFwcGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudEJ1ZmZlckxlbmd0aC5oYXMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgZXZlbnQgaXMgbm8gYnVmZmVyLWFibGUuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyTWFwS2V5ID0gRXZlbnRNYW5hZ2VyLiNnZXRNYXBLZXkoZXZlbnROYW1lLCBldmVudFdyYXBwZXIuY29udGV4dElkKTtcbiAgICAgICAgaWYgKCF0aGlzLiNldmVudEJ1ZmZlcnMuaGFzKGJ1ZmZlck1hcEtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuI2V2ZW50QnVmZmVycy5zZXQoYnVmZmVyTWFwS2V5LCBuZXcgQnVmZmVyX2pzXzEuQnVmZmVyKGV2ZW50QnVmZmVyTGVuZ3RoLmdldChldmVudE5hbWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZXZlbnRCdWZmZXJzLmdldChidWZmZXJNYXBLZXkpLmFkZChldmVudFdyYXBwZXIpO1xuICAgICAgICAvLyBBZGQgdGhlIGNvbnRleHQgdG8gdGhlIGxpc3Qgb2YgY29udGV4dHMgaGF2aW5nIGBldmVudE5hbWVgIGV2ZW50cy5cbiAgICAgICAgdGhpcy4jZXZlbnRUb0NvbnRleHRzTWFwLmdldChldmVudE5hbWUpLmFkZChldmVudFdyYXBwZXIuY29udGV4dElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGJ1ZmZlci1hYmxlLCBtYXJrIGl0IGFzIHNlbnQgdG8gdGhlIGdpdmVuIGNvbnRleHRJZCBhbmQgY2hhbm5lbC5cbiAgICAgKi9cbiAgICAjbWFya0V2ZW50U2VudChldmVudFdyYXBwZXIsIGNoYW5uZWwsIGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50QnVmZmVyTGVuZ3RoLmhhcyhldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSBldmVudCBpcyBubyBidWZmZXItYWJsZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0U2VudE1hcEtleSA9IEV2ZW50TWFuYWdlci4jZ2V0TWFwS2V5KGV2ZW50TmFtZSwgZXZlbnRXcmFwcGVyLmNvbnRleHRJZCwgY2hhbm5lbCk7XG4gICAgICAgIHRoaXMuI2xhc3RNZXNzYWdlU2VudC5zZXQobGFzdFNlbnRNYXBLZXksIE1hdGgubWF4KHRoaXMuI2xhc3RNZXNzYWdlU2VudC5nZXQobGFzdFNlbnRNYXBLZXkpID8/IDAsIGV2ZW50V3JhcHBlci5pZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGV2ZW50cyB3aGljaCBhcmUgYnVmZmVyZWQgYW5kIG5vdCB5ZXQgc2VudCB0byB0aGUgZ2l2ZW4gY2hhbm5lbCBldmVudHMuXG4gICAgICovXG4gICAgI2dldEJ1ZmZlcmVkRXZlbnRzKGV2ZW50TmFtZSwgY29udGV4dElkLCBjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck1hcEtleSA9IEV2ZW50TWFuYWdlci4jZ2V0TWFwS2V5KGV2ZW50TmFtZSwgY29udGV4dElkKTtcbiAgICAgICAgY29uc3QgbGFzdFNlbnRNYXBLZXkgPSBFdmVudE1hbmFnZXIuI2dldE1hcEtleShldmVudE5hbWUsIGNvbnRleHRJZCwgY2hhbm5lbCk7XG4gICAgICAgIGNvbnN0IGxhc3RTZW50TWVzc2FnZUlkID0gdGhpcy4jbGFzdE1lc3NhZ2VTZW50LmdldChsYXN0U2VudE1hcEtleSkgPz8gLUluZmluaXR5O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLiNldmVudEJ1ZmZlcnNcbiAgICAgICAgICAgIC5nZXQoYnVmZmVyTWFwS2V5KVxuICAgICAgICAgICAgPy5nZXQoKVxuICAgICAgICAgICAgLmZpbHRlcigod3JhcHBlcikgPT4gd3JhcHBlci5pZCA+IGxhc3RTZW50TWVzc2FnZUlkKSA/PyBbXTtcbiAgICAgICAgaWYgKGNvbnRleHRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRm9yIGdsb2JhbCBzdWJzY3JpcHRpb25zLCBldmVudHMgYnVmZmVyZWQgaW4gZWFjaCBjb250ZXh0IHNob3VsZCBiZSBzZW50IGJhY2suXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuI2V2ZW50VG9Db250ZXh0c01hcC5nZXQoZXZlbnROYW1lKS5rZXlzKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoX2NvbnRleHRJZCkgPT4gXG4gICAgICAgICAgICAvLyBFdmVudHMgd2l0aG91dCBjb250ZXh0IGFyZSBhbHJlYWR5IGluIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBfY29udGV4dElkICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgLy8gRXZlbnRzIGZyb20gZGVsZXRlZCBjb250ZXh0cyBzaG91bGQgbm90IGJlIHNlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0U3RvcmFnZS5oYXNDb250ZXh0KF9jb250ZXh0SWQpKVxuICAgICAgICAgICAgICAgIC5tYXAoKF9jb250ZXh0SWQpID0+IHRoaXMuI2dldEJ1ZmZlcmVkRXZlbnRzKGV2ZW50TmFtZSwgX2NvbnRleHRJZCwgY2hhbm5lbCkpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGV2ZW50cykgPT4gcmVzdWx0LnB1c2goLi4uZXZlbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zb3J0KChlMSwgZTIpID0+IGUxLmlkIC0gZTIuaWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRNYW5hZ2VyID0gRXZlbnRNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlc3Npb25Qcm9jZXNzb3IgPSB2b2lkIDA7XG5jbGFzcyBTZXNzaW9uUHJvY2Vzc29yIHtcbiAgICAjZXZlbnRNYW5hZ2VyO1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgYnJvd3NlckNkcENsaWVudCkge1xuICAgICAgICB0aGlzLiNldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQgPSBicm93c2VyQ2RwQ2xpZW50O1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB7IHJlYWR5OiBmYWxzZSwgbWVzc2FnZTogJ2FscmVhZHkgY29ubmVjdGVkJyB9O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGUoX3BhcmFtcykge1xuICAgICAgICAvLyBTaW5jZSBtYXBwZXIgZXhpc3RzLCB0aGVyZSBpcyBhIHNlc3Npb24gYWxyZWFkeS5cbiAgICAgICAgLy8gU3RpbGwgdGhlIG1hcHBlciBjYW4gaGFuZGxlIGNhcGFiaWxpdGllcyBmb3IgdXMuXG4gICAgICAgIC8vIEN1cnJlbnRseSwgb25seSBQdXBwZXRlZXIgY2FsbHMgaGVyZSBidXQsIGV2ZW50dWFsbHksIGV2ZXJ5IGNsaWVudFxuICAgICAgICAvLyBzaG91bGQgZGVsZWdyYXRlIGNhcGFiaWxpdHkgcHJvY2Vzc2luZyBoZXJlLlxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy4jYnJvd3NlckNkcENsaWVudC5zZW5kQ29tbWFuZCgnQnJvd3Nlci5nZXRWZXJzaW9uJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXNzaW9uSWQ6ICd1bmtub3duJyxcbiAgICAgICAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICAgICAgICAgIGFjY2VwdEluc2VjdXJlQ2VydHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJyb3dzZXJOYW1lOiB2ZXJzaW9uLnByb2R1Y3QsXG4gICAgICAgICAgICAgICAgYnJvd3NlclZlcnNpb246IHZlcnNpb24ucmV2aXNpb24sXG4gICAgICAgICAgICAgICAgcGxhdGZvcm1OYW1lOiAnJyxcbiAgICAgICAgICAgICAgICBzZXRXaW5kb3dSZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXRVcmw6ICcnLFxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogdmVyc2lvbi51c2VyQWdlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUocGFyYW1zLCBjaGFubmVsID0gbnVsbCkge1xuICAgICAgICBhd2FpdCB0aGlzLiNldmVudE1hbmFnZXIuc3Vic2NyaWJlKHBhcmFtcy5ldmVudHMsIHBhcmFtcy5jb250ZXh0cyA/PyBbbnVsbF0sIGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGFzeW5jIHVuc3Vic2NyaWJlKHBhcmFtcywgY2hhbm5lbCA9IG51bGwpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jZXZlbnRNYW5hZ2VyLnVuc3Vic2NyaWJlKHBhcmFtcy5ldmVudHMsIHBhcmFtcy5jb250ZXh0cyA/PyBbbnVsbF0sIGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuZXhwb3J0cy5TZXNzaW9uUHJvY2Vzc29yID0gU2Vzc2lvblByb2Nlc3Nvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlc3Npb25Qcm9jZXNzb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uTWFuYWdlciA9IHZvaWQgMDtcbmV4cG9ydHMuY2FydGVzaWFuUHJvZHVjdCA9IGNhcnRlc2lhblByb2R1Y3Q7XG5leHBvcnRzLnVucm9sbEV2ZW50cyA9IHVucm9sbEV2ZW50cztcbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG5jb25zdCBldmVudHNfanNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50cy5qc1wiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgY2FydGVzaWFuIHByb2R1Y3Qgb2YgdGhlIGdpdmVuIGFycmF5cy5cbiAqXG4gKiBFeGFtcGxlOlxuICogICBjYXJ0ZXNpYW4oWzEsIDJdLCBbJ2EnLCAnYiddKTsgPT4gW1sxLCAnYSddLCBbMSwgJ2InXSwgWzIsICdhJ10sIFsyLCAnYiddXVxuICovXG5mdW5jdGlvbiBjYXJ0ZXNpYW5Qcm9kdWN0KC4uLmEpIHtcbiAgICByZXR1cm4gYS5yZWR1Y2UoKGEsIGIpID0+IGEuZmxhdE1hcCgoZCkgPT4gYi5tYXAoKGUpID0+IFtkLCBlXS5mbGF0KCkpKSk7XG59XG4vKiogRXhwYW5kcyBcIkFsbEV2ZW50c1wiIGV2ZW50cyBpbnRvIGF0b21pYyBldmVudHMuICovXG5mdW5jdGlvbiB1bnJvbGxFdmVudHMoZXZlbnRzKSB7XG4gICAgY29uc3QgYWxsRXZlbnRzID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGFkZEV2ZW50cyhldmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICAgIGFsbEV2ZW50cy5hZGQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5Ccm93c2luZ0NvbnRleHQ6XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5Mb2c6XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTG9nLkV2ZW50TmFtZXMpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5OZXR3b3JrOlxuICAgICAgICAgICAgICAgIGFkZEV2ZW50cyhPYmplY3QudmFsdWVzKHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLk5ldHdvcmsuRXZlbnROYW1lcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLlNjcmlwdDpcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhbGxFdmVudHMuYWRkKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWy4uLmFsbEV2ZW50cy52YWx1ZXMoKV07XG59XG5jbGFzcyBTdWJzY3JpcHRpb25NYW5hZ2VyIHtcbiAgICAjc3Vic2NyaXB0aW9uUHJpb3JpdHkgPSAwO1xuICAgIC8vIEJyb3dzaW5nQ29udGV4dCBgbnVsbGAgbWVhbnMgdGhlIGV2ZW50IGhhcyBzdWJzY3JpcHRpb24gYWNyb3NzIGFsbCB0aGVcbiAgICAvLyBicm93c2luZyBjb250ZXh0cy5cbiAgICAvLyBDaGFubmVsIGBudWxsYCBtZWFucyBubyBgY2hhbm5lbGAgc2hvdWxkIGJlIGFkZGVkLlxuICAgICNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAjYnJvd3NpbmdDb250ZXh0U3RvcmFnZTtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHRTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgIH1cbiAgICBnZXRDaGFubmVsc1N1YnNjcmliZWRUb0V2ZW50KGV2ZW50TWV0aG9kLCBjb250ZXh0SWQpIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdGllc0FuZENoYW5uZWxzID0gQXJyYXkuZnJvbSh0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC5rZXlzKCkpXG4gICAgICAgICAgICAubWFwKChjaGFubmVsKSA9PiAoe1xuICAgICAgICAgICAgcHJpb3JpdHk6IHRoaXMuI2dldEV2ZW50U3Vic2NyaXB0aW9uUHJpb3JpdHlGb3JDaGFubmVsKGV2ZW50TWV0aG9kLCBjb250ZXh0SWQsIGNoYW5uZWwpLFxuICAgICAgICAgICAgY2hhbm5lbCxcbiAgICAgICAgfSkpXG4gICAgICAgICAgICAuZmlsdGVyKCh7IHByaW9yaXR5IH0pID0+IHByaW9yaXR5ICE9PSBudWxsKTtcbiAgICAgICAgLy8gU29ydCBjaGFubmVscyBieSBwcmlvcml0eS5cbiAgICAgICAgcmV0dXJuIHByaW9yaXRpZXNBbmRDaGFubmVsc1xuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KVxuICAgICAgICAgICAgLm1hcCgoeyBjaGFubmVsIH0pID0+IGNoYW5uZWwpO1xuICAgIH1cbiAgICAjZ2V0RXZlbnRTdWJzY3JpcHRpb25Qcmlvcml0eUZvckNoYW5uZWwoZXZlbnRNZXRob2QsIGNvbnRleHRJZCwgY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBjb250ZXh0VG9FdmVudE1hcCA9IHRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmdldChjaGFubmVsKTtcbiAgICAgICAgaWYgKGNvbnRleHRUb0V2ZW50TWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heWJlVG9wTGV2ZWxDb250ZXh0SWQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRUb3BMZXZlbENvbnRleHRJZChjb250ZXh0SWQpO1xuICAgICAgICAvLyBgbnVsbGAgY292ZXJzIGdsb2JhbCBzdWJzY3JpcHRpb24uXG4gICAgICAgIGNvbnN0IHJlbGV2YW50Q29udGV4dHMgPSBbLi4ubmV3IFNldChbbnVsbCwgbWF5YmVUb3BMZXZlbENvbnRleHRJZF0pXTtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgc3Vic2NyaXB0aW9uIHByaW9yaXRpZXMuXG4gICAgICAgIGNvbnN0IHByaW9yaXRpZXMgPSByZWxldmFudENvbnRleHRzXG4gICAgICAgICAgICAubWFwKChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHByaW9yaXR5IGZvciBleGFjdCBldmVudCBuYW1lXG4gICAgICAgICAgICBjb25zdCBwcmlvcml0eSA9IGNvbnRleHRUb0V2ZW50TWFwLmdldChjb250ZXh0KT8uZ2V0KGV2ZW50TWV0aG9kKTtcbiAgICAgICAgICAgIC8vIEZvciBDRFAgd2UgY2FuJ3QgcHJvdmlkZSBzcGVjaWZpYyBldmVudCBuYW1lIHdoZW4gc3Vic2NyaWJpbmdcbiAgICAgICAgICAgIC8vIHRvIHRoZSBtb2R1bGUgZGlyZWN0bHkuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoYXQgd2UgbmVlZCB0byBzZWUgZXZlbnQgYGNkcGAgZXhpdHMgaW4gdGhlIG1hcC5cbiAgICAgICAgICAgIGlmICgoMCwgZXZlbnRzX2pzXzEuaXNDZHBFdmVudCkoZXZlbnRNZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2RwUHJpb3JpdHkgPSBjb250ZXh0VG9FdmVudE1hcFxuICAgICAgICAgICAgICAgICAgICAuZ2V0KGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgID8uZ2V0KHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuQ2RwKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdWJzY3JpYmUgdG8gdGhlIGV2ZW50IGRpcmVjdGx5IGFuZCBgY2RwYCBtb2R1bGUgYXMgd2VsbFxuICAgICAgICAgICAgICAgIC8vIHByaW9yaXR5IHdpbGwgYmUgZGlmZmVyZW50IHdlIHRha2UgbWluaW1hbCBwcmlvcml0eVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmlvcml0eSAmJiBjZHBQcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWluKHByaW9yaXR5LCBjZHBQcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBBdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCB3ZSBoYXZlIHN1YnNjcmliZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIG9ubHkgb25lIG9mIHRoZSB0d29cbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5ID8/IGNkcFByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByaW9yaXR5O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigocCkgPT4gcCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHByaW9yaXRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBOb3Qgc3Vic2NyaWJlZCwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gbWluaW1hbCBwcmlvcml0eS5cbiAgICAgICAgcmV0dXJuIE1hdGgubWluKC4uLnByaW9yaXRpZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbW9kdWxlIEJpRGkrIG1vZHVsZVxuICAgICAqIEBwYXJhbSBjb250ZXh0SWQgYG51bGxgID09IGdsb2JhbGx5IHN1YnNjcmliZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgaXNTdWJzY3JpYmVkVG8obW9kdWxlT3JFdmVudCwgY29udGV4dElkID0gbnVsbCkge1xuICAgICAgICBjb25zdCB0b3BMZXZlbENvbnRleHQgPSB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmZpbmRUb3BMZXZlbENvbnRleHRJZChjb250ZXh0SWQpO1xuICAgICAgICBmb3IgKGNvbnN0IGJyb3dzZXJDb250ZXh0VG9FdmVudE1hcCBvZiB0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGV2ZW50TWFwXSBvZiBicm93c2VyQ29udGV4dFRvRXZlbnRNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IHN1YnNjcmliZWQgdG8gdGhpcyBjb250ZXh0IG9yIGdsb2JhbGx5XG4gICAgICAgICAgICAgICAgaWYgKHRvcExldmVsQ29udGV4dCAhPT0gaWQgJiYgaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRNYXAua2V5cygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBjb3ZlcnMgdGhlIGBjZHBgIGNhc2Ugd2hlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgdW5yb2xsIHRoZSBldmVudCBuYW1lc1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIEV2ZW50IGV4cGxpY2l0bHkgc3Vic2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICBldmVudCA9PT0gbW9kdWxlT3JFdmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZlbnQgc3Vic2NyaWJlZCB2aWEgbW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9PT0gbW9kdWxlT3JFdmVudC5zcGxpdCgnLicpLmF0KDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBleHBsaWNpdGx5IHN1YnNjcmliZWQgY29tcGFyZWQgdG8gbW9kdWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zcGxpdCgnLicpLmF0KDApID09PSBtb2R1bGVPckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gZXZlbnQgaW4gdGhlIGdpdmVuIGNvbnRleHQgYW5kIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHtFdmVudE5hbWVzfSBldmVudFxuICAgICAqIEBwYXJhbSB7QnJvd3NpbmdDb250ZXh0LkJyb3dzaW5nQ29udGV4dCB8IG51bGx9IGNvbnRleHRJZFxuICAgICAqIEBwYXJhbSB7QmlkaVBsdXNDaGFubmVsfSBjaGFubmVsXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9uSXRlbVtdfSBMaXN0IG9mXG4gICAgICogc3Vic2NyaXB0aW9ucy4gSWYgdGhlIGV2ZW50IGlzIGEgd2hvbGUgbW9kdWxlLCBpdCB3aWxsIHJldHVybiBhbGwgdGhlIHNwZWNpZmljXG4gICAgICogZXZlbnRzLiBJZiB0aGUgY29udGV4dElkIGlzIG51bGwsIGl0IHdpbGwgcmV0dXJuIGFsbCB0aGUgdG9wLWxldmVsIGNvbnRleHRzIHdoaWNoIHdlcmVcbiAgICAgKiBub3Qgc3Vic2NyaWJlZCBiZWZvcmUgdGhlIGNvbW1hbmQuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKGV2ZW50LCBjb250ZXh0SWQsIGNoYW5uZWwpIHtcbiAgICAgICAgLy8gQWxsIHRoZSBzdWJzY3JpcHRpb25zIGFyZSBoYW5kbGVkIG9uIHRoZSB0b3AtbGV2ZWwgY29udGV4dHMuXG4gICAgICAgIGNvbnRleHRJZCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZFRvcExldmVsQ29udGV4dElkKGNvbnRleHRJZCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHN1YnNjcmliZWQgZXZlbnQgaXMgYSB3aG9sZSBtb2R1bGVcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgY2FzZSBwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLkJyb3dzaW5nQ29udGV4dDpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5Ccm93c2luZ0NvbnRleHQuRXZlbnROYW1lcylcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3BlY2lmaWNFdmVudCkgPT4gdGhpcy5zdWJzY3JpYmUoc3BlY2lmaWNFdmVudCwgY29udGV4dElkLCBjaGFubmVsKSlcbiAgICAgICAgICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgICAgIGNhc2UgcHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuQmlEaU1vZHVsZS5Mb2c6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocHJvdG9jb2xfanNfMS5DaHJvbWl1bUJpZGkuTG9nLkV2ZW50TmFtZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHNwZWNpZmljRXZlbnQpID0+IHRoaXMuc3Vic2NyaWJlKHNwZWNpZmljRXZlbnQsIGNvbnRleHRJZCwgY2hhbm5lbCkpXG4gICAgICAgICAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgICAgICBjYXNlIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuTmV0d29yazpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5OZXR3b3JrLkV2ZW50TmFtZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHNwZWNpZmljRXZlbnQpID0+IHRoaXMuc3Vic2NyaWJlKHNwZWNpZmljRXZlbnQsIGNvbnRleHRJZCwgY2hhbm5lbCkpXG4gICAgICAgICAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgICAgICBjYXNlIHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuU2NyaXB0OlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLlNjcmlwdC5FdmVudE5hbWVzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChzcGVjaWZpY0V2ZW50KSA9PiB0aGlzLnN1YnNjcmliZShzcGVjaWZpY0V2ZW50LCBjb250ZXh0SWQsIGNoYW5uZWwpKVxuICAgICAgICAgICAgICAgICAgICAuZmxhdCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbGVmdCBlbXB0eS5cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmhhcyhjaGFubmVsKSkge1xuICAgICAgICAgICAgdGhpcy4jY2hhbm5lbFRvQ29udGV4dFRvRXZlbnRNYXAuc2V0KGNoYW5uZWwsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dFRvRXZlbnRNYXAgPSB0aGlzLiNjaGFubmVsVG9Db250ZXh0VG9FdmVudE1hcC5nZXQoY2hhbm5lbCk7XG4gICAgICAgIGlmICghY29udGV4dFRvRXZlbnRNYXAuaGFzKGNvbnRleHRJZCkpIHtcbiAgICAgICAgICAgIGNvbnRleHRUb0V2ZW50TWFwLnNldChjb250ZXh0SWQsIG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRNYXAgPSBjb250ZXh0VG9FdmVudE1hcC5nZXQoY29udGV4dElkKTtcbiAgICAgICAgY29uc3QgYWZmZWN0ZWRDb250ZXh0SWRzID0gKGNvbnRleHRJZCA9PT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldFRvcExldmVsQ29udGV4dHMoKS5tYXAoKGMpID0+IGMuaWQpXG4gICAgICAgICAgICA6IFtjb250ZXh0SWRdKVxuICAgICAgICAgICAgLy8gVGhlcmUgY2FuIGJlIGNvbnRleHRzIHRoYXQgYXJlIGFscmVhZHkgc3Vic2NyaWJlZCB0byB0aGUgZXZlbnQuIERvIG5vdCBpbmNsdWRlXG4gICAgICAgICAgICAvLyB0aGVtIHRvIHRoZSBvdXRwdXQuXG4gICAgICAgICAgICAuZmlsdGVyKChjb250ZXh0SWQpID0+ICF0aGlzLmlzU3Vic2NyaWJlZFRvKGV2ZW50LCBjb250ZXh0SWQpKTtcbiAgICAgICAgaWYgKCFldmVudE1hcC5oYXMoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyBBZGQgc3Vic2NyaXB0aW9uIG9ubHkgaWYgaXQncyBub3QgYWxyZWFkeSBzdWJzY3JpYmVkLlxuICAgICAgICAgICAgZXZlbnRNYXAuc2V0KGV2ZW50LCB0aGlzLiNzdWJzY3JpcHRpb25Qcmlvcml0eSsrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWZmZWN0ZWRDb250ZXh0SWRzLm1hcCgoY29udGV4dElkKSA9PiAoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBjb250ZXh0SWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGF0b21pY2FsbHkgZnJvbSBhbGwgZXZlbnRzIGluIHRoZSBnaXZlbiBjb250ZXh0cyBhbmQgY2hhbm5lbC5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZUFsbChldmVudHMsIGNvbnRleHRJZHMsIGNoYW5uZWwpIHtcbiAgICAgICAgLy8gQXNzZXJ0IGFsbCBjb250ZXh0cyBhcmUga25vd24uXG4gICAgICAgIGZvciAoY29uc3QgY29udGV4dElkIG9mIGNvbnRleHRJZHMpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHRTdG9yYWdlLmdldENvbnRleHQoY29udGV4dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudENvbnRleHRQYWlycyA9IGNhcnRlc2lhblByb2R1Y3QodW5yb2xsRXZlbnRzKGV2ZW50cyksIGNvbnRleHRJZHMpO1xuICAgICAgICAvLyBBc3NlcnQgYWxsIHVuc3Vic2NyaXB0aW9ucyBhcmUgdmFsaWQuXG4gICAgICAgIC8vIElmIGFueSBvZiB0aGUgdW5zdWJzY3JpcHRpb25zIGFyZSBpbnZhbGlkLCBkbyBub3QgdW5zdWJzY3JpYmUgZnJvbSBhbnl0aGluZy5cbiAgICAgICAgZXZlbnRDb250ZXh0UGFpcnNcbiAgICAgICAgICAgIC5tYXAoKFtldmVudCwgY29udGV4dElkXSkgPT4gdGhpcy4jY2hlY2tVbnN1YnNjcmliZShldmVudCwgY29udGV4dElkLCBjaGFubmVsKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgY2hhbm5lbC5cbiAgICAgKiBTeW50YWN0aWMgc3VnYXIgZm9yIFwidW5zdWJzY3JpYmVBbGxcIi5cbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShldmVudE5hbWUsIGNvbnRleHRJZCwgY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQWxsKFtldmVudE5hbWVdLCBbY29udGV4dElkXSwgY2hhbm5lbCk7XG4gICAgfVxuICAgICNjaGVja1Vuc3Vic2NyaWJlKGV2ZW50LCBjb250ZXh0SWQsIGNoYW5uZWwpIHtcbiAgICAgICAgLy8gQWxsIHRoZSBzdWJzY3JpcHRpb25zIGFyZSBoYW5kbGVkIG9uIHRoZSB0b3AtbGV2ZWwgY29udGV4dHMuXG4gICAgICAgIGNvbnRleHRJZCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZmluZFRvcExldmVsQ29udGV4dElkKGNvbnRleHRJZCk7XG4gICAgICAgIGlmICghdGhpcy4jY2hhbm5lbFRvQ29udGV4dFRvRXZlbnRNYXAuaGFzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYENhbm5vdCB1bnN1YnNjcmliZSBmcm9tICR7ZXZlbnR9LCAke2NvbnRleHRJZCA9PT0gbnVsbCA/ICdudWxsJyA6IGNvbnRleHRJZH0uIE5vIHN1YnNjcmlwdGlvbiBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0VG9FdmVudE1hcCA9IHRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmdldChjaGFubmVsKTtcbiAgICAgICAgaWYgKCFjb250ZXh0VG9FdmVudE1hcC5oYXMoY29udGV4dElkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uKGBDYW5ub3QgdW5zdWJzY3JpYmUgZnJvbSAke2V2ZW50fSwgJHtjb250ZXh0SWQgPT09IG51bGwgPyAnbnVsbCcgOiBjb250ZXh0SWR9LiBObyBzdWJzY3JpcHRpb24gZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnRNYXAgPSBjb250ZXh0VG9FdmVudE1hcC5nZXQoY29udGV4dElkKTtcbiAgICAgICAgaWYgKCFldmVudE1hcC5oYXMoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYENhbm5vdCB1bnN1YnNjcmliZSBmcm9tICR7ZXZlbnR9LCAke2NvbnRleHRJZCA9PT0gbnVsbCA/ICdudWxsJyA6IGNvbnRleHRJZH0uIE5vIHN1YnNjcmlwdGlvbiBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRNYXAuZGVsZXRlKGV2ZW50KTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIG1hcHMgaWYgZW1wdHkuXG4gICAgICAgICAgICBpZiAoZXZlbnRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRUb0V2ZW50TWFwLmRlbGV0ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGV4dFRvRXZlbnRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NoYW5uZWxUb0NvbnRleHRUb0V2ZW50TWFwLmRlbGV0ZShjaGFubmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmlwdGlvbk1hbmFnZXIgPSBTdWJzY3JpcHRpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uTWFuYWdlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNDZHBFdmVudCA9IGlzQ2RwRXZlbnQ7XG5leHBvcnRzLmFzc2VydFN1cHBvcnRlZEV2ZW50ID0gYXNzZXJ0U3VwcG9ydGVkRXZlbnQ7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHByb3RvY29sX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vcHJvdG9jb2wvcHJvdG9jb2wuanNcIik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZXZlbnQgaXMgYSBDRFAgZXZlbnQuXG4gKiBAc2VlIGh0dHBzOi8vY2hyb21lZGV2dG9vbHMuZ2l0aHViLmlvL2RldnRvb2xzLXByb3RvY29sL1xuICovXG5mdW5jdGlvbiBpc0NkcEV2ZW50KG5hbWUpIHtcbiAgICByZXR1cm4gKG5hbWUuc3BsaXQoJy4nKS5hdCgwKT8uc3RhcnRzV2l0aChwcm90b2NvbF9qc18xLkNocm9taXVtQmlkaS5CaURpTW9kdWxlLkNkcCkgPz8gZmFsc2UpO1xufVxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGV2ZW50IGlzIGtub3duIHRvIEJpRGkgb3IgQmlEaSssIG9yIHRocm93cyBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZEV2ZW50KG5hbWUpIHtcbiAgICBpZiAoIXByb3RvY29sX2pzXzEuQ2hyb21pdW1CaWRpLkVWRU5UX05BTUVTLmhhcyhuYW1lKSAmJiAhaXNDZHBFdmVudChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgcHJvdG9jb2xfanNfMS5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24oYFVua25vd24gZXZlbnQ6ICR7bmFtZX1gKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3JhZ2VQcm9jZXNzb3IgPSB2b2lkIDA7XG5jb25zdCBwcm90b2NvbF9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL3Byb3RvY29sL3Byb3RvY29sLmpzXCIpO1xuY29uc3QgYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvYXNzZXJ0LmpzXCIpO1xuY29uc3QgbG9nX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvbG9nLmpzXCIpO1xuY29uc3QgTmV0d29ya1Byb2Nlc3Nvcl9qc18xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvTmV0d29ya1Byb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IE5ldHdvcmtVdGlsc19qc18xID0gcmVxdWlyZShcIi4uL25ldHdvcmsvTmV0d29ya1V0aWxzLmpzXCIpO1xuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGBzdG9yYWdlYCBkb21haW4uXG4gKi9cbmNsYXNzIFN0b3JhZ2VQcm9jZXNzb3Ige1xuICAgICNicm93c2VyQ2RwQ2xpZW50O1xuICAgICNicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICNsb2dnZXI7XG4gICAgY29uc3RydWN0b3IoYnJvd3NlckNkcENsaWVudCwgYnJvd3NpbmdDb250ZXh0U3RvcmFnZSwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UgPSBicm93c2luZ0NvbnRleHRTdG9yYWdlO1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ2xpZW50ID0gYnJvd3NlckNkcENsaWVudDtcbiAgICAgICAgdGhpcy4jbG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVDb29raWVzKHBhcmFtcykge1xuICAgICAgICBjb25zdCBwYXJ0aXRpb25LZXkgPSB0aGlzLiNleHBhbmRTdG9yYWdlUGFydGl0aW9uU3BlYyhwYXJhbXMucGFydGl0aW9uKTtcbiAgICAgICAgbGV0IGNkcFJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2RwUmVzcG9uc2UgPSBhd2FpdCB0aGlzLiNicm93c2VyQ2RwQ2xpZW50LnNlbmRDb21tYW5kKCdTdG9yYWdlLmdldENvb2tpZXMnLCB7XG4gICAgICAgICAgICAgICAgYnJvd3NlckNvbnRleHRJZDogdGhpcy4jZ2V0Q2RwQnJvd3NlckNvbnRleHRJZChwYXJ0aXRpb25LZXkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzTm9TdWNoVXNlckNvbnRleHRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY29udGV4dCBpcyBub3QgZm91bmQsIHNwZWNpYWwgZXJyb3IgaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBwcm90b2NvbF9qc18xLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZHBDb29raWVzVG9EZWxldGUgPSBjZHBSZXNwb25zZS5jb29raWVzXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAvLyBDRFAncyBwYXJ0aXRpb24ga2V5IGlzIHRoZSBzb3VyY2Ugb3JpZ2luLiBJZiB0aGUgcmVxdWVzdCBzcGVjaWZpZXMgdGhlXG4gICAgICAgIC8vIGBzb3VyY2VPcmlnaW5gIHBhcnRpdGlvbiBrZXksIG9ubHkgY29va2llcyB3aXRoIHRoZSByZXF1ZXN0ZWQgc291cmNlIG9yaWdpblxuICAgICAgICAvLyBhcmUgcmV0dXJuZWQuXG4gICAgICAgIChjKSA9PiBwYXJ0aXRpb25LZXkuc291cmNlT3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGMucGFydGl0aW9uS2V5Py50b3BMZXZlbFNpdGUgPT09IHBhcnRpdGlvbktleS5zb3VyY2VPcmlnaW4pXG4gICAgICAgICAgICAuZmlsdGVyKChjZHBDb29raWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJpZGlDb29raWUgPSAoMCwgTmV0d29ya1V0aWxzX2pzXzEuY2RwVG9CaURpQ29va2llKShjZHBDb29raWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI21hdGNoQ29va2llKGJpZGlDb29raWUsIHBhcmFtcy5maWx0ZXIpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm1hcCgoY29va2llKSA9PiAoe1xuICAgICAgICAgICAgLi4uY29va2llLFxuICAgICAgICAgICAgLy8gU2V0IGV4cGlyeSB0byBwYXNzIGRhdGUgdG8gZGVsZXRlIHRoZSBjb29raWUuXG4gICAgICAgICAgICBleHBpcmVzOiAxLFxuICAgICAgICB9KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1N0b3JhZ2Uuc2V0Q29va2llcycsIHtcbiAgICAgICAgICAgIGNvb2tpZXM6IGNkcENvb2tpZXNUb0RlbGV0ZSxcbiAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0SWQ6IHRoaXMuI2dldENkcEJyb3dzZXJDb250ZXh0SWQocGFydGl0aW9uS2V5KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0aXRpb25LZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldENvb2tpZXMocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpdGlvbktleSA9IHRoaXMuI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjKHBhcmFtcy5wYXJ0aXRpb24pO1xuICAgICAgICBsZXQgY2RwUmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjZHBSZXNwb25zZSA9IGF3YWl0IHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1N0b3JhZ2UuZ2V0Q29va2llcycsIHtcbiAgICAgICAgICAgICAgICBicm93c2VyQ29udGV4dElkOiB0aGlzLiNnZXRDZHBCcm93c2VyQ29udGV4dElkKHBhcnRpdGlvbktleSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNOb1N1Y2hVc2VyQ29udGV4dEVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjb250ZXh0IGlzIG5vdCBmb3VuZCwgc3BlY2lhbCBlcnJvciBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb24oZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkQmlEaUNvb2tpZXMgPSBjZHBSZXNwb25zZS5jb29raWVzXG4gICAgICAgICAgICAuZmlsdGVyKFxuICAgICAgICAvLyBDRFAncyBwYXJ0aXRpb24ga2V5IGlzIHRoZSBzb3VyY2Ugb3JpZ2luLiBJZiB0aGUgcmVxdWVzdCBzcGVjaWZpZXMgdGhlXG4gICAgICAgIC8vIGBzb3VyY2VPcmlnaW5gIHBhcnRpdGlvbiBrZXksIG9ubHkgY29va2llcyB3aXRoIHRoZSByZXF1ZXN0ZWQgc291cmNlIG9yaWdpblxuICAgICAgICAvLyBhcmUgcmV0dXJuZWQuXG4gICAgICAgIChjKSA9PiBwYXJ0aXRpb25LZXkuc291cmNlT3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGMucGFydGl0aW9uS2V5Py50b3BMZXZlbFNpdGUgPT09IHBhcnRpdGlvbktleS5zb3VyY2VPcmlnaW4pXG4gICAgICAgICAgICAubWFwKChjKSA9PiAoMCwgTmV0d29ya1V0aWxzX2pzXzEuY2RwVG9CaURpQ29va2llKShjKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IHRoaXMuI21hdGNoQ29va2llKGMsIHBhcmFtcy5maWx0ZXIpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tpZXM6IGZpbHRlcmVkQmlEaUNvb2tpZXMsXG4gICAgICAgICAgICBwYXJ0aXRpb25LZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNldENvb2tpZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFydGl0aW9uS2V5ID0gdGhpcy4jZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWMocGFyYW1zLnBhcnRpdGlvbik7XG4gICAgICAgIGNvbnN0IGNkcENvb2tpZSA9ICgwLCBOZXR3b3JrVXRpbHNfanNfMS5iaWRpVG9DZHBDb29raWUpKHBhcmFtcywgcGFydGl0aW9uS2V5KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDZHBDbGllbnQuc2VuZENvbW1hbmQoJ1N0b3JhZ2Uuc2V0Q29va2llcycsIHtcbiAgICAgICAgICAgICAgICBjb29raWVzOiBbY2RwQ29va2llXSxcbiAgICAgICAgICAgICAgICBicm93c2VyQ29udGV4dElkOiB0aGlzLiNnZXRDZHBCcm93c2VyQ29udGV4dElkKHBhcnRpdGlvbktleSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNOb1N1Y2hVc2VyQ29udGV4dEVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBjb250ZXh0IGlzIG5vdCBmb3VuZCwgc3BlY2lhbCBlcnJvciBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb24oZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jbG9nZ2VyPy4obG9nX2pzXzEuTG9nVHlwZS5kZWJ1Z0Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IHByb3RvY29sX2pzXzEuVW5hYmxlVG9TZXRDb29raWVFeGNlcHRpb24oZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJ0aXRpb25LZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgICNpc05vU3VjaFVzZXJDb250ZXh0RXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBkZXRlY3QgaWYgdGhlIHVzZXIgY29udGV4dCBpcyBub3QgZm91bmQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjpjb250ZW50L2Jyb3dzZXIvZGV2dG9vbHMvcHJvdG9jb2wvYnJvd3Nlcl9oYW5kbGVyLmNjO2RyYz1hNTYxNTRkZDgxZTQ2Nzk3MTI0MjJhYzZlZWQyYzk1ODFjYjUxYWIwO2w9MzE0XG4gICAgICAgIHJldHVybiBlcnIubWVzc2FnZT8uc3RhcnRzV2l0aCgnRmFpbGVkIHRvIGZpbmQgYnJvd3NlciBjb250ZXh0IGZvciBpZCcpO1xuICAgIH1cbiAgICAjZ2V0Q2RwQnJvd3NlckNvbnRleHRJZChwYXJ0aXRpb25LZXkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnRpdGlvbktleS51c2VyQ29udGV4dCA9PT0gJ2RlZmF1bHQnXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBwYXJ0aXRpb25LZXkudXNlckNvbnRleHQ7XG4gICAgfVxuICAgICNleHBhbmRTdG9yYWdlUGFydGl0aW9uU3BlY0J5QnJvd3NpbmdDb250ZXh0KGRlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0SWQgPSBkZXNjcmlwdG9yLmNvbnRleHQ7XG4gICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dCA9IHRoaXMuI2Jyb3dzaW5nQ29udGV4dFN0b3JhZ2UuZ2V0Q29udGV4dChicm93c2luZ0NvbnRleHRJZCk7XG4gICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJkcml2ZXItYmlkaS8jYXNzb2NpYXRlZC1zdG9yYWdlLXBhcnRpdGlvbi5cbiAgICAgICAgLy8gRWFjaCBicm93c2luZyBjb250ZXh0IGFsc28gaGFzIGFuIGFzc29jaWF0ZWQgc3RvcmFnZSBwYXJ0aXRpb24sIHdoaWNoIGlzIHRoZVxuICAgICAgICAvLyBzdG9yYWdlIHBhcnRpdGlvbiBpdCB1c2VzIHRvIHBlcnNpc3QgZGF0YS4gSW4gQ2hyb21pdW0gaXQncyBhIGBCcm93c2VyQ29udGV4dGBcbiAgICAgICAgLy8gd2hpY2ggbWFwcyB0byBCaURpIGBVc2VyQ29udGV4dGAuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VyQ29udGV4dDogYnJvd3NpbmdDb250ZXh0LnVzZXJDb250ZXh0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWNCeVN0b3JhZ2VLZXkoZGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCB1bnN1cHBvcnRlZFBhcnRpdGlvbktleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBzb3VyY2VPcmlnaW4gPSBkZXNjcmlwdG9yLnNvdXJjZU9yaWdpbjtcbiAgICAgICAgaWYgKHNvdXJjZU9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBOZXR3b3JrUHJvY2Vzc29yX2pzXzEuTmV0d29ya1Byb2Nlc3Nvci5wYXJzZVVybFN0cmluZyhzb3VyY2VPcmlnaW4pO1xuICAgICAgICAgICAgaWYgKHVybC5vcmlnaW4gPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBgbnVsbGAgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIGxvY2FsIHBhZ2VzLlxuICAgICAgICAgICAgICAgIHNvdXJjZU9yaWdpbiA9IHVybC5vcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQb3J0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gQ0RQIENvb2tpZSdzIGBwYXJ0aXRpb25LZXlgLCBzbyBpdCBzaG91bGQgYmUgc3RyaXBwZWRcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSByZXF1ZXN0ZWQgc291cmNlIG9yaWdpbi5cbiAgICAgICAgICAgICAgICBzb3VyY2VPcmlnaW4gPSBgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0bmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIVsndHlwZScsICdzb3VyY2VPcmlnaW4nLCAndXNlckNvbnRleHQnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdW5zdXBwb3J0ZWRQYXJ0aXRpb25LZXlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zdXBwb3J0ZWRQYXJ0aXRpb25LZXlzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLiNsb2dnZXI/Lihsb2dfanNfMS5Mb2dUeXBlLmRlYnVnSW5mbywgYFVuc3VwcG9ydGVkIHBhcnRpdGlvbiBrZXlzOiAke0pTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyh1bnN1cHBvcnRlZFBhcnRpdGlvbktleXMpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgYHVzZXJDb250ZXh0YCB0byBgZGVmYXVsdGAgaWYgbm90IHByb3ZpZGVkLCBhcyBpdCdzIHJlcXVpcmVkIGluIENocm9taXVtLlxuICAgICAgICBjb25zdCB1c2VyQ29udGV4dCA9IGRlc2NyaXB0b3IudXNlckNvbnRleHQgPz8gJ2RlZmF1bHQnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlckNvbnRleHQsXG4gICAgICAgICAgICAuLi4oc291cmNlT3JpZ2luID09PSB1bmRlZmluZWQgPyB7fSA6IHsgc291cmNlT3JpZ2luIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAjZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWMocGFydGl0aW9uU3BlYykge1xuICAgICAgICBpZiAocGFydGl0aW9uU3BlYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBgdXNlckNvbnRleHRgIGlzIHJlcXVpcmVkIGluIENocm9taXVtLlxuICAgICAgICAgICAgcmV0dXJuIHsgdXNlckNvbnRleHQ6ICdkZWZhdWx0JyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aXRpb25TcGVjLnR5cGUgPT09ICdjb250ZXh0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V4cGFuZFN0b3JhZ2VQYXJ0aXRpb25TcGVjQnlCcm93c2luZ0NvbnRleHQocGFydGl0aW9uU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGFzc2VydF9qc18xLmFzc2VydCkocGFydGl0aW9uU3BlYy50eXBlID09PSAnc3RvcmFnZUtleScsICdVbmtub3duIHBhcnRpdGlvbiB0eXBlJyk7XG4gICAgICAgIC8vIFBhcnRpdGlvbiBzcGVjIGlzIGEgc3RvcmFnZSBwYXJ0aXRpb24uXG4gICAgICAgIC8vIExldCBwYXJ0aXRpb24ga2V5IGJlIHBhcnRpdGlvbiBzcGVjLlxuICAgICAgICByZXR1cm4gdGhpcy4jZXhwYW5kU3RvcmFnZVBhcnRpdGlvblNwZWNCeVN0b3JhZ2VLZXkocGFydGl0aW9uU3BlYyk7XG4gICAgfVxuICAgICNtYXRjaENvb2tpZShjb29raWUsIGZpbHRlcikge1xuICAgICAgICBpZiAoZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKGZpbHRlci5kb21haW4gPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIuZG9tYWluID09PSBjb29raWUuZG9tYWluKSAmJlxuICAgICAgICAgICAgKGZpbHRlci5uYW1lID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLm5hbWUgPT09IGNvb2tpZS5uYW1lKSAmJlxuICAgICAgICAgICAgLy8gYHZhbHVlYCBjb250YWlucyBmaWVsZHMgYHR5cGVgIGFuZCBgdmFsdWVgLlxuICAgICAgICAgICAgKGZpbHRlci52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKDAsIE5ldHdvcmtVdGlsc19qc18xLmRlc2VyaWFsaXplQnl0ZVZhbHVlKShmaWx0ZXIudmFsdWUpID09PVxuICAgICAgICAgICAgICAgICAgICAoMCwgTmV0d29ya1V0aWxzX2pzXzEuZGVzZXJpYWxpemVCeXRlVmFsdWUpKGNvb2tpZS52YWx1ZSkpICYmXG4gICAgICAgICAgICAoZmlsdGVyLnBhdGggPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIucGF0aCA9PT0gY29va2llLnBhdGgpICYmXG4gICAgICAgICAgICAoZmlsdGVyLnNpemUgPT09IHVuZGVmaW5lZCB8fCBmaWx0ZXIuc2l6ZSA9PT0gY29va2llLnNpemUpICYmXG4gICAgICAgICAgICAoZmlsdGVyLmh0dHBPbmx5ID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLmh0dHBPbmx5ID09PSBjb29raWUuaHR0cE9ubHkpICYmXG4gICAgICAgICAgICAoZmlsdGVyLnNlY3VyZSA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlci5zZWN1cmUgPT09IGNvb2tpZS5zZWN1cmUpICYmXG4gICAgICAgICAgICAoZmlsdGVyLnNhbWVTaXRlID09PSB1bmRlZmluZWQgfHwgZmlsdGVyLnNhbWVTaXRlID09PSBjb29raWUuc2FtZVNpdGUpICYmXG4gICAgICAgICAgICAoZmlsdGVyLmV4cGlyeSA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlci5leHBpcnkgPT09IGNvb2tpZS5leHBpcnkpKTtcbiAgICB9XG59XG5leHBvcnRzLlN0b3JhZ2VQcm9jZXNzb3IgPSBTdG9yYWdlUHJvY2Vzc29yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZVByb2Nlc3Nvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5kZXJzcGVjaWZpZWRTdG9yYWdlUGFydGl0aW9uRXhjZXB0aW9uID0gZXhwb3J0cy5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5hYmxlVG9TZXRDb29raWVFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaFN0b3JhZ2VQYXJ0aXRpb25FeGNlcHRpb24gPSBleHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gZXhwb3J0cy5VbmFibGVUb0Nsb3NlQnJvd3NlckV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXhjZXB0aW9uID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVua25vd25Db21tYW5kRXhjZXB0aW9uID0gZXhwb3J0cy5TZXNzaW9uTm90Q3JlYXRlZEV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaFNjcmlwdEV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoUmVxdWVzdEV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoTm9kZUV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoSW50ZXJjZXB0RXhjZXB0aW9uID0gZXhwb3J0cy5Ob1N1Y2hIaXN0b3J5RW50cnlFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaEhhbmRsZUV4Y2VwdGlvbiA9IGV4cG9ydHMuTm9TdWNoRnJhbWVFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaEVsZW1lbnRFeGNlcHRpb24gPSBleHBvcnRzLk5vU3VjaEFsZXJ0RXhjZXB0aW9uID0gZXhwb3J0cy5Nb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb24gPSBleHBvcnRzLkludmFsaWRTZXNzaW9uSWRFeGNlcHRpb24gPSBleHBvcnRzLkludmFsaWRTZWxlY3RvckV4Y2VwdGlvbiA9IGV4cG9ydHMuSW52YWxpZEFyZ3VtZW50RXhjZXB0aW9uID0gZXhwb3J0cy5FeGNlcHRpb24gPSB2b2lkIDA7XG5jbGFzcyBFeGNlcHRpb24ge1xuICAgIGVycm9yO1xuICAgIG1lc3NhZ2U7XG4gICAgc3RhY2t0cmFjZTtcbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgbWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IHN0YWNrdHJhY2U7XG4gICAgfVxuICAgIHRvRXJyb3JSZXNwb25zZShjb21tYW5kSWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBpZDogY29tbWFuZElkLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFja3RyYWNlOiB0aGlzLnN0YWNrdHJhY2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5FeGNlcHRpb24gPSBFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJpbnZhbGlkIGFyZ3VtZW50XCIgLyogRXJyb3JDb2RlLkludmFsaWRBcmd1bWVudCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQXJndW1lbnRFeGNlcHRpb24gPSBJbnZhbGlkQXJndW1lbnRFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJpbnZhbGlkIHNlbGVjdG9yXCIgLyogRXJyb3JDb2RlLkludmFsaWRTZWxlY3RvciAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU2VsZWN0b3JFeGNlcHRpb24gPSBJbnZhbGlkU2VsZWN0b3JFeGNlcHRpb247XG5jbGFzcyBJbnZhbGlkU2Vzc2lvbklkRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIgLyogRXJyb3JDb2RlLkludmFsaWRTZXNzaW9uSWQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFNlc3Npb25JZEV4Y2VwdGlvbiA9IEludmFsaWRTZXNzaW9uSWRFeGNlcHRpb247XG5jbGFzcyBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJtb3ZlIHRhcmdldCBvdXQgb2YgYm91bmRzXCIgLyogRXJyb3JDb2RlLk1vdmVUYXJnZXRPdXRPZkJvdW5kcyAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Nb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb24gPSBNb3ZlVGFyZ2V0T3V0T2ZCb3VuZHNFeGNlcHRpb247XG5jbGFzcyBOb1N1Y2hBbGVydEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggYWxlcnRcIiAvKiBFcnJvckNvZGUuTm9TdWNoQWxlcnQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoQWxlcnRFeGNlcHRpb24gPSBOb1N1Y2hBbGVydEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIGVsZW1lbnRcIiAvKiBFcnJvckNvZGUuTm9TdWNoRWxlbWVudCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uID0gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEZyYW1lRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBmcmFtZVwiIC8qIEVycm9yQ29kZS5Ob1N1Y2hGcmFtZSAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hGcmFtZUV4Y2VwdGlvbiA9IE5vU3VjaEZyYW1lRXhjZXB0aW9uO1xuY2xhc3MgTm9TdWNoSGFuZGxlRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBoYW5kbGVcIiAvKiBFcnJvckNvZGUuTm9TdWNoSGFuZGxlICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaEhhbmRsZUV4Y2VwdGlvbiA9IE5vU3VjaEhhbmRsZUV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaEhpc3RvcnlFbnRyeUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggaGlzdG9yeSBlbnRyeVwiIC8qIEVycm9yQ29kZS5Ob1N1Y2hIaXN0b3J5RW50cnkgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoSGlzdG9yeUVudHJ5RXhjZXB0aW9uID0gTm9TdWNoSGlzdG9yeUVudHJ5RXhjZXB0aW9uO1xuY2xhc3MgTm9TdWNoSW50ZXJjZXB0RXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwibm8gc3VjaCBpbnRlcmNlcHRcIiAvKiBFcnJvckNvZGUuTm9TdWNoSW50ZXJjZXB0ICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbiA9IE5vU3VjaEludGVyY2VwdEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaE5vZGVFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIG5vZGVcIiAvKiBFcnJvckNvZGUuTm9TdWNoTm9kZSAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hOb2RlRXhjZXB0aW9uID0gTm9TdWNoTm9kZUV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFJlcXVlc3RFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIHJlcXVlc3RcIiAvKiBFcnJvckNvZGUuTm9TdWNoUmVxdWVzdCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hSZXF1ZXN0RXhjZXB0aW9uID0gTm9TdWNoUmVxdWVzdEV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFNjcmlwdEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggc2NyaXB0XCIgLyogRXJyb3JDb2RlLk5vU3VjaFNjcmlwdCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob1N1Y2hTY3JpcHRFeGNlcHRpb24gPSBOb1N1Y2hTY3JpcHRFeGNlcHRpb247XG5jbGFzcyBOb1N1Y2hVc2VyQ29udGV4dEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcIm5vIHN1Y2ggdXNlciBjb250ZXh0XCIgLyogRXJyb3JDb2RlLk5vU3VjaFVzZXJDb250ZXh0ICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vU3VjaFVzZXJDb250ZXh0RXhjZXB0aW9uID0gTm9TdWNoVXNlckNvbnRleHRFeGNlcHRpb247XG5jbGFzcyBTZXNzaW9uTm90Q3JlYXRlZEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInNlc3Npb24gbm90IGNyZWF0ZWRcIiAvKiBFcnJvckNvZGUuU2Vzc2lvbk5vdENyZWF0ZWQgKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2Vzc2lvbk5vdENyZWF0ZWRFeGNlcHRpb24gPSBTZXNzaW9uTm90Q3JlYXRlZEV4Y2VwdGlvbjtcbmNsYXNzIFVua25vd25Db21tYW5kRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwidW5rbm93biBjb21tYW5kXCIgLyogRXJyb3JDb2RlLlVua25vd25Db21tYW5kICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25Db21tYW5kRXhjZXB0aW9uID0gVW5rbm93bkNvbW1hbmRFeGNlcHRpb247XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaykge1xuICAgICAgICBzdXBlcihcInVua25vd24gZXJyb3JcIiAvKiBFcnJvckNvZGUuVW5rbm93bkVycm9yICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcbmNsYXNzIFVuYWJsZVRvQ2FwdHVyZVNjcmVlbkV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBjYXB0dXJlIHNjcmVlblwiIC8qIEVycm9yQ29kZS5VbmFibGVUb0NhcHR1cmVTY3JlZW4gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXhjZXB0aW9uID0gVW5hYmxlVG9DYXB0dXJlU2NyZWVuRXhjZXB0aW9uO1xuY2xhc3MgVW5hYmxlVG9DbG9zZUJyb3dzZXJFeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJ1bmFibGUgdG8gY2xvc2UgYnJvd3NlclwiIC8qIEVycm9yQ29kZS5VbmFibGVUb0Nsb3NlQnJvd3NlciAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmFibGVUb0Nsb3NlQnJvd3NlckV4Y2VwdGlvbiA9IFVuYWJsZVRvQ2xvc2VCcm93c2VyRXhjZXB0aW9uO1xuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJ1bnN1cHBvcnRlZCBvcGVyYXRpb25cIiAvKiBFcnJvckNvZGUuVW5zdXBwb3J0ZWRPcGVyYXRpb24gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24gPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbjtcbmNsYXNzIE5vU3VjaFN0b3JhZ2VQYXJ0aXRpb25FeGNlcHRpb24gZXh0ZW5kcyBFeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YWNrdHJhY2UpIHtcbiAgICAgICAgc3VwZXIoXCJubyBzdWNoIHN0b3JhZ2UgcGFydGl0aW9uXCIgLyogRXJyb3JDb2RlLk5vU3VjaFN0b3JhZ2VQYXJ0aXRpb24gKi8sIG1lc3NhZ2UsIHN0YWNrdHJhY2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9TdWNoU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbiA9IE5vU3VjaFN0b3JhZ2VQYXJ0aXRpb25FeGNlcHRpb247XG5jbGFzcyBVbmFibGVUb1NldENvb2tpZUV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBzZXQgY29va2llXCIgLyogRXJyb3JDb2RlLlVuYWJsZVRvU2V0Q29va2llICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVuYWJsZVRvU2V0Q29va2llRXhjZXB0aW9uID0gVW5hYmxlVG9TZXRDb29raWVFeGNlcHRpb247XG5jbGFzcyBVbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbiBleHRlbmRzIEV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2t0cmFjZSkge1xuICAgICAgICBzdXBlcihcInVuYWJsZSB0byBzZXQgZmlsZSBpbnB1dFwiIC8qIEVycm9yQ29kZS5VbmFibGVUb1NldEZpbGVJbnB1dCAqLywgbWVzc2FnZSwgc3RhY2t0cmFjZSk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmFibGVUb1NldEZpbGVJbnB1dEV4Y2VwdGlvbiA9IFVuYWJsZVRvU2V0RmlsZUlucHV0RXhjZXB0aW9uO1xuY2xhc3MgVW5kZXJzcGVjaWZpZWRTdG9yYWdlUGFydGl0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFja3RyYWNlKSB7XG4gICAgICAgIHN1cGVyKFwidW5kZXJzcGVjaWZpZWQgc3RvcmFnZSBwYXJ0aXRpb25cIiAvKiBFcnJvckNvZGUuVW5kZXJzcGVjaWZpZWRTdG9yYWdlUGFydGl0aW9uICovLCBtZXNzYWdlLCBzdGFja3RyYWNlKTtcbiAgICB9XG59XG5leHBvcnRzLlVuZGVyc3BlY2lmaWVkU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbiA9IFVuZGVyc3BlY2lmaWVkU3RvcmFnZVBhcnRpdGlvbkV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yUmVzcG9uc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jZHAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVZFTlRfTkFNRVMgPSBleHBvcnRzLk5ldHdvcmsgPSBleHBvcnRzLkJyb3dzaW5nQ29udGV4dCA9IGV4cG9ydHMuTG9nID0gZXhwb3J0cy5TY3JpcHQgPSBleHBvcnRzLkJpRGlNb2R1bGUgPSB2b2lkIDA7XG4vLyBrZWVwLXNvcnRlZCBlbmRcbnZhciBCaURpTW9kdWxlO1xuKGZ1bmN0aW9uIChCaURpTW9kdWxlKSB7XG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICBCaURpTW9kdWxlW1wiQnJvd3NlclwiXSA9IFwiYnJvd3NlclwiO1xuICAgIEJpRGlNb2R1bGVbXCJCcm93c2luZ0NvbnRleHRcIl0gPSBcImJyb3dzaW5nQ29udGV4dFwiO1xuICAgIEJpRGlNb2R1bGVbXCJDZHBcIl0gPSBcImNkcFwiO1xuICAgIEJpRGlNb2R1bGVbXCJJbnB1dFwiXSA9IFwiaW5wdXRcIjtcbiAgICBCaURpTW9kdWxlW1wiTG9nXCJdID0gXCJsb2dcIjtcbiAgICBCaURpTW9kdWxlW1wiTmV0d29ya1wiXSA9IFwibmV0d29ya1wiO1xuICAgIEJpRGlNb2R1bGVbXCJTY3JpcHRcIl0gPSBcInNjcmlwdFwiO1xuICAgIEJpRGlNb2R1bGVbXCJTZXNzaW9uXCJdID0gXCJzZXNzaW9uXCI7XG4gICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG59KShCaURpTW9kdWxlIHx8IChleHBvcnRzLkJpRGlNb2R1bGUgPSBCaURpTW9kdWxlID0ge30pKTtcbnZhciBTY3JpcHQ7XG4oZnVuY3Rpb24gKFNjcmlwdCkge1xuICAgIGxldCBFdmVudE5hbWVzO1xuICAgIChmdW5jdGlvbiAoRXZlbnROYW1lcykge1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBzdGFydFxuICAgICAgICBFdmVudE5hbWVzW1wiTWVzc2FnZVwiXSA9IFwic2NyaXB0Lm1lc3NhZ2VcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIlJlYWxtQ3JlYXRlZFwiXSA9IFwic2NyaXB0LnJlYWxtQ3JlYXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiUmVhbG1EZXN0cm95ZWRcIl0gPSBcInNjcmlwdC5yZWFsbURlc3Ryb3llZFwiO1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICB9KShFdmVudE5hbWVzID0gU2NyaXB0LkV2ZW50TmFtZXMgfHwgKFNjcmlwdC5FdmVudE5hbWVzID0ge30pKTtcbn0pKFNjcmlwdCB8fCAoZXhwb3J0cy5TY3JpcHQgPSBTY3JpcHQgPSB7fSkpO1xudmFyIExvZztcbihmdW5jdGlvbiAoTG9nKSB7XG4gICAgbGV0IEV2ZW50TmFtZXM7XG4gICAgKGZ1bmN0aW9uIChFdmVudE5hbWVzKSB7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJMb2dFbnRyeUFkZGVkXCJdID0gXCJsb2cuZW50cnlBZGRlZFwiO1xuICAgIH0pKEV2ZW50TmFtZXMgPSBMb2cuRXZlbnROYW1lcyB8fCAoTG9nLkV2ZW50TmFtZXMgPSB7fSkpO1xufSkoTG9nIHx8IChleHBvcnRzLkxvZyA9IExvZyA9IHt9KSk7XG52YXIgQnJvd3NpbmdDb250ZXh0O1xuKGZ1bmN0aW9uIChCcm93c2luZ0NvbnRleHQpIHtcbiAgICBsZXQgRXZlbnROYW1lcztcbiAgICAoZnVuY3Rpb24gKEV2ZW50TmFtZXMpIHtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICAgICAgRXZlbnROYW1lc1tcIkNvbnRleHRDcmVhdGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQuY29udGV4dENyZWF0ZWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIkNvbnRleHREZXN0cm95ZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5jb250ZXh0RGVzdHJveWVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJEb21Db250ZW50TG9hZGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQuZG9tQ29udGVudExvYWRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRG93bmxvYWRXaWxsQmVnaW5cIl0gPSBcImJyb3dzaW5nQ29udGV4dC5kb3dubG9hZFdpbGxCZWdpblwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRnJhZ21lbnROYXZpZ2F0ZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5mcmFnbWVudE5hdmlnYXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiTG9hZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0LmxvYWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIk5hdmlnYXRpb25BYm9ydGVkXCJdID0gXCJicm93c2luZ0NvbnRleHQubmF2aWdhdGlvbkFib3J0ZWRcIjtcbiAgICAgICAgRXZlbnROYW1lc1tcIk5hdmlnYXRpb25GYWlsZWRcIl0gPSBcImJyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uRmFpbGVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJOYXZpZ2F0aW9uU3RhcnRlZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25TdGFydGVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJVc2VyUHJvbXB0Q2xvc2VkXCJdID0gXCJicm93c2luZ0NvbnRleHQudXNlclByb21wdENsb3NlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiVXNlclByb21wdE9wZW5lZFwiXSA9IFwiYnJvd3NpbmdDb250ZXh0LnVzZXJQcm9tcHRPcGVuZWRcIjtcbiAgICAgICAgLy8ga2VlcC1zb3J0ZWQgZW5kXG4gICAgfSkoRXZlbnROYW1lcyA9IEJyb3dzaW5nQ29udGV4dC5FdmVudE5hbWVzIHx8IChCcm93c2luZ0NvbnRleHQuRXZlbnROYW1lcyA9IHt9KSk7XG59KShCcm93c2luZ0NvbnRleHQgfHwgKGV4cG9ydHMuQnJvd3NpbmdDb250ZXh0ID0gQnJvd3NpbmdDb250ZXh0ID0ge30pKTtcbnZhciBOZXR3b3JrO1xuKGZ1bmN0aW9uIChOZXR3b3JrKSB7XG4gICAgbGV0IEV2ZW50TmFtZXM7XG4gICAgKGZ1bmN0aW9uIChFdmVudE5hbWVzKSB7XG4gICAgICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0XG4gICAgICAgIEV2ZW50TmFtZXNbXCJBdXRoUmVxdWlyZWRcIl0gPSBcIm5ldHdvcmsuYXV0aFJlcXVpcmVkXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJCZWZvcmVSZXF1ZXN0U2VudFwiXSA9IFwibmV0d29yay5iZWZvcmVSZXF1ZXN0U2VudFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiRmV0Y2hFcnJvclwiXSA9IFwibmV0d29yay5mZXRjaEVycm9yXCI7XG4gICAgICAgIEV2ZW50TmFtZXNbXCJSZXNwb25zZUNvbXBsZXRlZFwiXSA9IFwibmV0d29yay5yZXNwb25zZUNvbXBsZXRlZFwiO1xuICAgICAgICBFdmVudE5hbWVzW1wiUmVzcG9uc2VTdGFydGVkXCJdID0gXCJuZXR3b3JrLnJlc3BvbnNlU3RhcnRlZFwiO1xuICAgICAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbiAgICB9KShFdmVudE5hbWVzID0gTmV0d29yay5FdmVudE5hbWVzIHx8IChOZXR3b3JrLkV2ZW50TmFtZXMgPSB7fSkpO1xufSkoTmV0d29yayB8fCAoZXhwb3J0cy5OZXR3b3JrID0gTmV0d29yayA9IHt9KSk7XG5leHBvcnRzLkVWRU5UX05BTUVTID0gbmV3IFNldChbXG4gICAgLy8ga2VlcC1zb3J0ZWQgc3RhcnRcbiAgICAuLi5PYmplY3QudmFsdWVzKEJpRGlNb2R1bGUpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoQnJvd3NpbmdDb250ZXh0LkV2ZW50TmFtZXMpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoTG9nLkV2ZW50TmFtZXMpLFxuICAgIC4uLk9iamVjdC52YWx1ZXMoTmV0d29yay5FdmVudE5hbWVzKSxcbiAgICAuLi5PYmplY3QudmFsdWVzKFNjcmlwdC5FdmVudE5hbWVzKSxcbiAgICAvLyBrZWVwLXNvcnRlZCBlbmRcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hyb21pdW0tYmlkaS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViZHJpdmVyLWJpZGktcGVybWlzc2lvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmRyaXZlci1iaWRpLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWl1bUJpZGkgPSBleHBvcnRzLkNkcCA9IHZvaWQgMDtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0cy5DZHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY2RwLmpzXCIpKTtcbmV4cG9ydHMuQ2hyb21pdW1CaWRpID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Nocm9taXVtLWJpZGkuanNcIikpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dlbmVyYXRlZC93ZWJkcml2ZXItYmlkaS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRXJyb3JSZXNwb25zZS5qc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ2VuZXJhdGVkL3dlYmRyaXZlci1iaWRpLXBlcm1pc3Npb25zLmpzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvY29sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJhc2U2NFRvU3RyaW5nID0gYmFzZTY0VG9TdHJpbmc7XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gYmFzZTY0LlxuICpcbiAqIFVzZXMgdGhlIG5hdGl2ZSBXZWIgQVBJIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG8gYSBOb2RlSlMgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBiYXNlNjRUb1N0cmluZyhiYXNlNjRTdHIpIHtcbiAgICAvLyBBdmFpbGFibGUgb25seSBpZiBydW4gaW4gYSBicm93c2VyIGNvbnRleHQuXG4gICAgaWYgKCdhdG9iJyBpbiBnbG9iYWxUaGlzKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmF0b2IoYmFzZTY0U3RyKTtcbiAgICB9XG4gICAgLy8gQXZhaWxhYmxlIG9ubHkgaWYgcnVuIGluIGEgTm9kZUpTIGNvbnRleHQuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NFN0ciwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJ1ZmZlciA9IHZvaWQgMDtcbi8qKiBJbXBsZW1lbnRzIGEgRklGTyBidWZmZXIgd2l0aCBhIGZpeGVkIHNpemUuICovXG5jbGFzcyBCdWZmZXIge1xuICAgICNjYXBhY2l0eTtcbiAgICAjZW50cmllcyA9IFtdO1xuICAgICNvbkl0ZW1SZW1vdmVkO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjYXBhY2l0eSBUaGUgYnVmZmVyIGNhcGFjaXR5LlxuICAgICAqIEBwYXJhbSBvbkl0ZW1SZW1vdmVkIERlbGVnYXRlIGNhbGxlZCBmb3IgZWFjaCByZW1vdmVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FwYWNpdHksIG9uSXRlbVJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy4jY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy4jb25JdGVtUmVtb3ZlZCA9IG9uSXRlbVJlbW92ZWQ7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2VudHJpZXM7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLiNlbnRyaWVzLnB1c2godmFsdWUpO1xuICAgICAgICB3aGlsZSAodGhpcy4jZW50cmllcy5sZW5ndGggPiB0aGlzLiNjYXBhY2l0eSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuI2VudHJpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNvbkl0ZW1SZW1vdmVkPy4oaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWZhdWx0TWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIE1hcCB3aG9zZSBmdW5jdGlvbmFsaXR5IGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBpdHMgcGFyZW50XG4gKiBleGNlcHQgZm9yIHRoZSBmYWN0IHRoYXQgRGVmYXVsdE1hcCBuZXZlciByZXR1cm5zIHVuZGVmaW5lZC4gSXQgcHJvdmlkZXMgYVxuICogZGVmYXVsdCB2YWx1ZSBmb3Iga2V5cyB0aGF0IGRvIG5vdCBleGlzdC5cbiAqL1xuY2xhc3MgRGVmYXVsdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgLyoqIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHJldHVybiB3aGVuZXZlciBhIGtleSBpcyBub3QgcHJlc2VudCBpbiB0aGUgbWFwLiAqL1xuICAgICNnZXREZWZhdWx0VmFsdWU7XG4gICAgY29uc3RydWN0b3IoZ2V0RGVmYXVsdFZhbHVlLCBlbnRyaWVzKSB7XG4gICAgICAgIHN1cGVyKGVudHJpZXMpO1xuICAgICAgICB0aGlzLiNnZXREZWZhdWx0VmFsdWUgPSBnZXREZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHRoaXMuI2dldERlZmF1bHRWYWx1ZShrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0TWFwID0gRGVmYXVsdE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmF1bHRNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVmZXJyZWQgPSB2b2lkIDA7XG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgI2lzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAjcHJvbWlzZTtcbiAgICAjcmVzdWx0O1xuICAgICNyZXNvbHZlO1xuICAgICNyZWplY3Q7XG4gICAgZ2V0IGlzRmluaXNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpc0ZpbmlzaGVkO1xuICAgIH1cbiAgICBnZXQgcmVzdWx0KCkge1xuICAgICAgICBpZiAoIXRoaXMuI2lzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmZXJyZWQgaXMgbm90IGZpbmlzaGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLiNwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLiNyZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOZWVkZWQgdG8gYXZvaWQgYFVuY2F1Z2h0IChpbiBwcm9taXNlKWAuIFRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBgdGhlbmBcbiAgICAgICAgLy8gYW5kIGBjYXRjaGAgd2lsbCBiZSByZWplY3RlZCBhbnl3YXkuXG4gICAgICAgIHRoaXMuI3Byb21pc2UuY2F0Y2goKF9lcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb21pc2UudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3Byb21pc2UuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfVxuICAgIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy4jcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy4jaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy4jaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNyZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWplY3QocmVhc29uKSB7XG4gICAgICAgIGlmICghdGhpcy4jaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy4jaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiNyZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHJvbWlzZS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ1Byb21pc2UnO1xufVxuZXhwb3J0cy5EZWZlcnJlZCA9IERlZmVycmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJyZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kaXN0aW5jdFZhbHVlcyA9IGRpc3RpbmN0VmFsdWVzO1xuZXhwb3J0cy5kZXRlcm1pbmlzdGljSlNPTlN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNKU09OU3RyaW5naWZ5O1xuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRpc3RpbmN0IHZhbHVlcy4gT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQuXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBmaWx0ZXIuIFNob3VsZCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbiAqIEByZXR1cm4gLSBBbiBhcnJheSBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VmFsdWVzKHZhbHVlcykge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBtYXAuc2V0KGRldGVybWluaXN0aWNKU09OU3RyaW5naWZ5KHZhbHVlKSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShtYXAudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgb2JqZWN0IHdpdGgga2V5cyBzb3J0ZWQuIFRoaXMgaXMgcmVxdWlyZWQgdG9cbiAqIGVuc3VyZSB0aGF0IHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIGFuIG9iamVjdCBpcyBkZXRlcm1pbmlzdGljIGluZGVwZW5kZW50IG9mIHRoZVxuICogb3JkZXIgb2Yga2V5cy5cbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0pTT05TdHJpbmdpZnkob2JqKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZU9iamVjdChvYmopKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgb2JqID09PSBudWxsIHx8XG4gICAgICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBDb3B5IHRoZSBvcmlnaW5hbCBvYmplY3Qga2V5IGFuZCB2YWx1ZXMgdG8gYSBuZXcgb2JqZWN0IGluIHNvcnRlZCBvcmRlci5cbiAgICBjb25zdCBuZXdPYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopLnNvcnQoKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBuZXdPYmpba2V5XSA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZSk7IC8vIFJlY3Vyc2l2ZWx5IHNvcnQgbmVzdGVkIG9iamVjdHNcbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpc3RpbmN0VmFsdWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG4vKipcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG1pdHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibWl0dFwiKSk7XG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuICAgICNlbWl0dGVyID0gKDAsIG1pdHRfMS5kZWZhdWx0KSgpO1xuICAgIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy4jZW1pdHRlci5vbih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpa2UgYG9uYCBidXQgdGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBmaXJlZCBvbmNlIGFuZCB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHlvdSdkIGxpa2UgdG8gbGlzdGVuIHRvXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIGhhbmRsZXIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIGV2ZW50IG9jY3Vyc1xuICAgICAqIEByZXR1cm4gYHRoaXNgIHRvIGVuYWJsZSBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgb25jZShldmVudCwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBvbmNlSGFuZGxlciA9IChldmVudERhdGEpID0+IHtcbiAgICAgICAgICAgIGhhbmRsZXIoZXZlbnREYXRhKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgfVxuICAgIG9mZih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIub2ZmKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYW5kIGNhbGwgYW55IGFzc29jaWF0ZWQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBlbWl0LlxuICAgICAqIEBwYXJhbSBldmVudERhdGEgQW55IGRhdGEgdG8gZW1pdCB3aXRoIHRoZSBldmVudC5cbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGVyZSBhcmUgYW55IGxpc3RlbmVycywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZW1pdChldmVudCwgZXZlbnREYXRhKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIuZW1pdChldmVudCwgZXZlbnREYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBJZiBnaXZlbiBhbiBldmVudCBhcmd1bWVudCwgaXQgd2lsbCByZW1vdmUgb25seVxuICAgICAqIGxpc3RlbmVycyBmb3IgdGhhdCBldmVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgLSB0aGUgZXZlbnQgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3IuXG4gICAgICogQHJldHVybnMgYHRoaXNgIHRvIGVuYWJsZSB5b3UgdG8gY2hhaW4gbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuI2VtaXR0ZXIuYWxsLmRlbGV0ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNlbWl0dGVyLmFsbC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRFbWl0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNTaW5nbGVDb21wbGV4R3JhcGhlbWUgPSBpc1NpbmdsZUNvbXBsZXhHcmFwaGVtZTtcbmV4cG9ydHMuaXNTaW5nbGVHcmFwaGVtZSA9IGlzU2luZ2xlR3JhcGhlbWU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzaW5nbGUgY29tcGxleCBncmFwaGVtZS4gQSBjb21wbGV4IGdyYXBoZW1lIGlzIG9uZSB0aGF0XG4gKiBpcyBtYWRlIHVwIG9mIG11bHRpcGxlIGNoYXJhY3RlcnMuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlQ29tcGxleEdyYXBoZW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzU2luZ2xlR3JhcGhlbWUodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDE7XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gKi9cbmZ1bmN0aW9uIGlzU2luZ2xlR3JhcGhlbWUodmFsdWUpIHtcbiAgICAvLyBUaGVvcmV0aWNhbGx5IHRoZXJlIGNhbiBiZSBzb21lIHN0cmluZ3MgY29uc2lkZXJlZCBhIGdyYXBoZW1lIGluIHNvbWUgbG9jYWxlcywgbGlrZVxuICAgIC8vIHNsb3ZhayBcImNoXCIgZGlncmFwaC4gVXNlIGVuZ2xpc2ggbG9jYWxlIGZvciBjb25zaXN0ZW5jeS5cbiAgICAvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0dyYXBoZW1lX0NsdXN0ZXJfQm91bmRhcmllc1xuICAgIGNvbnN0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcignZW4nLCB7IGdyYW51bGFyaXR5OiAnZ3JhcGhlbWUnIH0pO1xuICAgIHJldHVybiBbLi4uc2VnbWVudGVyLnNlZ21lbnQodmFsdWUpXS5sZW5ndGggPT09IDE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HcmFwaGVtZVRvb2xzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkV3JhcHBlciA9IHZvaWQgMDtcbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCBhIHBvc2l0aXZlIHVuaXF1ZSBpbmNyZW1lbnRpbmcgaWQuXG4gKi9cbmNsYXNzIElkV3JhcHBlciB7XG4gICAgc3RhdGljICNjb3VudGVyID0gMDtcbiAgICAjaWQ7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2lkID0gKytJZFdyYXBwZXIuI2NvdW50ZXI7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2lkO1xuICAgIH1cbn1cbmV4cG9ydHMuSWRXcmFwcGVyID0gSWRXcmFwcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SWRXcmFwcGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKiBDb3B5cmlnaHQgMjAyMiBUaGUgQ2hyb21pdW0gQXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXV0ZXggPSB2b2lkIDA7XG4vKipcbiAqIFVzZSBNdXRleCBjbGFzcyB0byBjb29yZGluYXRlIGxvY2FsIGNvbmN1cnJlbnQgb3BlcmF0aW9ucy5cbiAqIE9uY2UgYGFjcXVpcmVgIHByb21pc2UgcmVzb2x2ZXMsIHlvdSBob2xkIHRoZSBsb2NrIGFuZCBtdXN0XG4gKiBjYWxsIGByZWxlYXNlYCBmdW5jdGlvbiByZXR1cm5lZCBieSBgYWNxdWlyZWAgdG8gcmVsZWFzZSB0aGVcbiAqIGxvY2suIEZhaWxpbmcgdG8gYHJlbGVhc2VgIHRoZSBsb2NrIG1heSBsZWFkIHRvIGRlYWRsb2Nrcy5cbiAqL1xuY2xhc3MgTXV0ZXgge1xuICAgICNsb2NrZWQgPSBmYWxzZTtcbiAgICAjYWNxdWlyZXJzID0gW107XG4gICAgLy8gVGhpcyBpcyBGSUZPLlxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0geyByZXNvbHZlZDogZmFsc2UgfTtcbiAgICAgICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYWNxdWlyZXJzLnB1c2goKCkgPT4gcmVzb2x2ZSh0aGlzLiNyZWxlYXNlLmJpbmQodGhpcywgc3RhdGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuI3JlbGVhc2UuYmluZCh0aGlzLCBzdGF0ZSkpO1xuICAgIH1cbiAgICAjcmVsZWFzZShzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbGVhc2UgbW9yZSB0aGFuIG9uY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy4jYWNxdWlyZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghcmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBydW4oYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlbGVhc2UgPSBhd2FpdCB0aGlzLmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5vdGUgd2UgbmVlZCB0byBhd2FpdCBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYXdhaXQgdG8gcmVsZWFzZSBBRlRFUlxuICAgICAgICAgICAgLy8gdGhhdCBhd2FpdCBoYXBwZW5zLiBSZXR1cm5pbmcgYWN0aW9uKCkgd2lsbCB0cmlnZ2VyIHRoZSByZWxlYXNlXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSB3aGljaCBpcyBjb3VudGVyIHRvIHdoYXQgd2Ugd2FudC5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTXV0ZXggPSBNdXRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11dGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ19qc18xID0gcmVxdWlyZShcIi4vbG9nLmpzXCIpO1xuY2xhc3MgUHJvY2Vzc2luZ1F1ZXVlIHtcbiAgICBzdGF0aWMgTE9HR0VSX1BSRUZJWCA9IGAke2xvZ19qc18xLkxvZ1R5cGUuZGVidWd9OnF1ZXVlYDtcbiAgICAjbG9nZ2VyO1xuICAgICNwcm9jZXNzb3I7XG4gICAgI3F1ZXVlID0gW107XG4gICAgLy8gRmxhZyB0byBrZWVwIG9ubHkgMSBhY3RpdmUgcHJvY2Vzc29yLlxuICAgICNpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcihwcm9jZXNzb3IsIGxvZ2dlcikge1xuICAgICAgICB0aGlzLiNwcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgIHRoaXMuI2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB9XG4gICAgYWRkKGVudHJ5LCBuYW1lKSB7XG4gICAgICAgIHRoaXMuI3F1ZXVlLnB1c2goW2VudHJ5LCBuYW1lXSk7XG4gICAgICAgIC8vIE5vIG5lZWQgaW4gd2FpdGluZy4gSnVzdCBpbml0aWFsaXplIHByb2Nlc3NvciBpZiBuZWVkZWQuXG4gICAgICAgIHZvaWQgdGhpcy4jcHJvY2Vzc0lmTmVlZGVkKCk7XG4gICAgfVxuICAgIGFzeW5jICNwcm9jZXNzSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLiNpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy4jcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlFbnRyeSA9IHRoaXMuI3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWFycmF5RW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtlbnRyeVByb21pc2UsIG5hbWVdID0gYXJyYXlFbnRyeTtcbiAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKFByb2Nlc3NpbmdRdWV1ZS5MT0dHRVJfUFJFRklYLCAnUHJvY2Vzc2luZyBldmVudDonLCBuYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGVudHJ5UHJvbWlzZVxuICAgICAgICAgICAgICAgIC50aGVuKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5raW5kID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ0V2ZW50IHRocmV3IGJlZm9yZSBzZW5kaW5nOicsIGVudHJ5LmVycm9yLm1lc3NhZ2UsIGVudHJ5LmVycm9yLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jcHJvY2Vzc29yKGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvZ2dlcj8uKGxvZ19qc18xLkxvZ1R5cGUuZGVidWdFcnJvciwgJ0V2ZW50IHdhcyBub3QgcHJvY2Vzc2VkOicsIGVycm9yPy5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2lzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvY2Vzc2luZ1F1ZXVlID0gUHJvY2Vzc2luZ1F1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvY2Vzc2luZ1F1ZXVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VUkxQYXR0ZXJuID0gdm9pZCAwO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCB1cmxwYXR0ZXJuX3BvbHlmaWxsXzEgPSByZXF1aXJlKFwidXJscGF0dGVybi1wb2x5ZmlsbFwiKTtcbi8vIFhYWDogU3dpdGNoIHRvIG5hdGl2ZSBVUkxQYXR0ZXJuIHdoZW4gYXZhaWxhYmxlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MDg0NFxubGV0IFVSTFBhdHRlcm4gPSB1cmxwYXR0ZXJuX3BvbHlmaWxsXzEuVVJMUGF0dGVybjtcbmV4cG9ydHMuVVJMUGF0dGVybiA9IFVSTFBhdHRlcm47XG5pZiAoJ1VSTFBhdHRlcm4nIGluIGdsb2JhbFRoaXMpIHtcbiAgICBleHBvcnRzLlVSTFBhdHRlcm4gPSBVUkxQYXR0ZXJuID0gZ2xvYmFsVGhpcy5VUkxQYXR0ZXJuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXJsUGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgPz8gJ0ludGVybmFsIGFzc2VydGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLlxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ1R5cGUgPSB2b2lkIDA7XG52YXIgTG9nVHlwZTtcbihmdW5jdGlvbiAoTG9nVHlwZSkge1xuICAgIC8vIGtlZXAtc29ydGVkIHN0YXJ0XG4gICAgTG9nVHlwZVtcImJpZGlcIl0gPSBcImJpZGlcIjtcbiAgICBMb2dUeXBlW1wiY2RwXCJdID0gXCJjZHBcIjtcbiAgICBMb2dUeXBlW1wiZGVidWdcIl0gPSBcImRlYnVnXCI7XG4gICAgTG9nVHlwZVtcImRlYnVnRXJyb3JcIl0gPSBcImRlYnVnOmVycm9yXCI7XG4gICAgTG9nVHlwZVtcImRlYnVnSW5mb1wiXSA9IFwiZGVidWc6aW5mb1wiO1xuICAgIC8vIGtlZXAtc29ydGVkIGVuZFxufSkoTG9nVHlwZSB8fCAoZXhwb3J0cy5Mb2dUeXBlID0gTG9nVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTEMuXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5jaGVzRnJvbUNtID0gaW5jaGVzRnJvbUNtO1xuLyoqIEByZXR1cm4gR2l2ZW4gYW4gaW5wdXQgaW4gY20sIGNvbnZlcnQgaXQgdG8gaW5jaGVzLiAqL1xuZnVuY3Rpb24gaW5jaGVzRnJvbUNtKGNtKSB7XG4gICAgcmV0dXJuIGNtIC8gMi41NDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXRDb252ZXJzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQy5cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dWlkdjQgPSB1dWlkdjQ7XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2NCBVVUlELCBhcyBzcGVjaWZpZWQgaW4gUkZDNDEyMi5cbiAqXG4gKiBVc2VzIHRoZSBuYXRpdmUgV2ViIENyeXB0byBBUEkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbHMgYmFjayB0byBhXG4gKiBwb2x5ZmlsbC5cbiAqXG4gKiBFeGFtcGxlOiAnOWIxZGViNGQtM2I3ZC00YmFkLTliZGQtMmIwZDdiM2RjYjZkJ1xuICovXG5mdW5jdGlvbiB1dWlkdjQoKSB7XG4gICAgLy8gQXZhaWxhYmxlIG9ubHkgaW4gc2VjdXJlIGNvbnRleHRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9DcnlwdG9fQVBJXG4gICAgaWYgKCdjcnlwdG8nIGluIGdsb2JhbFRoaXMgJiYgJ3JhbmRvbVVVSUQnIGluIGdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgICAgIC8vIE5vZGUgd2l0aFxuICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjIwLngvZG9jcy9hcGkvZ2xvYmFscy5odG1sI2NyeXB0b18xIG9yXG4gICAgICAgIC8vIHNlY3VyZSBicm93c2VyIGNvbnRleHQuXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbVZhbHVlcyA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBpZiAoJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyAmJiAnZ2V0UmFuZG9tVmFsdWVzJyBpbiBnbG9iYWxUaGlzLmNyeXB0bykge1xuICAgICAgICAvLyBOb2RlIHdpdGhcbiAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0LXYyMC54L2RvY3MvYXBpL2dsb2JhbHMuaHRtbCNjcnlwdG9fMSBvclxuICAgICAgICAvLyBicm93c2VyLlxuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tVmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgd2l0aG91dFxuICAgICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjIwLngvZG9jcy9hcGkvZ2xvYmFscy5odG1sI2NyeXB0b18xLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgICByZXF1aXJlKCdjcnlwdG8nKS53ZWJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbVZhbHVlcyk7XG4gICAgfVxuICAgIC8vIFNldCB2ZXJzaW9uICg0KSBhbmQgdmFyaWFudCAoUkZDNDEyMikgYml0cy5cbiAgICByYW5kb21WYWx1ZXNbNl0gPSAocmFuZG9tVmFsdWVzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJhbmRvbVZhbHVlc1s4XSA9IChyYW5kb21WYWx1ZXNbOF0gJiAweDNmKSB8IDB4ODA7XG4gICAgY29uc3QgYnl0ZXNUb0hleCA9IChieXRlcykgPT4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBieXRlc1RvSGV4KHJhbmRvbVZhbHVlcy5zdWJhcnJheSgwLCA0KSksXG4gICAgICAgIGJ5dGVzVG9IZXgocmFuZG9tVmFsdWVzLnN1YmFycmF5KDQsIDYpKSxcbiAgICAgICAgYnl0ZXNUb0hleChyYW5kb21WYWx1ZXMuc3ViYXJyYXkoNiwgOCkpLFxuICAgICAgICBieXRlc1RvSGV4KHJhbmRvbVZhbHVlcy5zdWJhcnJheSg4LCAxMCkpLFxuICAgICAgICBieXRlc1RvSGV4KHJhbmRvbVZhbHVlcy5zdWJhcnJheSgxMCwgMTYpKSxcbiAgICBdLmpvaW4oJy0nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV1aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIE09T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBQZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBSZT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgRWU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTt2YXIgT2U9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClNKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxrZT0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IGEgb2YgUmUodCkpIUVlLmNhbGwoZSxhKSYmYSE9PXImJk0oZSxhLHtnZXQ6KCk9PnRbYV0sZW51bWVyYWJsZTohKG49UGUodCxhKSl8fG4uZW51bWVyYWJsZX0pO3JldHVybiBlfTt2YXIgVGU9ZT0+a2UoTSh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgTmU9e307T2UoTmUse1VSTFBhdHRlcm46KCk9Pll9KTttb2R1bGUuZXhwb3J0cz1UZShOZSk7dmFyIFI9Y2xhc3N7dHlwZT0zO25hbWU9XCJcIjtwcmVmaXg9XCJcIjt2YWx1ZT1cIlwiO3N1ZmZpeD1cIlwiO21vZGlmaWVyPTM7Y29uc3RydWN0b3IodCxyLG4sYSxjLGwpe3RoaXMudHlwZT10LHRoaXMubmFtZT1yLHRoaXMucHJlZml4PW4sdGhpcy52YWx1ZT1hLHRoaXMuc3VmZml4PWMsdGhpcy5tb2RpZmllcj1sfWhhc0N1c3RvbU5hbWUoKXtyZXR1cm4gdGhpcy5uYW1lIT09XCJcIiYmdHlwZW9mIHRoaXMubmFtZSE9XCJudW1iZXJcIn19LEFlPS9bJF9cXHB7SURfU3RhcnR9XS91LHllPS9bJF9cXHUyMDBDXFx1MjAwRFxccHtJRF9Db250aW51ZX1dL3Usdj1cIi4qXCI7ZnVuY3Rpb24gd2UoZSx0KXtyZXR1cm4odD8vXltcXHgwMC1cXHhGRl0qJC86L15bXFx4MDAtXFx4N0ZdKiQvKS50ZXN0KGUpfWZ1bmN0aW9uIEQoZSx0PSExKXtsZXQgcj1bXSxuPTA7Zm9yKDtuPGUubGVuZ3RoOyl7bGV0IGE9ZVtuXSxjPWZ1bmN0aW9uKGwpe2lmKCF0KXRocm93IG5ldyBUeXBlRXJyb3IobCk7ci5wdXNoKHt0eXBlOlwiSU5WQUxJRF9DSEFSXCIsaW5kZXg6bix2YWx1ZTplW24rK119KX07aWYoYT09PVwiKlwiKXtyLnB1c2goe3R5cGU6XCJBU1RFUklTS1wiLGluZGV4Om4sdmFsdWU6ZVtuKytdfSk7Y29udGludWV9aWYoYT09PVwiK1wifHxhPT09XCI/XCIpe3IucHVzaCh7dHlwZTpcIk9USEVSX01PRElGSUVSXCIsaW5kZXg6bix2YWx1ZTplW24rK119KTtjb250aW51ZX1pZihhPT09XCJcXFxcXCIpe3IucHVzaCh7dHlwZTpcIkVTQ0FQRURfQ0hBUlwiLGluZGV4Om4rKyx2YWx1ZTplW24rK119KTtjb250aW51ZX1pZihhPT09XCJ7XCIpe3IucHVzaCh7dHlwZTpcIk9QRU5cIixpbmRleDpuLHZhbHVlOmVbbisrXX0pO2NvbnRpbnVlfWlmKGE9PT1cIn1cIil7ci5wdXNoKHt0eXBlOlwiQ0xPU0VcIixpbmRleDpuLHZhbHVlOmVbbisrXX0pO2NvbnRpbnVlfWlmKGE9PT1cIjpcIil7bGV0IGw9XCJcIixzPW4rMTtmb3IoO3M8ZS5sZW5ndGg7KXtsZXQgaT1lLnN1YnN0cihzLDEpO2lmKHM9PT1uKzEmJkFlLnRlc3QoaSl8fHMhPT1uKzEmJnllLnRlc3QoaSkpe2wrPWVbcysrXTtjb250aW51ZX1icmVha31pZighbCl7YyhgTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCAke259YCk7Y29udGludWV9ci5wdXNoKHt0eXBlOlwiTkFNRVwiLGluZGV4Om4sdmFsdWU6bH0pLG49cztjb250aW51ZX1pZihhPT09XCIoXCIpe2xldCBsPTEscz1cIlwiLGk9bisxLG89ITE7aWYoZVtpXT09PVwiP1wiKXtjKGBQYXR0ZXJuIGNhbm5vdCBzdGFydCB3aXRoIFwiP1wiIGF0ICR7aX1gKTtjb250aW51ZX1mb3IoO2k8ZS5sZW5ndGg7KXtpZighd2UoZVtpXSwhMSkpe2MoYEludmFsaWQgY2hhcmFjdGVyICcke2VbaV19JyBhdCAke2l9LmApLG89ITA7YnJlYWt9aWYoZVtpXT09PVwiXFxcXFwiKXtzKz1lW2krK10rZVtpKytdO2NvbnRpbnVlfWlmKGVbaV09PT1cIilcIil7aWYobC0tLGw9PT0wKXtpKys7YnJlYWt9fWVsc2UgaWYoZVtpXT09PVwiKFwiJiYobCsrLGVbaSsxXSE9PVwiP1wiKSl7YyhgQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgJHtpfWApLG89ITA7YnJlYWt9cys9ZVtpKytdfWlmKG8pY29udGludWU7aWYobCl7YyhgVW5iYWxhbmNlZCBwYXR0ZXJuIGF0ICR7bn1gKTtjb250aW51ZX1pZighcyl7YyhgTWlzc2luZyBwYXR0ZXJuIGF0ICR7bn1gKTtjb250aW51ZX1yLnB1c2goe3R5cGU6XCJSRUdFWFwiLGluZGV4Om4sdmFsdWU6c30pLG49aTtjb250aW51ZX1yLnB1c2goe3R5cGU6XCJDSEFSXCIsaW5kZXg6bix2YWx1ZTplW24rK119KX1yZXR1cm4gci5wdXNoKHt0eXBlOlwiRU5EXCIsaW5kZXg6bix2YWx1ZTpcIlwifSkscn1mdW5jdGlvbiBGKGUsdD17fSl7bGV0IHI9RChlKTt0LmRlbGltaXRlcj8/PVwiLyM/XCIsdC5wcmVmaXhlcz8/PVwiLi9cIjtsZXQgbj1gW14ke1ModC5kZWxpbWl0ZXIpfV0rP2AsYT1bXSxjPTAsbD0wLHM9XCJcIixpPW5ldyBTZXQsbz1oPT57aWYobDxyLmxlbmd0aCYmcltsXS50eXBlPT09aClyZXR1cm4gcltsKytdLnZhbHVlfSxmPSgpPT5vKFwiT1RIRVJfTU9ESUZJRVJcIik/P28oXCJBU1RFUklTS1wiKSxkPWg9PntsZXQgdT1vKGgpO2lmKHUhPT12b2lkIDApcmV0dXJuIHU7bGV0e3R5cGU6cCxpbmRleDpBfT1yW2xdO3Rocm93IG5ldyBUeXBlRXJyb3IoYFVuZXhwZWN0ZWQgJHtwfSBhdCAke0F9LCBleHBlY3RlZCAke2h9YCl9LFQ9KCk9PntsZXQgaD1cIlwiLHU7Zm9yKDt1PW8oXCJDSEFSXCIpPz9vKFwiRVNDQVBFRF9DSEFSXCIpOyloKz11O3JldHVybiBofSx4ZT1oPT5oLEw9dC5lbmNvZGVQYXJ0fHx4ZSxJPVwiXCIsVT1oPT57SSs9aH0sJD0oKT0+e0kubGVuZ3RoJiYoYS5wdXNoKG5ldyBSKDMsXCJcIixcIlwiLEwoSSksXCJcIiwzKSksST1cIlwiKX0sWD0oaCx1LHAsQSxaKT0+e2xldCBnPTM7c3dpdGNoKFope2Nhc2VcIj9cIjpnPTE7YnJlYWs7Y2FzZVwiKlwiOmc9MDticmVhaztjYXNlXCIrXCI6Zz0yO2JyZWFrfWlmKCF1JiYhcCYmZz09PTMpe1UoaCk7cmV0dXJufWlmKCQoKSwhdSYmIXApe2lmKCFoKXJldHVybjthLnB1c2gobmV3IFIoMyxcIlwiLFwiXCIsTChoKSxcIlwiLGcpKTtyZXR1cm59bGV0IG07cD9wPT09XCIqXCI/bT12Om09cDptPW47bGV0IE89MjttPT09bj8oTz0xLG09XCJcIik6bT09PXYmJihPPTAsbT1cIlwiKTtsZXQgUDtpZih1P1A9dTpwJiYoUD1jKyspLGkuaGFzKFApKXRocm93IG5ldyBUeXBlRXJyb3IoYER1cGxpY2F0ZSBuYW1lICcke1B9Jy5gKTtpLmFkZChQKSxhLnB1c2gobmV3IFIoTyxQLEwoaCksbSxMKEEpLGcpKX07Zm9yKDtsPHIubGVuZ3RoOyl7bGV0IGg9byhcIkNIQVJcIiksdT1vKFwiTkFNRVwiKSxwPW8oXCJSRUdFWFwiKTtpZighdSYmIXAmJihwPW8oXCJBU1RFUklTS1wiKSksdXx8cCl7bGV0IGc9aD8/XCJcIjt0LnByZWZpeGVzLmluZGV4T2YoZyk9PT0tMSYmKFUoZyksZz1cIlwiKSwkKCk7bGV0IG09ZigpO1goZyx1LHAsXCJcIixtKTtjb250aW51ZX1sZXQgQT1oPz9vKFwiRVNDQVBFRF9DSEFSXCIpO2lmKEEpe1UoQSk7Y29udGludWV9aWYobyhcIk9QRU5cIikpe2xldCBnPVQoKSxtPW8oXCJOQU1FXCIpLE89byhcIlJFR0VYXCIpOyFtJiYhTyYmKE89byhcIkFTVEVSSVNLXCIpKTtsZXQgUD1UKCk7ZChcIkNMT1NFXCIpO2xldCBiZT1mKCk7WChnLG0sTyxQLGJlKTtjb250aW51ZX0kKCksZChcIkVORFwiKX1yZXR1cm4gYX1mdW5jdGlvbiBTKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbLisqP14ke30oKVtcXF18L1xcXFxdKS9nLFwiXFxcXCQxXCIpfWZ1bmN0aW9uIEIoZSl7cmV0dXJuIGUmJmUuaWdub3JlQ2FzZT9cInVpXCI6XCJ1XCJ9ZnVuY3Rpb24gcShlLHQscil7cmV0dXJuIFcoRihlLHIpLHQscil9ZnVuY3Rpb24gayhlKXtzd2l0Y2goZSl7Y2FzZSAwOnJldHVyblwiKlwiO2Nhc2UgMTpyZXR1cm5cIj9cIjtjYXNlIDI6cmV0dXJuXCIrXCI7Y2FzZSAzOnJldHVyblwiXCJ9fWZ1bmN0aW9uIFcoZSx0LHI9e30pe3IuZGVsaW1pdGVyPz89XCIvIz9cIixyLnByZWZpeGVzPz89XCIuL1wiLHIuc2Vuc2l0aXZlPz89ITEsci5zdHJpY3Q/Pz0hMSxyLmVuZD8/PSEwLHIuc3RhcnQ/Pz0hMCxyLmVuZHNXaXRoPVwiXCI7bGV0IG49ci5zdGFydD9cIl5cIjpcIlwiO2ZvcihsZXQgcyBvZiBlKXtpZihzLnR5cGU9PT0zKXtzLm1vZGlmaWVyPT09Mz9uKz1TKHMudmFsdWUpOm4rPWAoPzoke1Mocy52YWx1ZSl9KSR7ayhzLm1vZGlmaWVyKX1gO2NvbnRpbnVlfXQmJnQucHVzaChzLm5hbWUpO2xldCBpPWBbXiR7UyhyLmRlbGltaXRlcil9XSs/YCxvPXMudmFsdWU7aWYocy50eXBlPT09MT9vPWk6cy50eXBlPT09MCYmKG89diksIXMucHJlZml4Lmxlbmd0aCYmIXMuc3VmZml4Lmxlbmd0aCl7cy5tb2RpZmllcj09PTN8fHMubW9kaWZpZXI9PT0xP24rPWAoJHtvfSkke2socy5tb2RpZmllcil9YDpuKz1gKCg/OiR7b30pJHtrKHMubW9kaWZpZXIpfSlgO2NvbnRpbnVlfWlmKHMubW9kaWZpZXI9PT0zfHxzLm1vZGlmaWVyPT09MSl7bis9YCg/OiR7UyhzLnByZWZpeCl9KCR7b30pJHtTKHMuc3VmZml4KX0pYCxuKz1rKHMubW9kaWZpZXIpO2NvbnRpbnVlfW4rPWAoPzoke1Mocy5wcmVmaXgpfWAsbis9YCgoPzoke299KSg/OmAsbis9UyhzLnN1ZmZpeCksbis9UyhzLnByZWZpeCksbis9YCg/OiR7b30pKSopJHtTKHMuc3VmZml4KX0pYCxzLm1vZGlmaWVyPT09MCYmKG4rPVwiP1wiKX1sZXQgYT1gWyR7UyhyLmVuZHNXaXRoKX1dfCRgLGM9YFske1Moci5kZWxpbWl0ZXIpfV1gO2lmKHIuZW5kKXJldHVybiByLnN0cmljdHx8KG4rPWAke2N9P2ApLHIuZW5kc1dpdGgubGVuZ3RoP24rPWAoPz0ke2F9KWA6bis9XCIkXCIsbmV3IFJlZ0V4cChuLEIocikpO3Iuc3RyaWN0fHwobis9YCg/OiR7Y30oPz0ke2F9KSk/YCk7bGV0IGw9ITE7aWYoZS5sZW5ndGgpe2xldCBzPWVbZS5sZW5ndGgtMV07cy50eXBlPT09MyYmcy5tb2RpZmllcj09PTMmJihsPXIuZGVsaW1pdGVyLmluZGV4T2Yocyk+LTEpfXJldHVybiBsfHwobis9YCg/PSR7Y318JHthfSlgKSxuZXcgUmVnRXhwKG4sQihyKSl9dmFyIHg9e2RlbGltaXRlcjpcIlwiLHByZWZpeGVzOlwiXCIsc2Vuc2l0aXZlOiEwLHN0cmljdDohMH0sSj17ZGVsaW1pdGVyOlwiLlwiLHByZWZpeGVzOlwiXCIsc2Vuc2l0aXZlOiEwLHN0cmljdDohMH0sUT17ZGVsaW1pdGVyOlwiL1wiLHByZWZpeGVzOlwiL1wiLHNlbnNpdGl2ZTohMCxzdHJpY3Q6ITB9O2Z1bmN0aW9uIGVlKGUsdCl7cmV0dXJuIGUubGVuZ3RoP2VbMF09PT1cIi9cIj8hMDohdHx8ZS5sZW5ndGg8Mj8hMTooZVswXT09XCJcXFxcXCJ8fGVbMF09PVwie1wiKSYmZVsxXT09XCIvXCI6ITF9ZnVuY3Rpb24gdGUoZSx0KXtyZXR1cm4gZS5zdGFydHNXaXRoKHQpP2Uuc3Vic3RyaW5nKHQubGVuZ3RoLGUubGVuZ3RoKTplfWZ1bmN0aW9uIENlKGUsdCl7cmV0dXJuIGUuZW5kc1dpdGgodCk/ZS5zdWJzdHIoMCxlLmxlbmd0aC10Lmxlbmd0aCk6ZX1mdW5jdGlvbiBfKGUpe3JldHVybiFlfHxlLmxlbmd0aDwyPyExOmVbMF09PT1cIltcInx8KGVbMF09PT1cIlxcXFxcInx8ZVswXT09PVwie1wiKSYmZVsxXT09PVwiW1wifXZhciByZT1bXCJmdHBcIixcImZpbGVcIixcImh0dHBcIixcImh0dHBzXCIsXCJ3c1wiLFwid3NzXCJdO2Z1bmN0aW9uIE4oZSl7aWYoIWUpcmV0dXJuITA7Zm9yKGxldCB0IG9mIHJlKWlmKGUudGVzdCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBuZShlLHQpe2lmKGU9dGUoZSxcIiNcIiksdHx8ZT09PVwiXCIpcmV0dXJuIGU7bGV0IHI9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHIuaGFzaD1lLHIuaGFzaD9yLmhhc2guc3Vic3RyaW5nKDEsci5oYXNoLmxlbmd0aCk6XCJcIn1mdW5jdGlvbiBzZShlLHQpe2lmKGU9dGUoZSxcIj9cIiksdHx8ZT09PVwiXCIpcmV0dXJuIGU7bGV0IHI9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHIuc2VhcmNoPWUsci5zZWFyY2g/ci5zZWFyY2guc3Vic3RyaW5nKDEsci5zZWFyY2gubGVuZ3RoKTpcIlwifWZ1bmN0aW9uIGllKGUsdCl7cmV0dXJuIHR8fGU9PT1cIlwiP2U6XyhlKT9LKGUpOmooZSl9ZnVuY3Rpb24gYWUoZSx0KXtpZih0fHxlPT09XCJcIilyZXR1cm4gZTtsZXQgcj1uZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtyZXR1cm4gci5wYXNzd29yZD1lLHIucGFzc3dvcmR9ZnVuY3Rpb24gb2UoZSx0KXtpZih0fHxlPT09XCJcIilyZXR1cm4gZTtsZXQgcj1uZXcgVVJMKFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiKTtyZXR1cm4gci51c2VybmFtZT1lLHIudXNlcm5hbWV9ZnVuY3Rpb24gY2UoZSx0LHIpe2lmKHJ8fGU9PT1cIlwiKXJldHVybiBlO2lmKHQmJiFyZS5pbmNsdWRlcyh0KSlyZXR1cm4gbmV3IFVSTChgJHt0fToke2V9YCkucGF0aG5hbWU7bGV0IG49ZVswXT09XCIvXCI7cmV0dXJuIGU9bmV3IFVSTChuP2U6XCIvLVwiK2UsXCJodHRwczovL2V4YW1wbGUuY29tXCIpLnBhdGhuYW1lLG58fChlPWUuc3Vic3RyaW5nKDIsZS5sZW5ndGgpKSxlfWZ1bmN0aW9uIGxlKGUsdCxyKXtyZXR1cm4geih0KT09PWUmJihlPVwiXCIpLHJ8fGU9PT1cIlwiP2U6RyhlKX1mdW5jdGlvbiBmZShlLHQpe3JldHVybiBlPUNlKGUsXCI6XCIpLHR8fGU9PT1cIlwiP2U6eShlKX1mdW5jdGlvbiB6KGUpe3N3aXRjaChlKXtjYXNlXCJ3c1wiOmNhc2VcImh0dHBcIjpyZXR1cm5cIjgwXCI7Y2FzZVwid3dzXCI6Y2FzZVwiaHR0cHNcIjpyZXR1cm5cIjQ0M1wiO2Nhc2VcImZ0cFwiOnJldHVyblwiMjFcIjtkZWZhdWx0OnJldHVyblwiXCJ9fWZ1bmN0aW9uIHkoZSl7aWYoZT09PVwiXCIpcmV0dXJuIGU7aWYoL15bLSsuQS1aYS16MC05XSokLy50ZXN0KGUpKXJldHVybiBlLnRvTG93ZXJDYXNlKCk7dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBwcm90b2NvbCAnJHtlfScuYCl9ZnVuY3Rpb24gaGUoZSl7aWYoZT09PVwiXCIpcmV0dXJuIGU7bGV0IHQ9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHQudXNlcm5hbWU9ZSx0LnVzZXJuYW1lfWZ1bmN0aW9uIHVlKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0LnBhc3N3b3JkPWUsdC5wYXNzd29yZH1mdW5jdGlvbiBqKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2lmKC9bXFx0XFxuXFxyICMlLzo8Pj9AW1xcXV5cXFxcfF0vZy50ZXN0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgaG9zdG5hbWUgJyR7ZX0nYCk7bGV0IHQ9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHQuaG9zdG5hbWU9ZSx0Lmhvc3RuYW1lfWZ1bmN0aW9uIEsoZSl7aWYoZT09PVwiXCIpcmV0dXJuIGU7aWYoL1teMC05YS1mQS1GW1xcXTpdL2cudGVzdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIElQdjYgaG9zdG5hbWUgJyR7ZX0nYCk7cmV0dXJuIGUudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiBHKGUpe2lmKGU9PT1cIlwifHwvXlswLTldKiQvLnRlc3QoZSkmJnBhcnNlSW50KGUpPD02NTUzNSlyZXR1cm4gZTt0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHBvcnQgJyR7ZX0nLmApfWZ1bmN0aW9uIGRlKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0LnBhdGhuYW1lPWVbMF0hPT1cIi9cIj9cIi8tXCIrZTplLGVbMF0hPT1cIi9cIj90LnBhdGhuYW1lLnN1YnN0cmluZygyLHQucGF0aG5hbWUubGVuZ3RoKTp0LnBhdGhuYW1lfWZ1bmN0aW9uIHBlKGUpe3JldHVybiBlPT09XCJcIj9lOm5ldyBVUkwoYGRhdGE6JHtlfWApLnBhdGhuYW1lfWZ1bmN0aW9uIGdlKGUpe2lmKGU9PT1cIlwiKXJldHVybiBlO2xldCB0PW5ldyBVUkwoXCJodHRwczovL2V4YW1wbGUuY29tXCIpO3JldHVybiB0LnNlYXJjaD1lLHQuc2VhcmNoLnN1YnN0cmluZygxLHQuc2VhcmNoLmxlbmd0aCl9ZnVuY3Rpb24gbWUoZSl7aWYoZT09PVwiXCIpcmV0dXJuIGU7bGV0IHQ9bmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIik7cmV0dXJuIHQuaGFzaD1lLHQuaGFzaC5zdWJzdHJpbmcoMSx0Lmhhc2gubGVuZ3RoKX12YXIgSD1jbGFzc3sjaTsjbj1bXTsjdD17fTsjZT0wOyNzPTE7I2w9MDsjbz0wOyNkPTA7I3A9MDsjZz0hMTtjb25zdHJ1Y3Rvcih0KXt0aGlzLiNpPXR9Z2V0IHJlc3VsdCgpe3JldHVybiB0aGlzLiN0fXBhcnNlKCl7Zm9yKHRoaXMuI249RCh0aGlzLiNpLCEwKTt0aGlzLiNlPHRoaXMuI24ubGVuZ3RoO3RoaXMuI2UrPXRoaXMuI3Mpe2lmKHRoaXMuI3M9MSx0aGlzLiNuW3RoaXMuI2VdLnR5cGU9PT1cIkVORFwiKXtpZih0aGlzLiNvPT09MCl7dGhpcy4jYigpLHRoaXMuI2YoKT90aGlzLiNyKDksMSk6dGhpcy4jaCgpP3RoaXMuI3IoOCwxKTp0aGlzLiNyKDcsMCk7Y29udGludWV9ZWxzZSBpZih0aGlzLiNvPT09Mil7dGhpcy4jdSg1KTtjb250aW51ZX10aGlzLiNyKDEwLDApO2JyZWFrfWlmKHRoaXMuI2Q+MClpZih0aGlzLiNBKCkpdGhpcy4jZC09MTtlbHNlIGNvbnRpbnVlO2lmKHRoaXMuI1QoKSl7dGhpcy4jZCs9MTtjb250aW51ZX1zd2l0Y2godGhpcy4jbyl7Y2FzZSAwOnRoaXMuI1AoKSYmdGhpcy4jdSgxKTticmVhaztjYXNlIDE6aWYodGhpcy4jUCgpKXt0aGlzLiNDKCk7bGV0IHQ9NyxyPTE7dGhpcy4jRSgpPyh0PTIscj0zKTp0aGlzLiNnJiYodD0yKSx0aGlzLiNyKHQscil9YnJlYWs7Y2FzZSAyOnRoaXMuI1MoKT90aGlzLiN1KDMpOih0aGlzLiN4KCl8fHRoaXMuI2goKXx8dGhpcy4jZigpKSYmdGhpcy4jdSg1KTticmVhaztjYXNlIDM6dGhpcy4jTygpP3RoaXMuI3IoNCwxKTp0aGlzLiNTKCkmJnRoaXMuI3IoNSwxKTticmVhaztjYXNlIDQ6dGhpcy4jUygpJiZ0aGlzLiNyKDUsMSk7YnJlYWs7Y2FzZSA1OnRoaXMuI3koKT90aGlzLiNwKz0xOnRoaXMuI3coKSYmKHRoaXMuI3AtPTEpLHRoaXMuI2soKSYmIXRoaXMuI3A/dGhpcy4jcig2LDEpOnRoaXMuI3goKT90aGlzLiNyKDcsMCk6dGhpcy4jaCgpP3RoaXMuI3IoOCwxKTp0aGlzLiNmKCkmJnRoaXMuI3IoOSwxKTticmVhaztjYXNlIDY6dGhpcy4jeCgpP3RoaXMuI3IoNywwKTp0aGlzLiNoKCk/dGhpcy4jcig4LDEpOnRoaXMuI2YoKSYmdGhpcy4jcig5LDEpO2JyZWFrO2Nhc2UgNzp0aGlzLiNoKCk/dGhpcy4jcig4LDEpOnRoaXMuI2YoKSYmdGhpcy4jcig5LDEpO2JyZWFrO2Nhc2UgODp0aGlzLiNmKCkmJnRoaXMuI3IoOSwxKTticmVhaztjYXNlIDk6YnJlYWs7Y2FzZSAxMDpicmVha319dGhpcy4jdC5ob3N0bmFtZSE9PXZvaWQgMCYmdGhpcy4jdC5wb3J0PT09dm9pZCAwJiYodGhpcy4jdC5wb3J0PVwiXCIpfSNyKHQscil7c3dpdGNoKHRoaXMuI28pe2Nhc2UgMDpicmVhaztjYXNlIDE6dGhpcy4jdC5wcm90b2NvbD10aGlzLiNjKCk7YnJlYWs7Y2FzZSAyOmJyZWFrO2Nhc2UgMzp0aGlzLiN0LnVzZXJuYW1lPXRoaXMuI2MoKTticmVhaztjYXNlIDQ6dGhpcy4jdC5wYXNzd29yZD10aGlzLiNjKCk7YnJlYWs7Y2FzZSA1OnRoaXMuI3QuaG9zdG5hbWU9dGhpcy4jYygpO2JyZWFrO2Nhc2UgNjp0aGlzLiN0LnBvcnQ9dGhpcy4jYygpO2JyZWFrO2Nhc2UgNzp0aGlzLiN0LnBhdGhuYW1lPXRoaXMuI2MoKTticmVhaztjYXNlIDg6dGhpcy4jdC5zZWFyY2g9dGhpcy4jYygpO2JyZWFrO2Nhc2UgOTp0aGlzLiN0Lmhhc2g9dGhpcy4jYygpO2JyZWFrO2Nhc2UgMTA6YnJlYWt9dGhpcy4jbyE9PTAmJnQhPT0xMCYmKFsxLDIsMyw0XS5pbmNsdWRlcyh0aGlzLiNvKSYmWzYsNyw4LDldLmluY2x1ZGVzKHQpJiYodGhpcy4jdC5ob3N0bmFtZT8/PVwiXCIpLFsxLDIsMyw0LDUsNl0uaW5jbHVkZXModGhpcy4jbykmJls4LDldLmluY2x1ZGVzKHQpJiYodGhpcy4jdC5wYXRobmFtZT8/PXRoaXMuI2c/XCIvXCI6XCJcIiksWzEsMiwzLDQsNSw2LDddLmluY2x1ZGVzKHRoaXMuI28pJiZ0PT09OSYmKHRoaXMuI3Quc2VhcmNoPz89XCJcIikpLHRoaXMuI1IodCxyKX0jUih0LHIpe3RoaXMuI289dCx0aGlzLiNsPXRoaXMuI2Urcix0aGlzLiNlKz1yLHRoaXMuI3M9MH0jYigpe3RoaXMuI2U9dGhpcy4jbCx0aGlzLiNzPTB9I3UodCl7dGhpcy4jYigpLHRoaXMuI289dH0jbSh0KXtyZXR1cm4gdDwwJiYodD10aGlzLiNuLmxlbmd0aC10KSx0PHRoaXMuI24ubGVuZ3RoP3RoaXMuI25bdF06dGhpcy4jblt0aGlzLiNuLmxlbmd0aC0xXX0jYSh0LHIpe2xldCBuPXRoaXMuI20odCk7cmV0dXJuIG4udmFsdWU9PT1yJiYobi50eXBlPT09XCJDSEFSXCJ8fG4udHlwZT09PVwiRVNDQVBFRF9DSEFSXCJ8fG4udHlwZT09PVwiSU5WQUxJRF9DSEFSXCIpfSNQKCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIjpcIil9I0UoKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlKzEsXCIvXCIpJiZ0aGlzLiNhKHRoaXMuI2UrMixcIi9cIil9I1MoKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlLFwiQFwiKX0jTygpe3JldHVybiB0aGlzLiNhKHRoaXMuI2UsXCI6XCIpfSNrKCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIjpcIil9I3goKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlLFwiL1wiKX0jaCgpe2lmKHRoaXMuI2EodGhpcy4jZSxcIj9cIikpcmV0dXJuITA7aWYodGhpcy4jblt0aGlzLiNlXS52YWx1ZSE9PVwiP1wiKXJldHVybiExO2xldCB0PXRoaXMuI20odGhpcy4jZS0xKTtyZXR1cm4gdC50eXBlIT09XCJOQU1FXCImJnQudHlwZSE9PVwiUkVHRVhcIiYmdC50eXBlIT09XCJDTE9TRVwiJiZ0LnR5cGUhPT1cIkFTVEVSSVNLXCJ9I2YoKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlLFwiI1wiKX0jVCgpe3JldHVybiB0aGlzLiNuW3RoaXMuI2VdLnR5cGU9PVwiT1BFTlwifSNBKCl7cmV0dXJuIHRoaXMuI25bdGhpcy4jZV0udHlwZT09XCJDTE9TRVwifSN5KCl7cmV0dXJuIHRoaXMuI2EodGhpcy4jZSxcIltcIil9I3coKXtyZXR1cm4gdGhpcy4jYSh0aGlzLiNlLFwiXVwiKX0jYygpe2xldCB0PXRoaXMuI25bdGhpcy4jZV0scj10aGlzLiNtKHRoaXMuI2wpLmluZGV4O3JldHVybiB0aGlzLiNpLnN1YnN0cmluZyhyLHQuaW5kZXgpfSNDKCl7bGV0IHQ9e307T2JqZWN0LmFzc2lnbih0LHgpLHQuZW5jb2RlUGFydD15O2xldCByPXEodGhpcy4jYygpLHZvaWQgMCx0KTt0aGlzLiNnPU4ocil9fTt2YXIgVj1bXCJwcm90b2NvbFwiLFwidXNlcm5hbWVcIixcInBhc3N3b3JkXCIsXCJob3N0bmFtZVwiLFwicG9ydFwiLFwicGF0aG5hbWVcIixcInNlYXJjaFwiLFwiaGFzaFwiXSxFPVwiKlwiO2Z1bmN0aW9uIFNlKGUsdCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcInBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLlwiKTtsZXQgcj1uZXcgVVJMKGUsdCk7cmV0dXJue3Byb3RvY29sOnIucHJvdG9jb2wuc3Vic3RyaW5nKDAsci5wcm90b2NvbC5sZW5ndGgtMSksdXNlcm5hbWU6ci51c2VybmFtZSxwYXNzd29yZDpyLnBhc3N3b3JkLGhvc3RuYW1lOnIuaG9zdG5hbWUscG9ydDpyLnBvcnQscGF0aG5hbWU6ci5wYXRobmFtZSxzZWFyY2g6ci5zZWFyY2ghPT1cIlwiP3Iuc2VhcmNoLnN1YnN0cmluZygxLHIuc2VhcmNoLmxlbmd0aCk6dm9pZCAwLGhhc2g6ci5oYXNoIT09XCJcIj9yLmhhc2guc3Vic3RyaW5nKDEsci5oYXNoLmxlbmd0aCk6dm9pZCAwfX1mdW5jdGlvbiBiKGUsdCl7cmV0dXJuIHQ/QyhlKTplfWZ1bmN0aW9uIHcoZSx0LHIpe2xldCBuO2lmKHR5cGVvZiB0LmJhc2VVUkw9PVwic3RyaW5nXCIpdHJ5e249bmV3IFVSTCh0LmJhc2VVUkwpLHQucHJvdG9jb2w9PT12b2lkIDAmJihlLnByb3RvY29sPWIobi5wcm90b2NvbC5zdWJzdHJpbmcoMCxuLnByb3RvY29sLmxlbmd0aC0xKSxyKSksIXImJnQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJnQucG9ydD09PXZvaWQgMCYmdC51c2VybmFtZT09PXZvaWQgMCYmKGUudXNlcm5hbWU9YihuLnVzZXJuYW1lLHIpKSwhciYmdC5wcm90b2NvbD09PXZvaWQgMCYmdC5ob3N0bmFtZT09PXZvaWQgMCYmdC5wb3J0PT09dm9pZCAwJiZ0LnVzZXJuYW1lPT09dm9pZCAwJiZ0LnBhc3N3b3JkPT09dm9pZCAwJiYoZS5wYXNzd29yZD1iKG4ucGFzc3dvcmQscikpLHQucHJvdG9jb2w9PT12b2lkIDAmJnQuaG9zdG5hbWU9PT12b2lkIDAmJihlLmhvc3RuYW1lPWIobi5ob3N0bmFtZSxyKSksdC5wcm90b2NvbD09PXZvaWQgMCYmdC5ob3N0bmFtZT09PXZvaWQgMCYmdC5wb3J0PT09dm9pZCAwJiYoZS5wb3J0PWIobi5wb3J0LHIpKSx0LnByb3RvY29sPT09dm9pZCAwJiZ0Lmhvc3RuYW1lPT09dm9pZCAwJiZ0LnBvcnQ9PT12b2lkIDAmJnQucGF0aG5hbWU9PT12b2lkIDAmJihlLnBhdGhuYW1lPWIobi5wYXRobmFtZSxyKSksdC5wcm90b2NvbD09PXZvaWQgMCYmdC5ob3N0bmFtZT09PXZvaWQgMCYmdC5wb3J0PT09dm9pZCAwJiZ0LnBhdGhuYW1lPT09dm9pZCAwJiZ0LnNlYXJjaD09PXZvaWQgMCYmKGUuc2VhcmNoPWIobi5zZWFyY2guc3Vic3RyaW5nKDEsbi5zZWFyY2gubGVuZ3RoKSxyKSksdC5wcm90b2NvbD09PXZvaWQgMCYmdC5ob3N0bmFtZT09PXZvaWQgMCYmdC5wb3J0PT09dm9pZCAwJiZ0LnBhdGhuYW1lPT09dm9pZCAwJiZ0LnNlYXJjaD09PXZvaWQgMCYmdC5oYXNoPT09dm9pZCAwJiYoZS5oYXNoPWIobi5oYXNoLnN1YnN0cmluZygxLG4uaGFzaC5sZW5ndGgpLHIpKX1jYXRjaHt0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGJhc2VVUkwgJyR7dC5iYXNlVVJMfScuYCl9aWYodHlwZW9mIHQucHJvdG9jb2w9PVwic3RyaW5nXCImJihlLnByb3RvY29sPWZlKHQucHJvdG9jb2wscikpLHR5cGVvZiB0LnVzZXJuYW1lPT1cInN0cmluZ1wiJiYoZS51c2VybmFtZT1vZSh0LnVzZXJuYW1lLHIpKSx0eXBlb2YgdC5wYXNzd29yZD09XCJzdHJpbmdcIiYmKGUucGFzc3dvcmQ9YWUodC5wYXNzd29yZCxyKSksdHlwZW9mIHQuaG9zdG5hbWU9PVwic3RyaW5nXCImJihlLmhvc3RuYW1lPWllKHQuaG9zdG5hbWUscikpLHR5cGVvZiB0LnBvcnQ9PVwic3RyaW5nXCImJihlLnBvcnQ9bGUodC5wb3J0LGUucHJvdG9jb2wscikpLHR5cGVvZiB0LnBhdGhuYW1lPT1cInN0cmluZ1wiKXtpZihlLnBhdGhuYW1lPXQucGF0aG5hbWUsbiYmIWVlKGUucGF0aG5hbWUscikpe2xldCBhPW4ucGF0aG5hbWUubGFzdEluZGV4T2YoXCIvXCIpO2E+PTAmJihlLnBhdGhuYW1lPWIobi5wYXRobmFtZS5zdWJzdHJpbmcoMCxhKzEpLHIpK2UucGF0aG5hbWUpfWUucGF0aG5hbWU9Y2UoZS5wYXRobmFtZSxlLnByb3RvY29sLHIpfXJldHVybiB0eXBlb2YgdC5zZWFyY2g9PVwic3RyaW5nXCImJihlLnNlYXJjaD1zZSh0LnNlYXJjaCxyKSksdHlwZW9mIHQuaGFzaD09XCJzdHJpbmdcIiYmKGUuaGFzaD1uZSh0Lmhhc2gscikpLGV9ZnVuY3Rpb24gQyhlKXtyZXR1cm4gZS5yZXBsYWNlKC8oWysqPzp7fSgpXFxcXF0pL2csXCJcXFxcJDFcIil9ZnVuY3Rpb24gTGUoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFsuKyo/XiR7fSgpW1xcXXwvXFxcXF0pL2csXCJcXFxcJDFcIil9ZnVuY3Rpb24gSWUoZSx0KXt0LmRlbGltaXRlcj8/PVwiLyM/XCIsdC5wcmVmaXhlcz8/PVwiLi9cIix0LnNlbnNpdGl2ZT8/PSExLHQuc3RyaWN0Pz89ITEsdC5lbmQ/Pz0hMCx0LnN0YXJ0Pz89ITAsdC5lbmRzV2l0aD1cIlwiO2xldCByPVwiLipcIixuPWBbXiR7TGUodC5kZWxpbWl0ZXIpfV0rP2AsYT0vWyRfXFx1MjAwQ1xcdTIwMERcXHB7SURfQ29udGludWV9XS91LGM9XCJcIjtmb3IobGV0IGw9MDtsPGUubGVuZ3RoOysrbCl7bGV0IHM9ZVtsXTtpZihzLnR5cGU9PT0zKXtpZihzLm1vZGlmaWVyPT09Myl7Yys9QyhzLnZhbHVlKTtjb250aW51ZX1jKz1geyR7QyhzLnZhbHVlKX19JHtrKHMubW9kaWZpZXIpfWA7Y29udGludWV9bGV0IGk9cy5oYXNDdXN0b21OYW1lKCksbz0hIXMuc3VmZml4Lmxlbmd0aHx8ISFzLnByZWZpeC5sZW5ndGgmJihzLnByZWZpeC5sZW5ndGghPT0xfHwhdC5wcmVmaXhlcy5pbmNsdWRlcyhzLnByZWZpeCkpLGY9bD4wP2VbbC0xXTpudWxsLGQ9bDxlLmxlbmd0aC0xP2VbbCsxXTpudWxsO2lmKCFvJiZpJiZzLnR5cGU9PT0xJiZzLm1vZGlmaWVyPT09MyYmZCYmIWQucHJlZml4Lmxlbmd0aCYmIWQuc3VmZml4Lmxlbmd0aClpZihkLnR5cGU9PT0zKXtsZXQgVD1kLnZhbHVlLmxlbmd0aD4wP2QudmFsdWVbMF06XCJcIjtvPWEudGVzdChUKX1lbHNlIG89IWQuaGFzQ3VzdG9tTmFtZSgpO2lmKCFvJiYhcy5wcmVmaXgubGVuZ3RoJiZmJiZmLnR5cGU9PT0zKXtsZXQgVD1mLnZhbHVlW2YudmFsdWUubGVuZ3RoLTFdO289dC5wcmVmaXhlcy5pbmNsdWRlcyhUKX1vJiYoYys9XCJ7XCIpLGMrPUMocy5wcmVmaXgpLGkmJihjKz1gOiR7cy5uYW1lfWApLHMudHlwZT09PTI/Yys9YCgke3MudmFsdWV9KWA6cy50eXBlPT09MT9pfHwoYys9YCgke259KWApOnMudHlwZT09PTAmJighaSYmKCFmfHxmLnR5cGU9PT0zfHxmLm1vZGlmaWVyIT09M3x8b3x8cy5wcmVmaXghPT1cIlwiKT9jKz1cIipcIjpjKz1gKCR7cn0pYCkscy50eXBlPT09MSYmaSYmcy5zdWZmaXgubGVuZ3RoJiZhLnRlc3Qocy5zdWZmaXhbMF0pJiYoYys9XCJcXFxcXCIpLGMrPUMocy5zdWZmaXgpLG8mJihjKz1cIn1cIikscy5tb2RpZmllciE9PTMmJihjKz1rKHMubW9kaWZpZXIpKX1yZXR1cm4gY312YXIgWT1jbGFzc3sjaTsjbj17fTsjdD17fTsjZT17fTsjcz17fTsjbD0hMTtjb25zdHJ1Y3Rvcih0PXt9LHIsbil7dHJ5e2xldCBhO2lmKHR5cGVvZiByPT1cInN0cmluZ1wiP2E9cjpuPXIsdHlwZW9mIHQ9PVwic3RyaW5nXCIpe2xldCBpPW5ldyBIKHQpO2lmKGkucGFyc2UoKSx0PWkucmVzdWx0LGE9PT12b2lkIDAmJnR5cGVvZiB0LnByb3RvY29sIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIGJhc2UgVVJMIG11c3QgYmUgcHJvdmlkZWQgZm9yIGEgcmVsYXRpdmUgY29uc3RydWN0b3Igc3RyaW5nLlwiKTt0LmJhc2VVUkw9YX1lbHNle2lmKCF0fHx0eXBlb2YgdCE9XCJvYmplY3RcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwicGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ3N0cmluZycgYW5kIGNhbm5vdCBjb252ZXJ0IHRvIGRpY3Rpb25hcnkuXCIpO2lmKGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcInBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLlwiKX10eXBlb2Ygbj5cInVcIiYmKG49e2lnbm9yZUNhc2U6ITF9KTtsZXQgYz17aWdub3JlQ2FzZTpuLmlnbm9yZUNhc2U9PT0hMH0sbD17cGF0aG5hbWU6RSxwcm90b2NvbDpFLHVzZXJuYW1lOkUscGFzc3dvcmQ6RSxob3N0bmFtZTpFLHBvcnQ6RSxzZWFyY2g6RSxoYXNoOkV9O3RoaXMuI2k9dyhsLHQsITApLHoodGhpcy4jaS5wcm90b2NvbCk9PT10aGlzLiNpLnBvcnQmJih0aGlzLiNpLnBvcnQ9XCJcIik7bGV0IHM7Zm9yKHMgb2YgVil7aWYoIShzIGluIHRoaXMuI2kpKWNvbnRpbnVlO2xldCBpPXt9LG89dGhpcy4jaVtzXTtzd2l0Y2godGhpcy4jdFtzXT1bXSxzKXtjYXNlXCJwcm90b2NvbFwiOk9iamVjdC5hc3NpZ24oaSx4KSxpLmVuY29kZVBhcnQ9eTticmVhaztjYXNlXCJ1c2VybmFtZVwiOk9iamVjdC5hc3NpZ24oaSx4KSxpLmVuY29kZVBhcnQ9aGU7YnJlYWs7Y2FzZVwicGFzc3dvcmRcIjpPYmplY3QuYXNzaWduKGkseCksaS5lbmNvZGVQYXJ0PXVlO2JyZWFrO2Nhc2VcImhvc3RuYW1lXCI6T2JqZWN0LmFzc2lnbihpLEopLF8obyk/aS5lbmNvZGVQYXJ0PUs6aS5lbmNvZGVQYXJ0PWo7YnJlYWs7Y2FzZVwicG9ydFwiOk9iamVjdC5hc3NpZ24oaSx4KSxpLmVuY29kZVBhcnQ9RzticmVhaztjYXNlXCJwYXRobmFtZVwiOk4odGhpcy4jbi5wcm90b2NvbCk/KE9iamVjdC5hc3NpZ24oaSxRLGMpLGkuZW5jb2RlUGFydD1kZSk6KE9iamVjdC5hc3NpZ24oaSx4LGMpLGkuZW5jb2RlUGFydD1wZSk7YnJlYWs7Y2FzZVwic2VhcmNoXCI6T2JqZWN0LmFzc2lnbihpLHgsYyksaS5lbmNvZGVQYXJ0PWdlO2JyZWFrO2Nhc2VcImhhc2hcIjpPYmplY3QuYXNzaWduKGkseCxjKSxpLmVuY29kZVBhcnQ9bWU7YnJlYWt9dHJ5e3RoaXMuI3Nbc109RihvLGkpLHRoaXMuI25bc109Vyh0aGlzLiNzW3NdLHRoaXMuI3Rbc10saSksdGhpcy4jZVtzXT1JZSh0aGlzLiNzW3NdLGkpLHRoaXMuI2w9dGhpcy4jbHx8dGhpcy4jc1tzXS5zb21lKGY9PmYudHlwZT09PTIpfWNhdGNoe3Rocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgJHtzfSBwYXR0ZXJuICcke3RoaXMuI2lbc119Jy5gKX19fWNhdGNoKGEpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBjb25zdHJ1Y3QgJ1VSTFBhdHRlcm4nOiAke2EubWVzc2FnZX1gKX19dGVzdCh0PXt9LHIpe2xldCBuPXtwYXRobmFtZTpcIlwiLHByb3RvY29sOlwiXCIsdXNlcm5hbWU6XCJcIixwYXNzd29yZDpcIlwiLGhvc3RuYW1lOlwiXCIscG9ydDpcIlwiLHNlYXJjaDpcIlwiLGhhc2g6XCJcIn07aWYodHlwZW9mIHQhPVwic3RyaW5nXCImJnIpdGhyb3cgbmV3IFR5cGVFcnJvcihcInBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdzdHJpbmcnLlwiKTtpZih0eXBlb2YgdD5cInVcIilyZXR1cm4hMTt0cnl7dHlwZW9mIHQ9PVwib2JqZWN0XCI/bj13KG4sdCwhMSk6bj13KG4sU2UodCxyKSwhMSl9Y2F0Y2h7cmV0dXJuITF9bGV0IGE7Zm9yKGEgb2YgVilpZighdGhpcy4jblthXS5leGVjKG5bYV0pKXJldHVybiExO3JldHVybiEwfWV4ZWModD17fSxyKXtsZXQgbj17cGF0aG5hbWU6XCJcIixwcm90b2NvbDpcIlwiLHVzZXJuYW1lOlwiXCIscGFzc3dvcmQ6XCJcIixob3N0bmFtZTpcIlwiLHBvcnQ6XCJcIixzZWFyY2g6XCJcIixoYXNoOlwiXCJ9O2lmKHR5cGVvZiB0IT1cInN0cmluZ1wiJiZyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnc3RyaW5nJy5cIik7aWYodHlwZW9mIHQ+XCJ1XCIpcmV0dXJuO3RyeXt0eXBlb2YgdD09XCJvYmplY3RcIj9uPXcobix0LCExKTpuPXcobixTZSh0LHIpLCExKX1jYXRjaHtyZXR1cm4gbnVsbH1sZXQgYT17fTtyP2EuaW5wdXRzPVt0LHJdOmEuaW5wdXRzPVt0XTtsZXQgYztmb3IoYyBvZiBWKXtsZXQgbD10aGlzLiNuW2NdLmV4ZWMobltjXSk7aWYoIWwpcmV0dXJuIG51bGw7bGV0IHM9e307Zm9yKGxldFtpLG9db2YgdGhpcy4jdFtjXS5lbnRyaWVzKCkpaWYodHlwZW9mIG89PVwic3RyaW5nXCJ8fHR5cGVvZiBvPT1cIm51bWJlclwiKXtsZXQgZj1sW2krMV07c1tvXT1mfWFbY109e2lucHV0Om5bY10/P1wiXCIsZ3JvdXBzOnN9fXJldHVybiBhfXN0YXRpYyBjb21wYXJlQ29tcG9uZW50KHQscixuKXtsZXQgYT0oaSxvKT0+e2ZvcihsZXQgZiBvZltcInR5cGVcIixcIm1vZGlmaWVyXCIsXCJwcmVmaXhcIixcInZhbHVlXCIsXCJzdWZmaXhcIl0pe2lmKGlbZl08b1tmXSlyZXR1cm4tMTtpZihpW2ZdPT09b1tmXSljb250aW51ZTtyZXR1cm4gMX1yZXR1cm4gMH0sYz1uZXcgUigzLFwiXCIsXCJcIixcIlwiLFwiXCIsMyksbD1uZXcgUigwLFwiXCIsXCJcIixcIlwiLFwiXCIsMykscz0oaSxvKT0+e2xldCBmPTA7Zm9yKDtmPE1hdGgubWluKGkubGVuZ3RoLG8ubGVuZ3RoKTsrK2Ype2xldCBkPWEoaVtmXSxvW2ZdKTtpZihkKXJldHVybiBkfXJldHVybiBpLmxlbmd0aD09PW8ubGVuZ3RoPzA6YShpW2ZdPz9jLG9bZl0/P2MpfTtyZXR1cm4hci4jZVt0XSYmIW4uI2VbdF0/MDpyLiNlW3RdJiYhbi4jZVt0XT9zKHIuI3NbdF0sW2xdKTohci4jZVt0XSYmbi4jZVt0XT9zKFtsXSxuLiNzW3RdKTpzKHIuI3NbdF0sbi4jc1t0XSl9Z2V0IHByb3RvY29sKCl7cmV0dXJuIHRoaXMuI2UucHJvdG9jb2x9Z2V0IHVzZXJuYW1lKCl7cmV0dXJuIHRoaXMuI2UudXNlcm5hbWV9Z2V0IHBhc3N3b3JkKCl7cmV0dXJuIHRoaXMuI2UucGFzc3dvcmR9Z2V0IGhvc3RuYW1lKCl7cmV0dXJuIHRoaXMuI2UuaG9zdG5hbWV9Z2V0IHBvcnQoKXtyZXR1cm4gdGhpcy4jZS5wb3J0fWdldCBwYXRobmFtZSgpe3JldHVybiB0aGlzLiNlLnBhdGhuYW1lfWdldCBzZWFyY2goKXtyZXR1cm4gdGhpcy4jZS5zZWFyY2h9Z2V0IGhhc2goKXtyZXR1cm4gdGhpcy4jZS5oYXNofWdldCBoYXNSZWdFeHBHcm91cHMoKXtyZXR1cm4gdGhpcy4jbH19O1xuIiwiY29uc3QgeyBVUkxQYXR0ZXJuIH0gPSByZXF1aXJlKFwiLi9kaXN0L3VybHBhdHRlcm4uY2pzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgVVJMUGF0dGVybiB9O1xuXG5pZiAoIWdsb2JhbFRoaXMuVVJMUGF0dGVybikge1xuICBnbG9iYWxUaGlzLlVSTFBhdHRlcm4gPSBVUkxQYXR0ZXJuO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obil7cmV0dXJue2FsbDpuPW58fG5ldyBNYXAsb246ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpP2kucHVzaChlKTpuLnNldCh0LFtlXSl9LG9mZjpmdW5jdGlvbih0LGUpe3ZhciBpPW4uZ2V0KHQpO2kmJihlP2kuc3BsaWNlKGkuaW5kZXhPZihlKT4+PjAsMSk6bi5zZXQodCxbXSkpfSxlbWl0OmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aSYmaS5zbGljZSgpLm1hcChmdW5jdGlvbihuKXtuKGUpfSksKGk9bi5nZXQoXCIqXCIpKSYmaS5zbGljZSgpLm1hcChmdW5jdGlvbihuKXtuKHQsZSl9KX19fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl0dC5tanMubWFwXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0ICogYXMgQmlkaU1hcHBlciBmcm9tICdjaHJvbWl1bS1iaWRpL2xpYi9janMvYmlkaU1hcHBlci9CaWRpTWFwcGVyLmpzJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vY29tbW9uL0RlYnVnLmpzJztcbmltcG9ydCB7IFRhcmdldENsb3NlRXJyb3IgfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IEJpZGlDb25uZWN0aW9uIH0gZnJvbSAnLi9Db25uZWN0aW9uLmpzJztcbmNvbnN0IGJpZGlTZXJ2ZXJMb2dnZXIgPSAocHJlZml4LCAuLi5hcmdzKSA9PiB7XG4gICAgZGVidWcoYGJpZGk6JHtwcmVmaXh9YCkoYXJncyk7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RCaWRpT3ZlckNkcChjZHAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRCaURpID0gbmV3IE5vT3BUcmFuc3BvcnQoKTtcbiAgICBjb25zdCBjZHBDb25uZWN0aW9uQWRhcHRlciA9IG5ldyBDZHBDb25uZWN0aW9uQWRhcHRlcihjZHApO1xuICAgIGNvbnN0IHBwdHJUcmFuc3BvcnQgPSB7XG4gICAgICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gRm9yd2FyZHMgYSBCaURpIGNvbW1hbmQgc2VudCBieSBQdXBwZXRlZXIgdG8gdGhlIGlucHV0IG9mIHRoZSBCaWRpU2VydmVyLlxuICAgICAgICAgICAgdHJhbnNwb3J0QmlEaS5lbWl0TWVzc2FnZShKU09OLnBhcnNlKG1lc3NhZ2UpKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBiaWRpU2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICBjZHBDb25uZWN0aW9uQWRhcHRlci5jbG9zZSgpO1xuICAgICAgICAgICAgY2RwLmRpc3Bvc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25tZXNzYWdlKF9tZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWV0aG9kIGlzIG92ZXJyaWRkZW4gYnkgdGhlIENvbm5lY3Rpb24uXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB0cmFuc3BvcnRCaURpLm9uKCdiaWRpUmVzcG9uc2UnLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAvLyBGb3J3YXJkcyBhIEJpRGkgZXZlbnQgc2VudCBieSBCaWRpU2VydmVyIHRvIFB1cHBldGVlci5cbiAgICAgICAgcHB0clRyYW5zcG9ydC5vbm1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHBwdHJCaURpQ29ubmVjdGlvbiA9IG5ldyBCaWRpQ29ubmVjdGlvbihjZHAudXJsKCksIHBwdHJUcmFuc3BvcnQsIGNkcC5kZWxheSwgY2RwLnRpbWVvdXQpO1xuICAgIGNvbnN0IGJpZGlTZXJ2ZXIgPSBhd2FpdCBCaWRpTWFwcGVyLkJpZGlTZXJ2ZXIuY3JlYXRlQW5kU3RhcnQodHJhbnNwb3J0QmlEaSwgY2RwQ29ubmVjdGlvbkFkYXB0ZXIsIFxuICAgIC8vIFRPRE86IG1vc3QgbGlrZWx5IG5lZWQgYSBsaXR0bGUgYml0IG9mIHJlZmFjdG9yaW5nXG4gICAgY2RwQ29ubmVjdGlvbkFkYXB0ZXIuYnJvd3NlckNsaWVudCgpLCAnJywge1xuICAgICAgICAvLyBPdmVycmlkZSBNYXBwZXIncyBgdW5oYW5kbGVkUHJvbXB0QmVoYXZpb3JgIGRlZmF1bHQgdmFsdWUgb2YgYGRpc21pc3NgIHRvXG4gICAgICAgIC8vIGBpZ25vcmVgLCBzbyB0aGF0IHVzZXIgY2FuIGhhbmRsZSB0aGUgcHJvbXB0IGluc3RlYWQgb2YganVzdCBjbG9zaW5nIGl0LlxuICAgICAgICB1bmhhbmRsZWRQcm9tcHRCZWhhdmlvcjoge1xuICAgICAgICAgICAgZGVmYXVsdDogXCJpZ25vcmVcIiAvKiBCaWRpLlNlc3Npb24uVXNlclByb21wdEhhbmRsZXJUeXBlLklnbm9yZSAqLyxcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9LCB1bmRlZmluZWQsIGJpZGlTZXJ2ZXJMb2dnZXIpO1xuICAgIHJldHVybiBwcHRyQmlEaUNvbm5lY3Rpb247XG59XG4vKipcbiAqIE1hbmFnZXMgQ0RQU2Vzc2lvbnMgZm9yIEJpZGlTZXJ2ZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ2RwQ29ubmVjdGlvbkFkYXB0ZXIge1xuICAgICNjZHA7XG4gICAgI2FkYXB0ZXJzID0gbmV3IE1hcCgpO1xuICAgICNicm93c2VyQ2RwQ29ubmVjdGlvbjtcbiAgICBjb25zdHJ1Y3RvcihjZHApIHtcbiAgICAgICAgdGhpcy4jY2RwID0gY2RwO1xuICAgICAgICB0aGlzLiNicm93c2VyQ2RwQ29ubmVjdGlvbiA9IG5ldyBDRFBDbGllbnRBZGFwdGVyKGNkcCk7XG4gICAgfVxuICAgIGJyb3dzZXJDbGllbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ2RwQ29ubmVjdGlvbjtcbiAgICB9XG4gICAgZ2V0Q2RwQ2xpZW50KGlkKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLiNjZHAuc2Vzc2lvbihpZCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIENEUCBzZXNzaW9uIHdpdGggaWQgJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuI2FkYXB0ZXJzLmhhcyhzZXNzaW9uKSkge1xuICAgICAgICAgICAgY29uc3QgYWRhcHRlciA9IG5ldyBDRFBDbGllbnRBZGFwdGVyKHNlc3Npb24sIGlkLCB0aGlzLiNicm93c2VyQ2RwQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLiNhZGFwdGVycy5zZXQoc2Vzc2lvbiwgYWRhcHRlcik7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jYWRhcHRlcnMuZ2V0KHNlc3Npb24pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNkcENvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBhZGFwdGVyIG9mIHRoaXMuI2FkYXB0ZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBhZGFwdGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdyYXBwZXIgb24gdG9wIG9mIENEUFNlc3Npb24vQ0RQQ29ubmVjdGlvbiB0byBzYXRpc2Z5IENEUCBpbnRlcmZhY2UgdGhhdFxuICogQmlkaVNlcnZlciBuZWVkcy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQ0RQQ2xpZW50QWRhcHRlciBleHRlbmRzIEJpZGlNYXBwZXIuRXZlbnRFbWl0dGVyIHtcbiAgICAjY2xvc2VkID0gZmFsc2U7XG4gICAgI2NsaWVudDtcbiAgICBzZXNzaW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgI2Jyb3dzZXJDbGllbnQ7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCBzZXNzaW9uSWQsIGJyb3dzZXJDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy4jYnJvd3NlckNsaWVudCA9IGJyb3dzZXJDbGllbnQ7XG4gICAgICAgIHRoaXMuI2NsaWVudC5vbignKicsIHRoaXMuI2ZvcndhcmRNZXNzYWdlKTtcbiAgICB9XG4gICAgYnJvd3NlckNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXJDbGllbnQ7XG4gICAgfVxuICAgICNmb3J3YXJkTWVzc2FnZSA9IChtZXRob2QsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChtZXRob2QsIGV2ZW50KTtcbiAgICB9O1xuICAgIGFzeW5jIHNlbmRDb21tYW5kKG1ldGhvZCwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLiNjbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NsaWVudC5zZW5kKG1ldGhvZCwgLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLiNjbGllbnQub2ZmKCcqJywgdGhpcy4jZm9yd2FyZE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLiNjbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpc0Nsb3NlRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVGFyZ2V0Q2xvc2VFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgdHJhbnNwb3J0IGlzIGdpdmVuIHRvIHRoZSBCaURpIHNlcnZlciBpbnN0YW5jZSBhbmQgYWxsb3dzIFB1cHBldGVlclxuICogdG8gc2VuZCBhbmQgcmVjZWl2ZSBjb21tYW5kcyB0byB0aGUgQmlEaVNlcnZlci5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBOb09wVHJhbnNwb3J0IGV4dGVuZHMgQmlkaU1hcHBlci5FdmVudEVtaXR0ZXIge1xuICAgICNvbk1lc3NhZ2UgPSBhc3luYyAoX20pID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgZW1pdE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2b2lkIHRoaXMuI29uTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgc2V0T25NZXNzYWdlKG9uTWVzc2FnZSkge1xuICAgICAgICB0aGlzLiNvbk1lc3NhZ2UgPSBvbk1lc3NhZ2U7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdiaWRpUmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuI29uTWVzc2FnZSA9IGFzeW5jIChfbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpZGlPdmVyQ2RwLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19zZXRGdW5jdGlvbk5hbWUgPSAodGhpcyAmJiB0aGlzLl9fc2V0RnVuY3Rpb25OYW1lKSB8fCBmdW5jdGlvbiAoZiwgbmFtZSwgcHJlZml4KSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcbmltcG9ydCB7IEJyb3dzZXIsIH0gZnJvbSAnLi4vYXBpL0Jyb3dzZXIuanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgYnViYmxlIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IEJpZGlCcm93c2VyQ29udGV4dCB9IGZyb20gJy4vQnJvd3NlckNvbnRleHQuanMnO1xuaW1wb3J0IHsgU2Vzc2lvbiB9IGZyb20gJy4vY29yZS9TZXNzaW9uLmpzJztcbmltcG9ydCB7IEJpZGlCcm93c2VyVGFyZ2V0IH0gZnJvbSAnLi9UYXJnZXQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlCcm93c2VyID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBCcm93c2VyO1xuICAgIGxldCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9pbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZGVzY3JpcHRvcjtcbiAgICByZXR1cm4gY2xhc3MgQmlkaUJyb3dzZXIgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZGVjb3JhdG9ycyA9IFtidWJibGUoKV07XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZGVzY3JpcHRvciA9IHsgZ2V0OiBfX3NldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLiN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlOyB9LCBcIiN0cnVzdGVkRW1pdHRlclwiLCBcImdldFwiKSwgc2V0OiBfX3NldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAodmFsdWUpIHsgdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9LCBcIiN0cnVzdGVkRW1pdHRlclwiLCBcInNldFwiKSB9LCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwiYWNjZXNzb3JcIiwgbmFtZTogXCIjdHJ1c3RlZEVtaXR0ZXJcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogdHJ1ZSwgYWNjZXNzOiB7IGhhczogb2JqID0+ICN0cnVzdGVkRW1pdHRlciBpbiBvYmosIGdldDogb2JqID0+IG9iai4jdHJ1c3RlZEVtaXR0ZXIsIHNldDogKG9iaiwgdmFsdWUpID0+IHsgb2JqLiN0cnVzdGVkRW1pdHRlciA9IHZhbHVlOyB9IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzLCBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG9jb2wgPSAnd2ViRHJpdmVyQmlEaSc7XG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSBnZW5lcmF0b3IgdG8gaW5jbHVkZSBmdWxseSBtb2R1bGVcbiAgICAgICAgc3RhdGljIHN1YnNjcmliZU1vZHVsZXMgPSBbXG4gICAgICAgICAgICAnYnJvd3NpbmdDb250ZXh0JyxcbiAgICAgICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgICAgICdsb2cnLFxuICAgICAgICAgICAgJ3NjcmlwdCcsXG4gICAgICAgIF07XG4gICAgICAgIHN0YXRpYyBzdWJzY3JpYmVDZHBFdmVudHMgPSBbXG4gICAgICAgICAgICAvLyBDb3ZlcmFnZVxuICAgICAgICAgICAgJ2NkcC5EZWJ1Z2dlci5zY3JpcHRQYXJzZWQnLFxuICAgICAgICAgICAgJ2NkcC5DU1Muc3R5bGVTaGVldEFkZGVkJyxcbiAgICAgICAgICAgICdjZHAuUnVudGltZS5leGVjdXRpb25Db250ZXh0c0NsZWFyZWQnLFxuICAgICAgICAgICAgLy8gVHJhY2luZ1xuICAgICAgICAgICAgJ2NkcC5UcmFjaW5nLnRyYWNpbmdDb21wbGV0ZScsXG4gICAgICAgICAgICAvLyBUT0RPOiBzdWJzY3JpYmUgdG8gYWxsIENEUCBldmVudHMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgICdjZHAuTmV0d29yay5yZXF1ZXN0V2lsbEJlU2VudCcsXG4gICAgICAgICAgICAnY2RwLkRlYnVnZ2VyLnNjcmlwdFBhcnNlZCcsXG4gICAgICAgICAgICAnY2RwLlBhZ2Uuc2NyZWVuY2FzdEZyYW1lJyxcbiAgICAgICAgXTtcbiAgICAgICAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgU2Vzc2lvbi5mcm9tKG9wdHMuY29ubmVjdGlvbiwge1xuICAgICAgICAgICAgICAgIGFsd2F5c01hdGNoOiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2VwdEluc2VjdXJlQ2VydHM6IG9wdHMuaWdub3JlSFRUUFNFcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldFVybDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBzZXNzaW9uLnN1YnNjcmliZShzZXNzaW9uLmNhcGFiaWxpdGllcy5icm93c2VyTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmaXJlZm94JylcbiAgICAgICAgICAgICAgICA/IEJpZGlCcm93c2VyLnN1YnNjcmliZU1vZHVsZXNcbiAgICAgICAgICAgICAgICA6IFsuLi5CaWRpQnJvd3Nlci5zdWJzY3JpYmVNb2R1bGVzLCAuLi5CaWRpQnJvd3Nlci5zdWJzY3JpYmVDZHBFdmVudHNdKTtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXIgPSBuZXcgQmlkaUJyb3dzZXIoc2Vzc2lvbi5icm93c2VyLCBvcHRzKTtcbiAgICAgICAgICAgIGJyb3dzZXIuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyO1xuICAgICAgICB9XG4gICAgICAgICN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzLCBuZXcgRXZlbnRFbWl0dGVyKCkpO1xuICAgICAgICBnZXQgI3RydXN0ZWRFbWl0dGVyKCkgeyByZXR1cm4gX3ByaXZhdGVfdHJ1c3RlZEVtaXR0ZXJfZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTsgfVxuICAgICAgICBzZXQgI3RydXN0ZWRFbWl0dGVyKHZhbHVlKSB7IHJldHVybiBfcHJpdmF0ZV90cnVzdGVkRW1pdHRlcl9kZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIHZhbHVlKTsgfVxuICAgICAgICAjcHJvY2VzcyA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9wcml2YXRlX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI2Nsb3NlQ2FsbGJhY2s7XG4gICAgICAgICNicm93c2VyQ29yZTtcbiAgICAgICAgI2RlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgI2Jyb3dzZXJDb250ZXh0cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICN0YXJnZXQgPSBuZXcgQmlkaUJyb3dzZXJUYXJnZXQodGhpcyk7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJyb3dzZXJDb3JlLCBvcHRzKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jcHJvY2VzcyA9IG9wdHMucHJvY2VzcztcbiAgICAgICAgICAgIHRoaXMuI2Nsb3NlQ2FsbGJhY2sgPSBvcHRzLmNsb3NlQ2FsbGJhY2s7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyQ29yZSA9IGJyb3dzZXJDb3JlO1xuICAgICAgICAgICAgdGhpcy4jZGVmYXVsdFZpZXdwb3J0ID0gb3B0cy5kZWZhdWx0Vmlld3BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXppbmcgZXhpc3RpbmcgY29udGV4dHMuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVzZXJDb250ZXh0IG9mIHRoaXMuI2Jyb3dzZXJDb3JlLnVzZXJDb250ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NyZWF0ZUJyb3dzZXJDb250ZXh0KHVzZXJDb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2Jyb3dzZXJDb3JlLm9uY2UoJ2Rpc2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiN0cnVzdGVkRW1pdHRlci5lbWl0KFwiZGlzY29ubmVjdGVkXCIgLyogQnJvd3NlckV2ZW50LkRpc2Nvbm5lY3RlZCAqLywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLiN0cnVzdGVkRW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy4jcHJvY2Vzcz8ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NlckNvcmUuZGlzcG9zZSgnQnJvd3NlciBwcm9jZXNzIGV4aXRlZC4nLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNicm93c2VyTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29yZS5zZXNzaW9uLmNhcGFiaWxpdGllcy5icm93c2VyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgI2Jyb3dzZXJWZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXJDb3JlLnNlc3Npb24uY2FwYWJpbGl0aWVzLmJyb3dzZXJWZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjZHBTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuI2Jyb3dzZXJOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2ZpcmVmb3gnKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB1c2VyQWdlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNvcmUuc2Vzc2lvbi5jYXBhYmlsaXRpZXMudXNlckFnZW50O1xuICAgICAgICB9XG4gICAgICAgICNjcmVhdGVCcm93c2VyQ29udGV4dCh1c2VyQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlckNvbnRleHQgPSBCaWRpQnJvd3NlckNvbnRleHQuZnJvbSh0aGlzLCB1c2VyQ29udGV4dCwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRWaWV3cG9ydDogdGhpcy4jZGVmYXVsdFZpZXdwb3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyQ29udGV4dHMuc2V0KHVzZXJDb250ZXh0LCBicm93c2VyQ29udGV4dCk7XG4gICAgICAgICAgICBicm93c2VyQ29udGV4dC50cnVzdGVkRW1pdHRlci5vbihcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jdHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyRXZlbnQuVGFyZ2V0Q3JlYXRlZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJvd3NlckNvbnRleHQudHJ1c3RlZEVtaXR0ZXIub24oXCJ0YXJnZXRjaGFuZ2VkXCIgLyogQnJvd3NlckNvbnRleHRFdmVudC5UYXJnZXRDaGFuZ2VkICovLCB0YXJnZXQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3RydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRjaGFuZ2VkXCIgLyogQnJvd3NlckV2ZW50LlRhcmdldENoYW5nZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyb3dzZXJDb250ZXh0LnRydXN0ZWRFbWl0dGVyLm9uKFwidGFyZ2V0ZGVzdHJveWVkXCIgLyogQnJvd3NlckNvbnRleHRFdmVudC5UYXJnZXREZXN0cm95ZWQgKi8sIHRhcmdldCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jdHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGRlc3Ryb3llZFwiIC8qIEJyb3dzZXJFdmVudC5UYXJnZXREZXN0cm95ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY29ubmVjdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNBRkVUWTogV2Ugb25seSBoYXZlIG9uZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29yZS5zZXNzaW9uLmNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgd3NFbmRwb2ludCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24udXJsO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2Jyb3dzZXJDb3JlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jY2xvc2VDYWxsYmFjaz8uY2FsbChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuI2Jyb3dzZXJDb3JlLmRpc2Nvbm5lY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3MgPz8gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjcmVhdGVCcm93c2VyQ29udGV4dChfb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdXNlckNvbnRleHQgPSBhd2FpdCB0aGlzLiNicm93c2VyQ29yZS5jcmVhdGVVc2VyQ29udGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWF0ZUJyb3dzZXJDb250ZXh0KHVzZXJDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB2ZXJzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuI2Jyb3dzZXJOYW1lfS8ke3RoaXMuI2Jyb3dzZXJWZXJzaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJvd3NlckNvbnRleHRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi50aGlzLiNicm93c2VyQ29yZS51c2VyQ29udGV4dHNdLm1hcChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NlckNvbnRleHRzLmdldChjb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRCcm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyQ29udGV4dHMuZ2V0KHRoaXMuI2Jyb3dzZXJDb3JlLmRlZmF1bHRVc2VyQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3UGFnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRCcm93c2VyQ29udGV4dCgpLm5ld1BhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLiN0YXJnZXQsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5icm93c2VyQ29udGV4dHMoKS5mbGF0TWFwKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC50YXJnZXRzKCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jYnJvd3NlckNvcmUuc2Vzc2lvbi5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBkZWJ1Z0luZm8oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdQcm90b2NvbEVycm9yczogdGhpcy5jb25uZWN0aW9uLmdldFBlbmRpbmdQcm90b2NvbEVycm9ycygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQmlkaUJyb3dzZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBXRUJfUEVSTUlTU0lPTl9UT19QUk9UT0NPTF9QRVJNSVNTSU9OIH0gZnJvbSAnLi4vYXBpL0Jyb3dzZXIuanMnO1xuaW1wb3J0IHsgQnJvd3NlckNvbnRleHQgfSBmcm9tICcuLi9hcGkvQnJvd3NlckNvbnRleHQuanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgYnViYmxlIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IFVzZXJDb250ZXh0IH0gZnJvbSAnLi9jb3JlL1VzZXJDb250ZXh0LmpzJztcbmltcG9ydCB7IEJpZGlQYWdlIH0gZnJvbSAnLi9QYWdlLmpzJztcbmltcG9ydCB7IEJpZGlXb3JrZXJUYXJnZXQgfSBmcm9tICcuL1RhcmdldC5qcyc7XG5pbXBvcnQgeyBCaWRpRnJhbWVUYXJnZXQsIEJpZGlQYWdlVGFyZ2V0IH0gZnJvbSAnLi9UYXJnZXQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlCcm93c2VyQ29udGV4dCA9ICgoKSA9PiB7XG4gICAgbGV0IF9jbGFzc1N1cGVyID0gQnJvd3NlckNvbnRleHQ7XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIHJldHVybiBjbGFzcyBCaWRpQnJvd3NlckNvbnRleHQgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnMgPSBbYnViYmxlKCldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwiYWNjZXNzb3JcIiwgbmFtZTogXCJ0cnVzdGVkRW1pdHRlclwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwidHJ1c3RlZEVtaXR0ZXJcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai50cnVzdGVkRW1pdHRlciwgc2V0OiAob2JqLCB2YWx1ZSkgPT4geyBvYmoudHJ1c3RlZEVtaXR0ZXIgPSB2YWx1ZTsgfSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIF90cnVzdGVkRW1pdHRlcl9pbml0aWFsaXplcnMsIF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20oYnJvd3NlciwgdXNlckNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQmlkaUJyb3dzZXJDb250ZXh0KGJyb3dzZXIsIHVzZXJDb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycywgbmV3IEV2ZW50RW1pdHRlcigpKTtcbiAgICAgICAgZ2V0IHRydXN0ZWRFbWl0dGVyKCkgeyByZXR1cm4gdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZTsgfVxuICAgICAgICBzZXQgdHJ1c3RlZEVtaXR0ZXIodmFsdWUpIHsgdGhpcy4jdHJ1c3RlZEVtaXR0ZXJfYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9XG4gICAgICAgICNicm93c2VyID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI2RlZmF1bHRWaWV3cG9ydDtcbiAgICAgICAgLy8gVGhpcyBpcyBwdWJsaWMgYmVjYXVzZSBvZiBjb29raWVzLlxuICAgICAgICB1c2VyQ29udGV4dDtcbiAgICAgICAgI3BhZ2VzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgI3RhcmdldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICNvdmVycmlkZXMgPSBbXTtcbiAgICAgICAgY29uc3RydWN0b3IoYnJvd3NlciwgdXNlckNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2VyID0gYnJvd3NlcjtcbiAgICAgICAgICAgIHRoaXMudXNlckNvbnRleHQgPSB1c2VyQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuI2RlZmF1bHRWaWV3cG9ydCA9IG9wdGlvbnMuZGVmYXVsdFZpZXdwb3J0O1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRhcmdldHMgZm9yIGV4aXN0aW5nIGJyb3dzaW5nIGNvbnRleHRzLlxuICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2luZ0NvbnRleHQgb2YgdGhpcy51c2VyQ29udGV4dC5icm93c2luZ0NvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51c2VyQ29udGV4dC5vbignYnJvd3Npbmdjb250ZXh0JywgKHsgYnJvd3NpbmdDb250ZXh0IH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy4jY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTUNvbnRlbnRMb2FkZWQgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gYnJvd3NpbmdDb250ZXh0IHN0aWxsIG1heSBiZSBuYXZpZ2F0aW5nIGZyb20gdGhlIGFib3V0OmJsYW5rXG4gICAgICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0Lm9uY2UoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicm93c2luZ0NvbnRleHQub3JpZ2luYWxPcGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGV4dCBvZiB0aGlzLnVzZXJDb250ZXh0LmJyb3dzaW5nQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pZCA9PT0gYnJvd3NpbmdDb250ZXh0Lm9yaWdpbmFsT3BlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3BhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KGNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInBvcHVwXCIgLyogUGFnZUV2ZW50LlBvcHVwICovLCBwYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51c2VyQ29udGV4dC5vbignY2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAjY3JlYXRlUGFnZShicm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBCaWRpUGFnZS5mcm9tKHRoaXMsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLiNwYWdlcy5zZXQoYnJvd3NpbmdDb250ZXh0LCBwYWdlKTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJjbG9zZVwiIC8qIFBhZ2VFdmVudC5DbG9zZSAqLywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3BhZ2VzLmRlbGV0ZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyAtLSBUYXJnZXQgc3R1ZmYgc3RhcnRzIGhlcmUgLS1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VUYXJnZXQgPSBuZXcgQmlkaVBhZ2VUYXJnZXQocGFnZSk7XG4gICAgICAgICAgICBjb25zdCBwYWdlVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuI3RhcmdldHMuc2V0KHBhZ2UsIFtwYWdlVGFyZ2V0LCBwYWdlVGFyZ2V0c10pO1xuICAgICAgICAgICAgcGFnZS50cnVzdGVkRW1pdHRlci5vbihcImZyYW1lYXR0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVBdHRhY2hlZCAqLywgZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBCaWRpRnJhbWVUYXJnZXQoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICBwYWdlVGFyZ2V0cy5zZXQoYmlkaUZyYW1lLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJmcmFtZW5hdmlnYXRlZFwiIC8qIFBhZ2VFdmVudC5GcmFtZU5hdmlnYXRlZCAqLywgZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHBhZ2VUYXJnZXRzLmdldChiaWRpRnJhbWUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHRhcmdldCwgdGhlbiB0aGlzIGlzIHRoZSBwYWdlJ3MgZnJhbWUuXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNoYW5nZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENoYW5nZWQgKi8sIHBhZ2VUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnVzdGVkRW1pdHRlci5lbWl0KFwidGFyZ2V0Y2hhbmdlZFwiIC8qIEJyb3dzZXJDb250ZXh0RXZlbnQuVGFyZ2V0Q2hhbmdlZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJmcmFtZWRldGFjaGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lRGV0YWNoZWQgKi8sIGZyYW1lID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWRpRnJhbWUgPSBmcmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBwYWdlVGFyZ2V0cy5nZXQoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYWdlVGFyZ2V0cy5kZWxldGUoYmlkaUZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRkZXN0cm95ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldERlc3Ryb3llZCAqLywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFnZS50cnVzdGVkRW1pdHRlci5vbihcIndvcmtlcmNyZWF0ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyQ3JlYXRlZCAqLywgd29ya2VyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWRpV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBCaWRpV29ya2VyVGFyZ2V0KGJpZGlXb3JrZXIpO1xuICAgICAgICAgICAgICAgIHBhZ2VUYXJnZXRzLnNldChiaWRpV29ya2VyLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhZ2UudHJ1c3RlZEVtaXR0ZXIub24oXCJ3b3JrZXJkZXN0cm95ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyRGVzdHJveWVkICovLCB3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFnZVRhcmdldHMuZ2V0KGJpZGlXb3JrZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhZ2VUYXJnZXRzLmRlbGV0ZSh3b3JrZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGRlc3Ryb3llZFwiIC8qIEJyb3dzZXJDb250ZXh0RXZlbnQuVGFyZ2V0RGVzdHJveWVkICovLCB0YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYWdlLnRydXN0ZWRFbWl0dGVyLm9uKFwiY2xvc2VcIiAvKiBQYWdlRXZlbnQuQ2xvc2UgKi8sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiN0YXJnZXRzLmRlbGV0ZShwYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ0YXJnZXRkZXN0cm95ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldERlc3Ryb3llZCAqLywgcGFnZVRhcmdldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInRhcmdldGNyZWF0ZWRcIiAvKiBCcm93c2VyQ29udGV4dEV2ZW50LlRhcmdldENyZWF0ZWQgKi8sIHBhZ2VUYXJnZXQpO1xuICAgICAgICAgICAgLy8gLS0gVGFyZ2V0IHN0dWZmIGVuZHMgaGVyZSAtLVxuICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy4jdGFyZ2V0cy52YWx1ZXMoKV0uZmxhdE1hcCgoW3RhcmdldCwgZnJhbWVzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdGFyZ2V0LCAuLi5mcmFtZXMudmFsdWVzKCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgbmV3UGFnZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZ3VhcmQgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMSwgYXdhaXQgdGhpcy53YWl0Rm9yU2NyZWVuc2hvdE9wZXJhdGlvbnMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLnVzZXJDb250ZXh0LmNyZWF0ZUJyb3dzaW5nQ29udGV4dChcInRhYlwiIC8qIEJpZGkuQnJvd3NpbmdDb250ZXh0LkNyZWF0ZVR5cGUuVGFiICovKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZXMuZ2V0KGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgaXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNkZWZhdWx0Vmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHBhZ2Uuc2V0Vmlld3BvcnQodGhpcy4jZGVmYXVsdFZpZXdwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzdXBwb3J0IGZvciBzZXRWaWV3cG9ydCBpbiBGaXJlZm94LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNJbmNvZ25pdG8oKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCBjb250ZXh0IGNhbm5vdCBiZSBjbG9zZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlckNvbnRleHQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3RhcmdldHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicm93c2VyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcGFnZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMudXNlckNvbnRleHQuYnJvd3NpbmdDb250ZXh0c10ubWFwKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYWdlcy5nZXQoY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc0luY29nbml0bygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJDb250ZXh0LmlkICE9PSBVc2VyQ29udGV4dC5ERUZBVUxUO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIG92ZXJyaWRlUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnNTZXQgPSBuZXcgU2V0KHBlcm1pc3Npb25zLm1hcChwZXJtaXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm90b2NvbFBlcm1pc3Npb24gPSBXRUJfUEVSTUlTU0lPTl9UT19QUk9UT0NPTF9QRVJNSVNTSU9OLmdldChwZXJtaXNzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3RvY29sUGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcGVybWlzc2lvbjogJyArIHBlcm1pc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGVybWlzc2lvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oV0VCX1BFUk1JU1NJT05fVE9fUFJPVE9DT0xfUEVSTUlTU0lPTi5rZXlzKCkpLm1hcChwZXJtaXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVzZXJDb250ZXh0LnNldFBlcm1pc3Npb25zKG9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwZXJtaXNzaW9uLFxuICAgICAgICAgICAgICAgIH0sIHBlcm1pc3Npb25zU2V0LmhhcyhwZXJtaXNzaW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFwiZ3JhbnRlZFwiIC8qIEJpZGkuUGVybWlzc2lvbnMuUGVybWlzc2lvblN0YXRlLkdyYW50ZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBcImRlbmllZFwiIC8qIEJpZGkuUGVybWlzc2lvbnMuUGVybWlzc2lvblN0YXRlLkRlbmllZCAqLyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jb3ZlcnJpZGVzLnB1c2goeyBvcmlnaW4sIHBlcm1pc3Npb24gfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZSBwZXJtaXNzaW9ucyBhcmUgb3V0ZGF0ZWQgYW5kIHNldHRpbmcgdGhlbSB0byBkZW5pZWQgZG9lc1xuICAgICAgICAgICAgICAgIC8vIG5vdCB3b3JrLlxuICAgICAgICAgICAgICAgIGlmICghcGVybWlzc2lvbnNTZXQuaGFzKHBlcm1pc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xlYXJQZXJtaXNzaW9uT3ZlcnJpZGVzKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLiNvdmVycmlkZXMubWFwKCh7IHBlcm1pc3Npb24sIG9yaWdpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgLnNldFBlcm1pc3Npb25zKG9yaWdpbiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwZXJtaXNzaW9uLFxuICAgICAgICAgICAgICAgIH0sIFwicHJvbXB0XCIgLyogQmlkaS5QZXJtaXNzaW9ucy5QZXJtaXNzaW9uU3RhdGUuUHJvbXB0ICovKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZGVidWdFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuI292ZXJyaWRlcyA9IFtdO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJDb250ZXh0LmlkID09PSBVc2VyQ29udGV4dC5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJDb250ZXh0LmlkO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpQnJvd3NlckNvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJDb250ZXh0LmpzLm1hcCIsImltcG9ydCB7IENEUFNlc3Npb24gfSBmcm9tICcuLi9hcGkvQ0RQU2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBUYXJnZXRDbG9zZUVycm9yLCBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICcuLi91dGlsL0RlZmVycmVkLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpQ2RwU2Vzc2lvbiBleHRlbmRzIENEUFNlc3Npb24ge1xuICAgIHN0YXRpYyBzZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAjZGV0YWNoZWQgPSBmYWxzZTtcbiAgICAjY29ubmVjdGlvbjtcbiAgICAjc2Vzc2lvbklkID0gRGVmZXJyZWQuY3JlYXRlKCk7XG4gICAgZnJhbWU7XG4gICAgY29uc3RydWN0b3IoZnJhbWUsIHNlc3Npb25JZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyYW1lID0gZnJhbWU7XG4gICAgICAgIGlmICghdGhpcy5mcmFtZS5wYWdlKCkuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmZyYW1lLnBhZ2UoKS5icm93c2VyKCkuY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy4jY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGlmIChzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3Nlc3Npb25JZC5yZXNvbHZlKHNlc3Npb25JZCk7XG4gICAgICAgICAgICBCaWRpQ2RwU2Vzc2lvbi5zZXNzaW9ucy5zZXQoc2Vzc2lvbklkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZCgnY2RwLmdldFNlc3Npb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBmcmFtZS5faWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZXNzaW9uSWQucmVzb2x2ZShyZXN1bHQuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIEJpZGlDZHBTZXNzaW9uLnNlc3Npb25zLnNldChyZXN1bHQuc2Vzc2lvbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzZXNzaW9uSWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNBRkVUWTogV2UgbmV2ZXIgdGhyb3cgI3Nlc3Npb25JZC5cbiAgICAgICAgQmlkaUNkcFNlc3Npb24uc2Vzc2lvbnMuc2V0KHRoaXMuI3Nlc3Npb25JZC52YWx1ZSgpLCB0aGlzKTtcbiAgICB9XG4gICAgY29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgc2VuZChtZXRob2QsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy4jY29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oJ0NEUCBzdXBwb3J0IGlzIHJlcXVpcmVkIGZvciB0aGlzIGZlYXR1cmUuIFRoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDRFAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2RldGFjaGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGFyZ2V0Q2xvc2VFcnJvcihgUHJvdG9jb2wgZXJyb3IgKCR7bWV0aG9kfSk6IFNlc3Npb24gY2xvc2VkLiBNb3N0IGxpa2VseSB0aGUgcGFnZSBoYXMgYmVlbiBjbG9zZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuI3Nlc3Npb25JZC52YWx1ZU9yVGhyb3coKTtcbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuI2Nvbm5lY3Rpb24uc2VuZCgnY2RwLnNlbmRDb21tYW5kJywge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgIH0sIG9wdGlvbnM/LnRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGV0YWNoKCkge1xuICAgICAgICBpZiAodGhpcy4jY29ubmVjdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0aW9uLmNsb3NlZCB8fFxuICAgICAgICAgICAgdGhpcy4jZGV0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmFtZS5jbGllbnQuc2VuZCgnVGFyZ2V0LmRldGFjaEZyb21UYXJnZXQnLCB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLmlkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIEJpZGlDZHBTZXNzaW9uLnNlc3Npb25zLmRlbGV0ZSh0aGlzLmlkKCkpO1xuICAgICAgICB0aGlzLiNkZXRhY2hlZCA9IHRydWU7XG4gICAgfTtcbiAgICBpZCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLiNzZXNzaW9uSWQudmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6ICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNEUFNlc3Npb24uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IENhbGxiYWNrUmVnaXN0cnkgfSBmcm9tICcuLi9jb21tb24vQ2FsbGJhY2tSZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2NvbW1vbi9EZWJ1Zy5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlsL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBCaWRpQ2RwU2Vzc2lvbiB9IGZyb20gJy4vQ0RQU2Vzc2lvbi5qcyc7XG5jb25zdCBkZWJ1Z1Byb3RvY29sU2VuZCA9IGRlYnVnKCdwdXBwZXRlZXI6d2ViRHJpdmVyQmlEaTpTRU5EIOKWuicpO1xuY29uc3QgZGVidWdQcm90b2NvbFJlY2VpdmUgPSBkZWJ1ZygncHVwcGV0ZWVyOndlYkRyaXZlckJpRGk6UkVDViDil4AnKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgI3VybDtcbiAgICAjdHJhbnNwb3J0O1xuICAgICNkZWxheTtcbiAgICAjdGltZW91dCA9IDA7XG4gICAgI2Nsb3NlZCA9IGZhbHNlO1xuICAgICNjYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tSZWdpc3RyeSgpO1xuICAgICNlbWl0dGVycyA9IFtdO1xuICAgIGNvbnN0cnVjdG9yKHVybCwgdHJhbnNwb3J0LCBkZWxheSA9IDAsIHRpbWVvdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICB0aGlzLiNkZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLiN0aW1lb3V0ID0gdGltZW91dCA/PyAxODBfMDAwO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMuI3RyYW5zcG9ydC5vbm1lc3NhZ2UgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQub25jbG9zZSA9IHRoaXMudW5iaW5kLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjbG9zZWQ7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN1cmw7XG4gICAgfVxuICAgIHBpcGVUbyhlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXJzLnB1c2goZW1pdHRlcik7XG4gICAgfVxuICAgIGVtaXQodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbWl0dGVyIG9mIHRoaXMuI2VtaXR0ZXJzKSB7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQodHlwZSwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KHR5cGUsIGV2ZW50KTtcbiAgICB9XG4gICAgc2VuZChtZXRob2QsIHBhcmFtcywgdGltZW91dCkge1xuICAgICAgICBhc3NlcnQoIXRoaXMuI2Nsb3NlZCwgJ1Byb3RvY29sIGVycm9yOiBDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NhbGxiYWNrcy5jcmVhdGUobWV0aG9kLCB0aW1lb3V0ID8/IHRoaXMuI3RpbWVvdXQsIGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWJ1Z1Byb3RvY29sU2VuZChzdHJpbmdpZmllZE1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy4jdHJhbnNwb3J0LnNlbmQoc3RyaW5naWZpZWRNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIG9uTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLiNkZWxheSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoZiA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgdGhpcy4jZGVsYXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdQcm90b2NvbFJlY2VpdmUobWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgIGlmICgndHlwZScgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3VjY2Vzcyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2NhbGxiYWNrcy5yZXNvbHZlKG9iamVjdC5pZCwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdC5pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jY2FsbGJhY2tzLnJlamVjdChvYmplY3QuaWQsIGNyZWF0ZVByb3RvY29sRXJyb3Iob2JqZWN0KSwgYCR7b2JqZWN0LmVycm9yfTogJHtvYmplY3QubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V2ZW50JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2RwRXZlbnQob2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQmlkaUNkcFNlc3Npb24uc2Vzc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KG9iamVjdC5wYXJhbXMuc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LmVtaXQob2JqZWN0LnBhcmFtcy5ldmVudCwgb2JqZWN0LnBhcmFtcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogV2Uga25vdyB0aGUgbWV0aG9kIGFuZCBwYXJhbWV0ZXIgc3RpbGwgbWF0Y2ggaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KG9iamVjdC5tZXRob2QsIG9iamVjdC5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZlbiBpZiB0aGUgcmVzcG9uc2UgaW4gbm90IGluIEJpRGkgcHJvdG9jb2wgZm9ybWF0IGJ1dCBgaWRgIGlzIHByb3ZpZGVkLCByZWplY3RcbiAgICAgICAgLy8gdGhlIGNhbGxiYWNrLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGVuZHBvaW50IHN1cHBvcnRzIENEUCBpbnN0ZWFkIG9mIEJpRGkuXG4gICAgICAgIGlmICgnaWQnIGluIG9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy4jY2FsbGJhY2tzLnJlamVjdChvYmplY3QuaWQsIGBQcm90b2NvbCBFcnJvci4gTWVzc2FnZSBpcyBub3QgaW4gQmlEaSBwcm90b2NvbCBmb3JtYXQ6ICcke21lc3NhZ2V9J2AsIG9iamVjdC5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0Vycm9yKG9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuYmluZHMgdGhlIGNvbm5lY3Rpb24sIGJ1dCBrZWVwcyB0aGUgdHJhbnNwb3J0IG9wZW4uIFVzZWZ1bCB3aGVuIHRoZSB0cmFuc3BvcnQgd2lsbFxuICAgICAqIGJlIHJldXNlZCBieSBvdGhlciBjb25uZWN0aW9uIGUuZy4gd2l0aCBkaWZmZXJlbnQgcHJvdG9jb2wuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5iaW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gQm90aCBtYXkgc3RpbGwgYmUgaW52b2tlZCBhbmQgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgdGhpcy4jdHJhbnNwb3J0Lm9ubWVzc2FnZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy4jdHJhbnNwb3J0Lm9uY2xvc2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuI2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmJpbmRzIHRoZSBjb25uZWN0aW9uIGFuZCBjbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICB0aGlzLiN0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0UGVuZGluZ1Byb3RvY29sRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FsbGJhY2tzLmdldFBlbmRpbmdQcm90b2NvbEVycm9ycygpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sRXJyb3Iob2JqZWN0KSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBgJHtvYmplY3QuZXJyb3J9ICR7b2JqZWN0Lm1lc3NhZ2V9YDtcbiAgICBpZiAob2JqZWN0LnN0YWNrdHJhY2UpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgICR7b2JqZWN0LnN0YWNrdHJhY2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpc0NkcEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lm1ldGhvZC5zdGFydHNXaXRoKCdjZHAuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5pbXBvcnQgeyBkZWJ1Z0Vycm9yIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlEZXNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBkZXNlcmlhbGl6ZShyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGRlYnVnRXJyb3IoJ1NlcnZpY2UgZGlkIG5vdCBwcm9kdWNlIGEgcmVzdWx0LicpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZT8ubWFwKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlPy5yZWR1Y2UoKGFjYywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5hZGQodGhpcy5kZXNlcmlhbGl6ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH0sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU/LnJlZHVjZSgoYWNjLCB0dXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHRoaXMuI2Rlc2VyaWFsaXplVHVwbGUodHVwbGUpO1xuICAgICAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZT8ucmVkdWNlKChhY2MsIHR1cGxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gdGhpcy4jZGVzZXJpYWxpemVUdXBsZSh0dXBsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Muc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICBjYXNlICdwcm9taXNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlc3VsdC52YWx1ZS5wYXR0ZXJuLCByZXN1bHQudmFsdWUuZmxhZ3MpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Rlc2VyaWFsaXplTnVtYmVyKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBCaWdJbnQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdFcnJvcihgRGVzZXJpYWxpemF0aW9uIG9mIHR5cGUgJHtyZXN1bHQudHlwZX0gbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhdGljICNkZXNlcmlhbGl6ZU51bWJlcih2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICctMCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0wO1xuICAgICAgICAgICAgY2FzZSAnTmFOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgY2FzZSAnSW5maW5pdHknOlxuICAgICAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICAgIGNhc2UgJy1JbmZpbml0eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyAjZGVzZXJpYWxpemVUdXBsZShbc2VyaWFsaXplZEtleSwgc2VyaWFsaXplZFZhbHVlXSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2Ygc2VyaWFsaXplZEtleSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gc2VyaWFsaXplZEtleVxuICAgICAgICAgICAgOiB0aGlzLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRLZXkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVzZXJpYWxpemUoc2VyaWFsaXplZFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsga2V5LCB2YWx1ZSB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlc2VyaWFsaXplci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgRGlhbG9nIH0gZnJvbSAnLi4vYXBpL0RpYWxvZy5qcyc7XG5leHBvcnQgY2xhc3MgQmlkaURpYWxvZyBleHRlbmRzIERpYWxvZyB7XG4gICAgc3RhdGljIGZyb20ocHJvbXB0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlkaURpYWxvZyhwcm9tcHQpO1xuICAgIH1cbiAgICAjcHJvbXB0O1xuICAgIGNvbnN0cnVjdG9yKHByb21wdCkge1xuICAgICAgICBzdXBlcihwcm9tcHQuaW5mby50eXBlLCBwcm9tcHQuaW5mby5tZXNzYWdlLCBwcm9tcHQuaW5mby5kZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLiNwcm9tcHQgPSBwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZShvcHRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3Byb21wdC5oYW5kbGUoe1xuICAgICAgICAgICAgYWNjZXB0OiBvcHRpb25zLmFjY2VwdCxcbiAgICAgICAgICAgIHVzZXJUZXh0OiBvcHRpb25zLnRleHQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpYWxvZy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlID0gKHRoaXMgJiYgdGhpcy5fX2FkZERpc3Bvc2FibGVSZXNvdXJjZSkgfHwgZnVuY3Rpb24gKGVudiwgdmFsdWUsIGFzeW5jKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XG4gICAgICAgIHZhciBkaXNwb3NlO1xuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICAgICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICAgICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2Rpc3Bvc2VSZXNvdXJjZXMgPSAodGhpcyAmJiB0aGlzLl9fZGlzcG9zZVJlc291cmNlcykgfHwgKGZ1bmN0aW9uIChTdXBwcmVzc2VkRXJyb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVudikge1xuICAgICAgICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICAgICAgICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBTdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgICAgICAgICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgd2hpbGUgKGVudi5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjID0gZW52LnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZWMuZGlzcG9zZSAmJiByZWMuZGlzcG9zZS5jYWxsKHJlYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWMuYXN5bmMpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfTtcbn0pKHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59KTtcbmltcG9ydCB7IEVsZW1lbnRIYW5kbGUgfSBmcm9tICcuLi9hcGkvRWxlbWVudEhhbmRsZS5qcyc7XG5pbXBvcnQgeyBBc3luY0l0ZXJhYmxlVXRpbCB9IGZyb20gJy4uL3V0aWwvQXN5bmNJdGVyYWJsZVV0aWwuanMnO1xuaW1wb3J0IHsgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IEJpZGlKU0hhbmRsZSB9IGZyb20gJy4vSlNIYW5kbGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlFbGVtZW50SGFuZGxlID0gKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IF9jbGFzc1N1cGVyID0gRWxlbWVudEhhbmRsZTtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2F1dG9maWxsX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jb250ZW50RnJhbWVfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgQmlkaUVsZW1lbnRIYW5kbGUgZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX2F1dG9maWxsX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKCldO1xuICAgICAgICAgICAgX2NvbnRlbnRGcmFtZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZCgpLCAoX2EgPSBFbGVtZW50SGFuZGxlKS5iaW5kSXNvbGF0ZWRIYW5kbGUuYmluZChfYSldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9hdXRvZmlsbF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYXV0b2ZpbGxcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImF1dG9maWxsXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouYXV0b2ZpbGwgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2NvbnRlbnRGcmFtZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY29udGVudEZyYW1lXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJjb250ZW50RnJhbWVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jb250ZW50RnJhbWUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb20odmFsdWUsIHJlYWxtKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZGlFbGVtZW50SGFuZGxlKHZhbHVlLCByZWFsbSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUsIHJlYWxtKSB7XG4gICAgICAgICAgICBzdXBlcihCaWRpSlNIYW5kbGUuZnJvbSh2YWx1ZSwgcmVhbG0pKTtcbiAgICAgICAgICAgIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVhbG0oKSB7XG4gICAgICAgICAgICAvLyBTQUZFVFk6IFNlZSB0aGUgc3VwZXIgY2FsbCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUucmVhbG07XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhbG0uZW52aXJvbm1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3RlVmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGUucmVtb3RlVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhdXRvZmlsbChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmZyYW1lLmNsaWVudDtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVJbmZvID0gYXdhaXQgY2xpZW50LnNlbmQoJ0RPTS5kZXNjcmliZU5vZGUnLCB7XG4gICAgICAgICAgICAgICAgb2JqZWN0SWQ6IHRoaXMuaGFuZGxlLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZElkID0gbm9kZUluZm8ubm9kZS5iYWNrZW5kTm9kZUlkO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IHRoaXMuZnJhbWUuX2lkO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnNlbmQoJ0F1dG9maWxsLnRyaWdnZXInLCB7XG4gICAgICAgICAgICAgICAgZmllbGRJZCxcbiAgICAgICAgICAgICAgICBmcmFtZUlkLFxuICAgICAgICAgICAgICAgIGNhcmQ6IGRhdGEuY3JlZGl0Q2FyZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvbnRlbnRGcmFtZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMSwgKGF3YWl0IHRoaXMuZXZhbHVhdGVIYW5kbGUoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9KSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhhbmRsZS5yZW1vdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnd2luZG93Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wYWdlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mcmFtZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLl9pZCA9PT0gdmFsdWUudmFsdWUuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSkgPz8gbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgICAgIGVudl8xLmVycm9yID0gZV8xO1xuICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgdXBsb2FkRmlsZSguLi5maWxlcykge1xuICAgICAgICAgICAgLy8gTG9jYXRlIGFsbCBmaWxlcyBhbmQgY29uZmlybSB0aGF0IHRoZXkgZXhpc3QuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NvbnNpc3RlbnQtdHlwZS1pbXBvcnRzXG4gICAgICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IGF3YWl0IGltcG9ydCgncGF0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSlNIYW5kbGUjdXBsb2FkRmlsZSBjYW4gb25seSBiZSB1c2VkIGluIE5vZGUtbGlrZSBlbnZpcm9ubWVudHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgud2luMzIuaXNBYnNvbHV0ZShmaWxlKSB8fCBwYXRoLnBvc2l4LmlzQWJzb2x1dGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mcmFtZS5zZXRGaWxlcyh0aGlzLCBmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgKnF1ZXJ5QVhUcmVlKG5hbWUsIHJvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmZyYW1lLmxvY2F0ZU5vZGVzKHRoaXMsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYWNjZXNzaWJpbGl0eScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIEFzeW5jSXRlcmFibGVVdGlsLm1hcChyZXN1bHRzLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGFuZ2Ugb3duZXJzaGlwIHNpbmNlIHRoZSBkZWZhdWx0IG93bmVyc2hpcCBpcyBwcm9iYWJseSBub25lLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoQmlkaUVsZW1lbnRIYW5kbGUuZnJvbShub2RlLCB0aGlzLnJlYWxtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQmlkaUVsZW1lbnRIYW5kbGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVsZW1lbnRIYW5kbGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgKiBhcyBCaWRpIGZyb20gJ2Nocm9taXVtLWJpZGkvbGliL2Nqcy9wcm90b2NvbC9wcm90b2NvbC5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2sgfSBmcm9tICcuLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVGdW5jdGlvbiwgc3RyaW5naWZ5RnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL0Z1bmN0aW9uLmpzJztcbmltcG9ydCB7IEJpZGlFbGVtZW50SGFuZGxlIH0gZnJvbSAnLi9FbGVtZW50SGFuZGxlLmpzJztcbmltcG9ydCB7IEJpZGlKU0hhbmRsZSB9IGZyb20gJy4vSlNIYW5kbGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEV4cG9zZWFibGVGdW5jdGlvbiB7XG4gICAgc3RhdGljIGFzeW5jIGZyb20oZnJhbWUsIG5hbWUsIGFwcGx5LCBpc29sYXRlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZnVuYyA9IG5ldyBFeHBvc2VhYmxlRnVuY3Rpb24oZnJhbWUsIG5hbWUsIGFwcGx5LCBpc29sYXRlKTtcbiAgICAgICAgYXdhaXQgZnVuYy4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICB9XG4gICAgI2ZyYW1lO1xuICAgIG5hbWU7XG4gICAgI2FwcGx5O1xuICAgICNpc29sYXRlO1xuICAgICNjaGFubmVsO1xuICAgICNzY3JpcHRzID0gW107XG4gICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lLCBuYW1lLCBhcHBseSwgaXNvbGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gZnJhbWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI2FwcGx5ID0gYXBwbHk7XG4gICAgICAgIHRoaXMuI2lzb2xhdGUgPSBpc29sYXRlO1xuICAgICAgICB0aGlzLiNjaGFubmVsID0gYF9fcHVwcGV0ZWVyX18ke3RoaXMuI2ZyYW1lLl9pZH1fcGFnZV9leHBvc2VGdW5jdGlvbl8ke3RoaXMubmFtZX1gO1xuICAgIH1cbiAgICBhc3luYyAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuI2Nvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgICAgICAgICB0eXBlOiAnY2hhbm5lbCcsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuI2NoYW5uZWwsXG4gICAgICAgICAgICAgICAgb3duZXJzaGlwOiBcInJvb3RcIiAvKiBCaWRpLlNjcmlwdC5SZXN1bHRPd25lcnNoaXAuUm9vdCAqLyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25FbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIoY29ubmVjdGlvbikpO1xuICAgICAgICBjb25uZWN0aW9uRW1pdHRlci5vbihCaWRpLkNocm9taXVtQmlkaS5TY3JpcHQuRXZlbnROYW1lcy5NZXNzYWdlLCB0aGlzLiNoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHN0cmluZ2lmeUZ1bmN0aW9uKGludGVycG9sYXRlRnVuY3Rpb24oKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgICAgICAgICAgICAgICBbUExBQ0VIT0xERVIoJ25hbWUnKV06IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhbcmVzb2x2ZSwgcmVqZWN0LCBhcmdzXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgeyBuYW1lOiBKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpIH0pKTtcbiAgICAgICAgY29uc3QgZnJhbWVzID0gW3RoaXMuI2ZyYW1lXTtcbiAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgIGZyYW1lcy5wdXNoKC4uLmZyYW1lLmNoaWxkRnJhbWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGZyYW1lcy5tYXAoYXN5bmMgKGZyYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IHRoaXMuI2lzb2xhdGUgPyBmcmFtZS5pc29sYXRlZFJlYWxtKCkgOiBmcmFtZS5tYWluUmVhbG0oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3NjcmlwdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmJyb3dzaW5nQ29udGV4dC5hZGRQcmVsb2FkU2NyaXB0KGZ1bmN0aW9uRGVjbGFyYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2NoYW5uZWxdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FuZGJveDogcmVhbG0uc2FuZGJveCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHJlYWxtLnJlYWxtLmNhbGxGdW5jdGlvbihmdW5jdGlvbkRlY2xhcmF0aW9uLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbY2hhbm5lbF0sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuI3NjcmlwdHMucHVzaChbZnJhbWUsIHNjcmlwdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCB0aGUgZnJhbWUgcHJvYmFibHkgZG9lc24ndCBzdXBwb3J0IGNhbGwgZnVuY3Rpb24uIFdlXG4gICAgICAgICAgICAgICAgLy8gZmFpbCBncmFjZWZ1bGx5LlxuICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCAjY29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lLnBhZ2UoKS5icm93c2VyKCkuY29ubmVjdGlvbjtcbiAgICB9XG4gICAgI2hhbmRsZU1lc3NhZ2UgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jaGFubmVsICE9PSB0aGlzLiNjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhbG0gPSB0aGlzLiNnZXRSZWFsbShwYXJhbXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcmVhbG0pIHtcbiAgICAgICAgICAgICAgICAvLyBVbnJlbGF0ZWQgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhSGFuZGxlID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIEJpZGlKU0hhbmRsZS5mcm9tKHBhcmFtcy5kYXRhLCByZWFsbSksIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3NIYW5kbGUgPSBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnZfMSwgYXdhaXQgZGF0YUhhbmRsZS5ldmFsdWF0ZUhhbmRsZSgoWywgLCBhcmdzXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfSksIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIG5ldyBEaXNwb3NhYmxlU3RhY2soKSwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGhhbmRsZV0gb2YgYXdhaXQgYXJnc0hhbmRsZS5nZXRQcm9wZXJ0aWVzKCkpIHtcbiAgICAgICAgICAgICAgICBzdGFjay51c2UoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGhhbmRsZXMgYXJlIHBhc3NlZCBhcyBpcy5cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlIGluc3RhbmNlb2YgQmlkaUVsZW1lbnRIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1sraW5kZXhdID0gaGFuZGxlO1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51c2UoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBwYXNzZWQgYXMgdGhlIEpTIHZhbHVlLlxuICAgICAgICAgICAgICAgIGFyZ3NbK2luZGV4XSA9IGhhbmRsZS5qc29uVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuI2FwcGx5KC4uLihhd2FpdCBQcm9taXNlLmFsbChhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGRhdGFIYW5kbGUuZXZhbHVhdGUoKFssIHJlamVjdF0sIG5hbWUsIG1lc3NhZ2UsIHN0YWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBkYXRhSGFuZGxlLmV2YWx1YXRlKChbLCByZWplY3RdLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGRhdGFIYW5kbGUuZXZhbHVhdGUoKFtyZXNvbHZlXSwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVidWdFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMSkge1xuICAgICAgICAgICAgZW52XzEuZXJyb3IgPSBlXzE7XG4gICAgICAgICAgICBlbnZfMS5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52XzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAjZ2V0UmVhbG0oc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy4jZmluZEZyYW1lKHNvdXJjZS5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFmcmFtZSkge1xuICAgICAgICAgICAgLy8gVW5yZWxhdGVkIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYW1lLnJlYWxtKHNvdXJjZS5yZWFsbSk7XG4gICAgfVxuICAgICNmaW5kRnJhbWUoaWQpIHtcbiAgICAgICAgY29uc3QgZnJhbWVzID0gW3RoaXMuI2ZyYW1lXTtcbiAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChmcmFtZS5faWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVzLnB1c2goLi4uZnJhbWUuY2hpbGRGcmFtZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbU3ltYm9sLmRpc3Bvc2VdKCkge1xuICAgICAgICB2b2lkIHRoaXNbU3ltYm9sLmFzeW5jRGlzcG9zZV0oKS5jYXRjaChkZWJ1Z0Vycm9yKTtcbiAgICB9XG4gICAgYXN5bmMgW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKCkge1xuICAgICAgICB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuI3NjcmlwdHMubWFwKGFzeW5jIChbZnJhbWUsIHNjcmlwdF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gdGhpcy4jaXNvbGF0ZSA/IGZyYW1lLmlzb2xhdGVkUmVhbG0oKSA6IGZyYW1lLm1haW5SZWFsbSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHJlYWxtLmV2YWx1YXRlKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMubmFtZSksXG4gICAgICAgICAgICAgICAgICAgIC4uLmZyYW1lLmNoaWxkRnJhbWVzKCkubWFwKGNoaWxkRnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkRnJhbWUuZXZhbHVhdGUobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbFRoaXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYnJvd3NpbmdDb250ZXh0LnJlbW92ZVByZWxvYWRTY3JpcHQoc2NyaXB0KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXhwb3NlZEZ1bmN0aW9uLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG52YXIgX19zZXRGdW5jdGlvbk5hbWUgPSAodGhpcyAmJiB0aGlzLl9fc2V0RnVuY3Rpb25OYW1lKSB8fCBmdW5jdGlvbiAoZiwgbmFtZSwgcHJlZml4KSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcbmltcG9ydCAqIGFzIEJpZGkgZnJvbSAnY2hyb21pdW0tYmlkaS9saWIvY2pzL3Byb3RvY29sL3Byb3RvY29sLmpzJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIGRlZmVyLCBkZWxheVdoZW4sIGZpbHRlciwgZmlyc3QsIGZpcnN0VmFsdWVGcm9tLCBtYXAsIG9mLCByYWNlV2l0aCwgc3dpdGNoTWFwLCB9IGZyb20gJy4uLy4uL3RoaXJkX3BhcnR5L3J4anMvcnhqcy5qcyc7XG5pbXBvcnQgeyBGcmFtZSwgdGhyb3dJZkRldGFjaGVkLCB9IGZyb20gJy4uL2FwaS9GcmFtZS5qcyc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5IH0gZnJvbSAnLi4vY2RwL0FjY2Vzc2liaWxpdHkuanMnO1xuaW1wb3J0IHsgQ29uc29sZU1lc3NhZ2UsIH0gZnJvbSAnLi4vY29tbW9uL0NvbnNvbGVNZXNzYWdlLmpzJztcbmltcG9ydCB7IFRhcmdldENsb3NlRXJyb3IsIFVuc3VwcG9ydGVkT3BlcmF0aW9uIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBkZWJ1Z0Vycm9yLCBmcm9tRW1pdHRlckV2ZW50LCB0aW1lb3V0IH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgaXNFcnJvckxpa2UgfSBmcm9tICcuLi91dGlsL0Vycm9yTGlrZS5qcyc7XG5pbXBvcnQgeyBCaWRpQ2RwU2Vzc2lvbiB9IGZyb20gJy4vQ0RQU2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBCaWRpRGVzZXJpYWxpemVyIH0gZnJvbSAnLi9EZXNlcmlhbGl6ZXIuanMnO1xuaW1wb3J0IHsgQmlkaURpYWxvZyB9IGZyb20gJy4vRGlhbG9nLmpzJztcbmltcG9ydCB7IEV4cG9zZWFibGVGdW5jdGlvbiB9IGZyb20gJy4vRXhwb3NlZEZ1bmN0aW9uLmpzJztcbmltcG9ydCB7IEJpZGlIVFRQUmVxdWVzdCwgcmVxdWVzdHMgfSBmcm9tICcuL0hUVFBSZXF1ZXN0LmpzJztcbmltcG9ydCB7IEJpZGlKU0hhbmRsZSB9IGZyb20gJy4vSlNIYW5kbGUuanMnO1xuaW1wb3J0IHsgQmlkaUZyYW1lUmVhbG0gfSBmcm9tICcuL1JlYWxtLmpzJztcbmltcG9ydCB7IHJld3JpdGVOYXZpZ2F0aW9uRXJyb3IgfSBmcm9tICcuL3V0aWwuanMnO1xuaW1wb3J0IHsgQmlkaVdlYldvcmtlciB9IGZyb20gJy4vV2ViV29ya2VyLmpzJztcbmxldCBCaWRpRnJhbWUgPSAoKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBGcmFtZTtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2dvdG9fZGVjb3JhdG9ycztcbiAgICBsZXQgX3NldENvbnRlbnRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3dhaXRGb3JOYXZpZ2F0aW9uX2RlY29yYXRvcnM7XG4gICAgbGV0IF9wcml2YXRlX3dhaXRGb3JMb2FkJF9kZWNvcmF0b3JzO1xuICAgIGxldCBfcHJpdmF0ZV93YWl0Rm9yTG9hZCRfZGVzY3JpcHRvcjtcbiAgICBsZXQgX3ByaXZhdGVfd2FpdEZvck5ldHdvcmtJZGxlJF9kZWNvcmF0b3JzO1xuICAgIGxldCBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2Rlc2NyaXB0b3I7XG4gICAgbGV0IF9zZXRGaWxlc19kZWNvcmF0b3JzO1xuICAgIGxldCBfbG9jYXRlTm9kZXNfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgQmlkaUZyYW1lIGV4dGVuZHMgX2NsYXNzU3VwZXIge1xuICAgICAgICBzdGF0aWMge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUoX2NsYXNzU3VwZXJbU3ltYm9sLm1ldGFkYXRhXSA/PyBudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9nb3RvX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRldGFjaGVkXTtcbiAgICAgICAgICAgIF9zZXRDb250ZW50X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRldGFjaGVkXTtcbiAgICAgICAgICAgIF93YWl0Rm9yTmF2aWdhdGlvbl9kZWNvcmF0b3JzID0gW3Rocm93SWZEZXRhY2hlZF07XG4gICAgICAgICAgICBfcHJpdmF0ZV93YWl0Rm9yTG9hZCRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGV0YWNoZWRdO1xuICAgICAgICAgICAgX3ByaXZhdGVfd2FpdEZvck5ldHdvcmtJZGxlJF9kZWNvcmF0b3JzID0gW3Rocm93SWZEZXRhY2hlZF07XG4gICAgICAgICAgICBfc2V0RmlsZXNfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGV0YWNoZWRdO1xuICAgICAgICAgICAgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRldGFjaGVkXTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZ290b19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZ290b1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiZ290b1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmdvdG8gfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3NldENvbnRlbnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldENvbnRlbnRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldENvbnRlbnRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5zZXRDb250ZW50IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF93YWl0Rm9yTmF2aWdhdGlvbl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwid2FpdEZvck5hdmlnYXRpb25cIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcIndhaXRGb3JOYXZpZ2F0aW9uXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoud2FpdEZvck5hdmlnYXRpb24gfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgX3ByaXZhdGVfd2FpdEZvckxvYWQkX2Rlc2NyaXB0b3IgPSB7IHZhbHVlOiBfX3NldEZ1bmN0aW9uTmFtZShmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHdhaXRVbnRpbCA9ICdsb2FkJyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0OiBtcyA9IHRoaXMudGltZW91dFNldHRpbmdzLm5hdmlnYXRpb25UaW1lb3V0KCkgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3YWl0VW50aWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0VW50aWwgPSBbd2FpdFVudGlsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGlmZWN5Y2xlRXZlbnQgb2Ygd2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGxpZmVjeWNsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbG9hZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmFkZCgnbG9hZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZG9tY29udGVudGxvYWRlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmFkZCgnRE9NQ29udGVudExvYWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChbLi4uZXZlbnRzXS5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb21FbWl0dGVyRXZlbnQodGhpcy5icm93c2luZ0NvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLnBpcGUobWFwKCgpID0+IHsgfSksIGZpcnN0KCksIHJhY2VXaXRoKHRpbWVvdXQobXMpLCB0aGlzLiNkZXRhY2hlZCQoKS5waXBlKG1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lIGRldGFjaGVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9KSkpKTtcbiAgICAgICAgICAgICAgICB9LCBcIiN3YWl0Rm9yTG9hZCRcIikgfSwgX3ByaXZhdGVfd2FpdEZvckxvYWQkX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCIjd2FpdEZvckxvYWQkXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IHRydWUsIGFjY2VzczogeyBoYXM6IG9iaiA9PiAjd2FpdEZvckxvYWQkIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLiN3YWl0Rm9yTG9hZCQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgX3ByaXZhdGVfd2FpdEZvck5ldHdvcmtJZGxlJF9kZXNjcmlwdG9yID0geyB2YWx1ZTogX19zZXRGdW5jdGlvbk5hbWUoZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB3YWl0VW50aWwgPSAnbG9hZCcgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3YWl0VW50aWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0VW50aWwgPSBbd2FpdFVudGlsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uY3VycmVuY3kgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiB3YWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXR3b3JraWRsZTAnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gTWF0aC5taW4oMCwgY29uY3VycmVuY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV0d29ya2lkbGUyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jdXJyZW5jeSA9IE1hdGgubWluKDIsIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2UoKS53YWl0Rm9yTmV0d29ya0lkbGUkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgPz8gdGhpcy50aW1lb3V0U2V0dGluZ3MudGltZW91dCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIFwiI3dhaXRGb3JOZXR3b3JrSWRsZSRcIikgfSwgX3ByaXZhdGVfd2FpdEZvck5ldHdvcmtJZGxlJF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiI3dhaXRGb3JOZXR3b3JrSWRsZSRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogdHJ1ZSwgYWNjZXNzOiB7IGhhczogb2JqID0+ICN3YWl0Rm9yTmV0d29ya0lkbGUkIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLiN3YWl0Rm9yTmV0d29ya0lkbGUkIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRGaWxlc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic2V0RmlsZXNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldEZpbGVzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0RmlsZXMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJsb2NhdGVOb2Rlc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwibG9jYXRlTm9kZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5sb2NhdGVOb2RlcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbShwYXJlbnQsIGJyb3dzaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSBuZXcgQmlkaUZyYW1lKHBhcmVudCwgYnJvd3NpbmdDb250ZXh0KTtcbiAgICAgICAgICAgIGZyYW1lLiNpbml0aWFsaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgI3BhcmVudCA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICAjZnJhbWVzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgcmVhbG1zO1xuICAgICAgICBfaWQ7XG4gICAgICAgIGNsaWVudDtcbiAgICAgICAgYWNjZXNzaWJpbGl0eTtcbiAgICAgICAgY29uc3RydWN0b3IocGFyZW50LCBicm93c2luZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dCA9IGJyb3dzaW5nQ29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gYnJvd3NpbmdDb250ZXh0LmlkO1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBuZXcgQmlkaUNkcFNlc3Npb24odGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlYWxtcyA9IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBCaWRpRnJhbWVSZWFsbS5mcm9tKHRoaXMuYnJvd3NpbmdDb250ZXh0LmRlZmF1bHRSZWFsbSwgdGhpcyksXG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IEJpZGlGcmFtZVJlYWxtLmZyb20odGhpcy5icm93c2luZ0NvbnRleHQuY3JlYXRlV2luZG93UmVhbG0oYF9fcHVwcGV0ZWVyX2ludGVybmFsXyR7TWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiAxMDAwMCl9YCksIHRoaXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eSA9IG5ldyBBY2Nlc3NpYmlsaXR5KHRoaXMucmVhbG1zLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBicm93c2luZ0NvbnRleHQgb2YgdGhpcy5icm93c2luZ0NvbnRleHQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNjcmVhdGVGcmFtZVRhcmdldChicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ2Jyb3dzaW5nY29udGV4dCcsICh7IGJyb3dzaW5nQ29udGV4dCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY3JlYXRlRnJhbWVUYXJnZXQoYnJvd3NpbmdDb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNlc3Npb24gb2YgQmlkaUNkcFNlc3Npb24uc2Vzc2lvbnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uZnJhbWUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb24ub25DbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJmcmFtZWRldGFjaGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lRGV0YWNoZWQgKi8sIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dC5vbigncmVxdWVzdCcsICh7IHJlcXVlc3QgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGh0dHBSZXF1ZXN0ID0gQmlkaUhUVFBSZXF1ZXN0LmZyb20ocmVxdWVzdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdzdWNjZXNzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2UoKS50cnVzdGVkRW1pdHRlci5lbWl0KFwicmVxdWVzdGZpbmlzaGVkXCIgLyogUGFnZUV2ZW50LlJlcXVlc3RGaW5pc2hlZCAqLywgaHR0cFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXF1ZXN0ZmFpbGVkXCIgLyogUGFnZUV2ZW50LlJlcXVlc3RGYWlsZWQgKi8sIGh0dHBSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2b2lkIGh0dHBSZXF1ZXN0LmZpbmFsaXplSW50ZXJjZXB0aW9ucygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dC5vbignbmF2aWdhdGlvbicsICh7IG5hdmlnYXRpb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRpb24ub25jZSgnZnJhZ21lbnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJmcmFtZW5hdmlnYXRlZFwiIC8qIFBhZ2VFdmVudC5GcmFtZU5hdmlnYXRlZCAqLywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJsb2FkXCIgLyogUGFnZUV2ZW50LkxvYWQgKi8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWRMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2UoKS50cnVzdGVkRW1pdHRlci5lbWl0KFwiZG9tY29udGVudGxvYWRlZFwiIC8qIFBhZ2VFdmVudC5ET01Db250ZW50TG9hZGVkICovLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJmcmFtZW5hdmlnYXRlZFwiIC8qIFBhZ2VFdmVudC5GcmFtZU5hdmlnYXRlZCAqLywgdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCd1c2VycHJvbXB0JywgKHsgdXNlclByb21wdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImRpYWxvZ1wiIC8qIFBhZ2VFdmVudC5EaWFsb2cgKi8sIEJpZGlEaWFsb2cuZnJvbSh1c2VyUHJvbXB0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0Lm9uKCdsb2cnLCAoeyBlbnRyeSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lkICE9PSBlbnRyeS5zb3VyY2UuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0NvbnNvbGVMb2dFbnRyeShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IGVudHJ5LmFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluUmVhbG0oKS5jcmVhdGVIYW5kbGUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhcmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVkdWNlKCh2YWx1ZSwgYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IGFyZyBpbnN0YW5jZW9mIEJpZGlKU0hhbmRsZSAmJiBhcmcuaXNQcmltaXRpdmVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gQmlkaURlc2VyaWFsaXplci5kZXNlcmlhbGl6ZShhcmcucmVtb3RlVmFsdWUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3ZhbHVlfSAke3BhcnNlZFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgIH0sICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhZ2UoKS50cnVzdGVkRW1pdHRlci5lbWl0KFwiY29uc29sZVwiIC8qIFBhZ2VFdmVudC5Db25zb2xlICovLCBuZXcgQ29uc29sZU1lc3NhZ2UoZW50cnkubWV0aG9kLCB0ZXh0LCBhcmdzLCBnZXRTdGFja1RyYWNlTG9jYXRpb25zKGVudHJ5LnN0YWNrVHJhY2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSmF2YVNjcmlwdExvZ0VudHJ5KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlbnRyeS50ZXh0ID8/ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUhlaWdodCA9IGVycm9yLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZUxpbmVzID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLnNwbGljZSgwLCBtZXNzYWdlSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhY2tMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuc3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBlbnRyeS5zdGFja1RyYWNlLmNhbGxGcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHdlIG5lZWQgdG8gYWRkIGAxYCBiZWNhdXNlIHRoZSB2YWx1ZXMgYXJlIDAtaW5kZXhlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja0xpbmVzLnB1c2goYCAgICBhdCAke2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnPGFub255bW91cz4nfSAoJHtmcmFtZS51cmx9OiR7ZnJhbWUubGluZU51bWJlciArIDF9OiR7ZnJhbWUuY29sdW1uTnVtYmVyICsgMX0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID49IEVycm9yLnN0YWNrVHJhY2VMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBbLi4ubWVzc2FnZUxpbmVzLCAuLi5zdGFja0xpbmVzXS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInBhZ2VlcnJvclwiIC8qIFBhZ2VFdmVudC5QYWdlRXJyb3IgKi8sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnRXJyb3IoYFVuaGFuZGxlZCBMb2dFbnRyeSB3aXRoIHR5cGUgXCIke2VudHJ5LnR5cGV9XCIsIHRleHQgXCIke2VudHJ5LnRleHR9XCIgYW5kIGxldmVsIFwiJHtlbnRyeS5sZXZlbH1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5icm93c2luZ0NvbnRleHQub24oJ3dvcmtlcicsICh7IHJlYWxtIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3b3JrZXIgPSBCaWRpV2ViV29ya2VyLmZyb20odGhpcywgcmVhbG0pO1xuICAgICAgICAgICAgICAgIHJlYWxtLm9uKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ3b3JrZXJkZXN0cm95ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyRGVzdHJveWVkICovLCB3b3JrZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJ3b3JrZXJjcmVhdGVkXCIgLyogUGFnZUV2ZW50LldvcmtlckNyZWF0ZWQgKi8sIHdvcmtlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAjY3JlYXRlRnJhbWVUYXJnZXQoYnJvd3NpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZSA9IEJpZGlGcmFtZS5mcm9tKHRoaXMsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZXMuc2V0KGJyb3dzaW5nQ29udGV4dCwgZnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5wYWdlKCkudHJ1c3RlZEVtaXR0ZXIuZW1pdChcImZyYW1lYXR0YWNoZWRcIiAvKiBQYWdlRXZlbnQuRnJhbWVBdHRhY2hlZCAqLywgZnJhbWUpO1xuICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0Lm9uKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZnJhbWVzLmRlbGV0ZShicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHRpbWVvdXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2UoKS5fdGltZW91dFNldHRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIG1haW5SZWFsbSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWxtcy5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlzb2xhdGVkUmVhbG0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFsbXMuaW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmVhbG0oaWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhbG0gb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnJlYWxtcykpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhbG0ucmVhbG0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFsbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGFnZSgpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgQmlkaUZyYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlzT09QRnJhbWUoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5icm93c2luZ0NvbnRleHQudXJsO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudEZyYW1lKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3BhcmVudCBpbnN0YW5jZW9mIEJpZGlGcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEZyYW1lcygpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy5icm93c2luZ0NvbnRleHQuY2hpbGRyZW5dLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lcy5nZXQoY2hpbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgI2RldGFjaGVkJCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUVtaXR0ZXJFdmVudCh0aGlzLnBhZ2UoKS50cnVzdGVkRW1pdHRlciwgXCJmcmFtZWRldGFjaGVkXCIgLyogUGFnZUV2ZW50LkZyYW1lRGV0YWNoZWQgKi8pLnBpcGUoZmlsdGVyKGRldGFjaGVkRnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWNoZWRGcmFtZSA9PT0gdGhpcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnb3RvKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBbcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdEZvck5hdmlnYXRpb24ob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgLy8gU29tZSBpbXBsZW1lbnRhdGlvbnMgY3VycmVudGx5IG9ubHkgcmVwb3J0IGVycm9ycyB3aGVuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlYWRpbmVzcz1pbnRlcmFjdGl2ZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFJlbGF0ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDY2MDFcbiAgICAgICAgICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dFxuICAgICAgICAgICAgICAgICAgICAubmF2aWdhdGUodXJsLCBcImludGVyYWN0aXZlXCIgLyogQmlkaS5Ccm93c2luZ0NvbnRleHQuUmVhZGluZXNzU3RhdGUuSW50ZXJhY3RpdmUgKi8pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Vycm9yTGlrZShlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ25ldDo6RVJSX0hUVFBfUkVTUE9OU0VfQ09ERV9GQUlMVVJFJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLmNhdGNoKHJld3JpdGVOYXZpZ2F0aW9uRXJyb3IodXJsLCBvcHRpb25zLnRpbWVvdXQgPz8gdGhpcy50aW1lb3V0U2V0dGluZ3MubmF2aWdhdGlvblRpbWVvdXQoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENvbnRlbnQoaHRtbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGcmFtZUNvbnRlbnQoaHRtbCksXG4gICAgICAgICAgICAgICAgZmlyc3RWYWx1ZUZyb20oY29tYmluZUxhdGVzdChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3dhaXRGb3JMb2FkJChvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jd2FpdEZvck5ldHdvcmtJZGxlJChvcHRpb25zKSxcbiAgICAgICAgICAgICAgICBdKSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB3YWl0Rm9yTmF2aWdhdGlvbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dDogbXMgPSB0aGlzLnRpbWVvdXRTZXR0aW5ncy5uYXZpZ2F0aW9uVGltZW91dCgpIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gdGhpcy5jaGlsZEZyYW1lcygpLm1hcChmcmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLiNkZXRhY2hlZCQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZpcnN0VmFsdWVGcm9tKGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICAgICAgICAgIGZyb21FbWl0dGVyRXZlbnQodGhpcy5icm93c2luZ0NvbnRleHQsICduYXZpZ2F0aW9uJykucGlwZShzd2l0Y2hNYXAoKHsgbmF2aWdhdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiN3YWl0Rm9yTG9hZCQob3B0aW9ucykucGlwZShkZWxheVdoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KGZyYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLCByYWNlV2l0aChmcm9tRW1pdHRlckV2ZW50KG5hdmlnYXRpb24sICdmcmFnbWVudCcpLCBmcm9tRW1pdHRlckV2ZW50KG5hdmlnYXRpb24sICdmYWlsZWQnKSwgZnJvbUVtaXR0ZXJFdmVudChuYXZpZ2F0aW9uLCAnYWJvcnRlZCcpLnBpcGUobWFwKCh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hdmlnYXRpb24gYWJvcnRlZDogJHt1cmx9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSksIHN3aXRjaE1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmF2aWdhdGlvbi5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVxdWVzdEZpbmlzaGVkJChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZHVjZXMgZmxha2luZXNzIGlmIHRoZSByZXNwb25zZSBldmVudHMgYXJyaXZlIGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc3VhbGx5LCB0aGUgcmVzcG9uc2Ugb3IgZXJyb3IgaXMgYWxyZWFkeSB0aGVyZSBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZSB8fCByZXF1ZXN0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2YobmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0RmluaXNoZWQkKHJlcXVlc3QucmVkaXJlY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tRW1pdHRlckV2ZW50KHJlcXVlc3QsICdzdWNjZXNzJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKHJhY2VXaXRoKGZyb21FbWl0dGVyRXZlbnQocmVxdWVzdCwgJ2Vycm9yJykpLCByYWNlV2l0aChmcm9tRW1pdHRlckV2ZW50KHJlcXVlc3QsICdyZWRpcmVjdCcpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5waXBlKHN3aXRjaE1hcCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEZpbmlzaGVkJChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdEZpbmlzaGVkJChuYXZpZ2F0aW9uLnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKG5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIHRoaXMuI3dhaXRGb3JOZXR3b3JrSWRsZSQob3B0aW9ucyksXG4gICAgICAgICAgICBdKS5waXBlKG1hcCgoW25hdmlnYXRpb25dKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5hdmlnYXRpb24ucmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RSZXF1ZXN0ID0gcmVxdWVzdC5sYXN0UmVkaXJlY3QgPz8gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBjb25zdCBodHRwUmVxdWVzdCA9IHJlcXVlc3RzLmdldChsYXN0UmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXF1ZXN0LnJlc3BvbnNlKCk7XG4gICAgICAgICAgICB9KSwgcmFjZVdpdGgodGltZW91dChtcyksIHRoaXMuI2RldGFjaGVkJCgpLnBpcGUobWFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGFyZ2V0Q2xvc2VFcnJvcignRnJhbWUgZGV0YWNoZWQuJyk7XG4gICAgICAgICAgICB9KSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FpdEZvckRldmljZVByb21wdCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkZXRhY2hlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyb3dzaW5nQ29udGV4dC5jbG9zZWQ7XG4gICAgICAgIH1cbiAgICAgICAgI2V4cG9zZWRGdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGFzeW5jIGV4cG9zZUZ1bmN0aW9uKG5hbWUsIGFwcGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jZXhwb3NlZEZ1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBhZGQgcGFnZSBiaW5kaW5nIHdpdGggbmFtZSAke25hbWV9OiBnbG9iYWxUaGlzWycke25hbWV9J10gYWxyZWFkeSBleGlzdHMhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleHBvc2VhYmxlID0gYXdhaXQgRXhwb3NlYWJsZUZ1bmN0aW9uLmZyb20odGhpcywgbmFtZSwgYXBwbHkpO1xuICAgICAgICAgICAgdGhpcy4jZXhwb3NlZEZ1bmN0aW9ucy5zZXQobmFtZSwgZXhwb3NlYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlRXhwb3NlZEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWRGdW5jdGlvbiA9IHRoaXMuI2V4cG9zZWRGdW5jdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKCFleHBvc2VkRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZW1vdmUgcGFnZSBiaW5kaW5nIHdpdGggbmFtZSAke25hbWV9OiB3aW5kb3dbJyR7bmFtZX0nXSBkb2VzIG5vdCBleGlzdHMhYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNleHBvc2VkRnVuY3Rpb25zLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGF3YWl0IGV4cG9zZWRGdW5jdGlvbltTeW1ib2wuYXN5bmNEaXNwb3NlXSgpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNyZWF0ZUNEUFNlc3Npb24oKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlc3Npb25JZCB9ID0gYXdhaXQgdGhpcy5jbGllbnQuc2VuZCgnVGFyZ2V0LmF0dGFjaFRvVGFyZ2V0Jywge1xuICAgICAgICAgICAgICAgIHRhcmdldElkOiB0aGlzLl9pZCxcbiAgICAgICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJyb3dzaW5nQ29udGV4dC5zdWJzY3JpYmUoW0JpZGkuQ2hyb21pdW1CaWRpLkJpRGlNb2R1bGUuQ2RwXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZGlDZHBTZXNzaW9uKHRoaXMsIHNlc3Npb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICN3YWl0Rm9yTG9hZCQoKSB7IHJldHVybiBfcHJpdmF0ZV93YWl0Rm9yTG9hZCRfZGVzY3JpcHRvci52YWx1ZTsgfVxuICAgICAgICBnZXQgI3dhaXRGb3JOZXR3b3JrSWRsZSQoKSB7IHJldHVybiBfcHJpdmF0ZV93YWl0Rm9yTmV0d29ya0lkbGUkX2Rlc2NyaXB0b3IudmFsdWU7IH1cbiAgICAgICAgYXN5bmMgc2V0RmlsZXMoZWxlbWVudCwgZmlsZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYnJvd3NpbmdDb250ZXh0LnNldEZpbGVzKFxuICAgICAgICAgICAgLy8gU0FGRVRZOiBFbGVtZW50SGFuZGxlcyBhcmUgYWx3YXlzIHJlbW90ZSByZWZlcmVuY2VzLlxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdGVWYWx1ZSgpLCBmaWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgbG9jYXRlTm9kZXMoZWxlbWVudCwgbG9jYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYnJvd3NpbmdDb250ZXh0LmxvY2F0ZU5vZGVzKGxvY2F0b3IsIFxuICAgICAgICAgICAgLy8gU0FGRVRZOiBFbGVtZW50SGFuZGxlcyBhcmUgYWx3YXlzIHJlbW90ZSByZWZlcmVuY2VzLlxuICAgICAgICAgICAgW2VsZW1lbnQucmVtb3RlVmFsdWUoKV0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpRnJhbWUgfTtcbmZ1bmN0aW9uIGlzQ29uc29sZUxvZ0VudHJ5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdjb25zb2xlJztcbn1cbmZ1bmN0aW9uIGlzSmF2YVNjcmlwdExvZ0VudHJ5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09ICdqYXZhc2NyaXB0Jztcbn1cbmZ1bmN0aW9uIGdldFN0YWNrVHJhY2VMb2NhdGlvbnMoc3RhY2tUcmFjZSkge1xuICAgIGNvbnN0IHN0YWNrVHJhY2VMb2NhdGlvbnMgPSBbXTtcbiAgICBpZiAoc3RhY2tUcmFjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxGcmFtZSBvZiBzdGFja1RyYWNlLmNhbGxGcmFtZXMpIHtcbiAgICAgICAgICAgIHN0YWNrVHJhY2VMb2NhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBjYWxsRnJhbWUudXJsLFxuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGNhbGxGcmFtZS5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY2FsbEZyYW1lLmNvbHVtbk51bWJlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFja1RyYWNlTG9jYXRpb25zO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJhbWUuanMubWFwIiwidmFyIF9hO1xuaW1wb3J0IHsgSFRUUFJlcXVlc3QsIFNUQVRVU19URVhUUywgaGFuZGxlRXJyb3IsIH0gZnJvbSAnLi4vYXBpL0hUVFBSZXF1ZXN0LmpzJztcbmltcG9ydCB7IFVuc3VwcG9ydGVkT3BlcmF0aW9uIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBCaWRpSFRUUFJlc3BvbnNlIH0gZnJvbSAnLi9IVFRQUmVzcG9uc2UuanMnO1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpSFRUUFJlcXVlc3QgZXh0ZW5kcyBIVFRQUmVxdWVzdCB7XG4gICAgc3RhdGljIGZyb20oYmlkaVJlcXVlc3QsIGZyYW1lLCByZWRpcmVjdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IF9hKGJpZGlSZXF1ZXN0LCBmcmFtZSwgcmVkaXJlY3QpO1xuICAgICAgICByZXF1ZXN0LiNpbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICAjcmVkaXJlY3RDaGFpbjtcbiAgICAjcmVzcG9uc2UgPSBudWxsO1xuICAgIGlkO1xuICAgICNmcmFtZTtcbiAgICAjcmVxdWVzdDtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0LCBmcmFtZSwgcmVkaXJlY3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgcmVxdWVzdHMuc2V0KHJlcXVlc3QsIHRoaXMpO1xuICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5lbmFibGVkID0gcmVxdWVzdC5pc0Jsb2NrZWQ7XG4gICAgICAgIHRoaXMuI3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLiNyZWRpcmVjdENoYWluID0gcmVkaXJlY3QgPyByZWRpcmVjdC4jcmVkaXJlY3RDaGFpbiA6IFtdO1xuICAgICAgICB0aGlzLmlkID0gcmVxdWVzdC5pZDtcbiAgICB9XG4gICAgZ2V0IGNsaWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lLmNsaWVudDtcbiAgICB9XG4gICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuI3JlcXVlc3Qub24oJ3JlZGlyZWN0JywgcmVxdWVzdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBodHRwUmVxdWVzdCA9IF9hLmZyb20ocmVxdWVzdCwgdGhpcy4jZnJhbWUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy4jcmVkaXJlY3RDaGFpbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbmNlKCdzdWNjZXNzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZyYW1lXG4gICAgICAgICAgICAgICAgICAgIC5wYWdlKClcbiAgICAgICAgICAgICAgICAgICAgLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXF1ZXN0ZmluaXNoZWRcIiAvKiBQYWdlRXZlbnQuUmVxdWVzdEZpbmlzaGVkICovLCBodHRwUmVxdWVzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgLnBhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInJlcXVlc3RmYWlsZWRcIiAvKiBQYWdlRXZlbnQuUmVxdWVzdEZhaWxlZCAqLywgaHR0cFJlcXVlc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2b2lkIGh0dHBSZXF1ZXN0LmZpbmFsaXplSW50ZXJjZXB0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4jcmVxdWVzdC5vbmNlKCdzdWNjZXNzJywgZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNyZXNwb25zZSA9IEJpZGlIVFRQUmVzcG9uc2UuZnJvbShkYXRhLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3JlcXVlc3Qub24oJ2F1dGhlbnRpY2F0ZScsIHRoaXMuI2hhbmRsZUF1dGhlbnRpY2F0aW9uKTtcbiAgICAgICAgdGhpcy4jZnJhbWUucGFnZSgpLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJyZXF1ZXN0XCIgLyogUGFnZUV2ZW50LlJlcXVlc3QgKi8sIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy4jaGFzSW50ZXJuYWxIZWFkZXJPdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJjZXB0aW9uLmhhbmRsZXJzLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29udGludWUoe1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMoKSxcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3QudXJsO1xuICAgIH1cbiAgICByZXNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBtZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0Lm1ldGhvZDtcbiAgICB9XG4gICAgcG9zdERhdGEoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBoYXNQb3N0RGF0YSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUG9zdERhdGEoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBnZXQgI2hhc0ludGVybmFsSGVhZGVyT3ZlcndyaXRlKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihPYmplY3Qua2V5cyh0aGlzLiNleHRyYUhUVFBIZWFkZXJzKS5sZW5ndGggfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuI3VzZXJBZ2VudEhlYWRlcnMpLmxlbmd0aCk7XG4gICAgfVxuICAgIGdldCAjZXh0cmFIVFRQSGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lPy5wYWdlKCkuX2V4dHJhSFRUUEhlYWRlcnMgPz8ge307XG4gICAgfVxuICAgIGdldCAjdXNlckFnZW50SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lPy5wYWdlKCkuX3VzZXJBZ2VudEhlYWRlcnMgPz8ge307XG4gICAgfVxuICAgIGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgdGhpcy4jcmVxdWVzdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2hlYWRlci5uYW1lLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyLnZhbHVlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgICAgLi4udGhpcy4jZXh0cmFIVFRQSGVhZGVycyxcbiAgICAgICAgICAgIC4uLnRoaXMuI3VzZXJBZ2VudEhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVzcG9uc2U7XG4gICAgfVxuICAgIGZhaWx1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZXF1ZXN0LmVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yVGV4dDogdGhpcy4jcmVxdWVzdC5lcnJvciB9O1xuICAgIH1cbiAgICBpc05hdmlnYXRpb25SZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdC5uYXZpZ2F0aW9uICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGluaXRpYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3QuaW5pdGlhdG9yO1xuICAgIH1cbiAgICByZWRpcmVjdENoYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVkaXJlY3RDaGFpbi5zbGljZSgpO1xuICAgIH1cbiAgICBmcmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lO1xuICAgIH1cbiAgICBhc3luYyBjb250aW51ZShvdmVycmlkZXMsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBzdXBlci5jb250aW51ZSh7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLiNoYXNJbnRlcm5hbEhlYWRlck92ZXJ3cml0ZSA/IHRoaXMuaGVhZGVycygpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgICAgICB9LCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGFzeW5jIF9jb250aW51ZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QmlkaUhlYWRlcnMob3ZlcnJpZGVzLmhlYWRlcnMpO1xuICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5oYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI3JlcXVlc3RcbiAgICAgICAgICAgIC5jb250aW51ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgdXJsOiBvdmVycmlkZXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiBvdmVycmlkZXMubWV0aG9kLFxuICAgICAgICAgICAgYm9keTogb3ZlcnJpZGVzLnBvc3REYXRhXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYnRvYShvdmVycmlkZXMucG9zdERhdGEpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMubGVuZ3RoID4gMCA/IGhlYWRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRpb24uaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9hYm9ydCgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRpb24uaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXF1ZXN0LmZhaWxSZXF1ZXN0KCkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmNlcHRpb24uaGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfcmVzcG9uZChyZXNwb25zZSwgX3ByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMuaW50ZXJjZXB0aW9uLmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICBsZXQgcGFyc2VkQm9keTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIHBhcnNlZEJvZHkgPSBIVFRQUmVxdWVzdC5nZXRSZXNwb25zZShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gZ2V0QmlkaUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnRMZW5ndGggPSBoZWFkZXJzLnNvbWUoaGVhZGVyID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXIubmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNwb25zZS5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29udGVudC10eXBlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3BvbnNlLmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkQm9keT8uY29udGVudExlbmd0aCAmJiAhaGFzQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgaGVhZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnY29udGVudC1sZW5ndGgnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKHBhcnNlZEJvZHkuY29udGVudExlbmd0aCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cyB8fCAyMDA7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNyZXF1ZXN0XG4gICAgICAgICAgICAucHJvdmlkZVJlc3BvbnNlKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMubGVuZ3RoID4gMCA/IGhlYWRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZWFzb25QaHJhc2U6IFNUQVRVU19URVhUU1tzdGF0dXNdLFxuICAgICAgICAgICAgYm9keTogcGFyc2VkQm9keT8uYmFzZTY0XG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkQm9keT8uYmFzZTY0LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmludGVyY2VwdGlvbi5oYW5kbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNhdXRoZW50aWNhdGlvbkhhbmRsZWQgPSBmYWxzZTtcbiAgICAjaGFuZGxlQXV0aGVudGljYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuI2ZyYW1lLnBhZ2UoKS5fY3JlZGVudGlhbHM7XG4gICAgICAgIGlmIChjcmVkZW50aWFscyAmJiAhdGhpcy4jYXV0aGVudGljYXRpb25IYW5kbGVkKSB7XG4gICAgICAgICAgICB0aGlzLiNhdXRoZW50aWNhdGlvbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdm9pZCB0aGlzLiNyZXF1ZXN0LmNvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Byb3ZpZGVDcmVkZW50aWFscycsXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IGNyZWRlbnRpYWxzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXNzd29yZDogY3JlZGVudGlhbHMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm9pZCB0aGlzLiNyZXF1ZXN0LmNvbnRpbnVlV2l0aEF1dGgoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2NhbmNlbCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5fYSA9IEJpZGlIVFRQUmVxdWVzdDtcbmZ1bmN0aW9uIGdldEJpZGlIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gW107XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJhd0hlYWRlcnMgPz8gW10pKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzKHZhbHVlLCB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUVFBSZXF1ZXN0LmpzLm1hcCIsInZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEhUVFBSZXNwb25zZSB9IGZyb20gJy4uL2FwaS9IVFRQUmVzcG9uc2UuanMnO1xuaW1wb3J0IHsgVW5zdXBwb3J0ZWRPcGVyYXRpb24gfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IGludm9rZUF0TW9zdE9uY2VGb3JBcmd1bWVudHMgfSBmcm9tICcuLi91dGlsL2RlY29yYXRvcnMuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJpZGlIVFRQUmVzcG9uc2UgPSAoKCkgPT4ge1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEhUVFBSZXNwb25zZTtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX3JlbW90ZUFkZHJlc3NfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgQmlkaUhUVFBSZXNwb25zZSBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfcmVtb3RlQWRkcmVzc19kZWNvcmF0b3JzID0gW2ludm9rZUF0TW9zdE9uY2VGb3JBcmd1bWVudHNdO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZW1vdGVBZGRyZXNzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJyZW1vdGVBZGRyZXNzXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJyZW1vdGVBZGRyZXNzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVtb3RlQWRkcmVzcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbShkYXRhLCByZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBCaWRpSFRUUFJlc3BvbnNlKGRhdGEsIHJlcXVlc3QpO1xuICAgICAgICAgICAgcmVzcG9uc2UuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICAjZGF0YSA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI3JlcXVlc3Q7XG4gICAgICAgIGNvbnN0cnVjdG9yKGRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNkYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2RhdGEuZnJvbUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAuZnJhbWUoKVxuICAgICAgICAgICAgICAgICAgICA/LnBhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAudHJ1c3RlZEVtaXR0ZXIuZW1pdChcInJlcXVlc3RzZXJ2ZWRmcm9tY2FjaGVcIiAvKiBQYWdlRXZlbnQuUmVxdWVzdFNlcnZlZEZyb21DYWNoZSAqLywgdGhpcy4jcmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNyZXF1ZXN0LmZyYW1lKCk/LnBhZ2UoKS50cnVzdGVkRW1pdHRlci5lbWl0KFwicmVzcG9uc2VcIiAvKiBQYWdlRXZlbnQuUmVzcG9uc2UgKi8sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlbW90ZUFkZHJlc3MoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlwOiAnJyxcbiAgICAgICAgICAgICAgICBwb3J0OiAtMSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEudXJsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXR1cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNkYXRhLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBzdGF0dXNUZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RhdGEuc3RhdHVzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIG9uY2UgdGhlIEZpcmVmb3ggaW1wbGVtZW50YXRpb24gaXMgY29tcGxpYW50IHdpdGggaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNnZXQtdGhlLXJlc3BvbnNlLWRhdGEuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiB0aGlzLiNkYXRhLmhlYWRlcnMgfHwgW10pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIEJpbmFyeSBIZWFkZXJzXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyN0eXBlLW5ldHdvcmstSGVhZGVyXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci52YWx1ZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2hlYWRlci5uYW1lLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBmcm9tQ2FjaGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGF0YS5mcm9tQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgdGltaW5nKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogRmlsZSBhbmQgaXNzdWUgd2l0aCBCaURpIHNwZWNcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlcXVlc3QuZnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tU2VydmljZVdvcmtlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWN1cml0eURldGFpbHMoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQmlkaUhUVFBSZXNwb25zZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRUUFJlc3BvbnNlLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5pbXBvcnQgeyBLZXlib2FyZCwgTW91c2UsIE1vdXNlQnV0dG9uLCBUb3VjaHNjcmVlbiwgfSBmcm9tICcuLi9hcGkvSW5wdXQuanMnO1xuaW1wb3J0IHsgVW5zdXBwb3J0ZWRPcGVyYXRpb24gfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbnZhciBTb3VyY2VBY3Rpb25zVHlwZTtcbihmdW5jdGlvbiAoU291cmNlQWN0aW9uc1R5cGUpIHtcbiAgICBTb3VyY2VBY3Rpb25zVHlwZVtcIk5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICBTb3VyY2VBY3Rpb25zVHlwZVtcIktleVwiXSA9IFwia2V5XCI7XG4gICAgU291cmNlQWN0aW9uc1R5cGVbXCJQb2ludGVyXCJdID0gXCJwb2ludGVyXCI7XG4gICAgU291cmNlQWN0aW9uc1R5cGVbXCJXaGVlbFwiXSA9IFwid2hlZWxcIjtcbn0pKFNvdXJjZUFjdGlvbnNUeXBlIHx8IChTb3VyY2VBY3Rpb25zVHlwZSA9IHt9KSk7XG52YXIgQWN0aW9uVHlwZTtcbihmdW5jdGlvbiAoQWN0aW9uVHlwZSkge1xuICAgIEFjdGlvblR5cGVbXCJQYXVzZVwiXSA9IFwicGF1c2VcIjtcbiAgICBBY3Rpb25UeXBlW1wiS2V5RG93blwiXSA9IFwia2V5RG93blwiO1xuICAgIEFjdGlvblR5cGVbXCJLZXlVcFwiXSA9IFwia2V5VXBcIjtcbiAgICBBY3Rpb25UeXBlW1wiUG9pbnRlclVwXCJdID0gXCJwb2ludGVyVXBcIjtcbiAgICBBY3Rpb25UeXBlW1wiUG9pbnRlckRvd25cIl0gPSBcInBvaW50ZXJEb3duXCI7XG4gICAgQWN0aW9uVHlwZVtcIlBvaW50ZXJNb3ZlXCJdID0gXCJwb2ludGVyTW92ZVwiO1xuICAgIEFjdGlvblR5cGVbXCJTY3JvbGxcIl0gPSBcInNjcm9sbFwiO1xufSkoQWN0aW9uVHlwZSB8fCAoQWN0aW9uVHlwZSA9IHt9KSk7XG5jb25zdCBnZXRCaWRpS2V5VmFsdWUgPSAoa2V5KSA9PiB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgICAgIGtleSA9ICdFbnRlcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gTWVhc3VyZXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyByYXRoZXIgdGhhbiBVVEYtMTYgY29kZSB1bml0cy5cbiAgICBpZiAoWy4uLmtleV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ0NhbmNlbCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDEnO1xuICAgICAgICBjYXNlICdIZWxwJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwMic7XG4gICAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMDMnO1xuICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDA0JztcbiAgICAgICAgY2FzZSAnQ2xlYXInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDA1JztcbiAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDA3JztcbiAgICAgICAgY2FzZSAnU2hpZnQnOlxuICAgICAgICBjYXNlICdTaGlmdExlZnQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDA4JztcbiAgICAgICAgY2FzZSAnQ29udHJvbCc6XG4gICAgICAgIGNhc2UgJ0NvbnRyb2xMZWZ0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwOSc7XG4gICAgICAgIGNhc2UgJ0FsdCc6XG4gICAgICAgIGNhc2UgJ0FsdExlZnQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDBBJztcbiAgICAgICAgY2FzZSAnUGF1c2UnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDBCJztcbiAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAwQyc7XG4gICAgICAgIGNhc2UgJ1BhZ2VVcCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMEUnO1xuICAgICAgICBjYXNlICdQYWdlRG93bic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMEYnO1xuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDEwJztcbiAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTEnO1xuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDEyJztcbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTMnO1xuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxNCc7XG4gICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMTUnO1xuICAgICAgICBjYXNlICdJbnNlcnQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDE2JztcbiAgICAgICAgY2FzZSAnRGVsZXRlJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxNyc7XG4gICAgICAgIGNhc2UgJ051bXBhZEVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxOSc7XG4gICAgICAgIGNhc2UgJ051bXBhZDAnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDFBJztcbiAgICAgICAgY2FzZSAnTnVtcGFkMSc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMUInO1xuICAgICAgICBjYXNlICdOdW1wYWQyJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxQyc7XG4gICAgICAgIGNhc2UgJ051bXBhZDMnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDFEJztcbiAgICAgICAgY2FzZSAnTnVtcGFkNCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMUUnO1xuICAgICAgICBjYXNlICdOdW1wYWQ1JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAxRic7XG4gICAgICAgIGNhc2UgJ051bXBhZDYnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDIwJztcbiAgICAgICAgY2FzZSAnTnVtcGFkNyc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwMjEnO1xuICAgICAgICBjYXNlICdOdW1wYWQ4JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAyMic7XG4gICAgICAgIGNhc2UgJ051bXBhZDknOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDIzJztcbiAgICAgICAgY2FzZSAnTnVtcGFkTXVsdGlwbHknOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDI0JztcbiAgICAgICAgY2FzZSAnTnVtcGFkQWRkJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAyNSc7XG4gICAgICAgIGNhc2UgJ051bXBhZFN1YnRyYWN0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAyNyc7XG4gICAgICAgIGNhc2UgJ051bXBhZERlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDI4JztcbiAgICAgICAgY2FzZSAnTnVtcGFkRGl2aWRlJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAyOSc7XG4gICAgICAgIGNhc2UgJ0YxJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzMSc7XG4gICAgICAgIGNhc2UgJ0YyJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzMic7XG4gICAgICAgIGNhc2UgJ0YzJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzMyc7XG4gICAgICAgIGNhc2UgJ0Y0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzNCc7XG4gICAgICAgIGNhc2UgJ0Y1JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzNSc7XG4gICAgICAgIGNhc2UgJ0Y2JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzNic7XG4gICAgICAgIGNhc2UgJ0Y3JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzNyc7XG4gICAgICAgIGNhc2UgJ0Y4JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzOCc7XG4gICAgICAgIGNhc2UgJ0Y5JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzOSc7XG4gICAgICAgIGNhc2UgJ0YxMCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwM0EnO1xuICAgICAgICBjYXNlICdGMTEnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDNCJztcbiAgICAgICAgY2FzZSAnRjEyJzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTAzQyc7XG4gICAgICAgIGNhc2UgJ01ldGEnOlxuICAgICAgICBjYXNlICdNZXRhTGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwM0QnO1xuICAgICAgICBjYXNlICdTaGlmdFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnXFx1RTA1MCc7XG4gICAgICAgIGNhc2UgJ0NvbnRyb2xSaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwNTEnO1xuICAgICAgICBjYXNlICdBbHRSaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gJ1xcdUUwNTInO1xuICAgICAgICBjYXNlICdNZXRhUmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuICdcXHVFMDUzJztcbiAgICAgICAgY2FzZSAnRGlnaXQwJzpcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIGNhc2UgJ0RpZ2l0MSc6XG4gICAgICAgICAgICByZXR1cm4gJzEnO1xuICAgICAgICBjYXNlICdEaWdpdDInOlxuICAgICAgICAgICAgcmV0dXJuICcyJztcbiAgICAgICAgY2FzZSAnRGlnaXQzJzpcbiAgICAgICAgICAgIHJldHVybiAnMyc7XG4gICAgICAgIGNhc2UgJ0RpZ2l0NCc6XG4gICAgICAgICAgICByZXR1cm4gJzQnO1xuICAgICAgICBjYXNlICdEaWdpdDUnOlxuICAgICAgICAgICAgcmV0dXJuICc1JztcbiAgICAgICAgY2FzZSAnRGlnaXQ2JzpcbiAgICAgICAgICAgIHJldHVybiAnNic7XG4gICAgICAgIGNhc2UgJ0RpZ2l0Nyc6XG4gICAgICAgICAgICByZXR1cm4gJzcnO1xuICAgICAgICBjYXNlICdEaWdpdDgnOlxuICAgICAgICAgICAgcmV0dXJuICc4JztcbiAgICAgICAgY2FzZSAnRGlnaXQ5JzpcbiAgICAgICAgICAgIHJldHVybiAnOSc7XG4gICAgICAgIGNhc2UgJ0tleUEnOlxuICAgICAgICAgICAgcmV0dXJuICdhJztcbiAgICAgICAgY2FzZSAnS2V5Qic6XG4gICAgICAgICAgICByZXR1cm4gJ2InO1xuICAgICAgICBjYXNlICdLZXlDJzpcbiAgICAgICAgICAgIHJldHVybiAnYyc7XG4gICAgICAgIGNhc2UgJ0tleUQnOlxuICAgICAgICAgICAgcmV0dXJuICdkJztcbiAgICAgICAgY2FzZSAnS2V5RSc6XG4gICAgICAgICAgICByZXR1cm4gJ2UnO1xuICAgICAgICBjYXNlICdLZXlGJzpcbiAgICAgICAgICAgIHJldHVybiAnZic7XG4gICAgICAgIGNhc2UgJ0tleUcnOlxuICAgICAgICAgICAgcmV0dXJuICdnJztcbiAgICAgICAgY2FzZSAnS2V5SCc6XG4gICAgICAgICAgICByZXR1cm4gJ2gnO1xuICAgICAgICBjYXNlICdLZXlJJzpcbiAgICAgICAgICAgIHJldHVybiAnaSc7XG4gICAgICAgIGNhc2UgJ0tleUonOlxuICAgICAgICAgICAgcmV0dXJuICdqJztcbiAgICAgICAgY2FzZSAnS2V5Syc6XG4gICAgICAgICAgICByZXR1cm4gJ2snO1xuICAgICAgICBjYXNlICdLZXlMJzpcbiAgICAgICAgICAgIHJldHVybiAnbCc7XG4gICAgICAgIGNhc2UgJ0tleU0nOlxuICAgICAgICAgICAgcmV0dXJuICdtJztcbiAgICAgICAgY2FzZSAnS2V5Tic6XG4gICAgICAgICAgICByZXR1cm4gJ24nO1xuICAgICAgICBjYXNlICdLZXlPJzpcbiAgICAgICAgICAgIHJldHVybiAnbyc7XG4gICAgICAgIGNhc2UgJ0tleVAnOlxuICAgICAgICAgICAgcmV0dXJuICdwJztcbiAgICAgICAgY2FzZSAnS2V5USc6XG4gICAgICAgICAgICByZXR1cm4gJ3EnO1xuICAgICAgICBjYXNlICdLZXlSJzpcbiAgICAgICAgICAgIHJldHVybiAncic7XG4gICAgICAgIGNhc2UgJ0tleVMnOlxuICAgICAgICAgICAgcmV0dXJuICdzJztcbiAgICAgICAgY2FzZSAnS2V5VCc6XG4gICAgICAgICAgICByZXR1cm4gJ3QnO1xuICAgICAgICBjYXNlICdLZXlVJzpcbiAgICAgICAgICAgIHJldHVybiAndSc7XG4gICAgICAgIGNhc2UgJ0tleVYnOlxuICAgICAgICAgICAgcmV0dXJuICd2JztcbiAgICAgICAgY2FzZSAnS2V5Vyc6XG4gICAgICAgICAgICByZXR1cm4gJ3cnO1xuICAgICAgICBjYXNlICdLZXlYJzpcbiAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgIGNhc2UgJ0tleVknOlxuICAgICAgICAgICAgcmV0dXJuICd5JztcbiAgICAgICAgY2FzZSAnS2V5Wic6XG4gICAgICAgICAgICByZXR1cm4gJ3onO1xuICAgICAgICBjYXNlICdTZW1pY29sb24nOlxuICAgICAgICAgICAgcmV0dXJuICc7JztcbiAgICAgICAgY2FzZSAnRXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuICc9JztcbiAgICAgICAgY2FzZSAnQ29tbWEnOlxuICAgICAgICAgICAgcmV0dXJuICcsJztcbiAgICAgICAgY2FzZSAnTWludXMnOlxuICAgICAgICAgICAgcmV0dXJuICctJztcbiAgICAgICAgY2FzZSAnUGVyaW9kJzpcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIGNhc2UgJ1NsYXNoJzpcbiAgICAgICAgICAgIHJldHVybiAnLyc7XG4gICAgICAgIGNhc2UgJ0JhY2txdW90ZSc6XG4gICAgICAgICAgICByZXR1cm4gJ2AnO1xuICAgICAgICBjYXNlICdCcmFja2V0TGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ1snO1xuICAgICAgICBjYXNlICdCYWNrc2xhc2gnOlxuICAgICAgICAgICAgcmV0dXJuICdcXFxcJztcbiAgICAgICAgY2FzZSAnQnJhY2tldFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnXSc7XG4gICAgICAgIGNhc2UgJ1F1b3RlJzpcbiAgICAgICAgICAgIHJldHVybiAnXCInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGtleTogXCIke2tleX1cImApO1xuICAgIH1cbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaUtleWJvYXJkIGV4dGVuZHMgS2V5Ym9hcmQge1xuICAgICNwYWdlO1xuICAgIGNvbnN0cnVjdG9yKHBhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jcGFnZSA9IHBhZ2U7XG4gICAgfVxuICAgIGFzeW5jIGRvd24oa2V5LCBfb3B0aW9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuS2V5LFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX2tleWJvYXJkXCIgLyogSW5wdXRJZC5LZXlib2FyZCAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRCaWRpS2V5VmFsdWUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHVwKGtleSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuS2V5LFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX2tleWJvYXJkXCIgLyogSW5wdXRJZC5LZXlib2FyZCAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5VXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0QmlkaUtleVZhbHVlKGtleSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBwcmVzcyhrZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLktleURvd24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldEJpZGlLZXlWYWx1ZShrZXkpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBhdXNlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkZWxheSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLktleVVwLFxuICAgICAgICAgICAgdmFsdWU6IGdldEJpZGlLZXlWYWx1ZShrZXkpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLktleSxcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl9rZXlib2FyZFwiIC8qIElucHV0SWQuS2V5Ym9hcmQgKi8sXG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyB0eXBlKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gVGhpcyBzcHJlYWQgc2VwYXJhdGVzIHRoZSBjaGFyYWN0ZXJzIGludG8gY29kZSBwb2ludHMgcmF0aGVyIHRoYW4gVVRGLTE2XG4gICAgICAgIC8vIGNvZGUgdW5pdHMuXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFsuLi50ZXh0XS5tYXAoZ2V0QmlkaUtleVZhbHVlKTtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGVsYXkgPD0gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLktleURvd24sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5LZXlVcCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuS2V5RG93bixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBhdXNlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZGVsYXksXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLktleVVwLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuS2V5LFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX2tleWJvYXJkXCIgLyogSW5wdXRJZC5LZXlib2FyZCAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRDaGFyYWN0ZXIoY2hhcikge1xuICAgICAgICAvLyBNZWFzdXJlcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHJhdGhlciB0aGFuIFVURi0xNiBjb2RlIHVuaXRzLlxuICAgICAgICBpZiAoWy4uLmNoYXJdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgbW9yZSB0aGFuIDEgY2hhcmFjdGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gYXdhaXQgdGhpcy4jcGFnZS5mb2N1c2VkRnJhbWUoKTtcbiAgICAgICAgYXdhaXQgZnJhbWUuaXNvbGF0ZWRSZWFsbSgpLmV2YWx1YXRlKGFzeW5jIChjaGFyKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcsIGZhbHNlLCBjaGFyKTtcbiAgICAgICAgfSwgY2hhcik7XG4gICAgfVxufVxuY29uc3QgZ2V0QmlkaUJ1dHRvbiA9IChidXR0b24pID0+IHtcbiAgICBzd2l0Y2ggKGJ1dHRvbikge1xuICAgICAgICBjYXNlIE1vdXNlQnV0dG9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSBNb3VzZUJ1dHRvbi5NaWRkbGU6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSBNb3VzZUJ1dHRvbi5SaWdodDpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIE1vdXNlQnV0dG9uLkJhY2s6XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgY2FzZSBNb3VzZUJ1dHRvbi5Gb3J3YXJkOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpTW91c2UgZXh0ZW5kcyBNb3VzZSB7XG4gICAgI3BhZ2U7XG4gICAgI2xhc3RNb3ZlUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI3BhZ2UgPSBwYWdlO1xuICAgIH1cbiAgICBhc3luYyByZXNldCgpIHtcbiAgICAgICAgdGhpcy4jbGFzdE1vdmVQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5yZWxlYXNlQWN0aW9ucygpO1xuICAgIH1cbiAgICBhc3luYyBtb3ZlKHgsIHksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy4jbGFzdE1vdmVQb2ludDtcbiAgICAgICAgY29uc3QgdG8gPSB7XG4gICAgICAgICAgICB4OiBNYXRoLnJvdW5kKHgpLFxuICAgICAgICAgICAgeTogTWF0aC5yb3VuZCh5KSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBzdGVwcyA9IG9wdGlvbnMuc3RlcHMgPz8gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgKytpKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlck1vdmUsXG4gICAgICAgICAgICAgICAgeDogZnJvbS54ICsgKHRvLnggLSBmcm9tLngpICogKGkgLyBzdGVwcyksXG4gICAgICAgICAgICAgICAgeTogZnJvbS55ICsgKHRvLnkgLSBmcm9tLnkpICogKGkgLyBzdGVwcyksXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBvcHRpb25zLm9yaWdpbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJNb3ZlLFxuICAgICAgICAgICAgLi4udG8sXG4gICAgICAgICAgICBvcmlnaW46IG9wdGlvbnMub3JpZ2luLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmRyaXZlci1iaWRpLyNjb21tYW5kLWlucHV0LXBlcmZvcm1BY3Rpb25zOn46dGV4dD1pbnB1dC5Qb2ludGVyTW92ZUFjdGlvbiUyMCUzRCUyMCU3QiUwQSUyMCUyMHR5cGUlM0ElMjAlMjJwb2ludGVyTW92ZSUyMiUyQyUwQSUyMCUyMHglM0ElMjBqcyUyRGludCUyQ1xuICAgICAgICB0aGlzLiNsYXN0TW92ZVBvaW50ID0gdG87XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5Qb2ludGVyLFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX21vdXNlXCIgLyogSW5wdXRJZC5Nb3VzZSAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIGRvd24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5Qb2ludGVyLFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX21vdXNlXCIgLyogSW5wdXRJZC5Nb3VzZSAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlckRvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IGdldEJpZGlCdXR0b24ob3B0aW9ucy5idXR0b24gPz8gTW91c2VCdXR0b24uTGVmdCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyB1cChvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfbW91c2VcIiAvKiBJbnB1dElkLk1vdXNlICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyVXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IGdldEJpZGlCdXR0b24ob3B0aW9ucy5idXR0b24gPz8gTW91c2VCdXR0b24uTGVmdCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBjbGljayh4LCB5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJNb3ZlLFxuICAgICAgICAgICAgICAgIHg6IE1hdGgucm91bmQoeCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZCh5KSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9wdGlvbnMub3JpZ2luLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcG9pbnRlckRvd25BY3Rpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJEb3duLFxuICAgICAgICAgICAgYnV0dG9uOiBnZXRCaWRpQnV0dG9uKG9wdGlvbnMuYnV0dG9uID8/IE1vdXNlQnV0dG9uLkxlZnQpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwb2ludGVyVXBBY3Rpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBvaW50ZXJVcCxcbiAgICAgICAgICAgIGJ1dHRvbjogcG9pbnRlckRvd25BY3Rpb24uYnV0dG9uLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IChvcHRpb25zLmNvdW50ID8/IDEpOyArK2kpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChwb2ludGVyRG93bkFjdGlvbiwgcG9pbnRlclVwQWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25zLnB1c2gocG9pbnRlckRvd25BY3Rpb24pO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWxheSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBBY3Rpb25UeXBlLlBhdXNlLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmRlbGF5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aW9ucy5wdXNoKHBvaW50ZXJVcEFjdGlvbik7XG4gICAgICAgIGF3YWl0IHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0LnBlcmZvcm1BY3Rpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBTb3VyY2VBY3Rpb25zVHlwZS5Qb2ludGVyLFxuICAgICAgICAgICAgICAgIGlkOiBcIl9fcHVwcGV0ZWVyX21vdXNlXCIgLyogSW5wdXRJZC5Nb3VzZSAqLyxcbiAgICAgICAgICAgICAgICBhY3Rpb25zLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHdoZWVsKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuV2hlZWwsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfd2hlZWxcIiAvKiBJbnB1dElkLldoZWVsICovLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5TY3JvbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4odGhpcy4jbGFzdE1vdmVQb2ludCA/PyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVg6IG9wdGlvbnMuZGVsdGFYID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVk6IG9wdGlvbnMuZGVsdGFZID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBkcmFnKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgZHJhZ092ZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBkcmFnRW50ZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgZHJhZ0FuZERyb3AoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpVG91Y2hzY3JlZW4gZXh0ZW5kcyBUb3VjaHNjcmVlbiB7XG4gICAgI3BhZ2U7XG4gICAgY29uc3RydWN0b3IocGFnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNwYWdlID0gcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgdG91Y2hTdGFydCh4LCB5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfZmluZ2VyXCIgLyogSW5wdXRJZC5GaW5nZXIgKi8sXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogXCJ0b3VjaFwiIC8qIEJpZGkuSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi8sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlck1vdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZCh5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlckRvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMC41ICogMiwgLy8gMiB0aW1lcyBkZWZhdWx0IHRvdWNoIHJhZGl1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMC41ICogMiwgLy8gMiB0aW1lcyBkZWZhdWx0IHRvdWNoIHJhZGl1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNzdXJlOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZUFuZ2xlOiBNYXRoLlBJIC8gMixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHRvdWNoTW92ZSh4LCB5LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy4jcGFnZS5tYWluRnJhbWUoKS5icm93c2luZ0NvbnRleHQucGVyZm9ybUFjdGlvbnMoW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFNvdXJjZUFjdGlvbnNUeXBlLlBvaW50ZXIsXG4gICAgICAgICAgICAgICAgaWQ6IFwiX19wdXBwZXRlZXJfZmluZ2VyXCIgLyogSW5wdXRJZC5GaW5nZXIgKi8sXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZTogXCJ0b3VjaFwiIC8qIEJpZGkuSW5wdXQuUG9pbnRlclR5cGUuVG91Y2ggKi8sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFjdGlvblR5cGUuUG9pbnRlck1vdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZCh5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3B0aW9ucy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMC41ICogMiwgLy8gMiB0aW1lcyBkZWZhdWx0IHRvdWNoIHJhZGl1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMC41ICogMiwgLy8gMiB0aW1lcyBkZWZhdWx0IHRvdWNoIHJhZGl1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNzdXJlOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRpdHVkZUFuZ2xlOiBNYXRoLlBJIC8gMixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGFzeW5jIHRvdWNoRW5kKCkge1xuICAgICAgICBhd2FpdCB0aGlzLiNwYWdlLm1haW5GcmFtZSgpLmJyb3dzaW5nQ29udGV4dC5wZXJmb3JtQWN0aW9ucyhbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogU291cmNlQWN0aW9uc1R5cGUuUG9pbnRlcixcbiAgICAgICAgICAgICAgICBpZDogXCJfX3B1cHBldGVlcl9maW5nZXJcIiAvKiBJbnB1dElkLkZpbmdlciAqLyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBcInRvdWNoXCIgLyogQmlkaS5JbnB1dC5Qb2ludGVyVHlwZS5Ub3VjaCAqLyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQWN0aW9uVHlwZS5Qb2ludGVyVXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5pbXBvcnQgeyBKU0hhbmRsZSB9IGZyb20gJy4uL2FwaS9KU0hhbmRsZS5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgQmlkaURlc2VyaWFsaXplciB9IGZyb20gJy4vRGVzZXJpYWxpemVyLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpSlNIYW5kbGUgZXh0ZW5kcyBKU0hhbmRsZSB7XG4gICAgc3RhdGljIGZyb20odmFsdWUsIHJlYWxtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlkaUpTSGFuZGxlKHZhbHVlLCByZWFsbSk7XG4gICAgfVxuICAgICNyZW1vdGVWYWx1ZTtcbiAgICByZWFsbTtcbiAgICAjZGlzcG9zZWQgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcmVhbG0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jcmVtb3RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZWFsbSA9IHJlYWxtO1xuICAgIH1cbiAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NlZDtcbiAgICB9XG4gICAgYXN5bmMganNvblZhbHVlKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5ldmFsdWF0ZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc0VsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhbG0uZGVzdHJveUhhbmRsZXMoW3RoaXNdKTtcbiAgICB9XG4gICAgZ2V0IGlzUHJpbWl0aXZlVmFsdWUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy4jcmVtb3RlVmFsdWUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQcmltaXRpdmVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdKU0hhbmRsZTonICsgQmlkaURlc2VyaWFsaXplci5kZXNlcmlhbGl6ZSh0aGlzLiNyZW1vdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdKU0hhbmRsZUAnICsgdGhpcy4jcmVtb3RlVmFsdWUudHlwZTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gJ2hhbmRsZScgaW4gdGhpcy4jcmVtb3RlVmFsdWUgPyB0aGlzLiNyZW1vdGVWYWx1ZS5oYW5kbGUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbW90ZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVtb3RlVmFsdWU7XG4gICAgfVxuICAgIHJlbW90ZU9iamVjdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCdOb3QgYXZhaWxhYmxlIGluIFdlYkRyaXZlciBCaURpJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SlNIYW5kbGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBmaXJzdFZhbHVlRnJvbSwgZnJvbSwgcmFjZVdpdGggfSBmcm9tICcuLi8uLi90aGlyZF9wYXJ0eS9yeGpzL3J4anMuanMnO1xuaW1wb3J0IHsgUGFnZSwgfSBmcm9tICcuLi9hcGkvUGFnZS5qcyc7XG5pbXBvcnQgeyBDb3ZlcmFnZSB9IGZyb20gJy4uL2NkcC9Db3ZlcmFnZS5qcyc7XG5pbXBvcnQgeyBFbXVsYXRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vY2RwL0VtdWxhdGlvbk1hbmFnZXIuanMnO1xuaW1wb3J0IHsgVHJhY2luZyB9IGZyb20gJy4uL2NkcC9UcmFjaW5nLmpzJztcbmltcG9ydCB7IFVuc3VwcG9ydGVkT3BlcmF0aW9uIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGV2YWx1YXRpb25TdHJpbmcsIGlzU3RyaW5nLCBwYXJzZVBERk9wdGlvbnMsIHRpbWVvdXQsIH0gZnJvbSAnLi4vY29tbW9uL3V0aWwuanMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbC9hc3NlcnQuanMnO1xuaW1wb3J0IHsgYnViYmxlIH0gZnJvbSAnLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IGlzRXJyb3JMaWtlIH0gZnJvbSAnLi4vdXRpbC9FcnJvckxpa2UuanMnO1xuaW1wb3J0IHsgQmlkaUZyYW1lIH0gZnJvbSAnLi9GcmFtZS5qcyc7XG5pbXBvcnQgeyBCaWRpS2V5Ym9hcmQsIEJpZGlNb3VzZSwgQmlkaVRvdWNoc2NyZWVuIH0gZnJvbSAnLi9JbnB1dC5qcyc7XG5pbXBvcnQgeyByZXdyaXRlTmF2aWdhdGlvbkVycm9yIH0gZnJvbSAnLi91dGlsLmpzJztcbi8qKlxuICogSW1wbGVtZW50cyBQYWdlIHVzaW5nIFdlYkRyaXZlciBCaURpLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgQmlkaVBhZ2UgPSAoKCkgPT4ge1xuICAgIGxldCBfY2xhc3NTdXBlciA9IFBhZ2U7XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF90cnVzdGVkRW1pdHRlcl9leHRyYUluaXRpYWxpemVycyA9IFtdO1xuICAgIHJldHVybiBjbGFzcyBCaWRpUGFnZSBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfdHJ1c3RlZEVtaXR0ZXJfZGVjb3JhdG9ycyA9IFtidWJibGUoKV07XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3RydXN0ZWRFbWl0dGVyX2RlY29yYXRvcnMsIHsga2luZDogXCJhY2Nlc3NvclwiLCBuYW1lOiBcInRydXN0ZWRFbWl0dGVyXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJ0cnVzdGVkRW1pdHRlclwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnRydXN0ZWRFbWl0dGVyLCBzZXQ6IChvYmosIHZhbHVlKSA9PiB7IG9iai50cnVzdGVkRW1pdHRlciA9IHZhbHVlOyB9IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgX3RydXN0ZWRFbWl0dGVyX2luaXRpYWxpemVycywgX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbShicm93c2VyQ29udGV4dCwgYnJvd3NpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gbmV3IEJpZGlQYWdlKGJyb3dzZXJDb250ZXh0LCBicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgcGFnZS4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgI3RydXN0ZWRFbWl0dGVyX2FjY2Vzc29yX3N0b3JhZ2UgPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfdHJ1c3RlZEVtaXR0ZXJfaW5pdGlhbGl6ZXJzLCBuZXcgRXZlbnRFbWl0dGVyKCkpO1xuICAgICAgICBnZXQgdHJ1c3RlZEVtaXR0ZXIoKSB7IHJldHVybiB0aGlzLiN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlOyB9XG4gICAgICAgIHNldCB0cnVzdGVkRW1pdHRlcih2YWx1ZSkgeyB0aGlzLiN0cnVzdGVkRW1pdHRlcl9hY2Nlc3Nvcl9zdG9yYWdlID0gdmFsdWU7IH1cbiAgICAgICAgI2Jyb3dzZXJDb250ZXh0ID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX3RydXN0ZWRFbWl0dGVyX2V4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI2ZyYW1lO1xuICAgICAgICAjdmlld3BvcnQgPSBudWxsO1xuICAgICAgICAjd29ya2VycyA9IG5ldyBTZXQoKTtcbiAgICAgICAga2V5Ym9hcmQ7XG4gICAgICAgIG1vdXNlO1xuICAgICAgICB0b3VjaHNjcmVlbjtcbiAgICAgICAgdHJhY2luZztcbiAgICAgICAgY292ZXJhZ2U7XG4gICAgICAgICNjZHBFbXVsYXRpb25NYW5hZ2VyO1xuICAgICAgICAjZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucztcbiAgICAgICAgX2NsaWVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmcmFtZS5jbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoYnJvd3NlckNvbnRleHQsIGJyb3dzaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuI2Jyb3dzZXJDb250ZXh0ID0gYnJvd3NlckNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZSA9IEJpZGlGcmFtZS5mcm9tKHRoaXMsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyID0gbmV3IEVtdWxhdGlvbk1hbmFnZXIodGhpcy4jZnJhbWUuY2xpZW50KTtcbiAgICAgICAgICAgIHRoaXMudHJhY2luZyA9IG5ldyBUcmFjaW5nKHRoaXMuI2ZyYW1lLmNsaWVudCk7XG4gICAgICAgICAgICB0aGlzLmNvdmVyYWdlID0gbmV3IENvdmVyYWdlKHRoaXMuI2ZyYW1lLmNsaWVudCk7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkID0gbmV3IEJpZGlLZXlib2FyZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubW91c2UgPSBuZXcgQmlkaU1vdXNlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy50b3VjaHNjcmVlbiA9IG5ldyBCaWRpVG91Y2hzY3JlZW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQub24oJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLmVtaXQoXCJjbG9zZVwiIC8qIFBhZ2VFdmVudC5DbG9zZSAqLywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnRydXN0ZWRFbWl0dGVyLm9uKFwid29ya2VyY3JlYXRlZFwiIC8qIFBhZ2VFdmVudC5Xb3JrZXJDcmVhdGVkICovLCB3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3dvcmtlcnMuYWRkKHdvcmtlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHJ1c3RlZEVtaXR0ZXIub24oXCJ3b3JrZXJkZXN0cm95ZWRcIiAvKiBQYWdlRXZlbnQuV29ya2VyRGVzdHJveWVkICovLCB3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuI3dvcmtlcnMuZGVsZXRlKHdvcmtlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfdXNlckFnZW50SGVhZGVycyA9IHt9O1xuICAgICAgICAjdXNlckFnZW50SW50ZXJjZXB0aW9uO1xuICAgICAgICAjdXNlckFnZW50UHJlbG9hZFNjcmlwdDtcbiAgICAgICAgYXN5bmMgc2V0VXNlckFnZW50KHVzZXJBZ2VudCwgdXNlckFnZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4jYnJvd3NlckNvbnRleHQuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCAmJiB1c2VyQWdlbnRNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbignQ3VycmVudCBCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYHVzZXJBZ2VudE1ldGFkYXRhYCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4jYnJvd3NlckNvbnRleHQuYnJvd3NlcigpLmNkcFN1cHBvcnRlZCAmJlxuICAgICAgICAgICAgICAgIHVzZXJBZ2VudE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2NsaWVudCgpLnNlbmQoJ05ldHdvcmsuc2V0VXNlckFnZW50T3ZlcnJpZGUnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJBZ2VudDogdXNlckFnZW50LFxuICAgICAgICAgICAgICAgICAgICB1c2VyQWdlbnRNZXRhZGF0YTogdXNlckFnZW50TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmFibGUgPSB1c2VyQWdlbnQgIT09ICcnO1xuICAgICAgICAgICAgdXNlckFnZW50ID0gdXNlckFnZW50ID8/IChhd2FpdCB0aGlzLiNicm93c2VyQ29udGV4dC5icm93c2VyKCkudXNlckFnZW50KCkpO1xuICAgICAgICAgICAgdGhpcy5fdXNlckFnZW50SGVhZGVycyA9IGVuYWJsZVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IHVzZXJBZ2VudCxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIHRoaXMuI3VzZXJBZ2VudEludGVyY2VwdGlvbiA9IGF3YWl0IHRoaXMuI3RvZ2dsZUludGVyY2VwdGlvbihbXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIEJpZGkuTmV0d29yay5JbnRlcmNlcHRQaGFzZS5CZWZvcmVSZXF1ZXN0U2VudCAqL10sIHRoaXMuI3VzZXJBZ2VudEludGVyY2VwdGlvbiwgZW5hYmxlKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVVzZXJBZ2VudCA9ICh1c2VyQWdlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAndXNlckFnZW50Jywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXNlckFnZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lcyA9IFt0aGlzLiNmcmFtZV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGZyYW1lcykge1xuICAgICAgICAgICAgICAgIGZyYW1lcy5wdXNoKC4uLmZyYW1lLmNoaWxkRnJhbWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI3VzZXJBZ2VudFByZWxvYWRTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZVNjcmlwdFRvRXZhbHVhdGVPbk5ld0RvY3VtZW50KHRoaXMuI3VzZXJBZ2VudFByZWxvYWRTY3JpcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW2V2YWx1YXRlVG9rZW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGVuYWJsZVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZXZhbHVhdGVPbk5ld0RvY3VtZW50KGNoYW5nZVVzZXJBZ2VudCwgdXNlckFnZW50KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGRpc2FibGUgdGhlIFVzZXJBZ2VudCB3ZSB3YW50IHRvXG4gICAgICAgICAgICAgICAgLy8gZXZhbHVhdGUgdGhlIG9yaWdpbmFsIHZhbHVlIGluIGFsbCBCcm93c2luZyBDb250ZXh0c1xuICAgICAgICAgICAgICAgIGZyYW1lcy5tYXAoZnJhbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWUuZXZhbHVhdGUoY2hhbmdlVXNlckFnZW50LCB1c2VyQWdlbnQpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB0aGlzLiN1c2VyQWdlbnRQcmVsb2FkU2NyaXB0ID0gZXZhbHVhdGVUb2tlbj8uaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRCeXBhc3NDU1AoZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIENEUC1zcGVjaWZpYyBjYXNlcyBzdWNoIGFzIG1wcmFjaC5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NsaWVudCgpLnNlbmQoJ1BhZ2Uuc2V0QnlwYXNzQ1NQJywgeyBlbmFibGVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHF1ZXJ5T2JqZWN0cyhwcm90b3R5cGVIYW5kbGUpIHtcbiAgICAgICAgICAgIGFzc2VydCghcHJvdG90eXBlSGFuZGxlLmRpc3Bvc2VkLCAnUHJvdG90eXBlIEpTSGFuZGxlIGlzIGRpc3Bvc2VkIScpO1xuICAgICAgICAgICAgYXNzZXJ0KHByb3RvdHlwZUhhbmRsZS5pZCwgJ1Byb3RvdHlwZSBKU0hhbmRsZSBtdXN0IG5vdCBiZSByZWZlcmVuY2luZyBwcmltaXRpdmUgdmFsdWUnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy4jZnJhbWUuY2xpZW50LnNlbmQoJ1J1bnRpbWUucXVlcnlPYmplY3RzJywge1xuICAgICAgICAgICAgICAgIHByb3RvdHlwZU9iamVjdElkOiBwcm90b3R5cGVIYW5kbGUuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmcmFtZS5tYWluUmVhbG0oKS5jcmVhdGVIYW5kbGUoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaGFuZGxlOiByZXNwb25zZS5vYmplY3RzLm9iamVjdElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJvd3NlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyb3dzZXJDb250ZXh0KCkuYnJvd3NlcigpO1xuICAgICAgICB9XG4gICAgICAgIGJyb3dzZXJDb250ZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXJDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIG1haW5GcmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmb2N1c2VkRnJhbWUoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnZfMSA9IHsgc3RhY2s6IFtdLCBlcnJvcjogdm9pZCAwLCBoYXNFcnJvcjogZmFsc2UgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIChhd2FpdCB0aGlzLm1haW5GcmFtZSgpXG4gICAgICAgICAgICAgICAgICAgIC5pc29sYXRlZFJlYWxtKClcbiAgICAgICAgICAgICAgICAgICAgLmV2YWx1YXRlSGFuZGxlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpbiA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHdpbi5kb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4uZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGVudFdpbmRvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gd2luLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGVudFdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luO1xuICAgICAgICAgICAgICAgIH0pKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGFuZGxlLnJlbW90ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlLnR5cGUgPT09ICd3aW5kb3cnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWVzKCkuZmluZChmcmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZS5faWQgPT09IHZhbHVlLnZhbHVlLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGZyYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xKSB7XG4gICAgICAgICAgICAgICAgZW52XzEuZXJyb3IgPSBlXzE7XG4gICAgICAgICAgICAgICAgZW52XzEuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19kaXNwb3NlUmVzb3VyY2VzKGVudl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmcmFtZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXMgPSBbdGhpcy4jZnJhbWVdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmcmFtZXMucHVzaCguLi5mcmFtZS5jaGlsZEZyYW1lcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFtZXM7XG4gICAgICAgIH1cbiAgICAgICAgaXNDbG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUuZGV0YWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2Uob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZW52XzIgPSB7IHN0YWNrOiBbXSwgZXJyb3I6IHZvaWQgMCwgaGFzRXJyb3I6IGZhbHNlIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9ndWFyZCA9IF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudl8yLCBhd2FpdCB0aGlzLiNicm93c2VyQ29udGV4dC53YWl0Rm9yU2NyZWVuc2hvdE9wZXJhdGlvbnMoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5jbG9zZShvcHRpb25zPy5ydW5CZWZvcmVVbmxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yKSB7XG4gICAgICAgICAgICAgICAgZW52XzIuZXJyb3IgPSBlXzI7XG4gICAgICAgICAgICAgICAgZW52XzIuaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19kaXNwb3NlUmVzb3VyY2VzKGVudl8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyByZWxvYWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBbcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuI2ZyYW1lLndhaXRGb3JOYXZpZ2F0aW9uKG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5yZWxvYWQoKSxcbiAgICAgICAgICAgIF0pLmNhdGNoKHJld3JpdGVOYXZpZ2F0aW9uRXJyb3IodGhpcy51cmwoKSwgb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMuX3RpbWVvdXRTZXR0aW5ncy5uYXZpZ2F0aW9uVGltZW91dCgpKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGVmYXVsdE5hdmlnYXRpb25UaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRTZXR0aW5ncy5zZXREZWZhdWx0TmF2aWdhdGlvblRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0RGVmYXVsdFRpbWVvdXQodGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dFNldHRpbmdzLnNldERlZmF1bHRUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGdldERlZmF1bHRUaW1lb3V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXRTZXR0aW5ncy50aW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNKYXZhU2NyaXB0RW5hYmxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmphdmFzY3JpcHRFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldEdlb2xvY2F0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLnNldEdlb2xvY2F0aW9uKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldEphdmFTY3JpcHRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLnNldEphdmFTY3JpcHRFbmFibGVkKGVuYWJsZWQpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVtdWxhdGVNZWRpYVR5cGUodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NkcEVtdWxhdGlvbk1hbmFnZXIuZW11bGF0ZU1lZGlhVHlwZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlbXVsYXRlQ1BVVGhyb3R0bGluZyhmYWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVDUFVUaHJvdHRsaW5nKGZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZW11bGF0ZU1lZGlhRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVNZWRpYUZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlbXVsYXRlVGltZXpvbmUodGltZXpvbmVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NkcEVtdWxhdGlvbk1hbmFnZXIuZW11bGF0ZVRpbWV6b25lKHRpbWV6b25lSWQpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVtdWxhdGVJZGxlU3RhdGUob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2RwRW11bGF0aW9uTWFuYWdlci5lbXVsYXRlSWRsZVN0YXRlKG92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZW11bGF0ZVZpc2lvbkRlZmljaWVuY3kodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2NkcEVtdWxhdGlvbk1hbmFnZXIuZW11bGF0ZVZpc2lvbkRlZmljaWVuY3kodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5icm93c2VyKCkuY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0Py53aWR0aCAmJiB2aWV3cG9ydD8uaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRldmljZVBpeGVsUmF0aW86IHZpZXdwb3J0Py5kZXZpY2VTY2FsZUZhY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2aWV3cG9ydC5kZXZpY2VTY2FsZUZhY3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuI3ZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmVlZHNSZWxvYWQgPSBhd2FpdCB0aGlzLiNjZHBFbXVsYXRpb25NYW5hZ2VyLmVtdWxhdGVWaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgICAgICAgICB0aGlzLiN2aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKG5lZWRzUmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3cG9ydCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN2aWV3cG9ydDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwZGYob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVvdXQ6IG1zID0gdGhpcy5fdGltZW91dFNldHRpbmdzLnRpbWVvdXQoKSwgcGF0aCA9IHVuZGVmaW5lZCB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHsgcHJpbnRCYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLCBtYXJnaW4sIGxhbmRzY2FwZSwgd2lkdGgsIGhlaWdodCwgcGFnZVJhbmdlczogcmFuZ2VzLCBzY2FsZSwgcHJlZmVyQ1NTUGFnZVNpemUsIH0gPSBwYXJzZVBERk9wdGlvbnMob3B0aW9ucywgJ2NtJyk7XG4gICAgICAgICAgICBjb25zdCBwYWdlUmFuZ2VzID0gcmFuZ2VzID8gcmFuZ2VzLnNwbGl0KCcsICcpIDogW107XG4gICAgICAgICAgICBhd2FpdCBmaXJzdFZhbHVlRnJvbShmcm9tKHRoaXMubWFpbkZyYW1lKClcbiAgICAgICAgICAgICAgICAuaXNvbGF0ZWRSZWFsbSgpXG4gICAgICAgICAgICAgICAgLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZm9udHMucmVhZHk7XG4gICAgICAgICAgICB9KSkucGlwZShyYWNlV2l0aCh0aW1lb3V0KG1zKSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmaXJzdFZhbHVlRnJvbShmcm9tKHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5wcmludCh7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb246IGxhbmRzY2FwZSA/ICdsYW5kc2NhcGUnIDogJ3BvcnRyYWl0JyxcbiAgICAgICAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYWdlUmFuZ2VzLFxuICAgICAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgICAgIHNocmlua1RvRml0OiAhcHJlZmVyQ1NTUGFnZVNpemUsXG4gICAgICAgICAgICB9KSkucGlwZShyYWNlV2l0aCh0aW1lb3V0KG1zKSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX21heWJlV3JpdGVCdWZmZXJUb0ZpbGUocGF0aCwgYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlUERGU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHRoaXMucGRmKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBfc2NyZWVuc2hvdChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNsaXAsIHR5cGUsIGNhcHR1cmVCZXlvbmRWaWV3cG9ydCwgcXVhbGl0eSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9taXRCYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5vbWl0QmFja2dyb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbihgQmlEaSBkb2VzIG5vdCBzdXBwb3J0ICdvbWl0QmFja2dyb3VuZCcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vcHRpbWl6ZUZvclNwZWVkICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKGBCaURpIGRvZXMgbm90IHN1cHBvcnQgJ29wdGltaXplRm9yU3BlZWQnLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnJvbVN1cmZhY2UgIT09IHVuZGVmaW5lZCAmJiAhb3B0aW9ucy5mcm9tU3VyZmFjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbihgQmlEaSBkb2VzIG5vdCBzdXBwb3J0ICdmcm9tU3VyZmFjZScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpcCAhPT0gdW5kZWZpbmVkICYmIGNsaXAuc2NhbGUgIT09IHVuZGVmaW5lZCAmJiBjbGlwLnNjYWxlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKGBCaURpIGRvZXMgbm90IHN1cHBvcnQgJ3NjYWxlJyBpbiAnY2xpcCcuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYm94O1xuICAgICAgICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZUJleW9uZFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJveCA9IGNsaXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY2xpcCBpcyBhbHdheXMgd2l0aCByZXNwZWN0IHRvIHRoZSBkb2N1bWVudCBjb29yZGluYXRlcywgc28gd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHRoaXMgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMgd2hlbiB3ZSBhcmVuJ3QgY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGJleW9uZCB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwYWdlTGVmdCwgcGFnZVRvcF0gPSBhd2FpdCB0aGlzLmV2YWx1YXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aW5kb3cudmlzdWFsVmlld3BvcnQgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LnBhZ2VMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5wYWdlVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJveCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNsaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjbGlwLnggLSBwYWdlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNsaXAueSAtIHBhZ2VUb3AsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5jYXB0dXJlU2NyZWVuc2hvdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBjYXB0dXJlQmV5b25kVmlld3BvcnQgPyAnZG9jdW1lbnQnIDogJ3ZpZXdwb3J0JyxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogYGltYWdlLyR7dHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi4ocXVhbGl0eSAhPT0gdW5kZWZpbmVkID8geyBxdWFsaXR5OiBxdWFsaXR5IC8gMTAwIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi4oYm94ID8geyBjbGlwOiB7IHR5cGU6ICdib3gnLCAuLi5ib3ggfSB9IDoge30pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2ZyYW1lLmNyZWF0ZUNEUFNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBicmluZ1RvRnJvbnQoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBldmFsdWF0ZU9uTmV3RG9jdW1lbnQocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZXZhbHVhdGlvbkV4cHJlc3Npb24ocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5hZGRQcmVsb2FkU2NyaXB0KGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgcmV0dXJuIHsgaWRlbnRpZmllcjogc2NyaXB0IH07XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlU2NyaXB0VG9FdmFsdWF0ZU9uTmV3RG9jdW1lbnQoaWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5yZW1vdmVQcmVsb2FkU2NyaXB0KGlkKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBleHBvc2VGdW5jdGlvbihuYW1lLCBwcHRyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1haW5GcmFtZSgpLmV4cG9zZUZ1bmN0aW9uKG5hbWUsICdkZWZhdWx0JyBpbiBwcHRyRnVuY3Rpb24gPyBwcHRyRnVuY3Rpb24uZGVmYXVsdCA6IHBwdHJGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaXNEcmFnSW50ZXJjZXB0aW9uRW5hYmxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRDYWNoZUVuYWJsZWQoZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNicm93c2VyQ29udGV4dC5icm93c2VyKCkuY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0LnNldENhY2hlQmVoYXZpb3IoZW5hYmxlZCA/ICdkZWZhdWx0JyA6ICdieXBhc3MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgQ0RQLXNwZWNpZmljIGNhc2VzIHN1Y2ggYXMgbXByYWNoLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2xpZW50KCkuc2VuZCgnTmV0d29yay5zZXRDYWNoZURpc2FibGVkJywge1xuICAgICAgICAgICAgICAgIGNhY2hlRGlzYWJsZWQ6ICFlbmFibGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY29va2llcyguLi51cmxzKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVXJscyA9ICh1cmxzLmxlbmd0aCA/IHVybHMgOiBbdGhpcy51cmwoKV0pLm1hcCh1cmwgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZXMgPSBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuZ2V0Q29va2llcygpO1xuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZXNcbiAgICAgICAgICAgICAgICAubWFwKGNvb2tpZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpZGlUb1B1cHBldGVlckNvb2tpZShjb29raWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGNvb2tpZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRVcmxzLnNvbWUodXJsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlc3RVcmxNYXRjaENvb2tpZShjb29raWUsIHVybCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc1NlcnZpY2VXb3JrZXJCeXBhc3NlZCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHdhaXRGb3JGaWxlQ2hvb3NlcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtlcnMoKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMuI3dvcmtlcnNdO1xuICAgICAgICB9XG4gICAgICAgICN1c2VySW50ZXJjZXB0aW9uO1xuICAgICAgICBhc3luYyBzZXRSZXF1ZXN0SW50ZXJjZXB0aW9uKGVuYWJsZSkge1xuICAgICAgICAgICAgdGhpcy4jdXNlckludGVyY2VwdGlvbiA9IGF3YWl0IHRoaXMuI3RvZ2dsZUludGVyY2VwdGlvbihbXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIEJpZGkuTmV0d29yay5JbnRlcmNlcHRQaGFzZS5CZWZvcmVSZXF1ZXN0U2VudCAqL10sIHRoaXMuI3VzZXJJbnRlcmNlcHRpb24sIGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgX2V4dHJhSFRUUEhlYWRlcnMgPSB7fTtcbiAgICAgICAgI2V4dHJhSGVhZGVyc0ludGVyY2VwdGlvbjtcbiAgICAgICAgYXN5bmMgc2V0RXh0cmFIVFRQSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBleHRyYUhUVFBIZWFkZXJzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGFzc2VydChpc1N0cmluZyh2YWx1ZSksIGBFeHBlY3RlZCB2YWx1ZSBvZiBoZWFkZXIgXCIke2tleX1cIiB0byBiZSBTdHJpbmcsIGJ1dCBcIiR7dHlwZW9mIHZhbHVlfVwiIGlzIGZvdW5kLmApO1xuICAgICAgICAgICAgICAgIGV4dHJhSFRUUEhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9leHRyYUhUVFBIZWFkZXJzID0gZXh0cmFIVFRQSGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuI2V4dHJhSGVhZGVyc0ludGVyY2VwdGlvbiA9IGF3YWl0IHRoaXMuI3RvZ2dsZUludGVyY2VwdGlvbihbXCJiZWZvcmVSZXF1ZXN0U2VudFwiIC8qIEJpZGkuTmV0d29yay5JbnRlcmNlcHRQaGFzZS5CZWZvcmVSZXF1ZXN0U2VudCAqL10sIHRoaXMuI2V4dHJhSGVhZGVyc0ludGVyY2VwdGlvbiwgQm9vbGVhbihPYmplY3Qua2V5cyh0aGlzLl9leHRyYUhUVFBIZWFkZXJzKS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBfY3JlZGVudGlhbHMgPSBudWxsO1xuICAgICAgICAjYXV0aEludGVyY2VwdGlvbjtcbiAgICAgICAgYXN5bmMgYXV0aGVudGljYXRlKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB0aGlzLiNhdXRoSW50ZXJjZXB0aW9uID0gYXdhaXQgdGhpcy4jdG9nZ2xlSW50ZXJjZXB0aW9uKFtcImF1dGhSZXF1aXJlZFwiIC8qIEJpZGkuTmV0d29yay5JbnRlcmNlcHRQaGFzZS5BdXRoUmVxdWlyZWQgKi9dLCB0aGlzLiNhdXRoSW50ZXJjZXB0aW9uLCBCb29sZWFuKGNyZWRlbnRpYWxzKSk7XG4gICAgICAgICAgICB0aGlzLl9jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jICN0b2dnbGVJbnRlcmNlcHRpb24ocGhhc2VzLCBpbnRlcmNlcHRpb24sIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWQgJiYgIWludGVyY2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuYWRkSW50ZXJjZXB0KHtcbiAgICAgICAgICAgICAgICAgICAgcGhhc2VzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWV4cGVjdGVkICYmIGludGVyY2VwdGlvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC51c2VyQ29udGV4dC5icm93c2VyLnJlbW92ZUludGVyY2VwdChpbnRlcmNlcHRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnRlcmNlcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgc2V0RHJhZ0ludGVyY2VwdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHNldEJ5cGFzc1NlcnZpY2VXb3JrZXIoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBzZXRPZmZsaW5lTW9kZShlbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2Jyb3dzZXJDb250ZXh0LmJyb3dzZXIoKS5jZHBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB1cGxvYWQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGxhdGVuY3k6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMub2ZmbGluZSA9IGVuYWJsZWQ7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jYXBwbHlOZXR3b3JrQ29uZGl0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVtdWxhdGVOZXR3b3JrQ29uZGl0aW9ucyhuZXR3b3JrQ29uZGl0aW9ucykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNicm93c2VyQ29udGV4dC5icm93c2VyKCkuY2RwU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBvZmZsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLnVwbG9hZCA9IG5ldHdvcmtDb25kaXRpb25zXG4gICAgICAgICAgICAgICAgPyBuZXR3b3JrQ29uZGl0aW9ucy51cGxvYWRcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICAgICAgdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5kb3dubG9hZCA9IG5ldHdvcmtDb25kaXRpb25zXG4gICAgICAgICAgICAgICAgPyBuZXR3b3JrQ29uZGl0aW9ucy5kb3dubG9hZFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLmxhdGVuY3kgPSBuZXR3b3JrQ29uZGl0aW9uc1xuICAgICAgICAgICAgICAgID8gbmV0d29ya0NvbmRpdGlvbnMubGF0ZW5jeVxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNhcHBseU5ldHdvcmtDb25kaXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2FwcGx5TmV0d29ya0NvbmRpdGlvbnMoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jbGllbnQoKS5zZW5kKCdOZXR3b3JrLmVtdWxhdGVOZXR3b3JrQ29uZGl0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBvZmZsaW5lOiB0aGlzLiNlbXVsYXRlZE5ldHdvcmtDb25kaXRpb25zLm9mZmxpbmUsXG4gICAgICAgICAgICAgICAgbGF0ZW5jeTogdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5sYXRlbmN5LFxuICAgICAgICAgICAgICAgIHVwbG9hZFRocm91Z2hwdXQ6IHRoaXMuI2VtdWxhdGVkTmV0d29ya0NvbmRpdGlvbnMudXBsb2FkLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkVGhyb3VnaHB1dDogdGhpcy4jZW11bGF0ZWROZXR3b3JrQ29uZGl0aW9ucy5kb3dubG9hZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENvb2tpZSguLi5jb29raWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlVVJMID0gdGhpcy51cmwoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VVcmxTdGFydHNXaXRoSFRUUCA9IHBhZ2VVUkwuc3RhcnRzV2l0aCgnaHR0cCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb29raWUgb2YgY29va2llcykge1xuICAgICAgICAgICAgICAgIGxldCBjb29raWVVcmwgPSBjb29raWUudXJsIHx8ICcnO1xuICAgICAgICAgICAgICAgIGlmICghY29va2llVXJsICYmIHBhZ2VVcmxTdGFydHNXaXRoSFRUUCkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWVVcmwgPSBwYWdlVVJMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NlcnQoY29va2llVXJsICE9PSAnYWJvdXQ6YmxhbmsnLCBgQmxhbmsgcGFnZSBjYW4gbm90IGhhdmUgY29va2llIFwiJHtjb29raWUubmFtZX1cImApO1xuICAgICAgICAgICAgICAgIGFzc2VydCghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoLmNhbGwoY29va2llVXJsIHx8ICcnLCAnZGF0YTonKSwgYERhdGEgVVJMIHBhZ2UgY2FuIG5vdCBoYXZlIGNvb2tpZSBcIiR7Y29va2llLm5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gVVJMLmNhblBhcnNlKGNvb2tpZVVybClcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgVVJMKGNvb2tpZVVybClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gY29va2llLmRvbWFpbiA/PyBub3JtYWxpemVkVXJsPy5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICBhc3NlcnQoZG9tYWluICE9PSB1bmRlZmluZWQsIGBBdCBsZWFzdCBvbmUgb2YgdGhlIHVybCBhbmQgZG9tYWluIG5lZWRzIHRvIGJlIHNwZWNpZmllZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpZGlDb29raWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb29raWUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvb2tpZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvb2tpZS5wYXRoICE9PSB1bmRlZmluZWQgPyB7IHBhdGg6IGNvb2tpZS5wYXRoIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihjb29raWUuaHR0cE9ubHkgIT09IHVuZGVmaW5lZCA/IHsgaHR0cE9ubHk6IGNvb2tpZS5odHRwT25seSB9IDoge30pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oY29va2llLnNlY3VyZSAhPT0gdW5kZWZpbmVkID8geyBzZWN1cmU6IGNvb2tpZS5zZWN1cmUgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvb2tpZS5zYW1lU2l0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgc2FtZVNpdGU6IGNvbnZlcnRDb29raWVzU2FtZVNpdGVDZHBUb0JpRGkoY29va2llLnNhbWVTaXRlKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKGNvb2tpZS5leHBpcmVzICE9PSB1bmRlZmluZWQgPyB7IGV4cGlyeTogY29va2llLmV4cGlyZXMgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgIC4uLmNkcFNwZWNpZmljQ29va2llUHJvcGVydGllc0Zyb21QdXBwZXRlZXJUb0JpZGkoY29va2llLCAnc2FtZVBhcnR5JywgJ3NvdXJjZVNjaGVtZScsICdwcmlvcml0eScsICd1cmwnKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChjb29raWUucGFydGl0aW9uS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5icm93c2VyQ29udGV4dCgpLnVzZXJDb250ZXh0LnNldENvb2tpZShiaWRpQ29va2llLCBjb29raWUucGFydGl0aW9uS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC5zZXRDb29raWUoYmlkaUNvb2tpZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGRlbGV0ZUNvb2tpZSguLi5jb29raWVzKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb29raWVzLm1hcChhc3luYyAoZGVsZXRlQ29va2llUmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZVVybCA9IGRlbGV0ZUNvb2tpZVJlcXVlc3QudXJsID8/IHRoaXMudXJsKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9IFVSTC5jYW5QYXJzZShjb29raWVVcmwpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IFVSTChjb29raWVVcmwpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IGRlbGV0ZUNvb2tpZVJlcXVlc3QuZG9tYWluID8/IG5vcm1hbGl6ZWRVcmw/Lmhvc3RuYW1lO1xuICAgICAgICAgICAgICAgIGFzc2VydChkb21haW4gIT09IHVuZGVmaW5lZCwgYEF0IGxlYXN0IG9uZSBvZiB0aGUgdXJsIGFuZCBkb21haW4gbmVlZHMgdG8gYmUgc3BlY2lmaWVkYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGVsZXRlQ29va2llUmVxdWVzdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAuLi4oZGVsZXRlQ29va2llUmVxdWVzdC5wYXRoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBwYXRoOiBkZWxldGVDb29raWVSZXF1ZXN0LnBhdGggfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNmcmFtZS5icm93c2luZ0NvbnRleHQuZGVsZXRlQ29va2llKGZpbHRlcik7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlRXhwb3NlZEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2ZyYW1lLnJlbW92ZUV4cG9zZWRGdW5jdGlvbihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRyaWNzKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZ29CYWNrKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuI2dvKC0xLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnb0ZvcndhcmQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy4jZ28oMSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2dvKGRlbHRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FpdEZvck5hdmlnYXRpb24ob3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dC50cmF2ZXJzZUhpc3RvcnkoZGVsdGEpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdhaXRGb3JOYXZpZ2F0aW9uIHNob3VsZCBiZSBjYW5jZWxsZWQgaWYgYW4gZXJyb3IgaGFwcGVucy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvckxpa2UoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdubyBzdWNoIGhpc3RvcnkgZW50cnknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2FpdEZvckRldmljZVByb21wdCgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCaWRpUGFnZSB9O1xuZnVuY3Rpb24gZXZhbHVhdGlvbkV4cHJlc3Npb24oZnVuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGAoKSA9PiB7JHtldmFsdWF0aW9uU3RyaW5nKGZ1biwgLi4uYXJncyl9fWA7XG59XG4vKipcbiAqIENoZWNrIGRvbWFpbnMgbWF0Y2guXG4gKiBBY2NvcmRpbmcgdG8gY29va2llcyBzcGVjLCB0aGlzIGNoZWNrIHNob3VsZCBtYXRjaCBzdWJkb21haW5zIGFzIHdlbGwsIGJ1dCBDRFBcbiAqIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGRvIHRoYXQsIHNvIHRoaXMgbWV0aG9kIG1hdGNoZXMgb25seSB0aGUgZXhhY3QgZG9tYWlucywgbm90XG4gKiB3aGF0IGlzIHdyaXR0ZW4gaW4gdGhlIHNwZWM6XG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzYyNjUjc2VjdGlvbi01LjEuM1xuICovXG5mdW5jdGlvbiB0ZXN0VXJsTWF0Y2hDb29raWVIb3N0bmFtZShjb29raWUsIG5vcm1hbGl6ZWRVcmwpIHtcbiAgICBjb25zdCBjb29raWVEb21haW4gPSBjb29raWUuZG9tYWluLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdXJsSG9zdG5hbWUgPSBub3JtYWxpemVkVXJsLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGNvb2tpZURvbWFpbiA9PT0gdXJsSG9zdG5hbWU7XG59XG4vKipcbiAqIENoZWNrIHBhdGhzIG1hdGNoLlxuICogU3BlYzogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MjY1I3NlY3Rpb24tNS4xLjRcbiAqL1xuZnVuY3Rpb24gdGVzdFVybE1hdGNoQ29va2llUGF0aChjb29raWUsIG5vcm1hbGl6ZWRVcmwpIHtcbiAgICBjb25zdCB1cmlQYXRoID0gbm9ybWFsaXplZFVybC5wYXRobmFtZTtcbiAgICBjb25zdCBjb29raWVQYXRoID0gY29va2llLnBhdGg7XG4gICAgaWYgKHVyaVBhdGggPT09IGNvb2tpZVBhdGgpIHtcbiAgICAgICAgLy8gVGhlIGNvb2tpZS1wYXRoIGFuZCB0aGUgcmVxdWVzdC1wYXRoIGFyZSBpZGVudGljYWwuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodXJpUGF0aC5zdGFydHNXaXRoKGNvb2tpZVBhdGgpKSB7XG4gICAgICAgIC8vIFRoZSBjb29raWUtcGF0aCBpcyBhIHByZWZpeCBvZiB0aGUgcmVxdWVzdC1wYXRoLlxuICAgICAgICBpZiAoY29va2llUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGNvb2tpZS1wYXRoIGlzICV4MkYgKFwiL1wiKS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmlQYXRoW2Nvb2tpZVBhdGgubGVuZ3RoXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSByZXF1ZXN0LXBhdGggdGhhdCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGNvb2tpZS1wYXRoXG4gICAgICAgICAgICAvLyBpcyBhICV4MkYgKFwiL1wiKSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrcyB0aGUgY29va2llIG1hdGNoZXMgdGhlIFVSTCBhY2NvcmRpbmcgdG8gdGhlIHNwZWM6XG4gKi9cbmZ1bmN0aW9uIHRlc3RVcmxNYXRjaENvb2tpZShjb29raWUsIHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgYXNzZXJ0KGNvb2tpZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAoIXRlc3RVcmxNYXRjaENvb2tpZUhvc3RuYW1lKGNvb2tpZSwgbm9ybWFsaXplZFVybCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGVzdFVybE1hdGNoQ29va2llUGF0aChjb29raWUsIG5vcm1hbGl6ZWRVcmwpO1xufVxuZnVuY3Rpb24gYmlkaVRvUHVwcGV0ZWVyQ29va2llKGJpZGlDb29raWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBiaWRpQ29va2llLm5hbWUsXG4gICAgICAgIC8vIFByZXNlbnRzIGJpbmFyeSB2YWx1ZSBhcyBiYXNlNjQgc3RyaW5nLlxuICAgICAgICB2YWx1ZTogYmlkaUNvb2tpZS52YWx1ZS52YWx1ZSxcbiAgICAgICAgZG9tYWluOiBiaWRpQ29va2llLmRvbWFpbixcbiAgICAgICAgcGF0aDogYmlkaUNvb2tpZS5wYXRoLFxuICAgICAgICBzaXplOiBiaWRpQ29va2llLnNpemUsXG4gICAgICAgIGh0dHBPbmx5OiBiaWRpQ29va2llLmh0dHBPbmx5LFxuICAgICAgICBzZWN1cmU6IGJpZGlDb29raWUuc2VjdXJlLFxuICAgICAgICBzYW1lU2l0ZTogY29udmVydENvb2tpZXNTYW1lU2l0ZUJpRGlUb0NkcChiaWRpQ29va2llLnNhbWVTaXRlKSxcbiAgICAgICAgZXhwaXJlczogYmlkaUNvb2tpZS5leHBpcnkgPz8gLTEsXG4gICAgICAgIHNlc3Npb246IGJpZGlDb29raWUuZXhwaXJ5ID09PSB1bmRlZmluZWQgfHwgYmlkaUNvb2tpZS5leHBpcnkgPD0gMCxcbiAgICAgICAgLy8gRXh0ZW5kaW5nIHdpdGggQ0RQLXNwZWNpZmljIHByb3BlcnRpZXMgd2l0aCBgZ29vZzpgIHByZWZpeC5cbiAgICAgICAgLi4uY2RwU3BlY2lmaWNDb29raWVQcm9wZXJ0aWVzRnJvbUJpZGlUb1B1cHBldGVlcihiaWRpQ29va2llLCAnc2FtZVBhcnR5JywgJ3NvdXJjZVNjaGVtZScsICdwYXJ0aXRpb25LZXknLCAncGFydGl0aW9uS2V5T3BhcXVlJywgJ3ByaW9yaXR5JyksXG4gICAgfTtcbn1cbmNvbnN0IENEUF9TUEVDSUZJQ19QUkVGSVggPSAnZ29vZzonO1xuLyoqXG4gKiBHZXRzIENEUC1zcGVjaWZpYyBwcm9wZXJ0aWVzIGZyb20gdGhlIEJpRGkgY29va2llIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjZHBTcGVjaWZpY0Nvb2tpZVByb3BlcnRpZXNGcm9tQmlkaVRvUHVwcGV0ZWVyKGJpZGlDb29raWUsIC4uLnByb3BlcnR5TmFtZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgaWYgKGJpZGlDb29raWVbQ0RQX1NQRUNJRklDX1BSRUZJWCArIHByb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldID0gYmlkaUNvb2tpZVtDRFBfU1BFQ0lGSUNfUFJFRklYICsgcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEdldHMgQ0RQLXNwZWNpZmljIHByb3BlcnRpZXMgZnJvbSB0aGUgY29va2llLCBhZGRzIENEUC1zcGVjaWZpYyBwcmVmaXhlcyBhbmQgcmV0dXJuc1xuICogdGhlbSBhcyBhIG5ldyBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgaW4gQmlEaS5cbiAqL1xuZnVuY3Rpb24gY2RwU3BlY2lmaWNDb29raWVQcm9wZXJ0aWVzRnJvbVB1cHBldGVlclRvQmlkaShjb29raWVQYXJhbSwgLi4ucHJvcGVydHlOYW1lcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydHlOYW1lcykge1xuICAgICAgICBpZiAoY29va2llUGFyYW1bcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtDRFBfU1BFQ0lGSUNfUFJFRklYICsgcHJvcGVydHldID0gY29va2llUGFyYW1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29va2llc1NhbWVTaXRlQmlEaVRvQ2RwKHNhbWVTaXRlKSB7XG4gICAgcmV0dXJuIHNhbWVTaXRlID09PSAnc3RyaWN0JyA/ICdTdHJpY3QnIDogc2FtZVNpdGUgPT09ICdsYXgnID8gJ0xheCcgOiAnTm9uZSc7XG59XG5mdW5jdGlvbiBjb252ZXJ0Q29va2llc1NhbWVTaXRlQ2RwVG9CaURpKHNhbWVTaXRlKSB7XG4gICAgcmV0dXJuIHNhbWVTaXRlID09PSAnU3RyaWN0J1xuICAgICAgICA/IFwic3RyaWN0XCIgLyogQmlkaS5OZXR3b3JrLlNhbWVTaXRlLlN0cmljdCAqL1xuICAgICAgICA6IHNhbWVTaXRlID09PSAnTGF4J1xuICAgICAgICAgICAgPyBcImxheFwiIC8qIEJpZGkuTmV0d29yay5TYW1lU2l0ZS5MYXggKi9cbiAgICAgICAgICAgIDogXCJub25lXCIgLyogQmlkaS5OZXR3b3JrLlNhbWVTaXRlLk5vbmUgKi87XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYWdlLmpzLm1hcCIsInZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBSZWFsbSB9IGZyb20gJy4uL2FwaS9SZWFsbS5qcyc7XG5pbXBvcnQgeyBBUklBUXVlcnlIYW5kbGVyIH0gZnJvbSAnLi4vY2RwL0FyaWFRdWVyeUhhbmRsZXIuanMnO1xuaW1wb3J0IHsgTGF6eUFyZyB9IGZyb20gJy4uL2NvbW1vbi9MYXp5QXJnLmpzJztcbmltcG9ydCB7IHNjcmlwdEluamVjdG9yIH0gZnJvbSAnLi4vY29tbW9uL1NjcmlwdEluamVjdG9yLmpzJztcbmltcG9ydCB7IGRlYnVnRXJyb3IsIGdldFNvdXJjZVB1cHBldGVlclVSTElmQXZhaWxhYmxlLCBnZXRTb3VyY2VVcmxDb21tZW50LCBpc1N0cmluZywgUHVwcGV0ZWVyVVJMLCBTT1VSQ0VfVVJMX1JFR0VYLCB9IGZyb20gJy4uL2NvbW1vbi91dGlsLmpzJztcbmltcG9ydCB7IEFzeW5jSXRlcmFibGVVdGlsIH0gZnJvbSAnLi4vdXRpbC9Bc3luY0l0ZXJhYmxlVXRpbC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvRnVuY3Rpb24uanMnO1xuaW1wb3J0IHsgQmlkaURlc2VyaWFsaXplciB9IGZyb20gJy4vRGVzZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IEJpZGlFbGVtZW50SGFuZGxlIH0gZnJvbSAnLi9FbGVtZW50SGFuZGxlLmpzJztcbmltcG9ydCB7IEV4cG9zZWFibGVGdW5jdGlvbiB9IGZyb20gJy4vRXhwb3NlZEZ1bmN0aW9uLmpzJztcbmltcG9ydCB7IEJpZGlKU0hhbmRsZSB9IGZyb20gJy4vSlNIYW5kbGUuanMnO1xuaW1wb3J0IHsgQmlkaVNlcmlhbGl6ZXIgfSBmcm9tICcuL1NlcmlhbGl6ZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlRXZhbHVhdGlvbkVycm9yIH0gZnJvbSAnLi91dGlsLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpUmVhbG0gZXh0ZW5kcyBSZWFsbSB7XG4gICAgcmVhbG07XG4gICAgY29uc3RydWN0b3IocmVhbG0sIHRpbWVvdXRTZXR0aW5ncykge1xuICAgICAgICBzdXBlcih0aW1lb3V0U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnJlYWxtID0gcmVhbG07XG4gICAgfVxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMucmVhbG0ub24oJ2Rlc3Ryb3llZCcsICh7IHJlYXNvbiB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRhc2tNYW5hZ2VyLnRlcm1pbmF0ZUFsbChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhbG0ub24oJ3VwZGF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZvaWQgdGhpcy50YXNrTWFuYWdlci5yZXJ1bkFsbCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50ZXJuYWxQdXBwZXRlZXJVdGlsO1xuICAgIGdldCBwdXBwZXRlZXJVdGlsKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHNjcmlwdEluamVjdG9yLmluamVjdChzY3JpcHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxQdXBwZXRlZXJVdGlsKSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbC50aGVuKGhhbmRsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxQdXBwZXRlZXJVdGlsID0gcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUhhbmRsZShzY3JpcHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sICF0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUHVwcGV0ZWVyVXRpbDtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVIYW5kbGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNldmFsdWF0ZShmYWxzZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGUocGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLiNldmFsdWF0ZSh0cnVlLCBwYWdlRnVuY3Rpb24sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyAjZXZhbHVhdGUocmV0dXJuQnlWYWx1ZSwgcGFnZUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVVybENvbW1lbnQgPSBnZXRTb3VyY2VVcmxDb21tZW50KGdldFNvdXJjZVB1cHBldGVlclVSTElmQXZhaWxhYmxlKHBhZ2VGdW5jdGlvbik/LnRvU3RyaW5nKCkgPz9cbiAgICAgICAgICAgIFB1cHBldGVlclVSTC5JTlRFUk5BTF9VUkwpO1xuICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHRPd25lcnNoaXAgPSByZXR1cm5CeVZhbHVlXG4gICAgICAgICAgICA/IFwibm9uZVwiIC8qIEJpZGkuU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Ob25lICovXG4gICAgICAgICAgICA6IFwicm9vdFwiIC8qIEJpZGkuU2NyaXB0LlJlc3VsdE93bmVyc2hpcC5Sb290ICovO1xuICAgICAgICBjb25zdCBzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHJldHVybkJ5VmFsdWVcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIG1heE9iamVjdERlcHRoOiAwLFxuICAgICAgICAgICAgICAgIG1heERvbURlcHRoOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHBhZ2VGdW5jdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBTT1VSQ0VfVVJMX1JFR0VYLnRlc3QocGFnZUZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgID8gcGFnZUZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgOiBgJHtwYWdlRnVuY3Rpb259XFxuJHtzb3VyY2VVcmxDb21tZW50fVxcbmA7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSB0aGlzLnJlYWxtLmV2YWx1YXRlKGV4cHJlc3Npb24sIHRydWUsIHtcbiAgICAgICAgICAgICAgICByZXN1bHRPd25lcnNoaXAsXG4gICAgICAgICAgICAgICAgdXNlckFjdGl2YXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvbkRlY2xhcmF0aW9uID0gc3RyaW5naWZ5RnVuY3Rpb24ocGFnZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24gPSBTT1VSQ0VfVVJMX1JFR0VYLnRlc3QoZnVuY3Rpb25EZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uRGVjbGFyYXRpb25cbiAgICAgICAgICAgICAgICA6IGAke2Z1bmN0aW9uRGVjbGFyYXRpb259XFxuJHtzb3VyY2VVcmxDb21tZW50fVxcbmA7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSB0aGlzLnJlYWxtLmNhbGxGdW5jdGlvbihmdW5jdGlvbkRlY2xhcmF0aW9uLCBcbiAgICAgICAgICAgIC8qIGF3YWl0UHJvbWlzZT0gKi8gdHJ1ZSwge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJncy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbChhcmdzLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplKGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgICAgIHJlc3VsdE93bmVyc2hpcCxcbiAgICAgICAgICAgICAgICB1c2VyQWN0aXZhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgaWYgKCd0eXBlJyBpbiByZXN1bHQgJiYgcmVzdWx0LnR5cGUgPT09ICdleGNlcHRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFdmFsdWF0aW9uRXJyb3IocmVzdWx0LmV4Y2VwdGlvbkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5CeVZhbHVlXG4gICAgICAgICAgICA/IEJpZGlEZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0LnJlc3VsdClcbiAgICAgICAgICAgIDogdGhpcy5jcmVhdGVIYW5kbGUocmVzdWx0LnJlc3VsdCk7XG4gICAgfVxuICAgIGNyZWF0ZUhhbmRsZShyZXN1bHQpIHtcbiAgICAgICAgaWYgKChyZXN1bHQudHlwZSA9PT0gJ25vZGUnIHx8IHJlc3VsdC50eXBlID09PSAnd2luZG93JykgJiZcbiAgICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBCaWRpRnJhbWVSZWFsbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZGlFbGVtZW50SGFuZGxlLmZyb20ocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlkaUpTSGFuZGxlLmZyb20ocmVzdWx0LCB0aGlzKTtcbiAgICB9XG4gICAgYXN5bmMgc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgTGF6eUFyZykge1xuICAgICAgICAgICAgYXJnID0gYXdhaXQgYXJnLmdldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQmlkaUpTSGFuZGxlIHx8IGFyZyBpbnN0YW5jZW9mIEJpZGlFbGVtZW50SGFuZGxlKSB7XG4gICAgICAgICAgICBpZiAoYXJnLnJlYWxtICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXJnLnJlYWxtIGluc3RhbmNlb2YgQmlkaUZyYW1lUmVhbG0pIHx8XG4gICAgICAgICAgICAgICAgICAgICEodGhpcyBpbnN0YW5jZW9mIEJpZGlGcmFtZVJlYWxtKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZXZhbHVhdGUgSlNIYW5kbGUgZnJvbSBkaWZmZXJlbnQgZ2xvYmFsIHR5cGVzLiBVc3VhbGx5IHRoaXMgbWVhbnMgeW91J3JlIHVzaW5nIGEgaGFuZGxlIGZyb20gYSB3b3JrZXIgaW4gYSBwYWdlIG9yIHZpY2UgdmVyc2EuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXJnLnJlYWxtLmVudmlyb25tZW50ICE9PSB0aGlzLmVudmlyb25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byBldmFsdWF0ZSBKU0hhbmRsZSBmcm9tIGRpZmZlcmVudCBmcmFtZXMuIFVzdWFsbHkgdGhpcyBtZWFucyB5b3UncmUgdXNpbmcgYSBoYW5kbGUgZnJvbSBhIHBhZ2Ugb24gYSBkaWZmZXJlbnQgcGFnZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNIYW5kbGUgaXMgZGlzcG9zZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJnLnJlbW90ZVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZGlTZXJpYWxpemVyLnNlcmlhbGl6ZShhcmcpO1xuICAgIH1cbiAgICBhc3luYyBkZXN0cm95SGFuZGxlcyhoYW5kbGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlSWRzID0gaGFuZGxlc1xuICAgICAgICAgICAgLm1hcCgoeyBpZCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKChpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFuZGxlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVhbG0uZGlzb3duKGhhbmRsZUlkcykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBtaWdodCBoYXBwZW4gaW4gY2FzZSBvZiBhIHBhZ2UgYmVlbiBuYXZpZ2F0ZWQgb3IgY2xvc2VkLlxuICAgICAgICAgICAgLy8gU3dhbGxvdyB0aGVzZSBzaW5jZSB0aGV5IGFyZSBoYXJtbGVzcyBhbmQgd2UgZG9uJ3QgbGVhayBhbnl0aGluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICBkZWJ1Z0Vycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFkb3B0SGFuZGxlKGhhbmRsZSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZXZhbHVhdGVIYW5kbGUobm9kZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSwgaGFuZGxlKSk7XG4gICAgfVxuICAgIGFzeW5jIHRyYW5zZmVySGFuZGxlKGhhbmRsZSkge1xuICAgICAgICBpZiAoaGFuZGxlLnJlYWxtID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZmVycmVkSGFuZGxlID0gdGhpcy5hZG9wdEhhbmRsZShoYW5kbGUpO1xuICAgICAgICBhd2FpdCBoYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdHJhbnNmZXJyZWRIYW5kbGU7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlGcmFtZVJlYWxtIGV4dGVuZHMgQmlkaVJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShyZWFsbSwgZnJhbWUpIHtcbiAgICAgICAgY29uc3QgZnJhbWVSZWFsbSA9IG5ldyBCaWRpRnJhbWVSZWFsbShyZWFsbSwgZnJhbWUpO1xuICAgICAgICBmcmFtZVJlYWxtLiNpbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiBmcmFtZVJlYWxtO1xuICAgIH1cbiAgICAjZnJhbWU7XG4gICAgY29uc3RydWN0b3IocmVhbG0sIGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKHJlYWxtLCBmcmFtZS50aW1lb3V0U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgIH1cbiAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBydW4gZmlyc3QuXG4gICAgICAgIHRoaXMucmVhbG0ub24oJ3VwZGF0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVudmlyb25tZW50LmNsZWFyRG9jdW1lbnRIYW5kbGUoKTtcbiAgICAgICAgICAgIHRoaXMuI2JpbmRpbmdzSW5zdGFsbGVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYmluZGluZ3NJbnN0YWxsZWQgPSBmYWxzZTtcbiAgICBnZXQgcHVwcGV0ZWVyVXRpbCgpIHtcbiAgICAgICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLiNiaW5kaW5nc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBFeHBvc2VhYmxlRnVuY3Rpb24uZnJvbSh0aGlzLmVudmlyb25tZW50LCAnX19hcmlhUXVlcnlTZWxlY3RvcicsIEFSSUFRdWVyeUhhbmRsZXIucXVlcnlPbmUsICEhdGhpcy5zYW5kYm94KSxcbiAgICAgICAgICAgICAgICBFeHBvc2VhYmxlRnVuY3Rpb24uZnJvbSh0aGlzLmVudmlyb25tZW50LCAnX19hcmlhUXVlcnlTZWxlY3RvckFsbCcsIGFzeW5jIChlbGVtZW50LCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gQVJJQVF1ZXJ5SGFuZGxlci5xdWVyeUFsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBlbGVtZW50LnJlYWxtLmV2YWx1YXRlSGFuZGxlKCguLi5lbGVtZW50cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB9LCAuLi4oYXdhaXQgQXN5bmNJdGVyYWJsZVV0aWwuY29sbGVjdChyZXN1bHRzKSkpO1xuICAgICAgICAgICAgICAgIH0sICEhdGhpcy5zYW5kYm94KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy4jYmluZGluZ3NJbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnB1cHBldGVlclV0aWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc2FuZGJveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbG0uc2FuZGJveDtcbiAgICB9XG4gICAgZ2V0IGVudmlyb25tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWU7XG4gICAgfVxuICAgIGFzeW5jIGFkb3B0QmFja2VuZE5vZGUoYmFja2VuZE5vZGVJZCkge1xuICAgICAgICBjb25zdCBlbnZfMSA9IHsgc3RhY2s6IFtdLCBlcnJvcjogdm9pZCAwLCBoYXNFcnJvcjogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2JqZWN0IH0gPSBhd2FpdCB0aGlzLiNmcmFtZS5jbGllbnQuc2VuZCgnRE9NLnJlc29sdmVOb2RlJywge1xuICAgICAgICAgICAgICAgIGJhY2tlbmROb2RlSWQsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkOiBhd2FpdCB0aGlzLnJlYWxtLnJlc29sdmVFeGVjdXRpb25Db250ZXh0SWQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIEJpZGlFbGVtZW50SGFuZGxlLmZyb20oe1xuICAgICAgICAgICAgICAgIGhhbmRsZTogb2JqZWN0Lm9iamVjdElkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdub2RlJyxcbiAgICAgICAgICAgIH0sIHRoaXMpLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRoZSBzaGFyZWRJZCwgc28gd2UgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHRvIG9idGFpbiBpdC5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGUuZXZhbHVhdGVIYW5kbGUoZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xKSB7XG4gICAgICAgICAgICBlbnZfMS5lcnJvciA9IGVfMTtcbiAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVdvcmtlclJlYWxtIGV4dGVuZHMgQmlkaVJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShyZWFsbSwgd29ya2VyKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlclJlYWxtID0gbmV3IEJpZGlXb3JrZXJSZWFsbShyZWFsbSwgd29ya2VyKTtcbiAgICAgICAgd29ya2VyUmVhbG0uaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gd29ya2VyUmVhbG07XG4gICAgfVxuICAgICN3b3JrZXI7XG4gICAgY29uc3RydWN0b3IocmVhbG0sIGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKHJlYWxtLCBmcmFtZS50aW1lb3V0U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLiN3b3JrZXIgPSBmcmFtZTtcbiAgICB9XG4gICAgZ2V0IGVudmlyb25tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd29ya2VyO1xuICAgIH1cbiAgICBhc3luYyBhZG9wdEJhY2tlbmROb2RlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZG9wdCBET00gbm9kZXMgaW50byBhIHdvcmtlci4nKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsbS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgaXNEYXRlLCBpc1BsYWluT2JqZWN0LCBpc1JlZ0V4cCB9IGZyb20gJy4uL2NvbW1vbi91dGlsLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFVuc2VyaWFsaXphYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVNlcmlhbGl6ZXIge1xuICAgIHN0YXRpYyBzZXJpYWxpemUoYXJnKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGFyZykge1xuICAgICAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zZXJpYWxpemFibGVFcnJvcihgVW5hYmxlIHRvIHNlcmlhbGl6YWJsZSAke3R5cGVvZiBhcmd9YCk7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiNzZXJpYWxpemVPYmplY3QoYXJnKTtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6ZU51bWJlcihhcmcpO1xuICAgICAgICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmlnaW50JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgI3NlcmlhbGl6ZU51bWJlcihhcmcpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAoT2JqZWN0LmlzKGFyZywgLTApKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICctMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmlzKGFyZywgSW5maW5pdHkpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdJbmZpbml0eSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmlzKGFyZywgLUluZmluaXR5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnLUluZmluaXR5JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChPYmplY3QuaXMoYXJnLCBOYU4pKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdOYU4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyAjc2VyaWFsaXplT2JqZWN0KGFyZykge1xuICAgICAgICBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdudWxsJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcnJheSA9IGFyZy5tYXAoc3ViQXJnID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoc3ViQXJnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRBcnJheSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArPSAnIFJlY3Vyc2l2ZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZC4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE9iamVjdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkT2JqZWN0LnB1c2goW3RoaXMuc2VyaWFsaXplKGtleSksIHRoaXMuc2VyaWFsaXplKGFyZ1trZXldKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VkT2JqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZWdleHAnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGFyZy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiBhcmcuZmxhZ3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RhdGUnLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBhcmcudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFVuc2VyaWFsaXphYmxlRXJyb3IoJ0N1c3RvbSBvYmplY3Qgc2VyaWFsaXphdGlvbiBub3QgcG9zc2libGUuIFVzZSBwbGFpbiBvYmplY3RzIGluc3RlYWQuJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VyaWFsaXplci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgVGFyZ2V0LCBUYXJnZXRUeXBlIH0gZnJvbSAnLi4vYXBpL1RhcmdldC5qcyc7XG5pbXBvcnQgeyBVbnN1cHBvcnRlZE9wZXJhdGlvbiB9IGZyb20gJy4uL2NvbW1vbi9FcnJvcnMuanMnO1xuaW1wb3J0IHsgQmlkaVBhZ2UgfSBmcm9tICcuL1BhZ2UuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlCcm93c2VyVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAjYnJvd3NlcjtcbiAgICBjb25zdHJ1Y3Rvcihicm93c2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2Jyb3dzZXIgPSBicm93c2VyO1xuICAgIH1cbiAgICBhc1BhZ2UoKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICB1cmwoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY3JlYXRlQ0RQU2Vzc2lvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxuICAgIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiBUYXJnZXRUeXBlLkJST1dTRVI7XG4gICAgfVxuICAgIGJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNicm93c2VyO1xuICAgIH1cbiAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Jyb3dzZXIuZGVmYXVsdEJyb3dzZXJDb250ZXh0KCk7XG4gICAgfVxuICAgIG9wZW5lcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlQYWdlVGFyZ2V0IGV4dGVuZHMgVGFyZ2V0IHtcbiAgICAjcGFnZTtcbiAgICBjb25zdHJ1Y3RvcihwYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI3BhZ2UgPSBwYWdlO1xuICAgIH1cbiAgICBhc3luYyBwYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICByZXR1cm4gQmlkaVBhZ2UuZnJvbSh0aGlzLmJyb3dzZXJDb250ZXh0KCksIHRoaXMuI3BhZ2UubWFpbkZyYW1lKCkuYnJvd3NpbmdDb250ZXh0KTtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZS51cmwoKTtcbiAgICB9XG4gICAgY3JlYXRlQ0RQU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhZ2UuY3JlYXRlQ0RQU2Vzc2lvbigpO1xuICAgIH1cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0VHlwZS5QQUdFO1xuICAgIH1cbiAgICBicm93c2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyQ29udGV4dCgpLmJyb3dzZXIoKTtcbiAgICB9XG4gICAgYnJvd3NlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYWdlLmJyb3dzZXJDb250ZXh0KCk7XG4gICAgfVxuICAgIG9wZW5lcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uKCk7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlGcmFtZVRhcmdldCBleHRlbmRzIFRhcmdldCB7XG4gICAgI2ZyYW1lO1xuICAgICNwYWdlO1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuI2ZyYW1lID0gZnJhbWU7XG4gICAgfVxuICAgIGFzeW5jIHBhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLiNwYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI3BhZ2UgPSBCaWRpUGFnZS5mcm9tKHRoaXMuYnJvd3NlckNvbnRleHQoKSwgdGhpcy4jZnJhbWUuYnJvd3NpbmdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4jcGFnZTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICByZXR1cm4gQmlkaVBhZ2UuZnJvbSh0aGlzLmJyb3dzZXJDb250ZXh0KCksIHRoaXMuI2ZyYW1lLmJyb3dzaW5nQ29udGV4dCk7XG4gICAgfVxuICAgIHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ZyYW1lLnVybCgpO1xuICAgIH1cbiAgICBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWUuY3JlYXRlQ0RQU2Vzc2lvbigpO1xuICAgIH1cbiAgICB0eXBlKCkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0VHlwZS5QQUdFO1xuICAgIH1cbiAgICBicm93c2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyQ29udGV4dCgpLmJyb3dzZXIoKTtcbiAgICB9XG4gICAgYnJvd3NlckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmcmFtZS5wYWdlKCkuYnJvd3NlckNvbnRleHQoKTtcbiAgICB9XG4gICAgb3BlbmVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQmlkaVdvcmtlclRhcmdldCBleHRlbmRzIFRhcmdldCB7XG4gICAgI3dvcmtlcjtcbiAgICBjb25zdHJ1Y3Rvcih3b3JrZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy4jd29ya2VyID0gd29ya2VyO1xuICAgIH1cbiAgICBhc3luYyBwYWdlKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgYXNQYWdlKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgdXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd29ya2VyLnVybCgpO1xuICAgIH1cbiAgICBjcmVhdGVDRFBTZXNzaW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRhcmdldFR5cGUuT1RIRVI7XG4gICAgfVxuICAgIGJyb3dzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb3dzZXJDb250ZXh0KCkuYnJvd3NlcigpO1xuICAgIH1cbiAgICBicm93c2VyQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3dvcmtlci5mcmFtZS5wYWdlKCkuYnJvd3NlckNvbnRleHQoKTtcbiAgICB9XG4gICAgb3BlbmVyKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYXJnZXQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmltcG9ydCB7IFdlYldvcmtlciB9IGZyb20gJy4uL2FwaS9XZWJXb3JrZXIuanMnO1xuaW1wb3J0IHsgVW5zdXBwb3J0ZWRPcGVyYXRpb24gfSBmcm9tICcuLi9jb21tb24vRXJyb3JzLmpzJztcbmltcG9ydCB7IEJpZGlXb3JrZXJSZWFsbSB9IGZyb20gJy4vUmVhbG0uanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZGlXZWJXb3JrZXIgZXh0ZW5kcyBXZWJXb3JrZXIge1xuICAgIHN0YXRpYyBmcm9tKGZyYW1lLCByZWFsbSkge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBuZXcgQmlkaVdlYldvcmtlcihmcmFtZSwgcmVhbG0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH1cbiAgICAjZnJhbWU7XG4gICAgI3JlYWxtO1xuICAgIGNvbnN0cnVjdG9yKGZyYW1lLCByZWFsbSkge1xuICAgICAgICBzdXBlcihyZWFsbS5vcmlnaW4pO1xuICAgICAgICB0aGlzLiNmcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLiNyZWFsbSA9IEJpZGlXb3JrZXJSZWFsbS5mcm9tKHJlYWxtLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZnJhbWU7XG4gICAgfVxuICAgIG1haW5SZWFsbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxtO1xuICAgIH1cbiAgICBnZXQgY2xpZW50KCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb24oKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJXb3JrZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vQmlkaU92ZXJDZHAuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Ccm93c2VyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vQnJvd3NlckNvbnRleHQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db25uZWN0aW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vRWxlbWVudEhhbmRsZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0ZyYW1lLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vSFRUUFJlcXVlc3QuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9IVFRQUmVzcG9uc2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9JbnB1dC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL0pTSGFuZGxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vUGFnZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL1JlYWxtLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZGkuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbnZhciBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSA9ICh0aGlzICYmIHRoaXMuX19hZGREaXNwb3NhYmxlUmVzb3VyY2UpIHx8IGZ1bmN0aW9uIChlbnYsIHZhbHVlLCBhc3luYykge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB2YXIgZGlzcG9zZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19kaXNwb3NlUmVzb3VyY2VzID0gKHRoaXMgJiYgdGhpcy5fX2Rpc3Bvc2VSZXNvdXJjZXMpIHx8IChmdW5jdGlvbiAoU3VwcHJlc3NlZEVycm9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnYpIHtcbiAgICAgICAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgICAgICAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICAgICAgICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH07XG59KSh0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufSk7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGluZXJ0SWZEaXNwb3NlZCwgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgeyBTaGFyZWRXb3JrZXJSZWFsbSB9IGZyb20gJy4vUmVhbG0uanMnO1xuaW1wb3J0IHsgVXNlckNvbnRleHQgfSBmcm9tICcuL1VzZXJDb250ZXh0LmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmxldCBCcm93c2VyID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jbG9zZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfYWRkUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzO1xuICAgIGxldCBfcmVtb3ZlSW50ZXJjZXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9jcmVhdGVVc2VyQ29udGV4dF9kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBCcm93c2VyIGV4dGVuZHMgX2NsYXNzU3VwZXIge1xuICAgICAgICBzdGF0aWMge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUoX2NsYXNzU3VwZXJbU3ltYm9sLm1ldGFkYXRhXSA/PyBudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZGlzcG9zZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZGlzcG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiZGlzcG9zZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmRpc3Bvc2UgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Nsb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjbG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY2xvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jbG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWRkUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYWRkUHJlbG9hZFNjcmlwdFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiYWRkUHJlbG9hZFNjcmlwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFkZFByZWxvYWRTY3JpcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbW92ZUludGVyY2VwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicmVtb3ZlSW50ZXJjZXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJyZW1vdmVJbnRlcmNlcHRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZW1vdmVJbnRlcmNlcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbW92ZVByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbW92ZVByZWxvYWRTY3JpcHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInJlbW92ZVByZWxvYWRTY3JpcHRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZW1vdmVQcmVsb2FkU2NyaXB0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jcmVhdGVVc2VyQ29udGV4dF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY3JlYXRlVXNlckNvbnRleHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNyZWF0ZVVzZXJDb250ZXh0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY3JlYXRlVXNlckNvbnRleHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzeW5jIGZyb20oc2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NlciA9IG5ldyBCcm93c2VyKHNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgYnJvd3Nlci4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgI2Nsb3NlZCA9IChfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyksIGZhbHNlKTtcbiAgICAgICAgI3JlYXNvbjtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjdXNlckNvbnRleHRzID0gbmV3IE1hcCgpO1xuICAgICAgICBzZXNzaW9uO1xuICAgICAgICAjc2hhcmVkV29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3RydWN0b3Ioc2Vzc2lvbikge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub25jZSgnZW5kZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignc2NyaXB0LnJlYWxtQ3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdzaGFyZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3NoYXJlZFdvcmtlcnMuc2V0KGluZm8ucmVhbG0sIFNoYXJlZFdvcmtlclJlYWxtLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc3luY1VzZXJDb250ZXh0cygpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc3luY0Jyb3dzaW5nQ29udGV4dHMoKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyAjc3luY1VzZXJDb250ZXh0cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IHVzZXJDb250ZXh0cyB9LCB9ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ2Jyb3dzZXIuZ2V0VXNlckNvbnRleHRzJywge30pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIHVzZXJDb250ZXh0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuI2NyZWF0ZVVzZXJDb250ZXh0KGNvbnRleHQudXNlckNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jICNzeW5jQnJvd3NpbmdDb250ZXh0cygpIHtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgY29udGV4dHMgYXJlIGNyZWF0ZWQgb3IgZGVzdHJveWVkIGR1cmluZyBgZ2V0VHJlZWAsIHdlIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyBzZXQgdG8gZGV0ZWN0IHRoZW0uXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0SWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGV0IGNvbnRleHRzO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudl8xID0geyBzdGFjazogW10sIGVycm9yOiB2b2lkIDAsIGhhc0Vycm9yOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52XzEsIG5ldyBFdmVudEVtaXR0ZXIodGhpcy5zZXNzaW9uKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmNvbnRleHRDcmVhdGVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0SWRzLmFkZChpbmZvLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuZ2V0VHJlZScsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dHMgPSByZXN1bHQuY29udGV4dHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW52XzEuZXJyb3IgPSBlXzE7XG4gICAgICAgICAgICAgICAgICAgIGVudl8xLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIF9fZGlzcG9zZVJlc291cmNlcyhlbnZfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2ltdWxhdGluZyBldmVudHMgc28gY29udGV4dHMgYXJlIGNyZWF0ZWQgbmF0dXJhbGx5LlxuICAgICAgICAgICAgZm9yIChjb25zdCBpbmZvIG9mIGNvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0SWRzLmhhcyhpbmZvLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5lbWl0KCdicm93c2luZ0NvbnRleHQuY29udGV4dENyZWF0ZWQnLCBpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dHMucHVzaCguLi5pbmZvLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI2NyZWF0ZVVzZXJDb250ZXh0KGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29udGV4dCA9IFVzZXJDb250ZXh0LmNyZWF0ZSh0aGlzLCBpZCk7XG4gICAgICAgICAgICB0aGlzLiN1c2VyQ29udGV4dHMuc2V0KHVzZXJDb250ZXh0LmlkLCB1c2VyQ29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih1c2VyQ29udGV4dCkpO1xuICAgICAgICAgICAgdXNlckNvbnRleHRFbWl0dGVyLm9uY2UoJ2Nsb3NlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB1c2VyQ29udGV4dEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jdXNlckNvbnRleHRzLmRlbGV0ZSh1c2VyQ29udGV4dC5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Nsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVmYXVsdFVzZXJDb250ZXh0KCkge1xuICAgICAgICAgICAgLy8gU0FGRVRZOiBBIFVzZXJDb250ZXh0IGlzIGFsd2F5cyBjcmVhdGVkIGZvciB0aGUgZGVmYXVsdCBjb250ZXh0LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3VzZXJDb250ZXh0cy5nZXQoVXNlckNvbnRleHQuREVGQVVMVCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFzb24gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHVzZXJDb250ZXh0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN1c2VyQ29udGV4dHMudmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24sIGNsb3NlZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLiNjbG9zZWQgPSBjbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdicm93c2VyLmNsb3NlJywge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCdCcm93c2VyIGFscmVhZHkgY2xvc2VkLicsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyBzY3JpcHQgfSwgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuYWRkUHJlbG9hZFNjcmlwdCcsIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IG9wdGlvbnMuY29udGV4dHM/Lm1hcChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuaWQ7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVtb3ZlSW50ZXJjZXB0KGludGVyY2VwdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ25ldHdvcmsucmVtb3ZlSW50ZXJjZXB0Jywge1xuICAgICAgICAgICAgICAgIGludGVyY2VwdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbW92ZVByZWxvYWRTY3JpcHQoc2NyaXB0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlc3Npb24uc2VuZCgnc2NyaXB0LnJlbW92ZVByZWxvYWRTY3JpcHQnLCB7XG4gICAgICAgICAgICAgICAgc2NyaXB0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlckNvbnRleHQoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyB1c2VyQ29udGV4dDogY29udGV4dCB9LCB9ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnNlbmQoJ2Jyb3dzZXIuY3JlYXRlVXNlckNvbnRleHQnLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jY3JlYXRlVXNlckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9jbG9zZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChicm93c2VyID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IEJ5IGRlZmluaXRpb24gb2YgYGRpc3Bvc2VkYCwgYCNyZWFzb25gIGlzIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXIuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2FkZFByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVJbnRlcmNlcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGJyb3dzZXIgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlci4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY3JlYXRlVXNlckNvbnRleHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoYnJvd3NlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIGRpc3Bvc2VTeW1ib2wpXSgpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA/Pz1cbiAgICAgICAgICAgICAgICAnQnJvd3NlciB3YXMgZGlzY29ubmVjdGVkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBzZXNzaW9uIGVuZGVkLic7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBCcm93c2VyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI0IEdvb2dsZSBJbmMuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgX19ydW5Jbml0aWFsaXplcnMgPSAodGhpcyAmJiB0aGlzLl9fcnVuSW5pdGlhbGl6ZXJzKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xudmFyIF9fZXNEZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19lc0RlY29yYXRlKSB8fCBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICAgIHZhciBfLCBkb25lID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgICBkb25lID0gdHJ1ZTtcbn07XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9jb21tb24vRXZlbnRFbWl0dGVyLmpzJztcbmltcG9ydCB7IGluZXJ0SWZEaXNwb3NlZCwgdGhyb3dJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uIH0gZnJvbSAnLi9OYXZpZ2F0aW9uLmpzJztcbmltcG9ydCB7IFdpbmRvd1JlYWxtIH0gZnJvbSAnLi9SZWFsbS5qcyc7XG5pbXBvcnQgeyBSZXF1ZXN0IH0gZnJvbSAnLi9SZXF1ZXN0LmpzJztcbmltcG9ydCB7IFVzZXJQcm9tcHQgfSBmcm9tICcuL1VzZXJQcm9tcHQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IEJyb3dzaW5nQ29udGV4dCA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICBsZXQgX2FjdGl2YXRlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jYXB0dXJlU2NyZWVuc2hvdF9kZWNvcmF0b3JzO1xuICAgIGxldCBfY2xvc2VfZGVjb3JhdG9ycztcbiAgICBsZXQgX3RyYXZlcnNlSGlzdG9yeV9kZWNvcmF0b3JzO1xuICAgIGxldCBfbmF2aWdhdGVfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbG9hZF9kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0Q2FjaGVCZWhhdmlvcl9kZWNvcmF0b3JzO1xuICAgIGxldCBfcHJpbnRfZGVjb3JhdG9ycztcbiAgICBsZXQgX2hhbmRsZVVzZXJQcm9tcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3NldFZpZXdwb3J0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9wZXJmb3JtQWN0aW9uc19kZWNvcmF0b3JzO1xuICAgIGxldCBfcmVsZWFzZUFjdGlvbnNfZGVjb3JhdG9ycztcbiAgICBsZXQgX2NyZWF0ZVdpbmRvd1JlYWxtX2RlY29yYXRvcnM7XG4gICAgbGV0IF9hZGRQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnM7XG4gICAgbGV0IF9hZGRJbnRlcmNlcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbW92ZVByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX2dldENvb2tpZXNfZGVjb3JhdG9ycztcbiAgICBsZXQgX3NldENvb2tpZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0RmlsZXNfZGVjb3JhdG9ycztcbiAgICBsZXQgX3N1YnNjcmliZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfYWRkSW50ZXJjZXB0aW9uX2RlY29yYXRvcnM7XG4gICAgbGV0IF9kZWxldGVDb29raWVfZGVjb3JhdG9ycztcbiAgICBsZXQgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnM7XG4gICAgcmV0dXJuIGNsYXNzIEJyb3dzaW5nQ29udGV4dCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfZGVsZXRlQ29va2llX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9kaXNwb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNwb3NlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkaXNwb3NlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZGlzcG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWN0aXZhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImFjdGl2YXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhY3RpdmF0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFjdGl2YXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jYXB0dXJlU2NyZWVuc2hvdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiY2FwdHVyZVNjcmVlbnNob3RcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNhcHR1cmVTY3JlZW5zaG90XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY2FwdHVyZVNjcmVlbnNob3QgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Nsb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjbG9zZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY2xvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5jbG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfdHJhdmVyc2VIaXN0b3J5X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJ0cmF2ZXJzZUhpc3RvcnlcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInRyYXZlcnNlSGlzdG9yeVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnRyYXZlcnNlSGlzdG9yeSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfbmF2aWdhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcIm5hdmlnYXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJuYXZpZ2F0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLm5hdmlnYXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZWxvYWRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbG9hZFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVsb2FkXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVsb2FkIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRDYWNoZUJlaGF2aW9yX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZXRDYWNoZUJlaGF2aW9yXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRDYWNoZUJlaGF2aW9yXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0Q2FjaGVCZWhhdmlvciB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfcHJpbnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInByaW50XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJwcmludFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnByaW50IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9oYW5kbGVVc2VyUHJvbXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJoYW5kbGVVc2VyUHJvbXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJoYW5kbGVVc2VyUHJvbXB0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouaGFuZGxlVXNlclByb21wdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0Vmlld3BvcnRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldFZpZXdwb3J0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRWaWV3cG9ydFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldFZpZXdwb3J0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9wZXJmb3JtQWN0aW9uc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicGVyZm9ybUFjdGlvbnNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInBlcmZvcm1BY3Rpb25zXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucGVyZm9ybUFjdGlvbnMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3JlbGVhc2VBY3Rpb25zX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJyZWxlYXNlQWN0aW9uc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVsZWFzZUFjdGlvbnNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5yZWxlYXNlQWN0aW9ucyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfY3JlYXRlV2luZG93UmVhbG1fZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImNyZWF0ZVdpbmRvd1JlYWxtXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJjcmVhdGVXaW5kb3dSZWFsbVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmNyZWF0ZVdpbmRvd1JlYWxtIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9hZGRQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJhZGRQcmVsb2FkU2NyaXB0XCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhZGRQcmVsb2FkU2NyaXB0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouYWRkUHJlbG9hZFNjcmlwdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWRkSW50ZXJjZXB0X2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJhZGRJbnRlcmNlcHRcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImFkZEludGVyY2VwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFkZEludGVyY2VwdCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfcmVtb3ZlUHJlbG9hZFNjcmlwdF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwicmVtb3ZlUHJlbG9hZFNjcmlwdFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVtb3ZlUHJlbG9hZFNjcmlwdFwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnJlbW92ZVByZWxvYWRTY3JpcHQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2dldENvb2tpZXNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImdldENvb2tpZXNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImdldENvb2tpZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5nZXRDb29raWVzIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRDb29raWVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldENvb2tpZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwic2V0Q29va2llXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0Q29va2llIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZXRGaWxlc19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic2V0RmlsZXNcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldEZpbGVzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2V0RmlsZXMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX3N1YnNjcmliZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwic3Vic2NyaWJlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzdWJzY3JpYmVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5zdWJzY3JpYmUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2FkZEludGVyY2VwdGlvbl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYWRkSW50ZXJjZXB0aW9uXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJhZGRJbnRlcmNlcHRpb25cIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5hZGRJbnRlcmNlcHRpb24gfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2RlbGV0ZUNvb2tpZV9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZGVsZXRlQ29va2llXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkZWxldGVDb29raWVcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kZWxldGVDb29raWUgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2xvY2F0ZU5vZGVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJsb2NhdGVOb2Rlc1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwibG9jYXRlTm9kZXNcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5sb2NhdGVOb2RlcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbSh1c2VyQ29udGV4dCwgcGFyZW50LCBpZCwgdXJsLCBvcmlnaW5hbE9wZW5lcikge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0ID0gbmV3IEJyb3dzaW5nQ29udGV4dCh1c2VyQ29udGV4dCwgcGFyZW50LCBpZCwgdXJsLCBvcmlnaW5hbE9wZW5lcik7XG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBicm93c2luZ0NvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgI25hdmlnYXRpb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNyZWFzb247XG4gICAgICAgICN1cmw7XG4gICAgICAgICNjaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjcmVhbG1zID0gbmV3IE1hcCgpO1xuICAgICAgICAjcmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGRlZmF1bHRSZWFsbTtcbiAgICAgICAgaWQ7XG4gICAgICAgIHBhcmVudDtcbiAgICAgICAgdXNlckNvbnRleHQ7XG4gICAgICAgIG9yaWdpbmFsT3BlbmVyO1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwYXJlbnQsIGlkLCB1cmwsIG9yaWdpbmFsT3BlbmVyKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxPcGVuZXIgPSBvcmlnaW5hbE9wZW5lcjtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFJlYWxtID0gdGhpcy4jY3JlYXRlV2luZG93UmVhbG0oKTtcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMudXNlckNvbnRleHQpKTtcbiAgICAgICAgICAgIHVzZXJDb250ZXh0RW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShgQnJvd3NpbmcgY29udGV4dCBhbHJlYWR5IGNsb3NlZDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy4jc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC5jb250ZXh0Q3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBhcmVudCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dCA9IEJyb3dzaW5nQ29udGV4dC5mcm9tKHRoaXMudXNlckNvbnRleHQsIHRoaXMsIGluZm8uY29udGV4dCwgaW5mby51cmwsIGluZm8ub3JpZ2luYWxPcGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2NoaWxkcmVuLnNldChpbmZvLmNvbnRleHQsIGJyb3dzaW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKGJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIub25jZSgnY2xvc2VkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNjaGlsZHJlbi5kZWxldGUoYnJvd3NpbmdDb250ZXh0LmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jyb3dzaW5nY29udGV4dCcsIHsgYnJvd3NpbmdDb250ZXh0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmNvbnRleHREZXN0cm95ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCdCcm93c2luZyBjb250ZXh0IGFscmVhZHkgY2xvc2VkLicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignYnJvd3NpbmdDb250ZXh0LmRvbUNvbnRlbnRMb2FkZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jdXJsID0gaW5mby51cmw7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdET01Db250ZW50TG9hZGVkJywgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC5sb2FkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3VybCA9IGluZm8udXJsO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZCcsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdicm93c2luZ0NvbnRleHQubmF2aWdhdGlvblN0YXJ0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkIG5vdCB1cGRhdGUgdGhpcy4jdXJsIGF0IHRoaXMgcG9pbnQgc2luY2UgdGhlIGNvbnRleHRcbiAgICAgICAgICAgICAgICAvLyBoYXMgbm90IGZpbmlzaGVkIG5hdmlnYXRpbmcgdG8gdGhlIGluZm8udXJsIHlldC5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgcmVxdWVzdF0gb2YgdGhpcy4jcmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5hdmlnYXRpb24gaGFzbid0IGZpbmlzaGVkLCB0aGVuIHRoaXMgaXMgbmVzdGVkIG5hdmlnYXRpb24uIFRoZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgbmF2aWdhdGlvbiB3aWxsIGhhbmRsZSB0aGlzLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNuYXZpZ2F0aW9uICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuI25hdmlnYXRpb24uZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoZSBuYXZpZ2F0aW9uIElEIGlzIG51bGwgZm9yIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiA9IE5hdmlnYXRpb24uZnJvbSh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI25hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBbJ2ZyYWdtZW50JywgJ2ZhaWxlZCcsICdhYm9ydGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbkVtaXR0ZXIub25jZShldmVudE5hbWUsICh7IHVybCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRW1pdHRlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCduYXZpZ2F0aW9uJywgeyBuYXZpZ2F0aW9uOiB0aGlzLiNuYXZpZ2F0aW9uIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5iZWZvcmVSZXF1ZXN0U2VudCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNyZXF1ZXN0cy5oYXMoZXZlbnQucmVxdWVzdC5yZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZWFucyB0aGUgcmVxdWVzdCBpcyBhIHJlZGlyZWN0LiBUaGlzIGlzIGhhbmRsZWQgaW4gUmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3IgYW4gQXV0aCBldmVudCB3YXMgaXNzdWVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IFJlcXVlc3QuZnJvbSh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdHMuc2V0KHJlcXVlc3QuaWQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHsgcmVxdWVzdCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2xvZy5lbnRyeUFkZGVkJywgZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5zb3VyY2UuY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9nJywgeyBlbnRyeSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC51c2VyUHJvbXB0T3BlbmVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uY29udGV4dCAhPT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9tcHQgPSBVc2VyUHJvbXB0LmZyb20odGhpcywgaW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd1c2VycHJvbXB0JywgeyB1c2VyUHJvbXB0IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNzZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNjaGlsZHJlbi52YWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYXNvbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVhbG1zKCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzIC0tIFJlcXVpcmVkXG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBzZWxmLmRlZmF1bHRSZWFsbTtcbiAgICAgICAgICAgICAgICB5aWVsZCogc2VsZi4jcmVhbG1zLnZhbHVlcygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgdG9wKCkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBwYXJlbnQgfSA9IGNvbnRleHQ7IHBhcmVudDsgeyBwYXJlbnQgfSA9IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHVybCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiN1cmw7XG4gICAgICAgIH1cbiAgICAgICAgI2NyZWF0ZVdpbmRvd1JlYWxtKHNhbmRib3gpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gV2luZG93UmVhbG0uZnJvbSh0aGlzLCBzYW5kYm94KTtcbiAgICAgICAgICAgIHJlYWxtLm9uKCd3b3JrZXInLCByZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd3b3JrZXInLCB7IHJlYWxtIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmFjdGl2YXRlJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBjYXB0dXJlU2NyZWVuc2hvdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGRhdGEgfSwgfSA9IGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmNhcHR1cmVTY3JlZW5zaG90Jywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY2xvc2UocHJvbXB0VW5sb2FkKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbLi4udGhpcy4jY2hpbGRyZW4udmFsdWVzKCldLm1hcChhc3luYyAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGlsZC5jbG9zZShwcm9tcHRVbmxvYWQpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuY2xvc2UnLCB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBwcm9tcHRVbmxvYWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyB0cmF2ZXJzZUhpc3RvcnkoZGVsdGEpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LnRyYXZlcnNlSGlzdG9yeScsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgbmF2aWdhdGUodXJsLCB3YWl0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0ZScsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB3YWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgcmVsb2FkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQucmVsb2FkJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENhY2hlQmVoYXZpb3IoY2FjaGVCZWhhdmlvcikge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBub3QgaW4gQmlEaSB0eXBlcyB5ZXQuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ25ldHdvcmsuc2V0Q2FjaGVCZWhhdmlvcicsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0czogW3RoaXMuaWRdLFxuICAgICAgICAgICAgICAgIGNhY2hlQmVoYXZpb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwcmludChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGRhdGEgfSwgfSA9IGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LnByaW50Jywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgaGFuZGxlVXNlclByb21wdChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmhhbmRsZVVzZXJQcm9tcHQnLCB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0Vmlld3BvcnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5zZXRWaWV3cG9ydCcsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBwZXJmb3JtQWN0aW9ucyhhY3Rpb25zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2lucHV0LnBlcmZvcm1BY3Rpb25zJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbGVhc2VBY3Rpb25zKCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdpbnB1dC5yZWxlYXNlQWN0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlV2luZG93UmVhbG0oc2FuZGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2NyZWF0ZVdpbmRvd1JlYWxtKHNhbmRib3gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyQ29udGV4dC5icm93c2VyLmFkZFByZWxvYWRTY3JpcHQoZnVuY3Rpb25EZWNsYXJhdGlvbiwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IFt0aGlzXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGFkZEludGVyY2VwdChvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyBpbnRlcmNlcHQgfSwgfSA9IGF3YWl0IHRoaXMudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uLnNlbmQoJ25ldHdvcmsuYWRkSW50ZXJjZXB0Jywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY29udGV4dHM6IFt0aGlzLmlkXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyByZW1vdmVQcmVsb2FkU2NyaXB0KHNjcmlwdCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyQ29udGV4dC5icm93c2VyLnJlbW92ZVByZWxvYWRTY3JpcHQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXRDb29raWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQ6IHsgY29va2llcyB9LCB9ID0gYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdzdG9yYWdlLmdldENvb2tpZXMnLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBwYXJ0aXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVzO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENvb2tpZShjb29raWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnc3RvcmFnZS5zZXRDb29raWUnLCB7XG4gICAgICAgICAgICAgICAgY29va2llLFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY29udGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldEZpbGVzKGVsZW1lbnQsIGZpbGVzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2lucHV0LnNldEZpbGVzJywge1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBmaWxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHN1YnNjcmliZShldmVudHMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc3Vic2NyaWJlKGV2ZW50cywgW3RoaXMuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBhZGRJbnRlcmNlcHRpb24oZXZlbnRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnN1YnNjcmliZShldmVudHMsIFt0aGlzLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9hY3RpdmF0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2NhcHR1cmVTY3JlZW5zaG90X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY2xvc2VfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF90cmF2ZXJzZUhpc3RvcnlfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9uYXZpZ2F0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3JlbG9hZF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldENhY2hlQmVoYXZpb3JfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9wcmludF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2hhbmRsZVVzZXJQcm9tcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9zZXRWaWV3cG9ydF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3BlcmZvcm1BY3Rpb25zX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfcmVsZWFzZUFjdGlvbnNfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9jcmVhdGVXaW5kb3dSZWFsbV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX2FkZFByZWxvYWRTY3JpcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9hZGRJbnRlcmNlcHRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoY29udGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9yZW1vdmVQcmVsb2FkU2NyaXB0X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfZ2V0Q29va2llc19kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldENvb2tpZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldEZpbGVzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfc3Vic2NyaWJlX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfYWRkSW50ZXJjZXB0aW9uX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ0Jyb3dzaW5nIGNvbnRleHQgYWxyZWFkeSBjbG9zZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIHVzZXIgY29udGV4dCBjbG9zZWQuJztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJywgeyByZWFzb246IHRoaXMuI3JlYXNvbiB9KTtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHN1cGVyW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGVsZXRlQ29va2llKC4uLmNvb2tpZUZpbHRlcnMpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNvb2tpZUZpbHRlcnMubWFwKGFzeW5jIChmaWx0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ3N0b3JhZ2UuZGVsZXRlQ29va2llcycsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBsb2NhdGVOb2Rlcyhsb2NhdG9yLCBzdGFydE5vZGVzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBhZGQgb3RoZXIgbG9jYXRlTm9kZXMgb3B0aW9ucyBpZiBuZWVkZWQuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ2Jyb3dzaW5nQ29udGV4dC5sb2NhdGVOb2RlcycsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIGxvY2F0b3IsXG4gICAgICAgICAgICAgICAgc3RhcnROb2Rlczogc3RhcnROb2Rlcy5sZW5ndGggPyBzdGFydE5vZGVzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdC5ub2RlcztcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgQnJvd3NpbmdDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2luZ0NvbnRleHQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgaW5lcnRJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgTmF2aWdhdGlvbiA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb24gPSBuZXcgTmF2aWdhdGlvbihjb250ZXh0KTtcbiAgICAgICAgICAgIG5hdmlnYXRpb24uI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgICNyZXF1ZXN0ID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAjbmF2aWdhdGlvbjtcbiAgICAgICAgI2Jyb3dzaW5nQ29udGV4dDtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjaWQ7XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLiNicm93c2luZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0RW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI2Jyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgYnJvd3NpbmdDb250ZXh0RW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmYWlsZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy4jYnJvd3NpbmdDb250ZXh0LnVybCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLm9uKCdyZXF1ZXN0JywgKHsgcmVxdWVzdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubmF2aWdhdGlvbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcmVxdWVzdCB3aXRoIGEgbmF2aWdhdGlvbiBJRCBjb21lcyBpbiwgdGhlbiB0aGUgbmF2aWdhdGlvbiBJRCBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhpcyBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy4jbWF0Y2hlcyhyZXF1ZXN0Lm5hdmlnYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNyZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEVtaXR0ZXIub24oJ3JlZGlyZWN0JywgcmVxdWVzdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI3Nlc3Npb24pKTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdicm93c2luZ0NvbnRleHQubmF2aWdhdGlvblN0YXJ0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jbmF2aWdhdGlvbiA9IE5hdmlnYXRpb24uZnJvbSh0aGlzLiNicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBvZiBbXG4gICAgICAgICAgICAgICAgJ2Jyb3dzaW5nQ29udGV4dC5kb21Db250ZW50TG9hZGVkJyxcbiAgICAgICAgICAgICAgICAnYnJvd3NpbmdDb250ZXh0LmxvYWQnLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKGV2ZW50TmFtZSwgaW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNvbnRleHQgIT09IHRoaXMuI2Jyb3dzaW5nQ29udGV4dC5pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5uYXZpZ2F0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy4jbWF0Y2hlcyhpbmZvLm5hdmlnYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtldmVudE5hbWUsIGV2ZW50XSBvZiBbXG4gICAgICAgICAgICAgICAgWydicm93c2luZ0NvbnRleHQuZnJhZ21lbnROYXZpZ2F0ZWQnLCAnZnJhZ21lbnQnXSxcbiAgICAgICAgICAgICAgICBbJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uRmFpbGVkJywgJ2ZhaWxlZCddLFxuICAgICAgICAgICAgICAgIFsnYnJvd3NpbmdDb250ZXh0Lm5hdmlnYXRpb25BYm9ydGVkJywgJ2Fib3J0ZWQnXSxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbihldmVudE5hbWUsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgd2UgZG9uJ3QgY2hlY2sgaWYgYG5hdmlnYXRpb25gIGlzIG51bGwgc2luY2UgYG51bGxgIG1lYW5zIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgbmF2aWdhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuI21hdGNoZXMoaW5mby5uYXZpZ2F0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBpbmZvLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoaW5mby50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI21hdGNoZXMobmF2aWdhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuI25hdmlnYXRpb24gIT09IHVuZGVmaW5lZCAmJiAhdGhpcy4jbmF2aWdhdGlvbi5kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaWQgPSBuYXZpZ2F0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2lkID09PSBuYXZpZ2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCAjc2Vzc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGdldCBuYXZpZ2F0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI25hdmlnYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgZGlzcG9zZVN5bWJvbCldKCkge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgTmF2aWdhdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmF2aWdhdGlvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xudmFyIF9hO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2ssIGRpc3Bvc2VTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFJlYWxtID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9kaXNvd25fZGVjb3JhdG9ycztcbiAgICBsZXQgX2NhbGxGdW5jdGlvbl9kZWNvcmF0b3JzO1xuICAgIGxldCBfZXZhbHVhdGVfZGVjb3JhdG9ycztcbiAgICBsZXQgX3Jlc29sdmVFeGVjdXRpb25Db250ZXh0SWRfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgUmVhbG0gZXh0ZW5kcyBfY2xhc3NTdXBlciB7XG4gICAgICAgIHN0YXRpYyB7XG4gICAgICAgICAgICBjb25zdCBfbWV0YWRhdGEgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLm1ldGFkYXRhID8gT2JqZWN0LmNyZWF0ZShfY2xhc3NTdXBlcltTeW1ib2wubWV0YWRhdGFdID8/IG51bGwpIDogdm9pZCAwO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9kaXNwb3NlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNwb3NlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJkaXNwb3NlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZGlzcG9zZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZGlzb3duX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJkaXNvd25cIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc293blwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmRpc293biB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfY2FsbEZ1bmN0aW9uX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJjYWxsRnVuY3Rpb25cIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImNhbGxGdW5jdGlvblwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmNhbGxGdW5jdGlvbiB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfZXZhbHVhdGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImV2YWx1YXRlXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJldmFsdWF0ZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmV2YWx1YXRlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJyZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJyZXNvbHZlRXhlY3V0aW9uQ29udGV4dElkXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVzb2x2ZUV4ZWN1dGlvbkNvbnRleHRJZCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIGlmIChfbWV0YWRhdGEpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTeW1ib2wubWV0YWRhdGEsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IF9tZXRhZGF0YSB9KTtcbiAgICAgICAgfVxuICAgICAgICAjcmVhc29uID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICBkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgaWQ7XG4gICAgICAgIG9yaWdpbjtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dElkO1xuICAgICAgICBjb25zdHJ1Y3RvcihpZCwgb3JpZ2luKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYXNvbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCB0YXJnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWFsbTogdGhpcy5pZCB9O1xuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZGlzb3duKGhhbmRsZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuZGlzb3duJywge1xuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNhbGxGdW5jdGlvbihmdW5jdGlvbkRlY2xhcmF0aW9uLCBhd2FpdFByb21pc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuY2FsbEZ1bmN0aW9uJywge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgICAgICAgICAgYXdhaXRQcm9taXNlLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBldmFsdWF0ZShleHByZXNzaW9uLCBhd2FpdFByb21pc2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5zZW5kKCdzY3JpcHQuZXZhbHVhdGUnLCB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBhd2FpdFByb21pc2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlc29sdmVFeGVjdXRpb25Db250ZXh0SWQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXhlY3V0aW9uQ29udGV4dElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5jb25uZWN0aW9uLnNlbmQoJ2NkcC5yZXNvbHZlUmVhbG0nLCB7IHJlYWxtOiB0aGlzLmlkIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uQ29udGV4dElkID0gcmVzdWx0LmV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGlvbkNvbnRleHRJZDtcbiAgICAgICAgfVxuICAgICAgICBbKF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgX2Rpc293bl9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfY2FsbEZ1bmN0aW9uX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHJlYWxtID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWxtLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9ldmFsdWF0ZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfcmVzb2x2ZUV4ZWN1dGlvbkNvbnRleHRJZF9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChyZWFsbSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBEaXNwb3NhbCBpbXBsaWVzIHRoaXMgZXhpc3RzLlxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsbS4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLCBwcm9iYWJseSBiZWNhdXNlIGFsbCBhc3NvY2lhdGVkIGJyb3dzaW5nIGNvbnRleHRzIGNsb3NlZC4nO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95ZWQnLCB7IHJlYXNvbjogdGhpcy4jcmVhc29uIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBSZWFsbSB9O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFdpbmRvd1JlYWxtIGV4dGVuZHMgUmVhbG0ge1xuICAgIHN0YXRpYyBmcm9tKGNvbnRleHQsIHNhbmRib3gpIHtcbiAgICAgICAgY29uc3QgcmVhbG0gPSBuZXcgV2luZG93UmVhbG0oY29udGV4dCwgc2FuZGJveCk7XG4gICAgICAgIHJlYWxtLiNpbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiByZWFsbTtcbiAgICB9XG4gICAgYnJvd3NpbmdDb250ZXh0O1xuICAgIHNhbmRib3g7XG4gICAgI3dvcmtlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgc2FuZGJveCkge1xuICAgICAgICBzdXBlcignJywgJycpO1xuICAgICAgICB0aGlzLmJyb3dzaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuc2FuZGJveCA9IHNhbmRib3g7XG4gICAgfVxuICAgICNpbml0aWFsaXplKCkge1xuICAgICAgICBjb25zdCBicm93c2luZ0NvbnRleHRFbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLmJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLm9uKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy5zZXNzaW9uKSk7XG4gICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCdzY3JpcHQucmVhbG1DcmVhdGVkJywgaW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAoaW5mby50eXBlICE9PSAnd2luZG93JyB8fFxuICAgICAgICAgICAgICAgIGluZm8uY29udGV4dCAhPT0gdGhpcy5icm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICBpbmZvLnNhbmRib3ggIT09IHRoaXMuc2FuZGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaWQgPSBpbmZvLnJlYWxtO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBpbmZvLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uQ29udGV4dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignc2NyaXB0LnJlYWxtQ3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSAhPT0gJ2RlZGljYXRlZC13b3JrZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmZvLm93bmVycy5pbmNsdWRlcyh0aGlzLmlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gRGVkaWNhdGVkV29ya2VyUmVhbG0uZnJvbSh0aGlzLCBpbmZvLnJlYWxtLCBpbmZvLm9yaWdpbik7XG4gICAgICAgICAgICB0aGlzLiN3b3JrZXJzLnNldChyZWFsbS5pZCwgcmVhbG0pO1xuICAgICAgICAgICAgY29uc3QgcmVhbG1FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcihyZWFsbSkpO1xuICAgICAgICAgICAgcmVhbG1FbWl0dGVyLm9uY2UoJ2Rlc3Ryb3llZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZWFsbUVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2luZ0NvbnRleHQudXNlckNvbnRleHQuYnJvd3Nlci5zZXNzaW9uO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4geyBjb250ZXh0OiB0aGlzLmJyb3dzaW5nQ29udGV4dC5pZCwgc2FuZGJveDogdGhpcy5zYW5kYm94IH07XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIERlZGljYXRlZFdvcmtlclJlYWxtIGV4dGVuZHMgUmVhbG0ge1xuICAgIHN0YXRpYyBmcm9tKG93bmVyLCBpZCwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gbmV3IF9hKG93bmVyLCBpZCwgb3JpZ2luKTtcbiAgICAgICAgcmVhbG0uI2luaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIHJlYWxtO1xuICAgIH1cbiAgICAjd29ya2VycyA9IG5ldyBNYXAoKTtcbiAgICBvd25lcnM7XG4gICAgY29uc3RydWN0b3Iob3duZXIsIGlkLCBvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoaWQsIG9yaWdpbik7XG4gICAgICAgIHRoaXMub3duZXJzID0gbmV3IFNldChbb3duZXJdKTtcbiAgICB9XG4gICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLnNlc3Npb24pKTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbURlc3Ryb3llZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8ucmVhbG0gIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLicpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbUNyZWF0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdkZWRpY2F0ZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mby5vd25lcnMuaW5jbHVkZXModGhpcy5pZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IF9hLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pO1xuICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5zZXQocmVhbG0uaWQsIHJlYWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIocmVhbG0pKTtcbiAgICAgICAgICAgIHJlYWxtRW1pdHRlci5vbmNlKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICAvLyBTQUZFVFk6IEF0IGxlYXN0IG9uZSBvd25lciB3aWxsIGV4aXN0LlxuICAgICAgICByZXR1cm4gdGhpcy5vd25lcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlLnNlc3Npb247XG4gICAgfVxufVxuX2EgPSBEZWRpY2F0ZWRXb3JrZXJSZWFsbTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFyZWRXb3JrZXJSZWFsbSBleHRlbmRzIFJlYWxtIHtcbiAgICBzdGF0aWMgZnJvbShicm93c2VyLCBpZCwgb3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gbmV3IFNoYXJlZFdvcmtlclJlYWxtKGJyb3dzZXIsIGlkLCBvcmlnaW4pO1xuICAgICAgICByZWFsbS4jaW5pdGlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gcmVhbG07XG4gICAgfVxuICAgICN3b3JrZXJzID0gbmV3IE1hcCgpO1xuICAgIGJyb3dzZXI7XG4gICAgY29uc3RydWN0b3IoYnJvd3NlciwgaWQsIG9yaWdpbikge1xuICAgICAgICBzdXBlcihpZCwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5icm93c2VyID0gYnJvd3NlcjtcbiAgICB9XG4gICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy5kaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLnNlc3Npb24pKTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbURlc3Ryb3llZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgaWYgKGluZm8ucmVhbG0gIT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoJ1JlYWxtIGFscmVhZHkgZGVzdHJveWVkLicpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ3NjcmlwdC5yZWFsbUNyZWF0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLnR5cGUgIT09ICdkZWRpY2F0ZWQtd29ya2VyJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5mby5vd25lcnMuaW5jbHVkZXModGhpcy5pZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IERlZGljYXRlZFdvcmtlclJlYWxtLmZyb20odGhpcywgaW5mby5yZWFsbSwgaW5mby5vcmlnaW4pO1xuICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5zZXQocmVhbG0uaWQsIHJlYWxtKTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtRW1pdHRlciA9IHRoaXMuZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIocmVhbG0pKTtcbiAgICAgICAgICAgIHJlYWxtRW1pdHRlci5vbmNlKCdkZXN0cm95ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4jd29ya2Vycy5kZWxldGUocmVhbG0uaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3dvcmtlcicsIHJlYWxtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5icm93c2VyLnNlc3Npb247XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbG0uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgaW5lcnRJZkRpc3Bvc2VkIH0gZnJvbSAnLi4vLi4vdXRpbC9kZWNvcmF0b3JzLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGVTdGFjaywgZGlzcG9zZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvZGlzcG9zYWJsZS5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5sZXQgUmVxdWVzdCA9ICgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Rpc3Bvc2VfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgUmVxdWVzdCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGJyb3dzaW5nQ29udGV4dCwgZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChicm93c2luZ0NvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJlcXVlc3QuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgICNlcnJvciA9IF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXMsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgI3JlZGlyZWN0O1xuICAgICAgICAjcmVzcG9uc2U7XG4gICAgICAgICNicm93c2luZ0NvbnRleHQ7XG4gICAgICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgI2V2ZW50O1xuICAgICAgICBjb25zdHJ1Y3Rvcihicm93c2luZ0NvbnRleHQsIGV2ZW50KSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0ID0gYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICAgICAgdGhpcy4jZXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgICAjaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLiNicm93c2luZ0NvbnRleHQpKTtcbiAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIub25jZSgnY2xvc2VkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNlcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcy4jZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuI3Nlc3Npb24pKTtcbiAgICAgICAgICAgIHNlc3Npb25FbWl0dGVyLm9uKCduZXR3b3JrLmJlZm9yZVJlcXVlc3RTZW50JywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlZGlyZWN0Q291bnQgIT09IHRoaXMuI2V2ZW50LnJlZGlyZWN0Q291bnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVkaXJlY3QgPSBSZXF1ZXN0LmZyb20odGhpcy4jYnJvd3NpbmdDb250ZXh0LCBldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWRpcmVjdCcsIHRoaXMuI3JlZGlyZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ25ldHdvcmsuYXV0aFJlcXVpcmVkJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHRyeSB0byBhdXRoZW50aWNhdGUgZm9yIGV2ZW50cyB0aGF0IGFyZSBub3QgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAhZXZlbnQuaXNCbG9ja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdXRoZW50aWNhdGUnLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5mZXRjaEVycm9yJywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jb250ZXh0ICE9PSB0aGlzLiNicm93c2luZ0NvbnRleHQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucmVxdWVzdC5yZXF1ZXN0ICE9PSB0aGlzLmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2ZW50LnJlZGlyZWN0Q291bnQgIT09IGV2ZW50LnJlZGlyZWN0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNlcnJvciA9IGV2ZW50LmVycm9yVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcy4jZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uRW1pdHRlci5vbignbmV0d29yay5yZXNwb25zZUNvbXBsZXRlZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29udGV4dCAhPT0gdGhpcy4jYnJvd3NpbmdDb250ZXh0LmlkIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlcXVlc3QucmVxdWVzdCAhPT0gdGhpcy5pZCB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNldmVudC5yZWRpcmVjdENvdW50ICE9PSBldmVudC5yZWRpcmVjdENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVzcG9uc2UgPSBldmVudC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnLCB0aGlzLiNyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVkaXJlY3QuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3Jlc3BvbnNlLnN0YXR1cyA+PSAzMDAgJiYgdGhpcy4jcmVzcG9uc2Uuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgI3Nlc3Npb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jYnJvd3NpbmdDb250ZXh0LnVzZXJDb250ZXh0LmJyb3dzZXIuc2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2V2ZW50LnJlcXVlc3QuaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQucmVxdWVzdC5yZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGdldCBpbml0aWF0b3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQuaW5pdGlhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQucmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IG5hdmlnYXRpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQubmF2aWdhdGlvbiA/PyB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHJlZGlyZWN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlZGlyZWN0O1xuICAgICAgICB9XG4gICAgICAgIGdldCBsYXN0UmVkaXJlY3QoKSB7XG4gICAgICAgICAgICBsZXQgcmVkaXJlY3QgPSB0aGlzLiNyZWRpcmVjdDtcbiAgICAgICAgICAgIHdoaWxlIChyZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWRpcmVjdCAmJiAhcmVkaXJlY3QuI3JlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWRpcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVkaXJlY3QgPSByZWRpcmVjdC4jcmVkaXJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVkaXJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHJlc3BvbnNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGdldCB1cmwoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnQucmVxdWVzdC51cmw7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzQmxvY2tlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNldmVudC5pc0Jsb2NrZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgY29udGludWVSZXF1ZXN0KHsgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGNvb2tpZXMsIGJvZHksIH0pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnbmV0d29yay5jb250aW51ZVJlcXVlc3QnLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBjb29raWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZmFpbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ25ldHdvcmsuZmFpbFJlcXVlc3QnLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDogdGhpcy5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHByb3ZpZGVSZXNwb25zZSh7IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSwgaGVhZGVycywgYm9keSwgfSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCduZXR3b3JrLnByb3ZpZGVSZXNwb25zZScsIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uUGhyYXNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNvbnRpbnVlV2l0aEF1dGgocGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuYWN0aW9uID09PSAncHJvdmlkZUNyZWRlbnRpYWxzJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnbmV0d29yay5jb250aW51ZVdpdGhBdXRoJywge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHBhcmFtZXRlcnMuYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogcGFyYW1ldGVycy5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnbmV0d29yay5jb250aW51ZVdpdGhBdXRoJywge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHBhcmFtZXRlcnMuYWN0aW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgICAgICB0aGlzW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIGRpc3Bvc2VTeW1ib2wpXSgpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHN1cGVyW2Rpc3Bvc2VTeW1ib2xdKCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcbmV4cG9ydCB7IFJlcXVlc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcXVlc3QuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgYnViYmxlLCBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCwgfSBmcm9tICcuLi8uLi91dGlsL2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0YWNrLCBkaXNwb3NlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9kaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7IEJyb3dzZXIgfSBmcm9tICcuL0Jyb3dzZXIuanMnO1xuLy8gVE9ETzogT25jZSBDaHJvbWUgc3VwcG9ydHMgc2Vzc2lvbi5zdGF0dXMgcHJvcGVybHksIHVuY29tbWVudCB0aGlzIGJsb2NrLlxuLy8gY29uc3QgTUFYX1JFVFJJRVMgPSA1O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFNlc3Npb24gPSAoKCkgPT4ge1xuICAgIGxldCBfY2xhc3NTdXBlciA9IEV2ZW50RW1pdHRlcjtcbiAgICBsZXQgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMgPSBbXTtcbiAgICBsZXQgX2Nvbm5lY3Rpb25fZGVjb3JhdG9ycztcbiAgICBsZXQgX2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9jb25uZWN0aW9uX2V4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9zZW5kX2RlY29yYXRvcnM7XG4gICAgbGV0IF9zdWJzY3JpYmVfZGVjb3JhdG9ycztcbiAgICBsZXQgX2FkZEludGVyY2VwdHNfZGVjb3JhdG9ycztcbiAgICBsZXQgX2VuZF9kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBTZXNzaW9uIGV4dGVuZHMgX2NsYXNzU3VwZXIge1xuICAgICAgICBzdGF0aWMge1xuICAgICAgICAgICAgY29uc3QgX21ldGFkYXRhID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5tZXRhZGF0YSA/IE9iamVjdC5jcmVhdGUoX2NsYXNzU3VwZXJbU3ltYm9sLm1ldGFkYXRhXSA/PyBudWxsKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfY29ubmVjdGlvbl9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwiYWNjZXNzb3JcIiwgbmFtZTogXCJjb25uZWN0aW9uXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJjb25uZWN0aW9uXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY29ubmVjdGlvbiwgc2V0OiAob2JqLCB2YWx1ZSkgPT4geyBvYmouY29ubmVjdGlvbiA9IHZhbHVlOyB9IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgX2Nvbm5lY3Rpb25faW5pdGlhbGl6ZXJzLCBfY29ubmVjdGlvbl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9zZW5kX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZW5kXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZW5kXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouc2VuZCB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc3Vic2NyaWJlX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzdWJzY3JpYmVcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInN1YnNjcmliZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnN1YnNjcmliZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfYWRkSW50ZXJjZXB0c19kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiYWRkSW50ZXJjZXB0c1wiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiYWRkSW50ZXJjZXB0c1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLmFkZEludGVyY2VwdHMgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2VuZF9kZWNvcmF0b3JzLCB7IGtpbmQ6IFwibWV0aG9kXCIsIG5hbWU6IFwiZW5kXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJlbmRcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5lbmQgfSwgbWV0YWRhdGE6IF9tZXRhZGF0YSB9LCBudWxsLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICBpZiAoX21ldGFkYXRhKSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU3ltYm9sLm1ldGFkYXRhLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBfbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzeW5jIGZyb20oY29ubmVjdGlvbiwgY2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHVudGlsIHRoZSBzZXNzaW9uIGlzIHJlYWR5LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE86IE9uY2UgQ2hyb21lIHN1cHBvcnRzIHNlc3Npb24uc3RhdHVzIHByb3Blcmx5LCB1bmNvbW1lbnQgdGhpcyBibG9ja1xuICAgICAgICAgICAgLy8gYW5kIHJlbW92ZSBgZ2V0QmlEaUNvbm5lY3Rpb25gIGluIEJyb3dzZXJDb25uZWN0b3IuXG4gICAgICAgICAgICAvLyBsZXQgc3RhdHVzID0ge21lc3NhZ2U6ICcnLCByZWFkeTogZmFsc2V9O1xuICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfUkVUUklFUzsgKytpKSB7XG4gICAgICAgICAgICAvLyAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLnNlbmQoJ3Nlc3Npb24uc3RhdHVzJywge30pKS5yZXN1bHQ7XG4gICAgICAgICAgICAvLyAgIGlmIChzdGF0dXMucmVhZHkpIHtcbiAgICAgICAgICAgIC8vICAgICBicmVhaztcbiAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgLy8gICAvLyBCYWNrb2ZmIGEgbGl0dGxlIGJpdCBlYWNoIHRpbWUuXG4gICAgICAgICAgICAvLyAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgLy8gICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsICgxIDw8IGkpICogMTAwKTtcbiAgICAgICAgICAgIC8vICAgfSk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBpZiAoIXN0YXR1cy5yZWFkeSkge1xuICAgICAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3Ioc3RhdHVzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZCgnc2Vzc2lvbi5uZXcnLCB7XG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24oY29ubmVjdGlvbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGF3YWl0IHNlc3Npb24uI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgICNyZWFzb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICNkaXNwb3NhYmxlcyA9IG5ldyBEaXNwb3NhYmxlU3RhY2soKTtcbiAgICAgICAgI2luZm87XG4gICAgICAgIGJyb3dzZXI7XG4gICAgICAgICNjb25uZWN0aW9uX2FjY2Vzc29yX3N0b3JhZ2UgPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfY29ubmVjdGlvbl9pbml0aWFsaXplcnMsIHZvaWQgMCk7XG4gICAgICAgIGdldCBjb25uZWN0aW9uKCkgeyByZXR1cm4gdGhpcy4jY29ubmVjdGlvbl9hY2Nlc3Nvcl9zdG9yYWdlOyB9XG4gICAgICAgIHNldCBjb25uZWN0aW9uKHZhbHVlKSB7IHRoaXMuI2Nvbm5lY3Rpb25fYWNjZXNzb3Jfc3RvcmFnZSA9IHZhbHVlOyB9XG4gICAgICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIGluZm8pIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfY29ubmVjdGlvbl9leHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgICAgICB0aGlzLiNpbmZvID0gaW5mbztcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICAvLyBTQUZFVFk6IFdlIHVzZSBgYW55YCB0byBhbGxvdyBhc3NpZ25tZW50IG9mIHRoZSByZWFkb25seSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIHRoaXMuYnJvd3NlciA9IGF3YWl0IEJyb3dzZXIuZnJvbSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXJFbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKHRoaXMuYnJvd3Nlcik7XG4gICAgICAgICAgICBicm93c2VyRW1pdHRlci5vbmNlKCdjbG9zZWQnLCAoeyByZWFzb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHksIHNvbWUgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBlbWl0IG5hdmlnYXRpb25TdGFydGVkIGV2ZW50XG4gICAgICAgICAgICAvLyBmb3IgZnJhZ21lbnQgbmF2aWdhdGlvbnMgKGFzIHBlciBzcGVjKSBhbmQgc29tZSBkby4gVGhpcyBjb3VsZCBlbWl0cyBhXG4gICAgICAgICAgICAvLyBzeW50aGV0aWMgbmF2aWdhdGlvblN0YXJ0ZWQgdG8gd29yayBhcm91bmQgdGhpcyBpbmNvbnNpc3RlbmN5LlxuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdicm93c2luZ0NvbnRleHQuZnJhZ21lbnROYXZpZ2F0ZWQnLCBpbmZvID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXMoaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWVuLmFkZChpbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jyb3dzaW5nQ29udGV4dC5uYXZpZ2F0aW9uU3RhcnRlZCcsIGluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYnJvd3NpbmdDb250ZXh0LmZyYWdtZW50TmF2aWdhdGVkJywgaW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2FwYWJpbGl0aWVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2luZm8uY2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZGVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBlbmRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFzb24gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jaW5mby5zZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcG9zZShyZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIHRoaXNbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5LCB0aGVyZSBpcyBhIDE6MSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0aGUgc2Vzc2lvbiBhbmQgdGhlXG4gICAgICAgICAqIHNlc3Npb24uIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IHN1cHBvcnQgbXVsdGlwbGUgc2Vzc2lvbnMgYW5kIGluIHRoYXRcbiAgICAgICAgICogY2FzZSB3ZSBhbHdheXMgbmVlZHMgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHNlc3Npb24gZm9yIHRoZSByaWdodCBzZXNzaW9uXG4gICAgICAgICAqIG9iamVjdCBpcyB1c2VkLCBzbyB3ZSBpbXBsZW1lbnQgdGhpcyBtZXRob2QgaGVyZSwgYWx0aG91Z2ggaXQncyBub3QgZGVmaW5lZFxuICAgICAgICAgKiBpbiB0aGUgc3BlYy5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc2VuZChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc3Vic2NyaWJlKGV2ZW50cywgY29udGV4dHMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZCgnc2Vzc2lvbi5zdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgICAgICAgIGNvbnRleHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgYWRkSW50ZXJjZXB0cyhldmVudHMsIGNvbnRleHRzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNlbmQoJ3Nlc3Npb24uc3Vic2NyaWJlJywge1xuICAgICAgICAgICAgICAgIGV2ZW50cyxcbiAgICAgICAgICAgICAgICBjb250ZXh0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGVuZCgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZW5kKCdzZXNzaW9uLmVuZCcsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZShgU2Vzc2lvbiBhbHJlYWR5IGVuZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFsoX2Nvbm5lY3Rpb25fZGVjb3JhdG9ycyA9IFtidWJibGUoKV0sIF9kaXNwb3NlX2RlY29yYXRvcnMgPSBbaW5lcnRJZkRpc3Bvc2VkXSwgX3NlbmRfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoc2Vzc2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9zdWJzY3JpYmVfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQoc2Vzc2lvbiA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU0FGRVRZOiBCeSBkZWZpbml0aW9uIG9mIGBkaXNwb3NlZGAsIGAjcmVhc29uYCBpcyBkZWZpbmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uLiNyZWFzb247XG4gICAgICAgICAgICB9KV0sIF9hZGRJbnRlcmNlcHRzX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfZW5kX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKHNlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogQnkgZGVmaW5pdGlvbiBvZiBgZGlzcG9zZWRgLCBgI3JlYXNvbmAgaXMgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbi4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1Nlc3Npb24gYWxyZWFkeSBkZXN0cm95ZWQsIHByb2JhYmx5IGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gYnJva2UuJztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kZWQnLCB7IHJlYXNvbjogdGhpcy4jcmVhc29uIH0pO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgU2Vzc2lvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2Vzc2lvbi5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNCBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xudmFyIF9fcnVuSW5pdGlhbGl6ZXJzID0gKHRoaXMgJiYgdGhpcy5fX3J1bkluaXRpYWxpemVycykgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gICAgfVxuICAgIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcbnZhciBfX2VzRGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZXNEZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gICAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gICAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgZG9uZSA9IHRydWU7XG59O1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vY29tbW9uL0V2ZW50RW1pdHRlci5qcyc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi8uLi91dGlsL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBpbmVydElmRGlzcG9zZWQsIHRocm93SWZEaXNwb3NlZCB9IGZyb20gJy4uLy4uL3V0aWwvZGVjb3JhdG9ycy5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlU3RhY2ssIGRpc3Bvc2VTeW1ib2wgfSBmcm9tICcuLi8uLi91dGlsL2Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHsgQnJvd3NpbmdDb250ZXh0IH0gZnJvbSAnLi9Ccm93c2luZ0NvbnRleHQuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xubGV0IFVzZXJDb250ZXh0ID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9jcmVhdGVCcm93c2luZ0NvbnRleHRfZGVjb3JhdG9ycztcbiAgICBsZXQgX3JlbW92ZV9kZWNvcmF0b3JzO1xuICAgIGxldCBfZ2V0Q29va2llc19kZWNvcmF0b3JzO1xuICAgIGxldCBfc2V0Q29va2llX2RlY29yYXRvcnM7XG4gICAgbGV0IF9zZXRQZXJtaXNzaW9uc19kZWNvcmF0b3JzO1xuICAgIHJldHVybiBjbGFzcyBVc2VyQ29udGV4dCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9jcmVhdGVCcm93c2luZ0NvbnRleHRfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImNyZWF0ZUJyb3dzaW5nQ29udGV4dFwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiY3JlYXRlQnJvd3NpbmdDb250ZXh0XCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouY3JlYXRlQnJvd3NpbmdDb250ZXh0IH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9yZW1vdmVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInJlbW92ZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwicmVtb3ZlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmoucmVtb3ZlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9nZXRDb29raWVzX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJnZXRDb29raWVzXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJnZXRDb29raWVzXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouZ2V0Q29va2llcyB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0Q29va2llX2RlY29yYXRvcnMsIHsga2luZDogXCJtZXRob2RcIiwgbmFtZTogXCJzZXRDb29raWVcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcInNldENvb2tpZVwiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldENvb2tpZSB9LCBtZXRhZGF0YTogX21ldGFkYXRhIH0sIG51bGwsIF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgICAgIF9fZXNEZWNvcmF0ZSh0aGlzLCBudWxsLCBfc2V0UGVybWlzc2lvbnNfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcInNldFBlcm1pc3Npb25zXCIsIHN0YXRpYzogZmFsc2UsIHByaXZhdGU6IGZhbHNlLCBhY2Nlc3M6IHsgaGFzOiBvYmogPT4gXCJzZXRQZXJtaXNzaW9uc1wiIGluIG9iaiwgZ2V0OiBvYmogPT4gb2JqLnNldFBlcm1pc3Npb25zIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBERUZBVUxUID0gJ2RlZmF1bHQnO1xuICAgICAgICBzdGF0aWMgY3JlYXRlKGJyb3dzZXIsIGlkKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IFVzZXJDb250ZXh0KGJyb3dzZXIsIGlkKTtcbiAgICAgICAgICAgIGNvbnRleHQuI2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgICNyZWFzb24gPSBfX3J1bkluaXRpYWxpemVycyh0aGlzLCBfaW5zdGFuY2VFeHRyYUluaXRpYWxpemVycyk7XG4gICAgICAgIC8vIE5vdGUgdGhlc2UgYXJlIG9ubHkgdG9wLWxldmVsIGNvbnRleHRzLlxuICAgICAgICAjYnJvd3NpbmdDb250ZXh0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgI2Rpc3Bvc2FibGVzID0gbmV3IERpc3Bvc2FibGVTdGFjaygpO1xuICAgICAgICAjaWQ7XG4gICAgICAgIGJyb3dzZXI7XG4gICAgICAgIGNvbnN0cnVjdG9yKGJyb3dzZXIsIGlkKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy4jaWQgPSBpZDtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NlciA9IGJyb3dzZXI7XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyRW1pdHRlciA9IHRoaXMuI2Rpc3Bvc2FibGVzLnVzZShuZXcgRXZlbnRFbWl0dGVyKHRoaXMuYnJvd3NlcikpO1xuICAgICAgICAgICAgYnJvd3NlckVtaXR0ZXIub25jZSgnY2xvc2VkJywgKHsgcmVhc29uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoYFVzZXIgY29udGV4dCBhbHJlYWR5IGNsb3NlZDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy4jc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC5jb250ZXh0Q3JlYXRlZCcsIGluZm8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmZvLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmZvLnVzZXJDb250ZXh0ICE9PSB0aGlzLiNpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dCA9IEJyb3dzaW5nQ29udGV4dC5mcm9tKHRoaXMsIHVuZGVmaW5lZCwgaW5mby5jb250ZXh0LCBpbmZvLnVybCwgaW5mby5vcmlnaW5hbE9wZW5lcik7XG4gICAgICAgICAgICAgICAgdGhpcy4jYnJvd3NpbmdDb250ZXh0cy5zZXQoYnJvd3NpbmdDb250ZXh0LmlkLCBicm93c2luZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcihicm93c2luZ0NvbnRleHQpKTtcbiAgICAgICAgICAgICAgICBicm93c2luZ0NvbnRleHRFbWl0dGVyLm9uKCdjbG9zZWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzaW5nQ29udGV4dEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Jyb3dzaW5nQ29udGV4dHMuZGVsZXRlKGJyb3dzaW5nQ29udGV4dC5pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdicm93c2luZ2NvbnRleHQnLCB7IGJyb3dzaW5nQ29udGV4dCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdldCAjc2Vzc2lvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJyb3dzZXIuc2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgYnJvd3NpbmdDb250ZXh0cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNicm93c2luZ0NvbnRleHRzLnZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhc29uICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGRpc3Bvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNpZDtcbiAgICAgICAgfVxuICAgICAgICBkaXNwb3NlKHJlYXNvbikge1xuICAgICAgICAgICAgdGhpcy4jcmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgdGhpc1tkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGNyZWF0ZUJyb3dzaW5nQ29udGV4dCh0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0OiB7IGNvbnRleHQ6IGNvbnRleHRJZCB9LCB9ID0gYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2luZ0NvbnRleHQuY3JlYXRlJywge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VDb250ZXh0OiBvcHRpb25zLnJlZmVyZW5jZUNvbnRleHQ/LmlkLFxuICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLiNpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYnJvd3NpbmdDb250ZXh0ID0gdGhpcy4jYnJvd3NpbmdDb250ZXh0cy5nZXQoY29udGV4dElkKTtcbiAgICAgICAgICAgIGFzc2VydChicm93c2luZ0NvbnRleHQsICdUaGUgV2ViRHJpdmVyIEJpRGkgaW1wbGVtZW50YXRpb24gaXMgZmFpbGluZyB0byBjcmVhdGUgYSBicm93c2luZyBjb250ZXh0IGNvcnJlY3RseS4nKTtcbiAgICAgICAgICAgIC8vIFdlIHVzZSBhbiBhcnJheSB0byBhdm9pZCB0aGUgcHJvbWlzZSBmcm9tIGJlaW5nIGF3YWl0ZWQuXG4gICAgICAgICAgICByZXR1cm4gYnJvd3NpbmdDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHJlbW92ZSgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdicm93c2VyLnJlbW92ZVVzZXJDb250ZXh0Jywge1xuICAgICAgICAgICAgICAgICAgICB1c2VyQ29udGV4dDogdGhpcy4jaWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoJ1VzZXIgY29udGV4dCBhbHJlYWR5IGNsb3NlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXRDb29raWVzKG9wdGlvbnMgPSB7fSwgc291cmNlT3JpZ2luID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdDogeyBjb29raWVzIH0sIH0gPSBhd2FpdCB0aGlzLiNzZXNzaW9uLnNlbmQoJ3N0b3JhZ2UuZ2V0Q29va2llcycsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHBhcnRpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RvcmFnZUtleScsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLiNpZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlT3JpZ2luLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb29raWVzO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIHNldENvb2tpZShjb29raWUsIHNvdXJjZU9yaWdpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdzdG9yYWdlLnNldENvb2tpZScsIHtcbiAgICAgICAgICAgICAgICBjb29raWUsXG4gICAgICAgICAgICAgICAgcGFydGl0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdG9yYWdlS2V5JyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29udGV4dDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgc2V0UGVybWlzc2lvbnMob3JpZ2luLCBkZXNjcmlwdG9yLCBzdGF0ZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jc2Vzc2lvbi5zZW5kKCdwZXJtaXNzaW9ucy5zZXRQZXJtaXNzaW9uJywge1xuICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHVzZXJDb250ZXh0OiB0aGlzLiNpZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFsoX2Rpc3Bvc2VfZGVjb3JhdG9ycyA9IFtpbmVydElmRGlzcG9zZWRdLCBfY3JlYXRlQnJvd3NpbmdDb250ZXh0X2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfcmVtb3ZlX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBfZ2V0Q29va2llc19kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldENvb2tpZV9kZWNvcmF0b3JzID0gW3Rocm93SWZEaXNwb3NlZChjb250ZXh0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuI3JlYXNvbjtcbiAgICAgICAgICAgIH0pXSwgX3NldFBlcm1pc3Npb25zX2RlY29yYXRvcnMgPSBbdGhyb3dJZkRpc3Bvc2VkKGNvbnRleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFNBRkVUWTogRGlzcG9zYWwgaW1wbGllcyB0aGlzIGV4aXN0cy5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1VzZXIgY29udGV4dCBhbHJlYWR5IGNsb3NlZCwgcHJvYmFibHkgYmVjYXVzZSB0aGUgYnJvd3NlciBkaXNjb25uZWN0ZWQvY2xvc2VkLic7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlZCcsIHsgcmVhc29uOiB0aGlzLiNyZWFzb24gfSk7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NhYmxlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICBzdXBlcltkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5leHBvcnQgeyBVc2VyQ29udGV4dCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXNlckNvbnRleHQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjQgR29vZ2xlIEluYy5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBfX3J1bkluaXRpYWxpemVycyA9ICh0aGlzICYmIHRoaXMuX19ydW5Jbml0aWFsaXplcnMpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gICAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG52YXIgX19lc0RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2VzRGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICAgIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICAgIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gICAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gICAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIGRvbmUgPSB0cnVlO1xufTtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL2NvbW1vbi9FdmVudEVtaXR0ZXIuanMnO1xuaW1wb3J0IHsgaW5lcnRJZkRpc3Bvc2VkLCB0aHJvd0lmRGlzcG9zZWQgfSBmcm9tICcuLi8uLi91dGlsL2RlY29yYXRvcnMuanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZVN0YWNrLCBkaXNwb3NlU3ltYm9sIH0gZnJvbSAnLi4vLi4vdXRpbC9kaXNwb3NhYmxlLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmxldCBVc2VyUHJvbXB0ID0gKCgpID0+IHtcbiAgICBsZXQgX2NsYXNzU3VwZXIgPSBFdmVudEVtaXR0ZXI7XG4gICAgbGV0IF9pbnN0YW5jZUV4dHJhSW5pdGlhbGl6ZXJzID0gW107XG4gICAgbGV0IF9kaXNwb3NlX2RlY29yYXRvcnM7XG4gICAgbGV0IF9oYW5kbGVfZGVjb3JhdG9ycztcbiAgICByZXR1cm4gY2xhc3MgVXNlclByb21wdCBleHRlbmRzIF9jbGFzc1N1cGVyIHtcbiAgICAgICAgc3RhdGljIHtcbiAgICAgICAgICAgIGNvbnN0IF9tZXRhZGF0YSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wubWV0YWRhdGEgPyBPYmplY3QuY3JlYXRlKF9jbGFzc1N1cGVyW1N5bWJvbC5tZXRhZGF0YV0gPz8gbnVsbCkgOiB2b2lkIDA7XG4gICAgICAgICAgICBfX2VzRGVjb3JhdGUodGhpcywgbnVsbCwgX2Rpc3Bvc2VfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImRpc3Bvc2VcIiwgc3RhdGljOiBmYWxzZSwgcHJpdmF0ZTogZmFsc2UsIGFjY2VzczogeyBoYXM6IG9iaiA9PiBcImRpc3Bvc2VcIiBpbiBvYmosIGdldDogb2JqID0+IG9iai5kaXNwb3NlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgX19lc0RlY29yYXRlKHRoaXMsIG51bGwsIF9oYW5kbGVfZGVjb3JhdG9ycywgeyBraW5kOiBcIm1ldGhvZFwiLCBuYW1lOiBcImhhbmRsZVwiLCBzdGF0aWM6IGZhbHNlLCBwcml2YXRlOiBmYWxzZSwgYWNjZXNzOiB7IGhhczogb2JqID0+IFwiaGFuZGxlXCIgaW4gb2JqLCBnZXQ6IG9iaiA9PiBvYmouaGFuZGxlIH0sIG1ldGFkYXRhOiBfbWV0YWRhdGEgfSwgbnVsbCwgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAgICAgaWYgKF9tZXRhZGF0YSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFN5bWJvbC5tZXRhZGF0YSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogX21ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tKGJyb3dzaW5nQ29udGV4dCwgaW5mbykge1xuICAgICAgICAgICAgY29uc3QgdXNlclByb21wdCA9IG5ldyBVc2VyUHJvbXB0KGJyb3dzaW5nQ29udGV4dCwgaW5mbyk7XG4gICAgICAgICAgICB1c2VyUHJvbXB0LiNpbml0aWFsaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlclByb21wdDtcbiAgICAgICAgfVxuICAgICAgICAjcmVhc29uID0gX19ydW5Jbml0aWFsaXplcnModGhpcywgX2luc3RhbmNlRXh0cmFJbml0aWFsaXplcnMpO1xuICAgICAgICAjcmVzdWx0O1xuICAgICAgICAjZGlzcG9zYWJsZXMgPSBuZXcgRGlzcG9zYWJsZVN0YWNrKCk7XG4gICAgICAgIGJyb3dzaW5nQ29udGV4dDtcbiAgICAgICAgaW5mbztcbiAgICAgICAgY29uc3RydWN0b3IoY29udGV4dCwgaW5mbykge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYnJvd3NpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIH1cbiAgICAgICAgI2luaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBjb25zdCBicm93c2VyQ29udGV4dEVtaXR0ZXIgPSB0aGlzLiNkaXNwb3NhYmxlcy51c2UobmV3IEV2ZW50RW1pdHRlcih0aGlzLmJyb3dzaW5nQ29udGV4dCkpO1xuICAgICAgICAgICAgYnJvd3NlckNvbnRleHRFbWl0dGVyLm9uY2UoJ2Nsb3NlZCcsICh7IHJlYXNvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKGBVc2VyIHByb21wdCBhbHJlYWR5IGNsb3NlZDogJHtyZWFzb259YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25FbWl0dGVyID0gdGhpcy4jZGlzcG9zYWJsZXMudXNlKG5ldyBFdmVudEVtaXR0ZXIodGhpcy4jc2Vzc2lvbikpO1xuICAgICAgICAgICAgc2Vzc2lvbkVtaXR0ZXIub24oJ2Jyb3dzaW5nQ29udGV4dC51c2VyUHJvbXB0Q2xvc2VkJywgcGFyYW1ldGVycyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdGhpcy5icm93c2luZ0NvbnRleHQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNyZXN1bHQgPSBwYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGFuZGxlZCcsIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgnVXNlciBwcm9tcHQgYWxyZWFkeSBoYW5kbGVkLicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0ICNzZXNzaW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJvd3NpbmdDb250ZXh0LnVzZXJDb250ZXh0LmJyb3dzZXIuc2Vzc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYXNvbiAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaGFuZGxlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXN1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcmVzdWx0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Jlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkaXNwb3NlKHJlYXNvbikge1xuICAgICAgICAgICAgdGhpcy4jcmVhc29uID0gcmVhc29uO1xuICAgICAgICAgICAgdGhpc1tkaXNwb3NlU3ltYm9sXSgpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGhhbmRsZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI3Nlc3Npb24uc2VuZCgnYnJvd3NpbmdDb250ZXh0LmhhbmRsZVVzZXJQcm9tcHQnLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmluZm8uY29udGV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gU0FGRVRZOiBgaGFuZGxlZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSB0aGUgYWJvdmUgcHJvbWlzZSByZXNvbHZlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgWyhfZGlzcG9zZV9kZWNvcmF0b3JzID0gW2luZXJ0SWZEaXNwb3NlZF0sIF9oYW5kbGVfZGVjb3JhdG9ycyA9IFt0aHJvd0lmRGlzcG9zZWQocHJvbXB0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTQUZFVFk6IERpc3Bvc2FsIGltcGxpZXMgdGhpcyBleGlzdHMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21wdC4jcmVhc29uO1xuICAgICAgICAgICAgfSldLCBkaXNwb3NlU3ltYm9sKV0oKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFzb24gPz89XG4gICAgICAgICAgICAgICAgJ1VzZXIgcHJvbXB0IGFscmVhZHkgY2xvc2VkLCBwcm9iYWJseSBiZWNhdXNlIHRoZSBhc3NvY2lhdGVkIGJyb3dzaW5nIGNvbnRleHQgd2FzIGRlc3Ryb3llZC4nO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZWQnLCB7IHJlYXNvbjogdGhpcy4jcmVhc29uIH0pO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgc3VwZXJbZGlzcG9zZVN5bWJvbF0oKTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuZXhwb3J0IHsgVXNlclByb21wdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXNlclByb21wdC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgSW5jLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuaW1wb3J0IHsgUHJvdG9jb2xFcnJvciwgVGltZW91dEVycm9yIH0gZnJvbSAnLi4vY29tbW9uL0Vycm9ycy5qcyc7XG5pbXBvcnQgeyBQdXBwZXRlZXJVUkwgfSBmcm9tICcuLi9jb21tb24vdXRpbC5qcyc7XG5pbXBvcnQgeyBCaWRpRGVzZXJpYWxpemVyIH0gZnJvbSAnLi9EZXNlcmlhbGl6ZXIuanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2YWx1YXRpb25FcnJvcihkZXRhaWxzKSB7XG4gICAgaWYgKGRldGFpbHMuZXhjZXB0aW9uLnR5cGUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIEJpZGlEZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoZGV0YWlscy5leGNlcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBbbmFtZSA9ICcnLCAuLi5wYXJ0c10gPSBkZXRhaWxzLnRleHQuc3BsaXQoJzogJyk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHBhcnRzLmpvaW4oJzogJyk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9IG5hbWU7XG4gICAgLy8gVGhlIGZpcnN0IGxpbmUgaXMgdGhpcyBmdW5jdGlvbiB3aGljaCB3ZSBpZ25vcmUuXG4gICAgY29uc3Qgc3RhY2tMaW5lcyA9IFtdO1xuICAgIGlmIChkZXRhaWxzLnN0YWNrVHJhY2UgJiYgc3RhY2tMaW5lcy5sZW5ndGggPCBFcnJvci5zdGFja1RyYWNlTGltaXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBmcmFtZSBvZiBkZXRhaWxzLnN0YWNrVHJhY2UuY2FsbEZyYW1lcy5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmIChQdXBwZXRlZXJVUkwuaXNQdXBwZXRlZXJVUkwoZnJhbWUudXJsKSAmJlxuICAgICAgICAgICAgICAgIGZyYW1lLnVybCAhPT0gUHVwcGV0ZWVyVVJMLklOVEVSTkFMX1VSTCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IFB1cHBldGVlclVSTC5wYXJzZShmcmFtZS51cmwpO1xuICAgICAgICAgICAgICAgIHN0YWNrTGluZXMudW5zaGlmdChgICAgIGF0ICR7ZnJhbWUuZnVuY3Rpb25OYW1lIHx8IHVybC5mdW5jdGlvbk5hbWV9ICgke3VybC5mdW5jdGlvbk5hbWV9IGF0ICR7dXJsLnNpdGVTdHJpbmd9LCA8YW5vbnltb3VzPjoke2ZyYW1lLmxpbmVOdW1iZXJ9OiR7ZnJhbWUuY29sdW1uTnVtYmVyfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrTGluZXMucHVzaChgICAgIGF0ICR7ZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICc8YW5vbnltb3VzPid9ICgke2ZyYW1lLnVybH06JHtmcmFtZS5saW5lTnVtYmVyfToke2ZyYW1lLmNvbHVtbk51bWJlcn0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tMaW5lcy5sZW5ndGggPj0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXJyb3Iuc3RhY2sgPSBbZGV0YWlscy50ZXh0LCAuLi5zdGFja0xpbmVzXS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZU5hdmlnYXRpb25FcnJvcihtZXNzYWdlLCBtcykge1xuICAgIHJldHVybiBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gYCBhdCAke21lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIFRpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBOYXZpZ2F0aW9uIHRpbWVvdXQgb2YgJHttc30gbXMgZXhjZWVkZWRgO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==